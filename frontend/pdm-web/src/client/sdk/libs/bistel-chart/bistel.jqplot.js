/**
 * Title: jqPlot Charts
 * 
 * Pure JavaScript plotting plugin for jQuery.
 * 
 * About: Version
 * 
 * version: 1.0.8 
 * revision: 1250
 * 
 * About: Copyright & License
 * 
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT and GPL version 2.0 licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly.
 * 
 * See <GPL Version 2> and <MIT License> contained within this distribution for further information. 
 *
 * The author would appreciate an email letting him know of any substantial
 * use of jqPlot.  You can reach the author at: chris at jqplot dot com 
 * or see http://www.jqplot.com/info.php.  This is, of course, not required.
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php.
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 * 
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 * 
 * About: Introduction
 * 
 * jqPlot requires jQuery (1.4+ required for certain features). jQuery 1.4.2 is included in the distribution.  
 * To use jqPlot include jQuery, the jqPlot jQuery plugin, the jqPlot css file and optionally 
 * the excanvas script for IE support in your web page:
 * 
 * > <!--[if lt IE 9]><script language="javascript" type="text/javascript" src="excanvas.js"></script><![endif]-->
 * > <script language="javascript" type="text/javascript" src="jquery-1.4.4.min.js"></script>
 * > <script language="javascript" type="text/javascript" src="jquery.jqplot.min.js"></script>
 * > <link rel="stylesheet" type="text/css" href="jquery.jqplot.css" />
 * 
 * jqPlot can be customized by overriding the defaults of any of the objects which make
 * up the plot. The general usage of jqplot is:
 * 
 * > chart = $.jqplot('targetElemId', [dataArray,...], {optionsObject});
 * 
 * The options available to jqplot are detailed in <jqPlot Options> in the jqPlotOptions.txt file.
 * 
 * An actual call to $.jqplot() may look like the 
 * examples below:
 * 
 * > chart = $.jqplot('chartdiv',  [[[1, 2],[3,5.12],[5,13.1],[7,33.6],[9,85.9],[11,219.9]]]);
 * 
 * or
 * 
 * > dataArray = [34,12,43,55,77];
 * > chart = $.jqplot('targetElemId', [dataArray, ...], {title:'My Plot', axes:{yaxis:{min:20, max:100}}});
 * 
 * For more inforrmation, see <jqPlot Usage>.
 * 
 * About: Usage
 * 
 * See <jqPlot Usage>
 * 
 * About: Available Options 
 * 
 * See <jqPlot Options> for a list of options available thorugh the options object (not complete yet!)
 * 
 * About: Options Usage
 * 
 * See <Options Tutorial>
 * 
 * About: Changes
 * 
 * See <Change Log>
 * 
 */

(function($) {
    // make sure undefined is undefined
    var undefined;
    
    $.fn.emptyForce = function() {
      for ( var i = 0, elem; (elem = $(this)[i]) != null; i++ ) {
        // Remove element nodes and prevent memory leaks
        if ( elem.nodeType === 1 ) {
          $.cleanData( elem.getElementsByTagName("*") );
        }
  
        // Remove any remaining nodes
        if ($.jqplot.use_excanvas) {
          elem.outerHTML = "";
        }
        else {
          while ( elem.firstChild ) {
            elem.removeChild( elem.firstChild );
          }
        }

        elem = null;
      }
  
      return $(this);
    };
  
    $.fn.removeChildForce = function(parent) {
      while ( parent.firstChild ) {
        this.removeChildForce( parent.firstChild );
        parent.removeChild( parent.firstChild );
      }
    };

    $.fn.jqplot = function() {
        var datas = [];
        var options = [];
        // see how many data arrays we have
        for (var i=0, l=arguments.length; i<l; i++) {
            if ($.isArray(arguments[i])) {
                datas.push(arguments[i]);
            }
            else if ($.isPlainObject(arguments[i])) {
                options.push(arguments[i]);
            }
        }

        return this.each(function(index) {
            var tid, 
                plot, 
                $this = $(this),
                dl = datas.length,
                ol = options.length,
                data, 
                opts;

            if (index < dl) {
                data = datas[index];
            }
            else {
                data = dl ? datas[dl-1] : null;
            }

            if (index < ol) {
                opts = options[index];
            }
            else {
                opts = ol ? options[ol-1] : null;
            }

            // does el have an id?
            // if not assign it one.
            tid = $this.attr('id');
            if (tid === undefined) {
                tid = 'jqplot_target_' + $.jqplot.targetCounter++;
                $this.attr('id', tid);
            }

            plot = $.jqplot(tid, data, opts);

            $this.data('jqplot', plot);
        });
    };


    /**
     * Namespace: $.jqplot
     * jQuery function called by the user to create a plot.
     *  
     * Parameters:
     * target - ID of target element to render the plot into.
     * data - an array of data series.
     * options - user defined options object.  See the individual classes for available options.
     * 
     * Properties:
     * config - object to hold configuration information for jqPlot plot object.
     * 
     * attributes:
     * enablePlugins - False to disable plugins by default.  Plugins must then be explicitly 
     *   enabled in the individual plot options.  Default: false.
     *   This property sets the "show" property of certain plugins to true or false.
     *   Only plugins that can be immediately active upon loading are affected.  This includes
     *   non-renderer plugins like cursor, dragable, highlighter, and trendline.
     * defaultHeight - Default height for plots where no css height specification exists.  This
     *   is a jqplot wide default.
     * defaultWidth - Default height for plots where no css height specification exists.  This
     *   is a jqplot wide default.
     */

    $.jqplot = function(target, data, options) {
        var _data = null, _options = null;

        if (arguments.length === 3) {
            _data = data;
            _options = options;
        }

        else if (arguments.length === 2) {
            if ($.isArray(data)) {
                _data = data;
            }

            else if ($.isPlainObject(data)) {
                _options = data;
            }
        }

        if (_data === null && _options !== null && _options.data) {
            _data = _options.data;
        }

        var plot = new jqPlot();
        // remove any error class that may be stuck on target.
        $('#'+target).removeClass('jqplot-error');
        
        if ($.jqplot.config.catchErrors) {
            try {
                plot.init(target, _data, _options);
                plot.draw();
                plot.themeEngine.init.call(plot);
                return plot;
            }
            catch(e) {
                var msg = $.jqplot.config.errorMessage || e.message;
                $('#'+target).append('<div class="jqplot-error-message">'+msg+'</div>');
                $('#'+target).addClass('jqplot-error');
                document.getElementById(target).style.background = $.jqplot.config.errorBackground;
                document.getElementById(target).style.border = $.jqplot.config.errorBorder;
                document.getElementById(target).style.fontFamily = $.jqplot.config.errorFontFamily;
                document.getElementById(target).style.fontSize = $.jqplot.config.errorFontSize;
                document.getElementById(target).style.fontStyle = $.jqplot.config.errorFontStyle;
                document.getElementById(target).style.fontWeight = $.jqplot.config.errorFontWeight;
            }
        }
        else {        
            plot.init(target, _data, _options);
            plot.draw();
            plot.themeEngine.init.call(plot);
            return plot;
        }
    };

    $.jqplot.version = "1.0.8";
    $.jqplot.revision = "1250";

    $.jqplot.targetCounter = 1;

    // canvas manager to reuse canvases on the plot.
    // Should help solve problem of canvases not being freed and
    // problem of waiting forever for firefox to decide to free memory.
    $.jqplot.CanvasManager = function() {
        // canvases are managed globally so that they can be reused
        // across plots after they have been freed
        if (typeof $.jqplot.CanvasManager.canvases == 'undefined') {
            $.jqplot.CanvasManager.canvases = [];
            $.jqplot.CanvasManager.free = [];
        }
        
        var myCanvases = [];
        
        this.getCanvas = function() {
            var canvas;
            var makeNew = true;
            
            if (!$.jqplot.use_excanvas) {
                for (var i = 0, l = $.jqplot.CanvasManager.canvases.length; i < l; i++) {
                    if ($.jqplot.CanvasManager.free[i] === true) {
                        makeNew = false;
                        canvas = $.jqplot.CanvasManager.canvases[i];
                        // $(canvas).removeClass('jqplot-canvasManager-free').addClass('jqplot-canvasManager-inuse');
                        $.jqplot.CanvasManager.free[i] = false;
                        myCanvases.push(i);
                        break;
                    }
                }
            }

            if (makeNew) {
                canvas = document.createElement('canvas');
                myCanvases.push($.jqplot.CanvasManager.canvases.length);
                $.jqplot.CanvasManager.canvases.push(canvas);
                $.jqplot.CanvasManager.free.push(false);
            }   
            
            return canvas;
        };
        
        // this method has to be used after settings the dimesions
        // on the element returned by getCanvas()
        this.initCanvas = function(canvas) {
            if ($.jqplot.use_excanvas) {
                return window.G_vmlCanvasManager.initElement(canvas);
            }
            return canvas;
        };

        this.freeAllCanvases = function() {
            for (var i = 0, l=myCanvases.length; i < l; i++) {
                this.freeCanvas(myCanvases[i]);
            }
            myCanvases = [];
        };

        this.freeCanvas = function(idx) {
            if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {
                // excanvas can't be reused, but properly unset
                window.G_vmlCanvasManager.uninitElement($.jqplot.CanvasManager.canvases[idx]);
                $.jqplot.CanvasManager.canvases[idx] = null;
            } 
            else {
                var canvas = $.jqplot.CanvasManager.canvases[idx];
                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                $(canvas).unbind().removeAttr('class').removeAttr('style');
                // Style attributes seemed to be still hanging around.  wierd.  Some ticks
                // still retained a left: 0px attribute after reusing a canvas.
                $(canvas).css({left: '', top: '', position: ''});
                // setting size to 0 may save memory of unused canvases?
                canvas.width = 0;
                canvas.height = 0;
                $.jqplot.CanvasManager.free[idx] = true;
            }
        };
        
    };

            
    // Convienence function that won't hang IE or FF without FireBug.
    $.jqplot.log = function() {
        if (window.console) {
            window.console.log.apply(window.console, arguments);
        }
    };
        
    $.jqplot.config = {
        addDomReference: false,
        enablePlugins:false,
        defaultHeight:300,
        defaultWidth:400,
        UTCAdjust:false,
        timezoneOffset: new Date(new Date().getTimezoneOffset() * 60000),
        errorMessage: '',
        errorBackground: '',
        errorBorder: '',
        errorFontFamily: '',
        errorFontSize: '',
        errorFontStyle: '',
        errorFontWeight: '',
        catchErrors: false,
        defaultTickFormatString: "%.1f",
        defaultColors: [ "#4bb2c5", "#EAA228", "#c5b47f", "#579575", "#839557", "#958c12", "#953579", "#4b5de4", "#d8b83f", "#ff5800", "#0085cc", "#c747a3", "#cddf54", "#FBD178", "#26B4E3", "#bd70c7"],
        defaultNegativeColors: [ "#498991", "#C08840", "#9F9274", "#546D61", "#646C4A", "#6F6621", "#6E3F5F", "#4F64B0", "#A89050", "#C45923", "#187399", "#945381", "#959E5C", "#C7AF7B", "#478396", "#907294"],
        dashLength: 4,
        gapLength: 4,
        dotGapLength: 2.5,
        srcLocation: 'jqplot/src/',
        pluginLocation: 'jqplot/src/plugins/'
    };
    
    
    $.jqplot.arrayMax = function( array ){
        return Math.max.apply( Math, array );
    };
    
    $.jqplot.arrayMin = function( array ){
        return Math.min.apply( Math, array );
    };
    
    $.jqplot.enablePlugins = $.jqplot.config.enablePlugins;
    
    // canvas related tests taken from modernizer:
    // Copyright (c) 2009 - 2010 Faruk Ates.
    // http://www.modernizr.com
    
    $.jqplot.support_canvas = function() {
        if (typeof $.jqplot.support_canvas.result == 'undefined') {
            $.jqplot.support_canvas.result = !!document.createElement('canvas').getContext; 
        }
        return $.jqplot.support_canvas.result;
    };
            
    $.jqplot.support_canvas_text = function() {
        if (typeof $.jqplot.support_canvas_text.result == 'undefined') {
            if (window.G_vmlCanvasManager !== undefined && window.G_vmlCanvasManager._version > 887) {
                $.jqplot.support_canvas_text.result = true;
            }
            else {
                $.jqplot.support_canvas_text.result = !!(document.createElement('canvas').getContext && typeof document.createElement('canvas').getContext('2d').fillText == 'function');
            }
             
        }
        return $.jqplot.support_canvas_text.result;
    };
    
    $.jqplot.use_excanvas = ((!$.support.boxModel || !$.support.objectAll || !$support.leadingWhitespace) && !$.jqplot.support_canvas()) ? true : false;
    
    /**
     * 
     * Hooks: jqPlot Pugin Hooks
     * 
     * $.jqplot.preInitHooks - called before initialization.
     * $.jqplot.postInitHooks - called after initialization.
     * $.jqplot.preParseOptionsHooks - called before user options are parsed.
     * $.jqplot.postParseOptionsHooks - called after user options are parsed.
     * $.jqplot.preDrawHooks - called before plot draw.
     * $.jqplot.postDrawHooks - called after plot draw.
     * $.jqplot.preDrawSeriesHooks - called before each series is drawn.
     * $.jqplot.postDrawSeriesHooks - called after each series is drawn.
     * $.jqplot.preDrawLegendHooks - called before the legend is drawn.
     * $.jqplot.addLegendRowHooks - called at the end of legend draw, so plugins
     *     can add rows to the legend table.
     * $.jqplot.preSeriesInitHooks - called before series is initialized.
     * $.jqplot.postSeriesInitHooks - called after series is initialized.
     * $.jqplot.preParseSeriesOptionsHooks - called before series related options
     *     are parsed.
     * $.jqplot.postParseSeriesOptionsHooks - called after series related options
     *     are parsed.
     * $.jqplot.eventListenerHooks - called at the end of plot drawing, binds
     *     listeners to the event canvas which lays on top of the grid area.
     * $.jqplot.preDrawSeriesShadowHooks - called before series shadows are drawn.
     * $.jqplot.postDrawSeriesShadowHooks - called after series shadows are drawn.
     * 
     */
    
    $.jqplot.preInitHooks = [];
    $.jqplot.postInitHooks = [];
    $.jqplot.preParseOptionsHooks = [];
    $.jqplot.postParseOptionsHooks = [];
    $.jqplot.preDrawHooks = [];
    $.jqplot.postDrawHooks = [];
    $.jqplot.preDrawSeriesHooks = [];
    $.jqplot.postDrawSeriesHooks = [];
    $.jqplot.preDrawLegendHooks = [];
    $.jqplot.addLegendRowHooks = [];
    $.jqplot.preSeriesInitHooks = [];
    $.jqplot.postSeriesInitHooks = [];
    $.jqplot.preParseSeriesOptionsHooks = [];
    $.jqplot.postParseSeriesOptionsHooks = [];
    $.jqplot.eventListenerHooks = [];
    $.jqplot.preDrawSeriesShadowHooks = [];
    $.jqplot.postDrawSeriesShadowHooks = [];

    // A superclass holding some common properties and methods.
    $.jqplot.ElemContainer = function() {
        this._elem;
        this._plotWidth;
        this._plotHeight;
        this._plotDimensions = {height:null, width:null};
    };
    
    $.jqplot.ElemContainer.prototype.createElement = function(el, offsets, clss, cssopts, attrib) {
        this._offsets = offsets;
        var klass = clss || 'jqplot';
        var elem = document.createElement(el);
        this._elem = $(elem);
        this._elem.addClass(klass);
        this._elem.css(cssopts);
        this._elem.attr(attrib);
        // avoid memory leak;
        elem = null;
        return this._elem;
    };
    
    $.jqplot.ElemContainer.prototype.getWidth = function() {
        if (this._elem) {
            return this._elem.outerWidth(true);
        }
        else {
            return null;
        }
    };
    
    $.jqplot.ElemContainer.prototype.getHeight = function() {
        if (this._elem) {
            return this._elem.outerHeight(true);
        }
        else {
            return null;
        }
    };
    
    $.jqplot.ElemContainer.prototype.getPosition = function() {
        if (this._elem) {
            return this._elem.position();
        }
        else {
            return {top:null, left:null, bottom:null, right:null};
        }
    };
    
    $.jqplot.ElemContainer.prototype.getTop = function() {
        return this.getPosition().top;
    };
    
    $.jqplot.ElemContainer.prototype.getLeft = function() {
        return this.getPosition().left;
    };
    
    $.jqplot.ElemContainer.prototype.getBottom = function() {
        return this._elem.css('bottom');
    };
    
    $.jqplot.ElemContainer.prototype.getRight = function() {
        return this._elem.css('right');
    };
    

    /**
     * Class: Axis
     * An individual axis object.  Cannot be instantiated directly, but created
     * by the Plot object.  Axis properties can be set or overridden by the 
     * options passed in from the user.
     * 
     */
    function Axis(name) {
        $.jqplot.ElemContainer.call(this);
        // Group: Properties
        //
        // Axes options are specified within an axes object at the top level of the 
        // plot options like so:
        // > {
        // >    axes: {
        // >        xaxis: {min: 5},
        // >        yaxis: {min: 2, max: 8, numberTicks:4},
        // >        x2axis: {pad: 1.5},
        // >        y2axis: {ticks:[22, 44, 66, 88]}
        // >        }
        // > }
        // There are 2 x axes, 'xaxis' and 'x2axis', and 
        // 9 yaxes, 'yaxis', 'y2axis'. 'y3axis', ...  Any or all of which may be specified.
        this.name = name;
        this._series = [];
        // prop: show
        // Wether to display the axis on the graph.
        this.show = false;
        // prop: tickRenderer
        // A class of a rendering engine for creating the ticks labels displayed on the plot, 
        // See <$.jqplot.AxisTickRenderer>.
        this.tickRenderer = $.jqplot.AxisTickRenderer;
        // prop: tickOptions
        // Options that will be passed to the tickRenderer, see <$.jqplot.AxisTickRenderer> options.
        this.tickOptions = {};
        // prop: labelRenderer
        // A class of a rendering engine for creating an axis label.
        this.labelRenderer = $.jqplot.AxisLabelRenderer;
        // prop: labelOptions
        // Options passed to the label renderer.
        this.labelOptions = {};
        // prop: label
        // Label for the axis
        this.label = null;
        // prop: showLabel
        // true to show the axis label.
        this.showLabel = true;
        // prop: min
        // minimum value of the axis (in data units, not pixels).
        this.min = null;
        // prop: max
        // maximum value of the axis (in data units, not pixels).
        this.max = null;
        // prop: autoscale
        // DEPRECATED
        // the default scaling algorithm produces superior results.
        this.autoscale = false;
        // prop: pad
        // Padding to extend the range above and below the data bounds.
        // The data range is multiplied by this factor to determine minimum and maximum axis bounds.
        // A value of 0 will be interpreted to mean no padding, and pad will be set to 1.0.
        this.pad = 1.2;
        // prop: padMax
        // Padding to extend the range above data bounds.
        // The top of the data range is multiplied by this factor to determine maximum axis bounds.
        // A value of 0 will be interpreted to mean no padding, and padMax will be set to 1.0.
        this.padMax = null;
        // prop: padMin
        // Padding to extend the range below data bounds.
        // The bottom of the data range is multiplied by this factor to determine minimum axis bounds.
        // A value of 0 will be interpreted to mean no padding, and padMin will be set to 1.0.
        this.padMin = null;
        // prop: ticks
        // 1D [val, val, ...] or 2D [[val, label], [val, label], ...] array of ticks for the axis.
        // If no label is specified, the value is formatted into an appropriate label.
        this.ticks = [];
        // prop: numberTicks
        // Desired number of ticks.  Default is to compute automatically.
        this.numberTicks;
        // prop: tickInterval
        // number of units between ticks.  Mutually exclusive with numberTicks.
        this.tickInterval;
        // prop: renderer
        // A class of a rendering engine that handles tick generation, 
        // scaling input data to pixel grid units and drawing the axis element.
        this.renderer = $.jqplot.LinearAxisRenderer;
        // prop: rendererOptions
        // renderer specific options.  See <$.jqplot.LinearAxisRenderer> for options.
        this.rendererOptions = {};
        // prop: showTicks
        // Wether to show the ticks (both marks and labels) or not.
        // Will not override showMark and showLabel options if specified on the ticks themselves.
        this.showTicks = true;
        // prop: showTickMarks
        // Wether to show the tick marks (line crossing grid) or not.
        // Overridden by showTicks and showMark option of tick itself.
        this.showTickMarks = true;
        // prop: showMinorTicks
        // Wether or not to show minor ticks.  This is renderer dependent.
        this.showMinorTicks = true;
        // prop: drawMajorGridlines
        // True to draw gridlines for major axis ticks.
        this.drawMajorGridlines = true;
        // prop: drawMinorGridlines
        // True to draw gridlines for minor ticks.
        this.drawMinorGridlines = false;
        // prop: drawMajorTickMarks
        // True to draw tick marks for major axis ticks.
        this.drawMajorTickMarks = true;
        // prop: drawMinorTickMarks
        // True to draw tick marks for minor ticks.  This is renderer dependent.
        this.drawMinorTickMarks = true;
        // prop: useSeriesColor
        // Use the color of the first series associated with this axis for the
        // tick marks and line bordering this axis.
        this.useSeriesColor = false;
        // prop: borderWidth
        // width of line stroked at the border of the axis.  Defaults
        // to the width of the grid boarder.
        this.borderWidth = null;
        // prop: borderColor
        // color of the border adjacent to the axis.  Defaults to grid border color.
        this.borderColor = null;
        // prop: scaleToHiddenSeries
        // True to include hidden series when computing axes bounds and scaling.
        this.scaleToHiddenSeries = false;
        // minimum and maximum values on the axis.
        this._dataBounds = {min:null, max:null};
        // statistics (min, max, mean) as well as actual data intervals for each series attached to axis.
        // holds collection of {intervals:[], min:, max:, mean: } objects for each series on axis.
        this._intervalStats = [];
        // pixel position from the top left of the min value and max value on the axis.
        this._offsets = {min:null, max:null};
        this._ticks=[];
        this._label = null;
        // prop: syncTicks
        // true to try and synchronize tick spacing across multiple axes so that ticks and
        // grid lines line up.  This has an impact on autoscaling algorithm, however.
        // In general, autoscaling an individual axis will work better if it does not
        // have to sync ticks.
        this.syncTicks = null;
        // prop: tickSpacing
        // Approximate pixel spacing between ticks on graph.  Used during autoscaling.
        // This number will be an upper bound, actual spacing will be less.
        this.tickSpacing = 75;
        // Properties to hold the original values for min, max, ticks, tickInterval and numberTicks
        // so they can be restored if altered by plugins.
        this._min = null;
        this._max = null;
        this._tickInterval = null;
        this._numberTicks = null;
        this.__ticks = null;
        // hold original user options.
        this._options = {};
    }
    
    Axis.prototype = new $.jqplot.ElemContainer();
    Axis.prototype.constructor = Axis;
    
    Axis.prototype.init = function() {
        if ($.isFunction(this.renderer)) {
            this.renderer = new this.renderer();  
        }
        // set the axis name
        this.tickOptions.axis = this.name;
        // if showMark or showLabel tick options not specified, use value of axis option.
        // showTicks overrides showTickMarks.
        if (this.tickOptions.showMark == null) {
            this.tickOptions.showMark = this.showTicks;
        }
        if (this.tickOptions.showMark == null) {
            this.tickOptions.showMark = this.showTickMarks;
        }
        if (this.tickOptions.showLabel == null) {
            this.tickOptions.showLabel = this.showTicks;
        }
        
        if (this.label == null || this.label == '') {
            this.showLabel = false;
        }
        else {
            this.labelOptions.label = this.label;
        }
        if (this.showLabel == false) {
            this.labelOptions.show = false;
        }
        // set the default padMax, padMin if not specified
        // special check, if no padding desired, padding
        // should be set to 1.0
        if (this.pad == 0) {
            this.pad = 1.0;
        }
        if (this.padMax == 0) {
            this.padMax = 1.0;
        }
        if (this.padMin == 0) {
            this.padMin = 1.0;
        }
        if (this.padMax == null) {
            this.padMax = (this.pad-1)/2 + 1;
        }
        if (this.padMin == null) {
            this.padMin = (this.pad-1)/2 + 1;
        }
        // now that padMin and padMax are correctly set, reset pad in case user has supplied 
        // padMin and/or padMax
        this.pad = this.padMax + this.padMin - 1;
        if (this.min != null || this.max != null) {
            this.autoscale = false;
        }
        // if not set, sync ticks for y axes but not x by default.
        if (this.syncTicks == null && this.name.indexOf('y') > -1) {
            this.syncTicks = true;
        }
        else if (this.syncTicks == null){
            this.syncTicks = false;
        }
        this.renderer.init.call(this, this.rendererOptions);
        
    };
    
    Axis.prototype.draw = function(ctx, plot) {
        // Memory Leaks patch
        if (this.__ticks) {
          this.__ticks = null;
        }

        return this.renderer.draw.call(this, ctx, plot);
        
    };
    
    Axis.prototype.set = function() {
        this.renderer.set.call(this);
    };
    
    Axis.prototype.pack = function(pos, offsets) {
        if (this.show) {
            this.renderer.pack.call(this, pos, offsets);
        }
        // these properties should all be available now.
        if (this._min == null) {
            this._min = this.min;
            this._max = this.max;
            this._tickInterval = this.tickInterval;
            this._numberTicks = this.numberTicks;
            this.__ticks = this._ticks;
        }
    };
    
    // reset the axis back to original values if it has been scaled, zoomed, etc.
    Axis.prototype.reset = function() {
        this.renderer.reset.call(this);
    };
    
    Axis.prototype.resetScale = function(opts) {
        $.extend(true, this, {min: null, max: null, numberTicks: null, tickInterval: null, _ticks: [], ticks: []}, opts);
        this.resetDataBounds();
    };
    
    Axis.prototype.resetDataBounds = function() {
        // Go through all the series attached to this axis and find
        // the min/max bounds for this axis.
        var db = this._dataBounds;
        db.min = null;
        db.max = null;
        var l, s, d;
        // check for when to force min 0 on bar series plots.
        var doforce = (this.show) ? true : false;
        for (var i=0; i<this._series.length; i++) {
            s = this._series[i];
            if (s.show || this.scaleToHiddenSeries) {
                d = s._plotData;
                if (s._type === 'line' && s.renderer.bands.show && this.name.charAt(0) !== 'x') {
                    d = [[0, s.renderer.bands._min], [1, s.renderer.bands._max]];
                }

                var minyidx = 1, maxyidx = 1;

                if (s._type != null && s._type == 'ohlc') {
                    minyidx = 3;
                    maxyidx = 2;
                }
                
                for (var j=0, l=d.length; j<l; j++) { 
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        if ((d[j][0] != null && d[j][0] < db.min) || db.min == null) {
                            db.min = d[j][0];
                        }
                        if ((d[j][0] != null && d[j][0] > db.max) || db.max == null) {
                            db.max = d[j][0];
                        }
                    }              
                    else {
                        if ((d[j][minyidx] != null && d[j][minyidx] < db.min) || db.min == null) {
                            db.min = d[j][minyidx];
                        }
                        if ((d[j][maxyidx] != null && d[j][maxyidx] > db.max) || db.max == null) {
                            db.max = d[j][maxyidx];
                        }
                    }              
                }

                // Hack to not pad out bottom of bar plots unless user has specified a padding.
                // every series will have a chance to set doforce to false.  once it is set to 
                // false, it cannot be reset to true.
                // If any series attached to axis is not a bar, wont force 0.
                if (doforce && s.renderer.constructor !== $.jqplot.BarRenderer) {
                    doforce = false;
                }

                else if (doforce && this._options.hasOwnProperty('forceTickAt0') && this._options.forceTickAt0 == false) {
                    doforce = false;
                }

                else if (doforce && s.renderer.constructor === $.jqplot.BarRenderer) {
                    if (s.barDirection == 'vertical' && this.name != 'xaxis' && this.name != 'x2axis') { 
                        if (this._options.pad != null || this._options.padMin != null) {
                            doforce = false;
                        }
                    }

                    else if (s.barDirection == 'horizontal' && (this.name == 'xaxis' || this.name == 'x2axis')) {
                        if (this._options.pad != null || this._options.padMin != null) {
                            doforce = false;
                        }
                    }

                }
            }
        }

        if (doforce && this.renderer.constructor === $.jqplot.LinearAxisRenderer && db.min >= 0) {
            this.padMin = 1.0;
            this.forceTickAt0 = true;
        }
    };

    /**
     * Class: Legend
     * Legend object.  Cannot be instantiated directly, but created
     * by the Plot object.  Legend properties can be set or overridden by the 
     * options passed in from the user.
     */
    function Legend(options) {
        $.jqplot.ElemContainer.call(this);
        // Group: Properties
        
        // prop: show
        // Wether to display the legend on the graph.
        this.show = false;
        // prop: location
        // Placement of the legend.  one of the compass directions: nw, n, ne, e, se, s, sw, w
        this.location = 'ne';
        // prop: labels
        // Array of labels to use.  By default the renderer will look for labels on the series.
        // Labels specified in this array will override labels specified on the series.
        this.labels = [];
        // prop: showLabels
        // true to show the label text on the  legend.
        this.showLabels = true;
        // prop: showSwatch
        // true to show the color swatches on the legend.
        this.showSwatches = true;
        // prop: placement
        // "insideGrid" places legend inside the grid area of the plot.
        // "outsideGrid" places the legend outside the grid but inside the plot container, 
        // shrinking the grid to accomodate the legend.
        // "inside" synonym for "insideGrid", 
        // "outside" places the legend ouside the grid area, but does not shrink the grid which
        // can cause the legend to overflow the plot container.
        this.placement = "insideGrid";
        // prop: xoffset
        // DEPRECATED.  Set the margins on the legend using the marginTop, marginLeft, etc. 
        // properties or via CSS margin styling of the .jqplot-table-legend class.
        this.xoffset = 0;
        // prop: yoffset
        // DEPRECATED.  Set the margins on the legend using the marginTop, marginLeft, etc. 
        // properties or via CSS margin styling of the .jqplot-table-legend class.
        this.yoffset = 0;
        // prop: border
        // css spec for the border around the legend box.
        this.border;
        // prop: background
        // css spec for the background of the legend box.
        this.background;
        // prop: textColor
        // css color spec for the legend text.
        this.textColor;
        // prop: fontFamily
        // css font-family spec for the legend text.
        this.fontFamily; 
        // prop: fontSize
        // css font-size spec for the legend text.
        this.fontSize ;
        // prop: rowSpacing
        // css padding-top spec for the rows in the legend.
        this.rowSpacing = '0.5em';
        // renderer
        // A class that will create a DOM object for the legend,
        // see <$.jqplot.TableLegendRenderer>.
        this.renderer = $.jqplot.TableLegendRenderer;
        // prop: rendererOptions
        // renderer specific options passed to the renderer.
        this.rendererOptions = {};
        // prop: predraw
        // Wether to draw the legend before the series or not.
        // Used with series specific legend renderers for pie, donut, mekko charts, etc.
        this.preDraw = false;
        // prop: marginTop
        // CSS margin for the legend DOM element. This will set an element 
        // CSS style for the margin which will override any style sheet setting.
        // The default will be taken from the stylesheet.
        this.marginTop = null;
        // prop: marginRight
        // CSS margin for the legend DOM element. This will set an element 
        // CSS style for the margin which will override any style sheet setting.
        // The default will be taken from the stylesheet.
        this.marginRight = null;
        // prop: marginBottom
        // CSS margin for the legend DOM element. This will set an element 
        // CSS style for the margin which will override any style sheet setting.
        // The default will be taken from the stylesheet.
        this.marginBottom = null;
        // prop: marginLeft
        // CSS margin for the legend DOM element. This will set an element 
        // CSS style for the margin which will override any style sheet setting.
        // The default will be taken from the stylesheet.
        this.marginLeft = null;
        // prop: escapeHtml
        // True to escape special characters with their html entity equivalents
        // in legend text.  "<" becomes &lt; and so on, so html tags are not rendered.
        this.escapeHtml = false;
        this._series = [];
        
        $.extend(true, this, options);
    }
    
    Legend.prototype = new $.jqplot.ElemContainer();
    Legend.prototype.constructor = Legend;
    
    Legend.prototype.setOptions = function(options) {
        $.extend(true, this, options);
        
        // Try to emulate deprecated behaviour
        // if user has specified xoffset or yoffset, copy these to
        // the margin properties.
        
        if (this.placement ==  'inside') {
            this.placement = 'insideGrid';
        }
        
        if (this.xoffset >0) {
            if (this.placement == 'insideGrid') {
                switch (this.location) {
                    case 'nw':
                    case 'w':
                    case 'sw':
                        if (this.marginLeft == null) {
                            this.marginLeft = this.xoffset + 'px';
                        }
                        this.marginRight = '0px';
                        break;
                    case 'ne':
                    case 'e':
                    case 'se':
                    default:
                        if (this.marginRight == null) {
                            this.marginRight = this.xoffset + 'px';
                        }
                        this.marginLeft = '0px';
                        break;
                }
            }
            else if (this.placement == 'outside') {
                switch (this.location) {
                    case 'nw':
                    case 'w':
                    case 'sw':
                        if (this.marginRight == null) {
                            this.marginRight = this.xoffset + 'px';
                        }
                        this.marginLeft = '0px';
                        break;
                    case 'ne':
                    case 'e':
                    case 'se':
                    default:
                        if (this.marginLeft == null) {
                            this.marginLeft = this.xoffset + 'px';
                        }
                        this.marginRight = '0px';
                        break;
                }
            }
            this.xoffset = 0;
        }
        
        if (this.yoffset >0) {
            if (this.placement == 'outside') {
                switch (this.location) {
                    case 'sw':
                    case 's':
                    case 'se':
                        if (this.marginTop == null) {
                            this.marginTop = this.yoffset + 'px';
                        }
                        this.marginBottom = '0px';
                        break;
                    case 'ne':
                    case 'n':
                    case 'nw':
                    default:
                        if (this.marginBottom == null) {
                            this.marginBottom = this.yoffset + 'px';
                        }
                        this.marginTop = '0px';
                        break;
                }
            }
            else if (this.placement == 'insideGrid') {
                switch (this.location) {
                    case 'sw':
                    case 's':
                    case 'se':
                        if (this.marginBottom == null) {
                            this.marginBottom = this.yoffset + 'px';
                        }
                        this.marginTop = '0px';
                        break;
                    case 'ne':
                    case 'n':
                    case 'nw':
                    default:
                        if (this.marginTop == null) {
                            this.marginTop = this.yoffset + 'px';
                        }
                        this.marginBottom = '0px';
                        break;
                }
            }
            this.yoffset = 0;
        }
        
        // TO-DO:
        // Handle case where offsets are < 0.
        //
    };
    
    Legend.prototype.init = function() {
        if ($.isFunction(this.renderer)) {
            this.renderer = new this.renderer();  
        }
        this.renderer.init.call(this, this.rendererOptions);
    };
    
    Legend.prototype.draw = function(offsets, plot) {
        for (var i=0; i<$.jqplot.preDrawLegendHooks.length; i++){
            $.jqplot.preDrawLegendHooks[i].call(this, offsets);
        }
        return this.renderer.draw.call(this, offsets, plot);
    };
    
    Legend.prototype.pack = function(offsets) {
        this.renderer.pack.call(this, offsets);
    };

    /**
     * Class: Title
     * Plot Title object.  Cannot be instantiated directly, but created
     * by the Plot object.  Title properties can be set or overridden by the 
     * options passed in from the user.
     * 
     * Parameters:
     * text - text of the title.
     */
    function Title(text) {
        $.jqplot.ElemContainer.call(this);
        // Group: Properties
        
        // prop: text
        // text of the title;
        this.text = text;
        // prop: show
        // whether or not to show the title
        this.show = true;
        // prop: fontFamily
        // css font-family spec for the text.
        this.fontFamily;
        // prop: fontSize
        // css font-size spec for the text.
        this.fontSize ;
        // prop: textAlign
        // css text-align spec for the text.
        this.textAlign;
        // prop: textColor
        // css color spec for the text.
        this.textColor;
        // prop: renderer
        // A class for creating a DOM element for the title,
        // see <$.jqplot.DivTitleRenderer>.
        this.renderer = $.jqplot.DivTitleRenderer;
        // prop: rendererOptions
        // renderer specific options passed to the renderer.
        this.rendererOptions = {};   
        // prop: escapeHtml
        // True to escape special characters with their html entity equivalents
        // in title text.  "<" becomes &lt; and so on, so html tags are not rendered.
        this.escapeHtml = false;
    }
    
    Title.prototype = new $.jqplot.ElemContainer();
    Title.prototype.constructor = Title;
    
    Title.prototype.init = function() {
        if ($.isFunction(this.renderer)) {
            this.renderer = new this.renderer();  
        }
        this.renderer.init.call(this, this.rendererOptions);
    };
    
    Title.prototype.draw = function(width) {
        return this.renderer.draw.call(this, width);
    };
    
    Title.prototype.pack = function() {
        this.renderer.pack.call(this);
    };


    /**
     * Class: Series
     * An individual data series object.  Cannot be instantiated directly, but created
     * by the Plot object.  Series properties can be set or overridden by the 
     * options passed in from the user.
     */
    function Series(options) {
        options = options || {};
        $.jqplot.ElemContainer.call(this);
        // Group: Properties
        // Properties will be assigned from a series array at the top level of the
        // options.  If you had two series and wanted to change the color and line
        // width of the first and set the second to use the secondary y axis with
        // no shadow and supply custom labels for each:
        // > {
        // >    series:[
        // >        {color: '#ff4466', lineWidth: 5, label:'good line'},
        // >        {yaxis: 'y2axis', shadow: false, label:'bad line'}
        // >    ]
        // > }

        // prop: show
        // whether or not to draw the series.
        this.show = true;
        // prop: xaxis
        // which x axis to use with this series, either 'xaxis' or 'x2axis'.
        this.xaxis = 'xaxis';
        this._xaxis;
        // prop: yaxis
        // which y axis to use with this series, either 'yaxis' or 'y2axis'.
        this.yaxis = 'yaxis';
        this._yaxis;
        this.gridBorderWidth = 2.0;
        // prop: renderer
        // A class of a renderer which will draw the series, 
        // see <$.jqplot.LineRenderer>.
        this.renderer = $.jqplot.LineRenderer;
        // prop: rendererOptions
        // Options to pass on to the renderer.
        this.rendererOptions = {};
        this.data = [];
        this.gridData = [];
        // prop: label
        // Line label to use in the legend.
        this.label = '';
        // prop: showLabel
        // true to show label for this series in the legend.
        this.showLabel = true;
        // prop: color
        // css color spec for the series
        this.color;
        // prop: negativeColor
        // css color spec used for filled (area) plots that are filled to zero and
        // the "useNegativeColors" option is true.
        this.negativeColor;
        // prop: lineWidth
        // width of the line in pixels.  May have different meanings depending on renderer.
        this.lineWidth = 2.5;
        // prop: lineJoin
        // Canvas lineJoin style between segments of series.
        this.lineJoin = 'round';
        // prop: lineCap
        // Canvas lineCap style at ends of line.
        this.lineCap = 'round';
        // prop: linePattern
        // line pattern 'dashed', 'dotted', 'solid', some combination
        // of '-' and '.' characters such as '.-.' or a numerical array like 
        // [draw, skip, draw, skip, ...] such as [1, 10] to draw a dotted line, 
        // [1, 10, 20, 10] to draw a dot-dash line, and so on.
        this.linePattern = 'solid';
        this.shadow = true;
        // prop: shadowAngle
        // Shadow angle in degrees
        this.shadowAngle = 45;
        // prop: shadowOffset
        // Shadow offset from line in pixels
        this.shadowOffset = 1.25;
        // prop: shadowDepth
        // Number of times shadow is stroked, each stroke offset shadowOffset from the last.
        this.shadowDepth = 3;
        // prop: shadowAlpha
        // Alpha channel transparency of shadow.  0 = transparent.
        this.shadowAlpha = '0.1';
        // prop: breakOnNull
        // Wether line segments should be be broken at null value.
        // False will join point on either side of line.
        this.breakOnNull = false;
        // prop: markerRenderer
        // A class of a renderer which will draw marker (e.g. circle, square, ...) at the data points,
        // see <$.jqplot.MarkerRenderer>.
        this.markerRenderer = $.jqplot.MarkerRenderer;
        // prop: markerOptions
        // renderer specific options to pass to the markerRenderer,
        // see <$.jqplot.MarkerRenderer>.
        this.markerOptions = {};
        // prop: showLine
        // whether to actually draw the line or not.  Series will still be renderered, even if no line is drawn.
        this.showLine = true;
        // prop: showMarker
        // whether or not to show the markers at the data points.
        this.showMarker = true;
        // prop: index
        // 0 based index of this series in the plot series array.
        this.index;
        // prop: fill
        // true or false, whether to fill under lines or in bars.
        // May not be implemented in all renderers.
        this.fill = false;
        // prop: fillColor
        // CSS color spec to use for fill under line.  Defaults to line color.
        this.fillColor;
        // prop: fillAlpha
        // Alpha transparency to apply to the fill under the line.
        // Use this to adjust alpha separate from fill color.
        this.fillAlpha;
        // prop: fillAndStroke
        // If true will stroke the line (with color this.color) as well as fill under it.
        // Applies only when fill is true.
        this.fillAndStroke = false;
        // prop: disableStack
        // true to not stack this series with other series in the plot.
        // To render properly, non-stacked series must come after any stacked series
        // in the plot's data series array.  So, the plot's data series array would look like:
        // > [stackedSeries1, stackedSeries2, ..., nonStackedSeries1, nonStackedSeries2, ...]
        // disableStack will put a gap in the stacking order of series, and subsequent
        // stacked series will not fill down through the non-stacked series and will
        // most likely not stack properly on top of the non-stacked series.
        this.disableStack = false;
        // _stack is set by the Plot if the plot is a stacked chart.
        // will stack lines or bars on top of one another to build a "mountain" style chart.
        // May not be implemented in all renderers.
        this._stack = false;
        // prop: neighborThreshold
        // how close or far (in pixels) the cursor must be from a point marker to detect the point.
        this.neighborThreshold = 4;
        // prop: fillToZero
        // true will force bar and filled series to fill toward zero on the fill Axis.
        this.fillToZero = false;
        // prop: fillToValue
        // fill a filled series to this value on the fill axis.
        // Works in conjunction with fillToZero, so that must be true.
        this.fillToValue = 0;
        // prop: fillAxis
        // Either 'x' or 'y'.  Which axis to fill the line toward if fillToZero is true.
        // 'y' means fill up/down to 0 on the y axis for this series.
        this.fillAxis = 'y';
        // prop: useNegativeColors
        // true to color negative values differently in filled and bar charts.
        this.useNegativeColors = true;
        this._stackData = [];
        // _plotData accounts for stacking.  If plots not stacked, _plotData and data are same.  If
        // stacked, _plotData is accumulation of stacking data.
        this._plotData = [];
        // _plotValues hold the individual x and y values that will be plotted for this series.
        this._plotValues = {x:[], y:[]};
        // statistics about the intervals between data points.  Used for auto scaling.
        this._intervals = {x:{}, y:{}};
        // data from the previous series, for stacked charts.
        this._prevPlotData = [];
        this._prevGridData = [];
        this._stackAxis = 'y';
        this._primaryAxis = '_xaxis';
        // give each series a canvas to draw on.  This should allow for redrawing speedups.
        this.canvas = new $.jqplot.GenericCanvas();
        this.shadowCanvas = new $.jqplot.GenericCanvas();
        this.plugins = {};
        // sum of y values in this series.
        this._sumy = 0;
        this._sumx = 0;
        this._type = '';
    }
    
    Series.prototype = new $.jqplot.ElemContainer();
    Series.prototype.constructor = Series;
    
    Series.prototype.init = function(index, gridbw, plot) {
        // weed out any null values in the data.
        this.index = index;
        this.gridBorderWidth = gridbw;
        var d = this.data;
        var temp = [], i, l;
        for (i=0, l=d.length; i<l; i++) {
            if (! this.breakOnNull) {
                if (d[i] == null || d[i][0] == null || d[i][1] == null) {
                    continue;
                }
                else {
                    temp.push(d[i]);
                }
            }
            else {
                // TODO: figure out what to do with null values
                // probably involve keeping nulls in data array
                // and then updating renderers to break line
                // when it hits null value.
                // For now, just keep value.
                temp.push(d[i]);
            }
        }
        this.data = temp;

        // parse the renderer options and apply default colors if not provided
        // Set color even if not shown, so series don't change colors when other
        // series on plot shown/hidden.
        if (!this.color) {
            this.color = plot.colorGenerator.get(this.index);
        }
        if (!this.negativeColor) {
            this.negativeColor = plot.negativeColorGenerator.get(this.index);
        }


        if (!this.fillColor) {
            this.fillColor = this.color;
        }
        if (this.fillAlpha) {
            var comp = $.jqplot.normalize2rgb(this.fillColor);
            var comp = $.jqplot.getColorComponents(comp);
            this.fillColor = 'rgba('+comp[0]+','+comp[1]+','+comp[2]+','+this.fillAlpha+')';
        }
        if ($.isFunction(this.renderer)) {
            this.renderer = new this.renderer();  
        }
        this.renderer.init.call(this, this.rendererOptions, plot);
        this.markerRenderer = new this.markerRenderer();
        if (!this.markerOptions.color) {
            this.markerOptions.color = this.color;
        }
        if (this.markerOptions.show == null) {
            this.markerOptions.show = this.showMarker;
        }
        this.showMarker = this.markerOptions.show;
        // the markerRenderer is called within its own scope, don't want to overwrite series options!!
        this.markerRenderer.init(this.markerOptions);
    };
    
    // data - optional data point array to draw using this series renderer
    // gridData - optional grid data point array to draw using this series renderer
    // stackData - array of cumulative data for stacked plots.
    Series.prototype.draw = function(sctx, opts, plot) {
        var options = (opts == undefined) ? {} : opts;
        sctx = (sctx == undefined) ? this.canvas._ctx : sctx;
        
        var j, data, gridData;
        
        // hooks get called even if series not shown
        // we don't clear canvas here, it would wipe out all other series as well.
        for (j=0; j<$.jqplot.preDrawSeriesHooks.length; j++) {
            $.jqplot.preDrawSeriesHooks[j].call(this, sctx, options);
        }
        if (this.show) {
            this.renderer.setGridData.call(this, plot);
            if (!options.preventJqPlotSeriesDrawTrigger) {
                $(sctx.canvas).trigger('jqplotSeriesDraw', [this.data, this.gridData]);
            }
            data = [];
            if (options.data) {
                data = options.data;
            }
            else if (!this._stack) {
                data = this.data;
            }
            else {
                data = this._plotData;
            }
            gridData = options.gridData || this.renderer.makeGridData.call(this, data, plot);

            if (this._type === 'line' && this.renderer.smooth && this.renderer._smoothedData.length) {
                gridData = this.renderer._smoothedData;
            }

            this.renderer.draw.call(this, sctx, gridData, options, plot);
        }
        
        for (j=0; j<$.jqplot.postDrawSeriesHooks.length; j++) {
            $.jqplot.postDrawSeriesHooks[j].call(this, sctx, options, plot);
        }
        
        sctx = opts = plot = j = data = gridData = null;
    };
    
    Series.prototype.drawShadow = function(sctx, opts, plot) {
        var options = (opts == undefined) ? {} : opts;
        sctx = (sctx == undefined) ? this.shadowCanvas._ctx : sctx;
        
        var j, data, gridData;
        
        // hooks get called even if series not shown
        // we don't clear canvas here, it would wipe out all other series as well.
        for (j=0; j<$.jqplot.preDrawSeriesShadowHooks.length; j++) {
            $.jqplot.preDrawSeriesShadowHooks[j].call(this, sctx, options);
        }
        if (this.shadow) {
            this.renderer.setGridData.call(this, plot);

            data = [];
            if (options.data) {
                data = options.data;
            }
            else if (!this._stack) {
                data = this.data;
            }
            else {
                data = this._plotData;
            }
            gridData = options.gridData || this.renderer.makeGridData.call(this, data, plot);
        
            this.renderer.drawShadow.call(this, sctx, gridData, options, plot);
        }
        
        for (j=0; j<$.jqplot.postDrawSeriesShadowHooks.length; j++) {
            $.jqplot.postDrawSeriesShadowHooks[j].call(this, sctx, options);
        }
        
        sctx = opts = plot = j = data = gridData = null;
        
    };
    
    // toggles series display on plot, e.g. show/hide series
    Series.prototype.toggleDisplay = function(ev, callback) {
        var s, speed;
        if (ev.data.series) {
            s = ev.data.series;
        }
        else {
            s = this;
        }

        if (ev.data.speed) {
            speed = ev.data.speed;
        }
        if (speed) {
            // this can be tricky because series may not have a canvas element if replotting.
            if (s.canvas._elem.is(':hidden') || !s.show) {
                s.show = true;

                s.canvas._elem.removeClass('jqplot-series-hidden');
                if (s.shadowCanvas._elem) {
                    s.shadowCanvas._elem.fadeIn(speed);
                }
                s.canvas._elem.fadeIn(speed, callback);
                s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-'+s.index).fadeIn(speed);
            }
            else {
                s.show = false;

                s.canvas._elem.addClass('jqplot-series-hidden');
                if (s.shadowCanvas._elem) {
                    s.shadowCanvas._elem.fadeOut(speed);
                }
                s.canvas._elem.fadeOut(speed, callback);
                s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-'+s.index).fadeOut(speed);
            }
        }
        else {
            // this can be tricky because series may not have a canvas element if replotting.
            if (s.canvas._elem.is(':hidden') || !s.show) {
                s.show = true;

                s.canvas._elem.removeClass('jqplot-series-hidden');
                if (s.shadowCanvas._elem) {
                    s.shadowCanvas._elem.show();
                }
                s.canvas._elem.show(0, callback);
                s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-'+s.index).show();
            }
            else {
                s.show = false;

                s.canvas._elem.addClass('jqplot-series-hidden');
                if (s.shadowCanvas._elem) {
                    s.shadowCanvas._elem.hide();
                }
                s.canvas._elem.hide(0, callback);
                s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-'+s.index).hide();
            }
        }
    };
    


    /**
     * Class: Grid
     * 
     * Object representing the grid on which the plot is drawn.  The grid in this
     * context is the area bounded by the axes, the area which will contain the series.
     * Note, the series are drawn on their own canvas.
     * The Grid object cannot be instantiated directly, but is created by the Plot object.  
     * Grid properties can be set or overridden by the options passed in from the user.
     */
    function Grid() {
        $.jqplot.ElemContainer.call(this);
        // Group: Properties
        
        // prop: drawGridlines
        // whether to draw the gridlines on the plot.
        this.drawGridlines = true;
        // prop: gridLineColor
        // color of the grid lines.
        this.gridLineColor = '#cccccc';
        // prop: gridLineWidth
        // width of the grid lines.
        this.gridLineWidth = 1.0;
        // prop: background
        // css spec for the background color.
        this.background = '#fffdf6';
        // prop: borderColor
        // css spec for the color of the grid border.
        this.borderColor = '#999999';
        // prop: borderWidth
        // width of the border in pixels.
        this.borderWidth = 2.0;
        // prop: drawBorder
        // True to draw border around grid.
        this.drawBorder = true;
        // prop: shadow
        // whether to show a shadow behind the grid.
        this.shadow = true;
        // prop: shadowAngle
        // shadow angle in degrees
        this.shadowAngle = 45;
        // prop: shadowOffset
        // Offset of each shadow stroke from the border in pixels
        this.shadowOffset = 1.5;
        // prop: shadowWidth
        // width of the stoke for the shadow
        this.shadowWidth = 3;
        // prop: shadowDepth
        // Number of times shadow is stroked, each stroke offset shadowOffset from the last.
        this.shadowDepth = 3;
        // prop: shadowColor
        // an optional css color spec for the shadow in 'rgba(n, n, n, n)' form
        this.shadowColor = null;
        // prop: shadowAlpha
        // Alpha channel transparency of shadow.  0 = transparent.
        this.shadowAlpha = '0.07';
        this._left;
        this._top;
        this._right;
        this._bottom;
        this._width;
        this._height;
        this._axes = [];
        // prop: renderer
        // Instance of a renderer which will actually render the grid,
        // see <$.jqplot.CanvasGridRenderer>.
        this.renderer = $.jqplot.CanvasGridRenderer;
        // prop: rendererOptions
        // Options to pass on to the renderer,
        // see <$.jqplot.CanvasGridRenderer>.
        this.rendererOptions = {};
        this._offsets = {top:null, bottom:null, left:null, right:null};
    }
    
    Grid.prototype = new $.jqplot.ElemContainer();
    Grid.prototype.constructor = Grid;
    
    Grid.prototype.init = function() {
        if ($.isFunction(this.renderer)) {
            this.renderer = new this.renderer();  
        }
        this.renderer.init.call(this, this.rendererOptions);
    };
    
    Grid.prototype.createElement = function(offsets,plot) {
        this._offsets = offsets;
        return this.renderer.createElement.call(this, plot);
    };
    
    Grid.prototype.draw = function() {
        this.renderer.draw.call(this);
    };
    
    $.jqplot.GenericCanvas = function() {
        $.jqplot.ElemContainer.call(this);
        this._ctx;  
    };
    
    $.jqplot.GenericCanvas.prototype = new $.jqplot.ElemContainer();
    $.jqplot.GenericCanvas.prototype.constructor = $.jqplot.GenericCanvas;
    
    $.jqplot.GenericCanvas.prototype.createElement = function(offsets, clss, plotDimensions, plot) {
        this._offsets = offsets;
        var klass = 'jqplot';
        if (clss != undefined) {
            klass = clss;
        }
        var elem;

        elem = plot.canvasManager.getCanvas();
        
        // if new plotDimensions supplied, use them.
        if (plotDimensions != null) {
            this._plotDimensions = plotDimensions;
        }
        
        elem.width = this._plotDimensions.width - this._offsets.left - this._offsets.right;
        elem.height = this._plotDimensions.height - this._offsets.top - this._offsets.bottom;
        this._elem = $(elem);
        this._elem.css({ position: 'absolute', left: this._offsets.left, top: this._offsets.top });
        
        this._elem.addClass(klass);
        
        elem = plot.canvasManager.initCanvas(elem);
        
        elem = null;
        return this._elem;
    };
    
    $.jqplot.GenericCanvas.prototype.setContext = function() {
        this._ctx = this._elem.get(0).getContext("2d");
        return this._ctx;
    };
    
    // Memory Leaks patch
    $.jqplot.GenericCanvas.prototype.resetCanvas = function() {
      if (this._elem) {
        if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {
           window.G_vmlCanvasManager.uninitElement(this._elem.get(0));
        }
        
        //this._elem.remove();
        this._elem.emptyForce();
      }
      
      this._ctx = null;
    };
    
    $.jqplot.HooksManager = function () {
        this.hooks =[];
        this.args = [];
    };
    
    $.jqplot.HooksManager.prototype.addOnce = function(fn, args) {
        args = args || [];
        var havehook = false;
        for (var i=0, l=this.hooks.length; i<l; i++) {
            if (this.hooks[i] == fn) {
                havehook = true;
            }
        }
        if (!havehook) {
            this.hooks.push(fn);
            this.args.push(args);
        }
    };
    
    $.jqplot.HooksManager.prototype.add = function(fn, args) {
        args = args || [];
        this.hooks.push(fn);
        this.args.push(args);
    };
    
    $.jqplot.EventListenerManager = function () {
        this.hooks =[];
    };
    
    $.jqplot.EventListenerManager.prototype.addOnce = function(ev, fn) {
        var havehook = false, h, i;
        for (var i=0, l=this.hooks.length; i<l; i++) {
            h = this.hooks[i];
            if (h[0] == ev && h[1] == fn) {
                havehook = true;
            }
        }
        if (!havehook) {
            this.hooks.push([ev, fn]);
        }
    };
    
    $.jqplot.EventListenerManager.prototype.add = function(ev, fn) {
        this.hooks.push([ev, fn]);
    };


    var _axisNames = ['yMidAxis', 'xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis'];

    /**
     * Class: jqPlot
     * Plot object returned by call to $.jqplot.  Handles parsing user options,
     * creating sub objects (Axes, legend, title, series) and rendering the plot.
     */
    function jqPlot() {
        // Group: Properties
        // These properties are specified at the top of the options object
        // like so:
        // > {
        // >     axesDefaults:{min:0},
        // >     series:[{color:'#6633dd'}],
        // >     title: 'A Plot'
        // > }
        //

        // prop: animate
        // True to animate the series on initial plot draw (renderer dependent).
        // Actual animation functionality must be supported in the renderer.
        this.animate = false;
        // prop: animateReplot
        // True to animate series after a call to the replot() method.
        // Use with caution!  Replots can happen very frequently under
        // certain circumstances (e.g. resizing, dragging points) and
        // animation in these situations can cause problems.
        this.animateReplot = false;
        // prop: axes
        // up to 4 axes are supported, each with its own options, 
        // See <Axis> for axis specific options.
        this.axes = {xaxis: new Axis('xaxis'), yaxis: new Axis('yaxis'), x2axis: new Axis('x2axis'), y2axis: new Axis('y2axis'), y3axis: new Axis('y3axis'), y4axis: new Axis('y4axis'), y5axis: new Axis('y5axis'), y6axis: new Axis('y6axis'), y7axis: new Axis('y7axis'), y8axis: new Axis('y8axis'), y9axis: new Axis('y9axis'), yMidAxis: new Axis('yMidAxis')};
        this.baseCanvas = new $.jqplot.GenericCanvas();
        // true to intercept right click events and fire a 'jqplotRightClick' event.
        // this will also block the context menu.
        this.captureRightClick = false;
        // prop: data
        // user's data.  Data should *NOT* be specified in the options object,
        // but be passed in as the second argument to the $.jqplot() function.
        // The data property is described here soley for reference. 
        // The data should be in the form of an array of 2D or 1D arrays like
        // > [ [[x1, y1], [x2, y2],...], [y1, y2, ...] ].
        this.data = [];
        // prop: dataRenderer
        // A callable which can be used to preprocess data passed into the plot.
        // Will be called with 3 arguments: the plot data, a reference to the plot,
        // and the value of dataRendererOptions.
        this.dataRenderer;
        // prop: dataRendererOptions
        // Options that will be passed to the dataRenderer.
        // Can be of any type.
        this.dataRendererOptions;
        this.defaults = {
            // prop: axesDefaults
            // default options that will be applied to all axes.
            // see <Axis> for axes options.
            axesDefaults: {},
            axes: {xaxis:{}, yaxis:{}, x2axis:{}, y2axis:{}, y3axis:{}, y4axis:{}, y5axis:{}, y6axis:{}, y7axis:{}, y8axis:{}, y9axis:{}, yMidAxis:{}},
            // prop: seriesDefaults
            // default options that will be applied to all series.
            // see <Series> for series options.
            seriesDefaults: {},
            series:[]
        };
        // prop: defaultAxisStart
        // 1-D data series are internally converted into 2-D [x,y] data point arrays
        // by jqPlot.  This is the default starting value for the missing x or y value.
        // The added data will be a monotonically increasing series (e.g. [1, 2, 3, ...])
        // starting at this value.
        this.defaultAxisStart = 1;
        // this.doCustomEventBinding = true;
        // prop: drawIfHidden
        // True to execute the draw method even if the plot target is hidden.
        // Generally, this should be false.  Most plot elements will not be sized/
        // positioned correclty if renderered into a hidden container.  To render into
        // a hidden container, call the replot method when the container is shown.
        this.drawIfHidden = false;
        this.eventCanvas = new $.jqplot.GenericCanvas();
        // prop: fillBetween
        // Fill between 2 line series in a plot.
        // Options object:
        // {
        //    series1: first index (0 based) of series in fill
        //    series2: second index (0 based) of series in fill
        //    color: color of fill [default fillColor of series1]
        //    baseSeries:  fill will be drawn below this series (0 based index)
        //    fill: false to turn off fill [default true].
        //  }
        this.fillBetween = {
            series1: null,
            series2: null,
            color: null,
            baseSeries: 0,
            fill: true
        };
        // prop; fontFamily
        // css spec for the font-family attribute.  Default for the entire plot.
        this.fontFamily;
        // prop: fontSize
        // css spec for the font-size attribute.  Default for the entire plot.
        this.fontSize;
        // prop: grid
        // See <Grid> for grid specific options.
        this.grid = new Grid();
        // prop: legend
        // see <$.jqplot.TableLegendRenderer>
        this.legend = new Legend();
        // prop: noDataIndicator
        // Options to set up a mock plot with a data loading indicator if no data is specified.
        this.noDataIndicator = {    
            show: false,
            indicator: 'Loading Data...',
            axes: {
                xaxis: {
                    min: 0,
                    max: 10,
                    tickInterval: 2,
                    show: true
                },
                yaxis: {
                    min: 0,
                    max: 12,
                    tickInterval: 3,
                    show: true
                }
            }
        };
        // prop: negativeSeriesColors 
        // colors to use for portions of the line below zero.
        this.negativeSeriesColors = $.jqplot.config.defaultNegativeColors;
        // container to hold all of the merged options.  Convienence for plugins.
        this.options = {};
        this.previousSeriesStack = [];
        // Namespace to hold plugins.  Generally non-renderer plugins add themselves to here.
        this.plugins = {};
        // prop: series
        // Array of series object options.
        // see <Series> for series specific options.
        this.series = [];
        // array of series indices. Keep track of order
        // which series canvases are displayed, lowest
        // to highest, back to front.
        this.seriesStack = [];
        // prop: seriesColors
        // Ann array of CSS color specifications that will be applied, in order,
        // to the series in the plot.  Colors will wrap around so, if their
        // are more series than colors, colors will be reused starting at the
        // beginning.  For pie charts, this specifies the colors of the slices.
        this.seriesColors = $.jqplot.config.defaultColors;
        // prop: sortData
        // false to not sort the data passed in by the user.
        // Many bar, stacked and other graphs as well as many plugins depend on
        // having sorted data.
        this.sortData = true;
        // prop: stackSeries
        // true or false, creates a stack or "mountain" plot.
        // Not all series renderers may implement this option.
        this.stackSeries = false;
        // a shortcut for axis syncTicks options.  Not implemented yet.
        this.syncXTicks = true;
        // a shortcut for axis syncTicks options.  Not implemented yet.
        this.syncYTicks = true;
        // the jquery object for the dom target.
        this.target = null; 
        // The id of the dom element to render the plot into
        this.targetId = null;
        // prop textColor
        // css spec for the css color attribute.  Default for the entire plot.
        this.textColor;
        // prop: title
        // Title object.  See <Title> for specific options.  As a shortcut, you
        // can specify the title option as just a string like: title: 'My Plot'
        // and this will create a new title object with the specified text.
        this.title = new Title();
        // Count how many times the draw method has been called while the plot is visible.
        // Mostly used to test if plot has never been dran (=0), has been successfully drawn
        // into a visible container once (=1) or draw more than once into a visible container.
        // Can use this in tests to see if plot has been visibly drawn at least one time.
        // After plot has been visibly drawn once, it generally doesn't need redrawing if its
        // container is hidden and shown.
        this._drawCount = 0;
        // sum of y values for all series in plot.
        // used in mekko chart.
        this._sumy = 0;
        this._sumx = 0;
        // array to hold the cumulative stacked series data.
        // used to ajust the individual series data, which won't have access to other
        // series data.
        this._stackData = [];
        // array that holds the data to be plotted. This will be the series data
        // merged with the the appropriate data from _stackData according to the stackAxis.
        this._plotData = [];
        this._width = null;
        this._height = null; 
        this._plotDimensions = {height:null, width:null};
        this._gridPadding = {top:null, right:null, bottom:null, left:null};
        this._defaultGridPadding = {top:10, right:10, bottom:23, left:10};

        this._addDomReference = $.jqplot.config.addDomReference;

        this.preInitHooks = new $.jqplot.HooksManager();
        this.postInitHooks = new $.jqplot.HooksManager();
        this.preParseOptionsHooks = new $.jqplot.HooksManager();
        this.postParseOptionsHooks = new $.jqplot.HooksManager();
        this.preDrawHooks = new $.jqplot.HooksManager();
        this.postDrawHooks = new $.jqplot.HooksManager();
        this.preDrawSeriesHooks = new $.jqplot.HooksManager();
        this.postDrawSeriesHooks = new $.jqplot.HooksManager();
        this.preDrawLegendHooks = new $.jqplot.HooksManager();
        this.addLegendRowHooks = new $.jqplot.HooksManager();
        this.preSeriesInitHooks = new $.jqplot.HooksManager();
        this.postSeriesInitHooks = new $.jqplot.HooksManager();
        this.preParseSeriesOptionsHooks = new $.jqplot.HooksManager();
        this.postParseSeriesOptionsHooks = new $.jqplot.HooksManager();
        this.eventListenerHooks = new $.jqplot.EventListenerManager();
        this.preDrawSeriesShadowHooks = new $.jqplot.HooksManager();
        this.postDrawSeriesShadowHooks = new $.jqplot.HooksManager();
        
        this.colorGenerator = new $.jqplot.ColorGenerator();
        this.negativeColorGenerator = new $.jqplot.ColorGenerator();

        this.canvasManager = new $.jqplot.CanvasManager();

        this.themeEngine = new $.jqplot.ThemeEngine();
        
        var seriesColorsIndex = 0;

        // Group: methods
        //
        // method: init
        // sets the plot target, checks data and applies user
        // options to plot.
        this.init = function(target, data, options) {
            options = options || {};
            for (var i=0; i<$.jqplot.preInitHooks.length; i++) {
                $.jqplot.preInitHooks[i].call(this, target, data, options);
            }

            for (var i=0; i<this.preInitHooks.hooks.length; i++) {
                this.preInitHooks.hooks[i].call(this, target, data, options);
            }
            
            this.targetId = '#'+target;
            this.target = $('#'+target);

            //////
            // Add a reference to plot
            //////
            if (this._addDomReference) {
                this.target.data('jqplot', this);
            }
            // remove any error class that may be stuck on target.
            this.target.removeClass('jqplot-error');
            if (!this.target.get(0)) {
                throw new Error("No plot target specified");
            }
            
            // make sure the target is positioned by some means and set css
            if (this.target.css('position') == 'static') {
                this.target.css('position', 'relative');
            }
            if (!this.target.hasClass('jqplot-target')) {
                this.target.addClass('jqplot-target');
            }
            
            // if no height or width specified, use a default.
            if (!this.target.height()) {
                var h;
                if (options && options.height) {
                    h = parseInt(options.height, 10);
                }
                else if (this.target.attr('data-height')) {
                    h = parseInt(this.target.attr('data-height'), 10);
                }
                else {
                    h = parseInt($.jqplot.config.defaultHeight, 10);
                }
                this._height = h;
                this.target.css('height', h+'px');
            }
            else {
                this._height = h = this.target.height();
            }
            if (!this.target.width()) {
                var w;
                if (options && options.width) {
                    w = parseInt(options.width, 10);
                }
                else if (this.target.attr('data-width')) {
                    w = parseInt(this.target.attr('data-width'), 10);
                }
                else {
                    w = parseInt($.jqplot.config.defaultWidth, 10);
                }
                this._width = w;
                this.target.css('width', w+'px');
            }
            else {
                this._width = w = this.target.width();
            }

            for (var i=0, l=_axisNames.length; i<l; i++) {
                this.axes[_axisNames[i]] = new Axis(_axisNames[i]);
            }
            
            this._plotDimensions.height = this._height;
            this._plotDimensions.width = this._width;
            this.grid._plotDimensions = this._plotDimensions;
            this.title._plotDimensions = this._plotDimensions;
            this.baseCanvas._plotDimensions = this._plotDimensions;
            this.eventCanvas._plotDimensions = this._plotDimensions;
            this.legend._plotDimensions = this._plotDimensions;
            if (this._height <=0 || this._width <=0 || !this._height || !this._width) {
                throw new Error("Canvas dimension not set");
            }
            
            if (options.dataRenderer && $.isFunction(options.dataRenderer)) {
                if (options.dataRendererOptions) {
                    this.dataRendererOptions = options.dataRendererOptions;
                }
                this.dataRenderer = options.dataRenderer;
                data = this.dataRenderer(data, this, this.dataRendererOptions);
            }
            
            if (options.noDataIndicator && $.isPlainObject(options.noDataIndicator)) {
                $.extend(true, this.noDataIndicator, options.noDataIndicator);
            }
            
            if (data == null || $.isArray(data) == false || data.length == 0 || $.isArray(data[0]) == false || data[0].length == 0) {
                
                if (this.noDataIndicator.show == false) {
                    throw new Error("No data specified");
                }
                
                else {
                    // have to be descructive here in order for plot to not try and render series.
                    // This means that $.jqplot() will have to be called again when there is data.
                    //delete options.series;
                    
                    for (var ax in this.noDataIndicator.axes) {
                        for (var prop in this.noDataIndicator.axes[ax]) {
                            this.axes[ax][prop] = this.noDataIndicator.axes[ax][prop];
                        }
                    }
                    
                    this.postDrawHooks.add(function() {
                        var eh = this.eventCanvas.getHeight();
                        var ew = this.eventCanvas.getWidth();
                        var temp = $('<div class="jqplot-noData-container" style="position:absolute;"></div>');
                        this.target.append(temp);
                        temp.height(eh);
                        temp.width(ew);
                        temp.css('top', this.eventCanvas._offsets.top);
                        temp.css('left', this.eventCanvas._offsets.left);
                        
                        var temp2 = $('<div class="jqplot-noData-contents" style="text-align:center; position:relative; margin-left:auto; margin-right:auto;"></div>');
                        temp.append(temp2);
                        temp2.html(this.noDataIndicator.indicator);
                        var th = temp2.height();
                        var tw = temp2.width();
                        temp2.height(th);
                        temp2.width(tw);
                        temp2.css('top', (eh - th)/2 + 'px');
                    });

                }
            }
            
            // make a copy of the data
            this.data = $.extend(true, [], data);
            
            this.parseOptions(options);
            
            if (this.textColor) {
                this.target.css('color', this.textColor);
            }
            if (this.fontFamily) {
                this.target.css('font-family', this.fontFamily);
            }
            if (this.fontSize) {
                this.target.css('font-size', this.fontSize);
            }
            
            this.title.init();
            this.legend.init();
            this._sumy = 0;
            this._sumx = 0;
            this.computePlotData();
            for (var i=0; i<this.series.length; i++) {
                // set default stacking order for series canvases
                this.seriesStack.push(i);
                this.previousSeriesStack.push(i);
                this.series[i].shadowCanvas._plotDimensions = this._plotDimensions;
                this.series[i].canvas._plotDimensions = this._plotDimensions;
                for (var j=0; j<$.jqplot.preSeriesInitHooks.length; j++) {
                    $.jqplot.preSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                for (var j=0; j<this.preSeriesInitHooks.hooks.length; j++) {
                    this.preSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                // this.populatePlotData(this.series[i], i);
                this.series[i]._plotDimensions = this._plotDimensions;
                this.series[i].init(i, this.grid.borderWidth, this);
                for (var j=0; j<$.jqplot.postSeriesInitHooks.length; j++) {
                    $.jqplot.postSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                for (var j=0; j<this.postSeriesInitHooks.hooks.length; j++) {
                    this.postSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                this._sumy += this.series[i]._sumy;
                this._sumx += this.series[i]._sumx;
            }

            var name,
                axis;
            for (var i=0, l=_axisNames.length; i<l; i++) {
                name = _axisNames[i];
                axis = this.axes[name];
                axis._plotDimensions = this._plotDimensions;
                axis.init();
                if (this.axes[name].borderColor == null) {
                    if (name.charAt(0) !== 'x' && axis.useSeriesColor === true && axis.show) {
                        axis.borderColor = axis._series[0].color;
                    }
                    else {
                        axis.borderColor = this.grid.borderColor;
                    }
                }
            }
            
            if (this.sortData) {
                sortData(this.series);
            }
            this.grid.init();
            this.grid._axes = this.axes;
            
            this.legend._series = this.series;

            for (var i=0; i<$.jqplot.postInitHooks.length; i++) {
                $.jqplot.postInitHooks[i].call(this, target, this.data, options);
            }

            for (var i=0; i<this.postInitHooks.hooks.length; i++) {
                this.postInitHooks.hooks[i].call(this, target, this.data, options);
            }
        };  
        
        // method: resetAxesScale
        // Reset the specified axes min, max, numberTicks and tickInterval properties to null
        // or reset these properties on all axes if no list of axes is provided.
        //
        // Parameters:
        // axes - Boolean to reset or not reset all axes or an array or object of axis names to reset.
        this.resetAxesScale = function(axes, options) {
            var opts = options || {};
            var ax = axes || this.axes;
            if (ax === true) {
                ax = this.axes;
            }
            if ($.isArray(ax)) {
                for (var i = 0; i < ax.length; i++) {
                    this.axes[ax[i]].resetScale(opts[ax[i]]);
                }
            }
            else if (typeof(ax) === 'object') {
                for (var name in ax) {
                    this.axes[name].resetScale(opts[name]);
                }
            }
        };
        // method: reInitialize
        // reinitialize plot for replotting.
        // not called directly.
        this.reInitialize = function (data, opts) {
            // Plot should be visible and have a height and width.
            // If plot doesn't have height and width for some
            // reason, set it by other means.  Plot must not have
            // a display:none attribute, however.

            var options = $.extend(true, {}, this.options, opts);

            var target = this.targetId.substr(1);
            var tdata = (data == null) ? this.data : data;

            for (var i=0; i<$.jqplot.preInitHooks.length; i++) {
                $.jqplot.preInitHooks[i].call(this, target, tdata, options);
            }

            for (var i=0; i<this.preInitHooks.hooks.length; i++) {
                this.preInitHooks.hooks[i].call(this, target, tdata, options);
            }
            
            this._height = this.target.height();
            this._width = this.target.width();
            
            if (this._height <=0 || this._width <=0 || !this._height || !this._width) {
                throw new Error("Target dimension not set");
            }
            
            this._plotDimensions.height = this._height;
            this._plotDimensions.width = this._width;
            this.grid._plotDimensions = this._plotDimensions;
            this.title._plotDimensions = this._plotDimensions;
            this.baseCanvas._plotDimensions = this._plotDimensions;
            this.eventCanvas._plotDimensions = this._plotDimensions;
            this.legend._plotDimensions = this._plotDimensions;

            var name,
                t, 
                j, 
                axis;

            for (var i=0, l=_axisNames.length; i<l; i++) {
                name = _axisNames[i];
                axis = this.axes[name];

                // Memory Leaks patch : clear ticks elements
                t = axis._ticks;
                for (var j = 0, tlen = t.length; j < tlen; j++) {
                  var el = t[j]._elem;
                  if (el) {
                    // if canvas renderer
                    if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {
                      window.G_vmlCanvasManager.uninitElement(el.get(0));
                    }
                    el.emptyForce();
                    el = null;
                    t._elem = null;
                  }
                }
                t = null;

                delete axis.ticks;
                delete axis._ticks;
                this.axes[name] = new Axis(name);
                this.axes[name]._plotWidth = this._width;
                this.axes[name]._plotHeight = this._height;
            }
            
            if (data) {
                if (options.dataRenderer && $.isFunction(options.dataRenderer)) {
                    if (options.dataRendererOptions) {
                        this.dataRendererOptions = options.dataRendererOptions;
                    }
                    this.dataRenderer = options.dataRenderer;
                    data = this.dataRenderer(data, this, this.dataRendererOptions);
                }
                
                // make a copy of the data
                this.data = $.extend(true, [], data);
            }

            if (opts) {
                this.parseOptions(options);
            }
            
            this.title._plotWidth = this._width;
            
            if (this.textColor) {
                this.target.css('color', this.textColor);
            }
            if (this.fontFamily) {
                this.target.css('font-family', this.fontFamily);
            }
            if (this.fontSize) {
                this.target.css('font-size', this.fontSize);
            }

            this.title.init();
            this.legend.init();
            this._sumy = 0;
            this._sumx = 0;

            this.seriesStack = [];
            this.previousSeriesStack = [];

            this.computePlotData();
            for (var i=0, l=this.series.length; i<l; i++) {
                // set default stacking order for series canvases
                this.seriesStack.push(i);
                this.previousSeriesStack.push(i);
                this.series[i].shadowCanvas._plotDimensions = this._plotDimensions;
                this.series[i].canvas._plotDimensions = this._plotDimensions;
                for (var j=0; j<$.jqplot.preSeriesInitHooks.length; j++) {
                    $.jqplot.preSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                for (var j=0; j<this.preSeriesInitHooks.hooks.length; j++) {
                    this.preSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                // this.populatePlotData(this.series[i], i);
                this.series[i]._plotDimensions = this._plotDimensions;
                this.series[i].init(i, this.grid.borderWidth, this);
                for (var j=0; j<$.jqplot.postSeriesInitHooks.length; j++) {
                    $.jqplot.postSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                for (var j=0; j<this.postSeriesInitHooks.hooks.length; j++) {
                    this.postSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                this._sumy += this.series[i]._sumy;
                this._sumx += this.series[i]._sumx;
            }

            for (var i=0, l=_axisNames.length; i<l; i++) {
                name = _axisNames[i];
                axis = this.axes[name];

                axis._plotDimensions = this._plotDimensions;
                axis.init();
                if (axis.borderColor == null) {
                    if (name.charAt(0) !== 'x' && axis.useSeriesColor === true && axis.show) {
                        axis.borderColor = axis._series[0].color;
                    }
                    else {
                        axis.borderColor = this.grid.borderColor;
                    }
                }
            }
            
            if (this.sortData) {
                sortData(this.series);
            }
            this.grid.init();
            this.grid._axes = this.axes;
            
            this.legend._series = this.series;

            for (var i=0, l=$.jqplot.postInitHooks.length; i<l; i++) {
                $.jqplot.postInitHooks[i].call(this, target, this.data, options);
            }

            for (var i=0, l=this.postInitHooks.hooks.length; i<l; i++) {
                this.postInitHooks.hooks[i].call(this, target, this.data, options);
            }
        };



        // method: quickInit
        // 
        // Quick reinitialization plot for replotting.
        // Does not parse options ore recreate axes and series.
        // not called directly.
        this.quickInit = function () {
            // Plot should be visible and have a height and width.
            // If plot doesn't have height and width for some
            // reason, set it by other means.  Plot must not have
            // a display:none attribute, however.
            
            this._height = this.target.height();
            this._width = this.target.width();
            
            if (this._height <=0 || this._width <=0 || !this._height || !this._width) {
                throw new Error("Target dimension not set");
            }
            
            this._plotDimensions.height = this._height;
            this._plotDimensions.width = this._width;
            this.grid._plotDimensions = this._plotDimensions;
            this.title._plotDimensions = this._plotDimensions;
            this.baseCanvas._plotDimensions = this._plotDimensions;
            this.eventCanvas._plotDimensions = this._plotDimensions;
            this.legend._plotDimensions = this._plotDimensions;
            
            for (var n in this.axes) {
                this.axes[n]._plotWidth = this._width;
                this.axes[n]._plotHeight = this._height;
            }
            
            this.title._plotWidth = this._width;
            
            if (this.textColor) {
                this.target.css('color', this.textColor);
            }
            if (this.fontFamily) {
                this.target.css('font-family', this.fontFamily);
            }
            if (this.fontSize) {
                this.target.css('font-size', this.fontSize);
            }
            
            this._sumy = 0;
            this._sumx = 0;
            this.computePlotData();
            for (var i=0; i<this.series.length; i++) {
                // this.populatePlotData(this.series[i], i);
                if (this.series[i]._type === 'line' && this.series[i].renderer.bands.show) {
                    this.series[i].renderer.initBands.call(this.series[i], this.series[i].renderer.options, this);
                }
                this.series[i]._plotDimensions = this._plotDimensions;
                this.series[i].canvas._plotDimensions = this._plotDimensions;
                //this.series[i].init(i, this.grid.borderWidth);
                this._sumy += this.series[i]._sumy;
                this._sumx += this.series[i]._sumx;
            }

            var name;
            
            for (var j=0; j<12; j++) {
                name = _axisNames[j];
                // Memory Leaks patch : clear ticks elements
                var t = this.axes[name]._ticks;
                for (var i = 0; i < t.length; i++) {
                  var el = t[i]._elem;
                  if (el) {
                    // if canvas renderer
                    if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {
                      window.G_vmlCanvasManager.uninitElement(el.get(0));
                    }
                    el.emptyForce();
                    el = null;
                    t._elem = null;
                  }
                }
                t = null;
                
                this.axes[name]._plotDimensions = this._plotDimensions;
                this.axes[name]._ticks = [];
                // this.axes[name].renderer.init.call(this.axes[name], {});
            }
            
            if (this.sortData) {
                sortData(this.series);
            }
            
            this.grid._axes = this.axes;
            
            this.legend._series = this.series;
        };
        
        // sort the series data in increasing order.
        function sortData(series) {
            var d, sd, pd, ppd, ret;
            for (var i=0; i<series.length; i++) {
                var check;
                var bat = [series[i].data, series[i]._stackData, series[i]._plotData, series[i]._prevPlotData];
                for (var n=0; n<4; n++) {
                    check = true;
                    d = bat[n];
                    if (series[i]._stackAxis == 'x') {
                        for (var j = 0; j < d.length; j++) {
                            if (typeof(d[j][1]) != "number") {
                                check = false;
                                break;
                            }
                        }
                        if (check) {
                            d.sort(function(a,b) { return a[1] - b[1]; });
                        }
                    }
                    else {
                        for (var j = 0; j < d.length; j++) {
                            if (typeof(d[j][0]) != "number") {
                                check = false;
                                break;
                            }
                        }
                        if (check) {
                            d.sort(function(a,b) { return a[0] - b[0]; });
                        }
                    }
                }
               
            }
        }

        this.computePlotData = function() {
            this._plotData = [];
            this._stackData = [];
            var series,
                index,
                l;


            for (index=0, l=this.series.length; index<l; index++) {
                series = this.series[index];
                this._plotData.push([]);
                this._stackData.push([]);
                var cd = series.data;
                this._plotData[index] = $.extend(true, [], cd);
                this._stackData[index] = $.extend(true, [], cd);
                series._plotData = this._plotData[index];
                series._stackData = this._stackData[index];
                var plotValues = {x:[], y:[]};

                if (this.stackSeries && !series.disableStack) {
                    series._stack = true;
                    ///////////////////////////
                    // have to check for nulls
                    ///////////////////////////
                    var sidx = (series._stackAxis === 'x') ? 0 : 1;

                    for (var k=0, cdl=cd.length; k<cdl; k++) {
                        var temp = cd[k][sidx];
                        if (temp == null) {
                            temp = 0;
                        }
                        this._plotData[index][k][sidx] = temp;
                        this._stackData[index][k][sidx] = temp;

                        if (index > 0) {
                            for (var j=index; j--;) {
                                var prevval = this._plotData[j][k][sidx];
                                // only need to sum up the stack axis column of data
                                // and only sum if it is of same sign.
                                // if previous series isn't same sign, keep looking
                                // at earlier series untill we find one of same sign.
                                if (temp * prevval >= 0) {
                                    this._plotData[index][k][sidx] += prevval;
                                    this._stackData[index][k][sidx] += prevval;
                                    break;
                                } 
                            }
                        }
                    }

                }
                else {
                    for (var i=0; i<series.data.length; i++) {
                        plotValues.x.push(series.data[i][0]);
                        plotValues.y.push(series.data[i][1]);
                    }
                    this._stackData.push(series.data);
                    this.series[index]._stackData = series.data;
                    this._plotData.push(series.data);
                    series._plotData = series.data;
                    series._plotValues = plotValues;
                }
                if (index>0) {
                    series._prevPlotData = this.series[index-1]._plotData;
                }
                series._sumy = 0;
                series._sumx = 0;
                for (i=series.data.length-1; i>-1; i--) {
                    series._sumy += series.data[i][1];
                    series._sumx += series.data[i][0];
                }
            }

        };
        
        // populate the _stackData and _plotData arrays for the plot and the series.
        this.populatePlotData = function(series, index) {
            // if a stacked chart, compute the stacked data
            this._plotData = [];
            this._stackData = [];
            series._stackData = [];
            series._plotData = [];
            var plotValues = {x:[], y:[]};
            if (this.stackSeries && !series.disableStack) {
                series._stack = true;
                var sidx = (series._stackAxis === 'x') ? 0 : 1;
                // var idx = sidx ? 0 : 1;
                // push the current data into stackData
                //this._stackData.push(this.series[i].data);
                var temp = $.extend(true, [], series.data);
                // create the data that will be plotted for this series
                var plotdata = $.extend(true, [], series.data);
                var tempx, tempy, dval, stackval, comparator;
                // for first series, nothing to add to stackData.
                for (var j=0; j<index; j++) {
                    var cd = this.series[j].data;
                    for (var k=0; k<cd.length; k++) {
                        dval = cd[k];
                        tempx = (dval[0] != null) ? dval[0] : 0;
                        tempy = (dval[1] != null) ? dval[1] : 0;
                        temp[k][0] += tempx;
                        temp[k][1] += tempy;
                        stackval = (sidx) ? tempy : tempx;
                        // only need to sum up the stack axis column of data
                        // and only sum if it is of same sign.
                        if (series.data[k][sidx] * stackval >= 0) {
                            plotdata[k][sidx] += stackval;
                        }
                    }
                }
                for (var i=0; i<plotdata.length; i++) {
                    plotValues.x.push(plotdata[i][0]);
                    plotValues.y.push(plotdata[i][1]);
                }
                this._plotData.push(plotdata);
                this._stackData.push(temp);
                series._stackData = temp;
                series._plotData = plotdata;
                series._plotValues = plotValues;
            }
            else {
                for (var i=0; i<series.data.length; i++) {
                    plotValues.x.push(series.data[i][0]);
                    plotValues.y.push(series.data[i][1]);
                }
                this._stackData.push(series.data);
                this.series[index]._stackData = series.data;
                this._plotData.push(series.data);
                series._plotData = series.data;
                series._plotValues = plotValues;
            }
            if (index>0) {
                series._prevPlotData = this.series[index-1]._plotData;
            }
            series._sumy = 0;
            series._sumx = 0;
            for (i=series.data.length-1; i>-1; i--) {
                series._sumy += series.data[i][1];
                series._sumx += series.data[i][0];
            }
        };
        
        // function to safely return colors from the color array and wrap around at the end.
        this.getNextSeriesColor = (function(t) {
            var idx = 0;
            var sc = t.seriesColors;
            
            return function () { 
                if (idx < sc.length) {
                    return sc[idx++];
                }
                else {
                    idx = 0;
                    return sc[idx++];
                }
            };
        })(this);
    
        this.parseOptions = function(options){
            for (var i=0; i<this.preParseOptionsHooks.hooks.length; i++) {
                this.preParseOptionsHooks.hooks[i].call(this, options);
            }
            for (var i=0; i<$.jqplot.preParseOptionsHooks.length; i++) {
                $.jqplot.preParseOptionsHooks[i].call(this, options);
            }
            this.options = $.extend(true, {}, this.defaults, options);
            var opts = this.options;
            this.animate = opts.animate;
            this.animateReplot = opts.animateReplot;
            this.stackSeries = opts.stackSeries;
            if ($.isPlainObject(opts.fillBetween)) {

                var temp = ['series1', 'series2', 'color', 'baseSeries', 'fill'], 
                    tempi;

                for (var i=0, l=temp.length; i<l; i++) {
                    tempi = temp[i];
                    if (opts.fillBetween[tempi] != null) {
                        this.fillBetween[tempi] = opts.fillBetween[tempi];
                    }
                }
            }

            if (opts.seriesColors) {
                this.seriesColors = opts.seriesColors;
            }
            if (opts.negativeSeriesColors) {
                this.negativeSeriesColors = opts.negativeSeriesColors;
            }
            if (opts.captureRightClick) {
                this.captureRightClick = opts.captureRightClick;
            }
            this.defaultAxisStart = (options && options.defaultAxisStart != null) ? options.defaultAxisStart : this.defaultAxisStart;
            this.colorGenerator.setColors(this.seriesColors);
            this.negativeColorGenerator.setColors(this.negativeSeriesColors);
            // var cg = new this.colorGenerator(this.seriesColors);
            // var ncg = new this.colorGenerator(this.negativeSeriesColors);
            // this._gridPadding = this.options.gridPadding;
            $.extend(true, this._gridPadding, opts.gridPadding);
            this.sortData = (opts.sortData != null) ? opts.sortData : this.sortData;
            for (var i=0; i<12; i++) {
                var n = _axisNames[i];
                var axis = this.axes[n];
                axis._options = $.extend(true, {}, opts.axesDefaults, opts.axes[n]);
                $.extend(true, axis, opts.axesDefaults, opts.axes[n]);
                axis._plotWidth = this._width;
                axis._plotHeight = this._height;
            }
            // if (this.data.length == 0) {
            //     this.data = [];
            //     for (var i=0; i<this.options.series.length; i++) {
            //         this.data.push(this.options.series.data);
            //     }    
            // }
                
            var normalizeData = function(data, dir, start) {
                // return data as an array of point arrays,
                // in form [[x1,y1...], [x2,y2...], ...]
                var temp = [];
                var i, l;
                dir = dir || 'vertical';
                if (!$.isArray(data[0])) {
                    // we have a series of scalars.  One line with just y values.
                    // turn the scalar list of data into a data array of form:
                    // [[1, data[0]], [2, data[1]], ...]
                    for (i=0, l=data.length; i<l; i++) {
                        if (dir == 'vertical') {
                            temp.push([start + i, data[i]]);   
                        }
                        else {
                            temp.push([data[i], start+i]);
                        }
                    }
                }            
                else {
                    // we have a properly formatted data series, copy it.
                    $.extend(true, temp, data);
                }
                return temp;
            };

            var colorIndex = 0;
            this.series = [];
            for (var i=0; i<this.data.length; i++) {
                var sopts = $.extend(true, {index: i}, {seriesColors:this.seriesColors, negativeSeriesColors:this.negativeSeriesColors}, this.options.seriesDefaults, this.options.series[i], {rendererOptions:{animation:{show: this.animate}}});
                // pass in options in case something needs set prior to initialization.
                var temp = new Series(sopts);
                for (var j=0; j<$.jqplot.preParseSeriesOptionsHooks.length; j++) {
                    $.jqplot.preParseSeriesOptionsHooks[j].call(temp, this.options.seriesDefaults, this.options.series[i]);
                }
                for (var j=0; j<this.preParseSeriesOptionsHooks.hooks.length; j++) {
                    this.preParseSeriesOptionsHooks.hooks[j].call(temp, this.options.seriesDefaults, this.options.series[i]);
                }
                // Now go back and apply the options to the series.  Really should just do this during initializaiton, but don't want to
                // mess up preParseSeriesOptionsHooks at this point.
                $.extend(true, temp, sopts);
                var dir = 'vertical';
                if (temp.renderer === $.jqplot.BarRenderer && temp.rendererOptions && temp.rendererOptions.barDirection == 'horizontal') {
                    dir = 'horizontal';
                    temp._stackAxis = 'x';
                    temp._primaryAxis = '_yaxis';
                }
                temp.data = normalizeData(this.data[i], dir, this.defaultAxisStart);
                switch (temp.xaxis) {
                    case 'xaxis':
                        temp._xaxis = this.axes.xaxis;
                        break;
                    case 'x2axis':
                        temp._xaxis = this.axes.x2axis;
                        break;
                    default:
                        break;
                }
                temp._yaxis = this.axes[temp.yaxis];
                temp._xaxis._series.push(temp);
                temp._yaxis._series.push(temp);
                if (temp.show) {
                    temp._xaxis.show = true;
                    temp._yaxis.show = true;
                }
                else {
                    if (temp._xaxis.scaleToHiddenSeries) {
                        temp._xaxis.show = true;
                    }
                    if (temp._yaxis.scaleToHiddenSeries) {
                        temp._yaxis.show = true;
                    }
                }

                // // parse the renderer options and apply default colors if not provided
                // if (!temp.color && temp.show != false) {
                //     temp.color = cg.next();
                //     colorIndex = cg.getIndex() - 1;;
                // }
                // if (!temp.negativeColor && temp.show != false) {
                //     temp.negativeColor = ncg.get(colorIndex);
                //     ncg.setIndex(colorIndex);
                // }
                if (!temp.label) {
                    temp.label = 'Series '+ (i+1).toString();
                }
                // temp.rendererOptions.show = temp.show;
                // $.extend(true, temp.renderer, {color:this.seriesColors[i]}, this.rendererOptions);
                this.series.push(temp);  
                for (var j=0; j<$.jqplot.postParseSeriesOptionsHooks.length; j++) {
                    $.jqplot.postParseSeriesOptionsHooks[j].call(this.series[i], this.options.seriesDefaults, this.options.series[i]);
                }
                for (var j=0; j<this.postParseSeriesOptionsHooks.hooks.length; j++) {
                    this.postParseSeriesOptionsHooks.hooks[j].call(this.series[i], this.options.seriesDefaults, this.options.series[i]);
                }
            }
            
            // copy the grid and title options into this object.
            $.extend(true, this.grid, this.options.grid);
            // if axis border properties aren't set, set default.
            for (var i=0, l=_axisNames.length; i<l; i++) {
                var n = _axisNames[i];
                var axis = this.axes[n];
                if (axis.borderWidth == null) {
                    axis.borderWidth =this.grid.borderWidth;
                }
            }
            
            if (typeof this.options.title == 'string') {
                this.title.text = this.options.title;
            }
            else if (typeof this.options.title == 'object') {
                $.extend(true, this.title, this.options.title);
            }
            this.title._plotWidth = this._width;
            this.legend.setOptions(this.options.legend);
            
            for (var i=0; i<$.jqplot.postParseOptionsHooks.length; i++) {
                $.jqplot.postParseOptionsHooks[i].call(this, options);
            }
            for (var i=0; i<this.postParseOptionsHooks.hooks.length; i++) {
                this.postParseOptionsHooks.hooks[i].call(this, options);
            }
        };
        
        // method: destroy
        // Releases all resources occupied by the plot
        this.destroy = function() {
            this.canvasManager.freeAllCanvases();
            if (this.eventCanvas && this.eventCanvas._elem) {
                this.eventCanvas._elem.unbind();
            }
            // Couple of posts on Stack Overflow indicate that empty() doesn't
            // always cear up the dom and release memory.  Sometimes setting
            // innerHTML property to null is needed.  Particularly on IE, may 
            // have to directly set it to null, bypassing $.
            this.target.empty();

            this.target[0].innerHTML = '';
        };
        
        // method: replot
        // Does a reinitialization of the plot followed by
        // a redraw.  Method could be used to interactively
        // change plot characteristics and then replot.
        //
        // Parameters:
        // options - Options used for replotting.
        //
        // Properties:
        // clear - false to not clear (empty) the plot container before replotting (default: true).
        // resetAxes - true to reset all axes min, max, numberTicks and tickInterval setting so axes will rescale themselves.
        //             optionally pass in list of axes to reset (e.g. ['xaxis', 'y2axis']) (default: false).
        this.replot = function(options) {
            var opts =  options || {};
            var data = opts.data || null;
            var clear = (opts.clear === false) ? false : true;
            var resetAxes = opts.resetAxes || false;
            delete opts.data;
            delete opts.clear;
            delete opts.resetAxes;

            this.target.trigger('jqplotPreReplot');
            
            if (clear) {
                this.destroy();
            }
            // if have data or other options, full reinit.
            // otherwise, quickinit.
            if (data || !$.isEmptyObject(opts)) {
                this.reInitialize(data, opts);
            }
            else {
                this.quickInit();
            }

            if (resetAxes) {
                this.resetAxesScale(resetAxes, opts.axes);
            }
            this.draw();
            this.target.trigger('jqplotPostReplot');
        };
        
        // method: redraw
        // Empties the plot target div and redraws the plot.
        // This enables plot data and properties to be changed
        // and then to comletely clear the plot and redraw.
        // redraw *will not* reinitialize any plot elements.
        // That is, axes will not be autoscaled and defaults
        // will not be reapplied to any plot elements.  redraw
        // is used primarily with zooming. 
        //
        // Parameters:
        // clear - false to not clear (empty) the plot container before redrawing (default: true).
        this.redraw = function(clear) {
            clear = (clear != null) ? clear : true;
            this.target.trigger('jqplotPreRedraw');
            if (clear) {
                this.canvasManager.freeAllCanvases();
                this.eventCanvas._elem.unbind();
                // Dont think I bind any events to the target, this shouldn't be necessary.
                // It will remove user's events.
                // this.target.unbind();
                this.target.empty();
            }
             for (var ax in this.axes) {
                this.axes[ax]._ticks = [];
            }
            this.computePlotData();
            // for (var i=0; i<this.series.length; i++) {
            //     this.populatePlotData(this.series[i], i);
            // }
            this._sumy = 0;
            this._sumx = 0;
            for (var i=0, tsl = this.series.length; i<tsl; i++) {
                this._sumy += this.series[i]._sumy;
                this._sumx += this.series[i]._sumx;
            }
            this.draw();
            this.target.trigger('jqplotPostRedraw');
        };
        
        // method: draw
        // Draws all elements of the plot into the container.
        // Does not clear the container before drawing.
        this.draw = function(){
            if (this.drawIfHidden || this.target.is(':visible')) {
                this.target.trigger('jqplotPreDraw');
                var i,
                    j,
                    l,
                    tempseries;
                for (i=0, l=$.jqplot.preDrawHooks.length; i<l; i++) {
                    $.jqplot.preDrawHooks[i].call(this);
                }
                for (i=0, l=this.preDrawHooks.hooks.length; i<l; i++) {
                    this.preDrawHooks.hooks[i].apply(this, this.preDrawSeriesHooks.args[i]);
                }
                // create an underlying canvas to be used for special features.
                this.target.append(this.baseCanvas.createElement({left:0, right:0, top:0, bottom:0}, 'jqplot-base-canvas', null, this));
                this.baseCanvas.setContext();
                this.target.append(this.title.draw());
                this.title.pack({top:0, left:0});
                
                // make room  for the legend between the grid and the edge.
                // pass a dummy offsets object and a reference to the plot.
                var legendElem = this.legend.draw({}, this);
                
                var gridPadding = {top:0, left:0, bottom:0, right:0};
                
                if (this.legend.placement == "outsideGrid") {
                    // temporarily append the legend to get dimensions
                    this.target.append(legendElem);
                    switch (this.legend.location) {
                        case 'n':
                            gridPadding.top += this.legend.getHeight();
                            break;
                        case 's':
                            gridPadding.bottom += this.legend.getHeight();
                            break;
                        case 'ne':
                        case 'e':
                        case 'se':
                            gridPadding.right += this.legend.getWidth();
                            break;
                        case 'nw':
                        case 'w':
                        case 'sw':
                            gridPadding.left += this.legend.getWidth();
                            break;
                        default:  // same as 'ne'
                            gridPadding.right += this.legend.getWidth();
                            break;
                    }
                    legendElem = legendElem.detach();
                }
                
                var ax = this.axes;
                var name;
                // draw the yMidAxis first, so xaxis of pyramid chart can adjust itself if needed.
                for (i=0; i<12; i++) {
                    name = _axisNames[i];
                    this.target.append(ax[name].draw(this.baseCanvas._ctx, this));
                    ax[name].set();
                }
                if (ax.yaxis.show) {
                    gridPadding.left += ax.yaxis.getWidth();
                }
                var ra = ['y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis'];
                var rapad = [0, 0, 0, 0, 0, 0, 0, 0];
                var gpr = 0;
                var n;
                for (n=0; n<8; n++) {
                    if (ax[ra[n]].show) {
                        gpr += ax[ra[n]].getWidth();
                        rapad[n] = gpr;
                    }
                }
                gridPadding.right += gpr;
                if (ax.x2axis.show) {
                    gridPadding.top += ax.x2axis.getHeight();
                }
                if (this.title.show) {
                    gridPadding.top += this.title.getHeight();
                }
                if (ax.xaxis.show) {
                    gridPadding.bottom += ax.xaxis.getHeight();
                }
                
                // end of gridPadding adjustments.

                // if user passed in gridDimensions option, check against calculated gridPadding
                if (this.options.gridDimensions && $.isPlainObject(this.options.gridDimensions)) {
                    var gdw = parseInt(this.options.gridDimensions.width, 10) || 0;
                    var gdh = parseInt(this.options.gridDimensions.height, 10) || 0;
                    var widthAdj = (this._width - gridPadding.left - gridPadding.right - gdw)/2;
                    var heightAdj = (this._height - gridPadding.top - gridPadding.bottom - gdh)/2;

                    if (heightAdj >= 0 && widthAdj >= 0) {
                        gridPadding.top += heightAdj;
                        gridPadding.bottom += heightAdj;
                        gridPadding.left += widthAdj;
                        gridPadding.right += widthAdj;
                    }
                }
                var arr = ['top', 'bottom', 'left', 'right'];
                for (var n in arr) {
                    if (this._gridPadding[arr[n]] == null && gridPadding[arr[n]] > 0) {
                        this._gridPadding[arr[n]] = gridPadding[arr[n]];
                    }
                    else if (this._gridPadding[arr[n]] == null) {
                        this._gridPadding[arr[n]] = this._defaultGridPadding[arr[n]];
                    }
                }
                
                var legendPadding = this._gridPadding;
                
                if (this.legend.placement === 'outsideGrid') {
                    legendPadding = {top:this.title.getHeight(), left: 0, right: 0, bottom: 0};
                    if (this.legend.location === 's') {
                        legendPadding.left = this._gridPadding.left;
                        legendPadding.right = this._gridPadding.right;
                    }
                }
                
                ax.xaxis.pack({position:'absolute', bottom:this._gridPadding.bottom - ax.xaxis.getHeight(), left:0, width:this._width}, {min:this._gridPadding.left, max:this._width - this._gridPadding.right});
                ax.yaxis.pack({position:'absolute', top:0, left:this._gridPadding.left - ax.yaxis.getWidth(), height:this._height}, {min:this._height - this._gridPadding.bottom, max: this._gridPadding.top});
                ax.x2axis.pack({position:'absolute', top:this._gridPadding.top - ax.x2axis.getHeight(), left:0, width:this._width}, {min:this._gridPadding.left, max:this._width - this._gridPadding.right});
                for (i=8; i>0; i--) {
                    ax[ra[i-1]].pack({position:'absolute', top:0, right:this._gridPadding.right - rapad[i-1]}, {min:this._height - this._gridPadding.bottom, max: this._gridPadding.top});
                }
                var ltemp = (this._width - this._gridPadding.left - this._gridPadding.right)/2.0 + this._gridPadding.left - ax.yMidAxis.getWidth()/2.0;
                ax.yMidAxis.pack({position:'absolute', top:0, left:ltemp, zIndex:9, textAlign: 'center'}, {min:this._height - this._gridPadding.bottom, max: this._gridPadding.top});
            
                this.target.append(this.grid.createElement(this._gridPadding, this));
                this.grid.draw();
                
                var series = this.series;
                var seriesLength = series.length;
                // put the shadow canvases behind the series canvases so shadows don't overlap on stacked bars.
                for (i=0, l=seriesLength; i<l; i++) {
                    // draw series in order of stacking.  This affects only
                    // order in which canvases are added to dom.
                    j = this.seriesStack[i];
                    this.target.append(series[j].shadowCanvas.createElement(this._gridPadding, 'jqplot-series-shadowCanvas', null, this));
                    series[j].shadowCanvas.setContext();
                    series[j].shadowCanvas._elem.data('seriesIndex', j);
                }
                
                for (i=0, l=seriesLength; i<l; i++) {
                    // draw series in order of stacking.  This affects only
                    // order in which canvases are added to dom.
                    j = this.seriesStack[i];
                    this.target.append(series[j].canvas.createElement(this._gridPadding, 'jqplot-series-canvas', null, this));
                    series[j].canvas.setContext();
                    series[j].canvas._elem.data('seriesIndex', j);
                }
                // Need to use filled canvas to capture events in IE.
                // Also, canvas seems to block selection of other elements in document on FF.
                this.target.append(this.eventCanvas.createElement(this._gridPadding, 'jqplot-event-canvas', null, this));
                this.eventCanvas.setContext();
                this.eventCanvas._ctx.fillStyle = 'rgba(0,0,0,0)';
                this.eventCanvas._ctx.fillRect(0,0,this.eventCanvas._ctx.canvas.width, this.eventCanvas._ctx.canvas.height);
            
                // bind custom event handlers to regular events.
                this.bindCustomEvents();
            
                // draw legend before series if the series needs to know the legend dimensions.
                if (this.legend.preDraw) {  
                    this.eventCanvas._elem.before(legendElem);
                    this.legend.pack(legendPadding);
                    if (this.legend._elem) {
                        this.drawSeries({legendInfo:{location:this.legend.location, placement:this.legend.placement, width:this.legend.getWidth(), height:this.legend.getHeight(), xoffset:this.legend.xoffset, yoffset:this.legend.yoffset}});
                    }
                    else {
                        this.drawSeries();
                    }
                }
                else {  // draw series before legend
                    this.drawSeries();
                    if (seriesLength) {
                        $(series[seriesLength-1].canvas._elem).after(legendElem);
                    }
                    this.legend.pack(legendPadding);                
                }
            
                // register event listeners on the overlay canvas
                for (var i=0, l=$.jqplot.eventListenerHooks.length; i<l; i++) {
                    // in the handler, this will refer to the eventCanvas dom element.
                    // make sure there are references back into plot objects.
                    this.eventCanvas._elem.bind($.jqplot.eventListenerHooks[i][0], {plot:this}, $.jqplot.eventListenerHooks[i][1]);
                }
            
                // register event listeners on the overlay canvas
                for (var i=0, l=this.eventListenerHooks.hooks.length; i<l; i++) {
                    // in the handler, this will refer to the eventCanvas dom element.
                    // make sure there are references back into plot objects.
                    this.eventCanvas._elem.bind(this.eventListenerHooks.hooks[i][0], {plot:this}, this.eventListenerHooks.hooks[i][1]);
                }

                var fb = this.fillBetween;
                if (fb.fill && fb.series1 !== fb.series2 && fb.series1 < seriesLength && fb.series2 < seriesLength && series[fb.series1]._type === 'line' && series[fb.series2]._type === 'line') {
                    this.doFillBetweenLines();
                }

                for (var i=0, l=$.jqplot.postDrawHooks.length; i<l; i++) {
                    $.jqplot.postDrawHooks[i].call(this);
                }

                for (var i=0, l=this.postDrawHooks.hooks.length; i<l; i++) {
                    this.postDrawHooks.hooks[i].apply(this, this.postDrawHooks.args[i]);
                }
            
                if (this.target.is(':visible')) {
                    this._drawCount += 1;
                }

                var temps, 
                    tempr,
                    sel,
                    _els;
                // ughh.  ideally would hide all series then show them.
                for (i=0, l=seriesLength; i<l; i++) {
                    temps = series[i];
                    tempr = temps.renderer;
                    sel = '.jqplot-point-label.jqplot-series-'+i;
                    if (tempr.animation && tempr.animation._supported && tempr.animation.show && (this._drawCount < 2 || this.animateReplot)) {
                        _els = this.target.find(sel);
                        _els.stop(true, true).hide();
                        temps.canvas._elem.stop(true, true).hide();
                        temps.shadowCanvas._elem.stop(true, true).hide();
                        temps.canvas._elem.jqplotEffect('blind', {mode: 'show', direction: tempr.animation.direction}, tempr.animation.speed);
                        temps.shadowCanvas._elem.jqplotEffect('blind', {mode: 'show', direction: tempr.animation.direction}, tempr.animation.speed);
                        _els.fadeIn(tempr.animation.speed*0.8);
                    }
                }
                _els = null;
            
                this.target.trigger('jqplotPostDraw', [this]);
            }
        };

        jqPlot.prototype.doFillBetweenLines = function () {
            var fb = this.fillBetween;
            var sid1 = fb.series1;
            var sid2 = fb.series2;
            // first series should always be lowest index
            var id1 = (sid1 < sid2) ? sid1 : sid2;
            var id2 = (sid2 >  sid1) ? sid2 : sid1;

            var series1 = this.series[id1];
            var series2 = this.series[id2];

            if (series2.renderer.smooth) {
                var tempgd = series2.renderer._smoothedData.slice(0).reverse();
            }
            else {
                var tempgd = series2.gridData.slice(0).reverse();
            }

            if (series1.renderer.smooth) {
                var gd = series1.renderer._smoothedData.concat(tempgd);
            }
            else {
                var gd = series1.gridData.concat(tempgd);
            }

            var color = (fb.color !== null) ? fb.color : this.series[sid1].fillColor;
            var baseSeries = (fb.baseSeries !== null) ? fb.baseSeries : id1;

            // now apply a fill to the shape on the lower series shadow canvas,
            // so it is behind both series.
            var sr = this.series[baseSeries].renderer.shapeRenderer;
            var opts = {fillStyle: color, fill: true, closePath: true};
            sr.draw(series1.shadowCanvas._ctx, gd, opts);
        };
        
        this.bindCustomEvents = function() {
            this.eventCanvas._elem.bind('click', {plot:this}, this.onClick);
            this.eventCanvas._elem.bind('dblclick', {plot:this}, this.onDblClick);
            this.eventCanvas._elem.bind('mousedown', {plot:this}, this.onMouseDown);
            this.eventCanvas._elem.bind('mousemove', {plot:this}, this.onMouseMove);
            this.eventCanvas._elem.bind('mouseenter', {plot:this}, this.onMouseEnter);
            this.eventCanvas._elem.bind('mouseleave', {plot:this}, this.onMouseLeave);
            if (this.captureRightClick) {
                this.eventCanvas._elem.bind('mouseup', {plot:this}, this.onRightClick);
                this.eventCanvas._elem.get(0).oncontextmenu = function() {
                    return false;
                };
            }
            else {
                this.eventCanvas._elem.bind('mouseup', {plot:this}, this.onMouseUp);
            }
        };
        
        function getEventPosition(ev) {
            var plot = ev.data.plot;
            var go = plot.eventCanvas._elem.offset();
            var gridPos = {x:ev.pageX - go.left, y:ev.pageY - go.top};
            var dataPos = {xaxis:null, yaxis:null, x2axis:null, y2axis:null, y3axis:null, y4axis:null, y5axis:null, y6axis:null, y7axis:null, y8axis:null, y9axis:null, yMidAxis:null};
            var an = ['xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
            var ax = plot.axes;
            var n, axis;
            for (n=11; n>0; n--) {
                axis = an[n-1];
                if (ax[axis].show) {
                    dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);
                }
            }

            return {offsets:go, gridPos:gridPos, dataPos:dataPos};
        }
        
        
        // function to check if event location is over a area area
        function checkIntersection(gridpos, plot) {
            var series = plot.series;
            var i, j, k, s, r, x, y, theta, sm, sa, minang, maxang;
            var d0, d, p, pp, points, bw, hp;
            var threshold, t;
            for (k=plot.seriesStack.length-1; k>=0; k--) {
                i = plot.seriesStack[k];
                s = series[i];
                hp = s._highlightThreshold;
                switch (s.renderer.constructor) {
                    case $.jqplot.BarRenderer:
                        x = gridpos.x;
                        y = gridpos.y;
                        for (j=0; j<s._barPoints.length; j++) {
                            points = s._barPoints[j];
                            p = s.gridData[j];
                            if (x>points[0][0] && x<points[2][0] && y>points[2][1] && y<points[0][1]) {
                                return {seriesIndex:s.index, pointIndex:j, gridData:p, data:s.data[j], points:s._barPoints[j]};
                            }
                        }
                        break;
                    case $.jqplot.PyramidRenderer:
                        x = gridpos.x;
                        y = gridpos.y;
                        for (j=0; j<s._barPoints.length; j++) {
                            points = s._barPoints[j];
                            p = s.gridData[j];
                            if (x > points[0][0] + hp[0][0] && x < points[2][0] + hp[2][0] && y > points[2][1] && y < points[0][1]) {
                                return {seriesIndex:s.index, pointIndex:j, gridData:p, data:s.data[j], points:s._barPoints[j]};
                            }
                        }
                        break;
                    
                    case $.jqplot.DonutRenderer:
                        sa = s.startAngle/180*Math.PI;
                        x = gridpos.x - s._center[0];
                        y = gridpos.y - s._center[1];
                        r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                        if (x > 0 && -y >= 0) {
                            theta = 2*Math.PI - Math.atan(-y/x);
                        }
                        else if (x > 0 && -y < 0) {
                            theta = -Math.atan(-y/x);
                        }
                        else if (x < 0) {
                            theta = Math.PI - Math.atan(-y/x);
                        }
                        else if (x == 0 && -y > 0) {
                            theta = 3*Math.PI/2;
                        }
                        else if (x == 0 && -y < 0) {
                            theta = Math.PI/2;
                        }
                        else if (x == 0 && y == 0) {
                            theta = 0;
                        }
                        if (sa) {
                            theta -= sa;
                            if (theta < 0) {
                                theta += 2*Math.PI;
                            }
                            else if (theta > 2*Math.PI) {
                                theta -= 2*Math.PI;
                            }
                        }
            
                        sm = s.sliceMargin/180*Math.PI;
                        if (r < s._radius && r > s._innerRadius) {
                            for (j=0; j<s.gridData.length; j++) {
                                minang = (j>0) ? s.gridData[j-1][1]+sm : sm;
                                maxang = s.gridData[j][1];
                                if (theta > minang && theta < maxang) {
                                    return {seriesIndex:s.index, pointIndex:j, gridData:[gridpos.x,gridpos.y], data:s.data[j]};
                                }
                            }
                        }
                        break;
                        
                    case $.jqplot.PieRenderer:
                        sa = s.startAngle/180*Math.PI;
                        x = gridpos.x - s._center[0];
                        y = gridpos.y - s._center[1];
                        r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                        if (x > 0 && -y >= 0) {
                            theta = 2*Math.PI - Math.atan(-y/x);
                        }
                        else if (x > 0 && -y < 0) {
                            theta = -Math.atan(-y/x);
                        }
                        else if (x < 0) {
                            theta = Math.PI - Math.atan(-y/x);
                        }
                        else if (x == 0 && -y > 0) {
                            theta = 3*Math.PI/2;
                        }
                        else if (x == 0 && -y < 0) {
                            theta = Math.PI/2;
                        }
                        else if (x == 0 && y == 0) {
                            theta = 0;
                        }
                        if (sa) {
                            theta -= sa;
                            if (theta < 0) {
                                theta += 2*Math.PI;
                            }
                            else if (theta > 2*Math.PI) {
                                theta -= 2*Math.PI;
                            }
                        }
            
                        sm = s.sliceMargin/180*Math.PI;
                        if (r < s._radius) {
                            for (j=0; j<s.gridData.length; j++) {
                                minang = (j>0) ? s.gridData[j-1][1]+sm : sm;
                                maxang = s.gridData[j][1];
                                if (theta > minang && theta < maxang) {
                                    return {seriesIndex:s.index, pointIndex:j, gridData:[gridpos.x,gridpos.y], data:s.data[j]};
                                }
                            }
                        }
                        break;
                        
                    case $.jqplot.BubbleRenderer:
                        x = gridpos.x;
                        y = gridpos.y;
                        var ret = null;
                        
                        if (s.show) {
                            for (var j=0; j<s.gridData.length; j++) {
                                p = s.gridData[j];
                                d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );
                                if (d <= p[2] && (d <= d0 || d0 == null)) {
                                   d0 = d;
                                   ret = {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                }
                            }
                            if (ret != null) {
                                return ret;
                            }
                        }
                        break;
                        
                    case $.jqplot.FunnelRenderer:
                        x = gridpos.x;
                        y = gridpos.y;
                        var v = s._vertices,
                            vfirst = v[0],
                            vlast = v[v.length-1],
                            lex,
                            rex,
                            cv;
    
                        // equations of right and left sides, returns x, y values given height of section (y value and 2 points)
    
                        function findedge (l, p1 , p2) {
                            var m = (p1[1] - p2[1])/(p1[0] - p2[0]);
                            var b = p1[1] - m*p1[0];
                            var y = l + p1[1];
        
                            return [(y - b)/m, y];
                        }
    
                        // check each section
                        lex = findedge(y, vfirst[0], vlast[3]);
                        rex = findedge(y, vfirst[1], vlast[2]);
                        for (j=0; j<v.length; j++) {
                            cv = v[j];
                            if (y >= cv[0][1] && y <= cv[3][1] && x >= lex[0] && x <= rex[0]) {
                                return {seriesIndex:s.index, pointIndex:j, gridData:null, data:s.data[j]};
                            }
                        }         
                        break;           
                    
                    case $.jqplot.LineRenderer:
                        x = gridpos.x;
                        y = gridpos.y;
                        r = s.renderer;
                        if (s.show) {
                            if ((s.fill || (s.renderer.bands.show && s.renderer.bands.fill)) && (!plot.plugins.highlighter || !plot.plugins.highlighter.show)) {
                                // first check if it is in bounding box
                                var inside = false;
                                if (x>s._boundingBox[0][0] && x<s._boundingBox[1][0] && y>s._boundingBox[1][1] && y<s._boundingBox[0][1]) { 
                                    // now check the crossing number   
                                    
                                    var numPoints = s._areaPoints.length;
                                    var ii;
                                    var j = numPoints-1;

                                    for(var ii=0; ii < numPoints; ii++) { 
                                        var vertex1 = [s._areaPoints[ii][0], s._areaPoints[ii][1]];
                                        var vertex2 = [s._areaPoints[j][0], s._areaPoints[j][1]];

                                        if (vertex1[1] < y && vertex2[1] >= y || vertex2[1] < y && vertex1[1] >= y)     {
                                            if (vertex1[0] + (y - vertex1[1]) / (vertex2[1] - vertex1[1]) * (vertex2[0] - vertex1[0]) < x) {
                                                inside = !inside;
                                            }
                                        }

                                        j = ii;
                                    }        
                                }
                                if (inside) {
                                    return {seriesIndex:i, pointIndex:null, gridData:s.gridData, data:s.data, points:s._areaPoints};
                                }
                                break;
                                
                            }

                            else {
                                t = s.markerRenderer.size/2+s.neighborThreshold;
                                threshold = (t > 0) ? t : 0;
                                for (var j=0; j<s.gridData.length; j++) {
                                    p = s.gridData[j];
                                    // neighbor looks different to OHLC chart.
                                    if (r.constructor == $.jqplot.OHLCRenderer) {
                                        if (r.candleStick) {
                                            var yp = s._yaxis.series_u2p;
                                            if (x >= p[0]-r._bodyWidth/2 && x <= p[0]+r._bodyWidth/2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                                                return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                            }
                                        }
                                        // if an open hi low close chart
                                        else if (!r.hlc){
                                            var yp = s._yaxis.series_u2p;
                                            if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                                                return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                            }
                                        }
                                        // a hi low close chart
                                        else {
                                            var yp = s._yaxis.series_u2p;
                                            if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {
                                                return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                            }
                                        }
                            
                                    }
                                    else if (p[0] != null && p[1] != null){
                                        d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );
                                        if (d <= threshold && (d <= d0 || d0 == null)) {
                                           d0 = d;
                                           return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                        }
                                    }
                                } 
                            }
                        }
                        break;
                        
                    default:
                        x = gridpos.x;
                        y = gridpos.y;
                        r = s.renderer;
                        if (s.show) {
                            t = s.markerRenderer.size/2+s.neighborThreshold;
                            threshold = (t > 0) ? t : 0;
                            for (var j=0; j<s.gridData.length; j++) {
                                p = s.gridData[j];
                                // neighbor looks different to OHLC chart.
                                if (r.constructor == $.jqplot.OHLCRenderer) {
                                    if (r.candleStick) {
                                        var yp = s._yaxis.series_u2p;
                                        if (x >= p[0]-r._bodyWidth/2 && x <= p[0]+r._bodyWidth/2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                        }
                                    }
                                    // if an open hi low close chart
                                    else if (!r.hlc){
                                        var yp = s._yaxis.series_u2p;
                                        if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                        }
                                    }
                                    // a hi low close chart
                                    else {
                                        var yp = s._yaxis.series_u2p;
                                        if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {
                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                        }
                                    }
                            
                                }
                                else {
                                    d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );
                                    if (d <= threshold && (d <= d0 || d0 == null)) {
                                       d0 = d;
                                       return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                    }
                                }
                            } 
                        }
                        break;
                }
            }
            
            return null;
        }
        
        
        
        this.onClick = function(ev) {
            // Event passed in is normalized and will have data attribute.
            // Event passed out is unnormalized.
            var positions = getEventPosition(ev);
            var p = ev.data.plot;
            var neighbor = checkIntersection(positions.gridPos, p);
            var evt = $.Event('jqplotClick');
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
        };
        
        this.onDblClick = function(ev) {
            // Event passed in is normalized and will have data attribute.
            // Event passed out is unnormalized.
            var positions = getEventPosition(ev);
            var p = ev.data.plot;
            var neighbor = checkIntersection(positions.gridPos, p);
            var evt = $.Event('jqplotDblClick');
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
        };
        
        this.onMouseDown = function(ev) {
            var positions = getEventPosition(ev);
            var p = ev.data.plot;
            var neighbor = checkIntersection(positions.gridPos, p);
            var evt = $.Event('jqplotMouseDown');
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
        };
        
        this.onMouseUp = function(ev) {
            var positions = getEventPosition(ev);
            var evt = $.Event('jqplotMouseUp');
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, ev.data.plot]);
        };
        
        this.onRightClick = function(ev) {
            var positions = getEventPosition(ev);
            var p = ev.data.plot;
            var neighbor = checkIntersection(positions.gridPos, p);
            if (p.captureRightClick) {
                if (ev.which == 3) {
                var evt = $.Event('jqplotRightClick');
                evt.pageX = ev.pageX;
                evt.pageY = ev.pageY;
                    $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
                }
                else {
                var evt = $.Event('jqplotMouseUp');
                evt.pageX = ev.pageX;
                evt.pageY = ev.pageY;
                    $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
                }
            }
        };
        
        this.onMouseMove = function(ev) {
            var positions = getEventPosition(ev);
            var p = ev.data.plot;
            var neighbor = checkIntersection(positions.gridPos, p);
            var evt = $.Event('jqplotMouseMove');
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
        };
        
        this.onMouseEnter = function(ev) {
            var positions = getEventPosition(ev);
            var p = ev.data.plot;
            var evt = $.Event('jqplotMouseEnter');
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            evt.relatedTarget = ev.relatedTarget;
            $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);
        };
        
        this.onMouseLeave = function(ev) {
            var positions = getEventPosition(ev);
            var p = ev.data.plot;
            var evt = $.Event('jqplotMouseLeave');
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            evt.relatedTarget = ev.relatedTarget;
            $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);
        };
        
        // method: drawSeries
        // Redraws all or just one series on the plot.  No axis scaling
        // is performed and no other elements on the plot are redrawn.
        // options is an options object to pass on to the series renderers.
        // It can be an empty object {}.  idx is the series index
        // to redraw if only one series is to be redrawn.
        this.drawSeries = function(options, idx){
            var i, series, ctx;
            // if only one argument passed in and it is a number, use it ad idx.
            idx = (typeof(options) === "number" && idx == null) ? options : idx;
            options = (typeof(options) === "object") ? options : {};
            // draw specified series
            if (idx != undefined) {
                series = this.series[idx];
                ctx = series.shadowCanvas._ctx;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                series.drawShadow(ctx, options, this);
                ctx = series.canvas._ctx;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                series.draw(ctx, options, this);
                if (series.renderer.constructor == $.jqplot.BezierCurveRenderer) {
                    if (idx < this.series.length - 1) {
                        this.drawSeries(idx+1); 
                    }
                }
            }
            
            else {
                // if call series drawShadow method first, in case all series shadows
                // should be drawn before any series.  This will ensure, like for 
                // stacked bar plots, that shadows don't overlap series.
                for (i=0; i<this.series.length; i++) {
                    // first clear the canvas
                    series = this.series[i];
                    ctx = series.shadowCanvas._ctx;
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    series.drawShadow(ctx, options, this);
                    ctx = series.canvas._ctx;
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    series.draw(ctx, options, this);
                }
            }
            options = idx = i = series = ctx = null;
        };
        
        // method: moveSeriesToFront
        // This method requires jQuery 1.4+
        // Moves the specified series canvas in front of all other series canvases.
        // This effectively "draws" the specified series on top of all other series,
        // although it is performed through DOM manipulation, no redrawing is performed.
        //
        // Parameters:
        // idx - 0 based index of the series to move.  This will be the index of the series
        // as it was first passed into the jqplot function.
        this.moveSeriesToFront = function (idx) { 
            idx = parseInt(idx, 10);
            var stackIndex = $.inArray(idx, this.seriesStack);
            // if already in front, return
            if (stackIndex == -1) {
                return;
            }
            if (stackIndex == this.seriesStack.length -1) {
                this.previousSeriesStack = this.seriesStack.slice(0);
                return;
            }
            var opidx = this.seriesStack[this.seriesStack.length -1];
            var serelem = this.series[idx].canvas._elem.detach();
            var shadelem = this.series[idx].shadowCanvas._elem.detach();
            this.series[opidx].shadowCanvas._elem.after(shadelem);
            this.series[opidx].canvas._elem.after(serelem);
            this.previousSeriesStack = this.seriesStack.slice(0);
            this.seriesStack.splice(stackIndex, 1);
            this.seriesStack.push(idx);
        };
        
        // method: moveSeriesToBack
        // This method requires jQuery 1.4+
        // Moves the specified series canvas behind all other series canvases.
        //
        // Parameters:
        // idx - 0 based index of the series to move.  This will be the index of the series
        // as it was first passed into the jqplot function.
        this.moveSeriesToBack = function (idx) {
            idx = parseInt(idx, 10);
            var stackIndex = $.inArray(idx, this.seriesStack);
            // if already in back, return
            if (stackIndex == 0 || stackIndex == -1) {
                return;
            }
            var opidx = this.seriesStack[0];
            var serelem = this.series[idx].canvas._elem.detach();
            var shadelem = this.series[idx].shadowCanvas._elem.detach();
            this.series[opidx].shadowCanvas._elem.before(shadelem);
            this.series[opidx].canvas._elem.before(serelem);
            this.previousSeriesStack = this.seriesStack.slice(0);
            this.seriesStack.splice(stackIndex, 1);
            this.seriesStack.unshift(idx);
        };
        
        // method: restorePreviousSeriesOrder
        // This method requires jQuery 1.4+
        // Restore the series canvas order to its previous state.
        // Useful to put a series back where it belongs after moving
        // it to the front.
        this.restorePreviousSeriesOrder = function () {
            var i, j, serelem, shadelem, temp, move, keep;
            // if no change, return.
            if (this.seriesStack == this.previousSeriesStack) {
                return;
            }
            for (i=1; i<this.previousSeriesStack.length; i++) {
                move = this.previousSeriesStack[i];
                keep = this.previousSeriesStack[i-1];
                serelem = this.series[move].canvas._elem.detach();
                shadelem = this.series[move].shadowCanvas._elem.detach();
                this.series[keep].shadowCanvas._elem.after(shadelem);
                this.series[keep].canvas._elem.after(serelem);
            }
            temp = this.seriesStack.slice(0);
            this.seriesStack = this.previousSeriesStack.slice(0);
            this.previousSeriesStack = temp;
        };
        
        // method: restoreOriginalSeriesOrder
        // This method requires jQuery 1.4+
        // Restore the series canvas order to its original order
        // when the plot was created.
        this.restoreOriginalSeriesOrder = function () {
            var i, j, arr=[], serelem, shadelem;
            for (i=0; i<this.series.length; i++) {
                arr.push(i);
            }
            if (this.seriesStack == arr) {
                return;
            }
            this.previousSeriesStack = this.seriesStack.slice(0);
            this.seriesStack = arr;
            for (i=1; i<this.seriesStack.length; i++) {
                serelem = this.series[i].canvas._elem.detach();
                shadelem = this.series[i].shadowCanvas._elem.detach();
                this.series[i-1].shadowCanvas._elem.after(shadelem);
                this.series[i-1].canvas._elem.after(serelem);
            }
        };
        
        this.activateTheme = function (name) {
            this.themeEngine.activate(this, name);
        };
    }
    
    
    // conpute a highlight color or array of highlight colors from given colors.
    $.jqplot.computeHighlightColors  = function(colors) {
        var ret;
        if ($.isArray(colors)) {
            ret = [];
            for (var i=0; i<colors.length; i++){
                var rgba = $.jqplot.getColorComponents(colors[i]);
                var newrgb = [rgba[0], rgba[1], rgba[2]];
                var sum = newrgb[0] + newrgb[1] + newrgb[2];
                for (var j=0; j<3; j++) {
                    // when darkening, lowest color component can be is 60.
                    newrgb[j] = (sum > 660) ?  newrgb[j] * 0.85 : 0.73 * newrgb[j] + 90;
                    newrgb[j] = parseInt(newrgb[j], 10);
                    (newrgb[j] > 255) ? 255 : newrgb[j];
                }
                // newrgb[3] = (rgba[3] > 0.4) ? rgba[3] * 0.4 : rgba[3] * 1.5;
                // newrgb[3] = (rgba[3] > 0.5) ? 0.8 * rgba[3] - .1 : rgba[3] + 0.2;
                newrgb[3] = 0.3 + 0.35 * rgba[3];
                ret.push('rgba('+newrgb[0]+','+newrgb[1]+','+newrgb[2]+','+newrgb[3]+')');
            }
        }
        else {
            var rgba = $.jqplot.getColorComponents(colors);
            var newrgb = [rgba[0], rgba[1], rgba[2]];
            var sum = newrgb[0] + newrgb[1] + newrgb[2];
            for (var j=0; j<3; j++) {
                // when darkening, lowest color component can be is 60.
                // newrgb[j] = (sum > 570) ?  newrgb[j] * 0.8 : newrgb[j] + 0.3 * (255 - newrgb[j]);
                // newrgb[j] = parseInt(newrgb[j], 10);
                newrgb[j] = (sum > 660) ?  newrgb[j] * 0.85 : 0.73 * newrgb[j] + 90;
                newrgb[j] = parseInt(newrgb[j], 10);
                (newrgb[j] > 255) ? 255 : newrgb[j];
            }
            // newrgb[3] = (rgba[3] > 0.4) ? rgba[3] * 0.4 : rgba[3] * 1.5;
            // newrgb[3] = (rgba[3] > 0.5) ? 0.8 * rgba[3] - .1 : rgba[3] + 0.2;
            newrgb[3] = 0.3 + 0.35 * rgba[3];
            ret = 'rgba('+newrgb[0]+','+newrgb[1]+','+newrgb[2]+','+newrgb[3]+')';
        }
        return ret;
    };
        
   $.jqplot.ColorGenerator = function(colors) {
        colors = colors || $.jqplot.config.defaultColors;
        var idx = 0;
        
        this.next = function () { 
            if (idx < colors.length) {
                return colors[idx++];
            }
            else {
                idx = 0;
                return colors[idx++];
            }
        };
        
        this.previous = function () { 
            if (idx > 0) {
                return colors[idx--];
            }
            else {
                idx = colors.length-1;
                return colors[idx];
            }
        };
        
        // get a color by index without advancing pointer.
        this.get = function(i) {
            var idx = i - colors.length * Math.floor(i/colors.length);
            return colors[idx];
        };
        
        this.setColors = function(c) {
            colors = c;
        };
        
        this.reset = function() {
            idx = 0;
        };

        this.getIndex = function() {
            return idx;
        };

        this.setIndex = function(index) {
            idx = index;
        };
    };

    // convert a hex color string to rgb string.
    // h - 3 or 6 character hex string, with or without leading #
    // a - optional alpha
    $.jqplot.hex2rgb = function(h, a) {
        h = h.replace('#', '');
        if (h.length == 3) {
            h = h.charAt(0)+h.charAt(0)+h.charAt(1)+h.charAt(1)+h.charAt(2)+h.charAt(2);
        }
        var rgb;
        rgb = 'rgba('+parseInt(h.slice(0,2), 16)+', '+parseInt(h.slice(2,4), 16)+', '+parseInt(h.slice(4,6), 16);
        if (a) {
            rgb += ', '+a;
        }
        rgb += ')';
        return rgb;
    };
    
    // convert an rgb color spec to a hex spec.  ignore any alpha specification.
    $.jqplot.rgb2hex = function(s) {
        var pat = /rgba?\( *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *(?:, *[0-9.]*)?\)/;
        var m = s.match(pat);
        var h = '#';
        for (var i=1; i<4; i++) {
            var temp;
            if (m[i].search(/%/) != -1) {
                temp = parseInt(255*m[i]/100, 10).toString(16);
                if (temp.length == 1) {
                    temp = '0'+temp;
                }
            }
            else {
                temp = parseInt(m[i], 10).toString(16);
                if (temp.length == 1) {
                    temp = '0'+temp;
                }
            }
            h += temp;
        }
        return h;
    };
    
    // given a css color spec, return an rgb css color spec
    $.jqplot.normalize2rgb = function(s, a) {
        if (s.search(/^ *rgba?\(/) != -1) {
            return s; 
        }
        else if (s.search(/^ *#?[0-9a-fA-F]?[0-9a-fA-F]/) != -1) {
            return $.jqplot.hex2rgb(s, a);
        }
        else {
            throw new Error('Invalid color spec');
        }
    };
    
    // extract the r, g, b, a color components out of a css color spec.
    $.jqplot.getColorComponents = function(s) {
        // check to see if a color keyword.
        s = $.jqplot.colorKeywordMap[s] || s;
        var rgb = $.jqplot.normalize2rgb(s);
        var pat = /rgba?\( *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *,? *([0-9.]* *)?\)/;
        var m = rgb.match(pat);
        var ret = [];
        for (var i=1; i<4; i++) {
            if (m[i].search(/%/) != -1) {
                ret[i-1] = parseInt(255*m[i]/100, 10);
            }
            else {
                ret[i-1] = parseInt(m[i], 10);
            }
        }
        ret[3] = parseFloat(m[4]) ? parseFloat(m[4]) : 1.0;
        return ret;
    };
    
    $.jqplot.colorKeywordMap = {
        aliceblue: 'rgb(240, 248, 255)',
        antiquewhite: 'rgb(250, 235, 215)',
        aqua: 'rgb( 0, 255, 255)',
        aquamarine: 'rgb(127, 255, 212)',
        azure: 'rgb(240, 255, 255)',
        beige: 'rgb(245, 245, 220)',
        bisque: 'rgb(255, 228, 196)',
        black: 'rgb( 0, 0, 0)',
        blanchedalmond: 'rgb(255, 235, 205)',
        blue: 'rgb( 0, 0, 255)',
        blueviolet: 'rgb(138, 43, 226)',
        brown: 'rgb(165, 42, 42)',
        burlywood: 'rgb(222, 184, 135)',
        cadetblue: 'rgb( 95, 158, 160)',
        chartreuse: 'rgb(127, 255, 0)',
        chocolate: 'rgb(210, 105, 30)',
        coral: 'rgb(255, 127, 80)',
        cornflowerblue: 'rgb(100, 149, 237)',
        cornsilk: 'rgb(255, 248, 220)',
        crimson: 'rgb(220, 20, 60)',
        cyan: 'rgb( 0, 255, 255)',
        darkblue: 'rgb( 0, 0, 139)',
        darkcyan: 'rgb( 0, 139, 139)',
        darkgoldenrod: 'rgb(184, 134, 11)',
        darkgray: 'rgb(169, 169, 169)',
        darkgreen: 'rgb( 0, 100, 0)',
        darkgrey: 'rgb(169, 169, 169)',
        darkkhaki: 'rgb(189, 183, 107)',
        darkmagenta: 'rgb(139, 0, 139)',
        darkolivegreen: 'rgb( 85, 107, 47)',
        darkorange: 'rgb(255, 140, 0)',
        darkorchid: 'rgb(153, 50, 204)',
        darkred: 'rgb(139, 0, 0)',
        darksalmon: 'rgb(233, 150, 122)',
        darkseagreen: 'rgb(143, 188, 143)',
        darkslateblue: 'rgb( 72, 61, 139)',
        darkslategray: 'rgb( 47, 79, 79)',
        darkslategrey: 'rgb( 47, 79, 79)',
        darkturquoise: 'rgb( 0, 206, 209)',
        darkviolet: 'rgb(148, 0, 211)',
        deeppink: 'rgb(255, 20, 147)',
        deepskyblue: 'rgb( 0, 191, 255)',
        dimgray: 'rgb(105, 105, 105)',
        dimgrey: 'rgb(105, 105, 105)',
        dodgerblue: 'rgb( 30, 144, 255)',
        firebrick: 'rgb(178, 34, 34)',
        floralwhite: 'rgb(255, 250, 240)',
        forestgreen: 'rgb( 34, 139, 34)',
        fuchsia: 'rgb(255, 0, 255)',
        gainsboro: 'rgb(220, 220, 220)',
        ghostwhite: 'rgb(248, 248, 255)',
        gold: 'rgb(255, 215, 0)',
        goldenrod: 'rgb(218, 165, 32)',
        gray: 'rgb(128, 128, 128)',
        grey: 'rgb(128, 128, 128)',
        green: 'rgb( 0, 128, 0)',
        greenyellow: 'rgb(173, 255, 47)',
        honeydew: 'rgb(240, 255, 240)',
        hotpink: 'rgb(255, 105, 180)',
        indianred: 'rgb(205, 92, 92)',
        indigo: 'rgb( 75, 0, 130)',
        ivory: 'rgb(255, 255, 240)',
        khaki: 'rgb(240, 230, 140)',
        lavender: 'rgb(230, 230, 250)',
        lavenderblush: 'rgb(255, 240, 245)',
        lawngreen: 'rgb(124, 252, 0)',
        lemonchiffon: 'rgb(255, 250, 205)',
        lightblue: 'rgb(173, 216, 230)',
        lightcoral: 'rgb(240, 128, 128)',
        lightcyan: 'rgb(224, 255, 255)',
        lightgoldenrodyellow: 'rgb(250, 250, 210)',
        lightgray: 'rgb(211, 211, 211)',
        lightgreen: 'rgb(144, 238, 144)',
        lightgrey: 'rgb(211, 211, 211)',
        lightpink: 'rgb(255, 182, 193)',
        lightsalmon: 'rgb(255, 160, 122)',
        lightseagreen: 'rgb( 32, 178, 170)',
        lightskyblue: 'rgb(135, 206, 250)',
        lightslategray: 'rgb(119, 136, 153)',
        lightslategrey: 'rgb(119, 136, 153)',
        lightsteelblue: 'rgb(176, 196, 222)',
        lightyellow: 'rgb(255, 255, 224)',
        lime: 'rgb( 0, 255, 0)',
        limegreen: 'rgb( 50, 205, 50)',
        linen: 'rgb(250, 240, 230)',
        magenta: 'rgb(255, 0, 255)',
        maroon: 'rgb(128, 0, 0)',
        mediumaquamarine: 'rgb(102, 205, 170)',
        mediumblue: 'rgb( 0, 0, 205)',
        mediumorchid: 'rgb(186, 85, 211)',
        mediumpurple: 'rgb(147, 112, 219)',
        mediumseagreen: 'rgb( 60, 179, 113)',
        mediumslateblue: 'rgb(123, 104, 238)',
        mediumspringgreen: 'rgb( 0, 250, 154)',
        mediumturquoise: 'rgb( 72, 209, 204)',
        mediumvioletred: 'rgb(199, 21, 133)',
        midnightblue: 'rgb( 25, 25, 112)',
        mintcream: 'rgb(245, 255, 250)',
        mistyrose: 'rgb(255, 228, 225)',
        moccasin: 'rgb(255, 228, 181)',
        navajowhite: 'rgb(255, 222, 173)',
        navy: 'rgb( 0, 0, 128)',
        oldlace: 'rgb(253, 245, 230)',
        olive: 'rgb(128, 128, 0)',
        olivedrab: 'rgb(107, 142, 35)',
        orange: 'rgb(255, 165, 0)',
        orangered: 'rgb(255, 69, 0)',
        orchid: 'rgb(218, 112, 214)',
        palegoldenrod: 'rgb(238, 232, 170)',
        palegreen: 'rgb(152, 251, 152)',
        paleturquoise: 'rgb(175, 238, 238)',
        palevioletred: 'rgb(219, 112, 147)',
        papayawhip: 'rgb(255, 239, 213)',
        peachpuff: 'rgb(255, 218, 185)',
        peru: 'rgb(205, 133, 63)',
        pink: 'rgb(255, 192, 203)',
        plum: 'rgb(221, 160, 221)',
        powderblue: 'rgb(176, 224, 230)',
        purple: 'rgb(128, 0, 128)',
        red: 'rgb(255, 0, 0)',
        rosybrown: 'rgb(188, 143, 143)',
        royalblue: 'rgb( 65, 105, 225)',
        saddlebrown: 'rgb(139, 69, 19)',
        salmon: 'rgb(250, 128, 114)',
        sandybrown: 'rgb(244, 164, 96)',
        seagreen: 'rgb( 46, 139, 87)',
        seashell: 'rgb(255, 245, 238)',
        sienna: 'rgb(160, 82, 45)',
        silver: 'rgb(192, 192, 192)',
        skyblue: 'rgb(135, 206, 235)',
        slateblue: 'rgb(106, 90, 205)',
        slategray: 'rgb(112, 128, 144)',
        slategrey: 'rgb(112, 128, 144)',
        snow: 'rgb(255, 250, 250)',
        springgreen: 'rgb( 0, 255, 127)',
        steelblue: 'rgb( 70, 130, 180)',
        tan: 'rgb(210, 180, 140)',
        teal: 'rgb( 0, 128, 128)',
        thistle: 'rgb(216, 191, 216)',
        tomato: 'rgb(255, 99, 71)',
        turquoise: 'rgb( 64, 224, 208)',
        violet: 'rgb(238, 130, 238)',
        wheat: 'rgb(245, 222, 179)',
        white: 'rgb(255, 255, 255)',
        whitesmoke: 'rgb(245, 245, 245)',
        yellow: 'rgb(255, 255, 0)',
        yellowgreen: 'rgb(154, 205, 50)'
    };

    


    // class: $.jqplot.AxisLabelRenderer
    // Renderer to place labels on the axes.
    $.jqplot.AxisLabelRenderer = function(options) {
        // Group: Properties
        $.jqplot.ElemContainer.call(this);
        // name of the axis associated with this tick
        this.axis;
        // prop: show
        // whether or not to show the tick (mark and label).
        this.show = true;
        // prop: label
        // The text or html for the label.
        this.label = '';
        this.fontFamily = null;
        this.fontSize = null;
        this.textColor = null;
        this._elem;
        // prop: escapeHTML
        // true to escape HTML entities in the label.
        this.escapeHTML = false;
        
        $.extend(true, this, options);
    };
    
    $.jqplot.AxisLabelRenderer.prototype = new $.jqplot.ElemContainer();
    $.jqplot.AxisLabelRenderer.prototype.constructor = $.jqplot.AxisLabelRenderer;
    
    $.jqplot.AxisLabelRenderer.prototype.init = function(options) {
        $.extend(true, this, options);
    };
    
    $.jqplot.AxisLabelRenderer.prototype.draw = function(ctx, plot) {
        // Memory Leaks patch
        if (this._elem) {
            this._elem.emptyForce();
            this._elem = null;
        }

        this._elem = $('<div style="position:absolute;" class="jqplot-'+this.axis+'-label"></div>');
        
        if (Number(this.label)) {
            this._elem.css('white-space', 'nowrap');
        }
        
        if (!this.escapeHTML) {
            this._elem.html(this.label);
        }
        else {
            this._elem.text(this.label);
        }
        if (this.fontFamily) {
            this._elem.css('font-family', this.fontFamily);
        }
        if (this.fontSize) {
            this._elem.css('font-size', this.fontSize);
        }
        if (this.textColor) {
            this._elem.css('color', this.textColor);
        }
        
        return this._elem;
    };
    
    $.jqplot.AxisLabelRenderer.prototype.pack = function() {
    };

    // class: $.jqplot.AxisTickRenderer
    // A "tick" object showing the value of a tick/gridline on the plot.
    $.jqplot.AxisTickRenderer = function(options) {
        // Group: Properties
        $.jqplot.ElemContainer.call(this);
        // prop: mark
        // tick mark on the axis.  One of 'inside', 'outside', 'cross', '' or null.
        this.mark = 'outside';
        // name of the axis associated with this tick
        this.axis;
        // prop: showMark
        // whether or not to show the mark on the axis.
        this.showMark = true;
        // prop: showGridline
        // whether or not to draw the gridline on the grid at this tick.
        this.showGridline = true;
        // prop: isMinorTick
        // if this is a minor tick.
        this.isMinorTick = false;
        // prop: size
        // Length of the tick beyond the grid in pixels.
        // DEPRECATED: This has been superceeded by markSize
        this.size = 4;
        // prop:  markSize
        // Length of the tick marks in pixels.  For 'cross' style, length
        // will be stoked above and below axis, so total length will be twice this.
        this.markSize = 6;
        // prop: show
        // whether or not to show the tick (mark and label).
        // Setting this to false requires more testing.  It is recommended
        // to set showLabel and showMark to false instead.
        this.show = true;
        // prop: showLabel
        // whether or not to show the label.
        this.showLabel = true;
        this.label = null;
        this.value = null;
        this._styles = {};
        // prop: formatter
        // A class of a formatter for the tick text.  sprintf by default.
        this.formatter = $.jqplot.DefaultTickFormatter;
        // prop: prefix
        // String to prepend to the tick label.
        // Prefix is prepended to the formatted tick label.
        this.prefix = '';
        // prop: suffix
        // String to append to the tick label.
        // Suffix is appended to the formatted tick label.
        this.suffix = '';
        // prop: formatString
        // string passed to the formatter.
        this.formatString = '';
        // prop: fontFamily
        // css spec for the font-family css attribute.
        this.fontFamily;
        // prop: fontSize
        // css spec for the font-size css attribute.
        this.fontSize;
        // prop: textColor
        // css spec for the color attribute.
        this.textColor;
        // prop: escapeHTML
        // true to escape HTML entities in the label.
        this.escapeHTML = false;
        this._elem;
        this._breakTick = false;
        
        $.extend(true, this, options);
    };
    
    $.jqplot.AxisTickRenderer.prototype.init = function(options) {
        $.extend(true, this, options);
    };
    
    $.jqplot.AxisTickRenderer.prototype = new $.jqplot.ElemContainer();
    $.jqplot.AxisTickRenderer.prototype.constructor = $.jqplot.AxisTickRenderer;
    
    $.jqplot.AxisTickRenderer.prototype.setTick = function(value, axisName, isMinor) {
        this.value = value;
        this.axis = axisName;
        if (isMinor) {
            this.isMinorTick = true;
        }
        return this;
    };
    
    $.jqplot.AxisTickRenderer.prototype.draw = function() {
        if (this.label === null) {
            this.label = this.prefix + this.formatter(this.formatString, this.value) + this.suffix;
        }
        var style = {position: 'absolute'};
        if (Number(this.label)) {
            style['whitSpace'] = 'nowrap';
        }
        
        // Memory Leaks patch
        if (this._elem) {
            this._elem.emptyForce();
            this._elem = null;
        }

        this._elem = $(document.createElement('div'));
        this._elem.addClass("jqplot-"+this.axis+"-tick");
        
        if (!this.escapeHTML) {
            this._elem.html(this.label);
        }
        else {
            this._elem.text(this.label);
        }
        
        this._elem.css(style);

        for (var s in this._styles) {
            this._elem.css(s, this._styles[s]);
        }
        if (this.fontFamily) {
            this._elem.css('font-family', this.fontFamily);
        }
        if (this.fontSize) {
            this._elem.css('font-size', this.fontSize);
        }
        if (this.textColor) {
            this._elem.css('color', this.textColor);
        }
        if (this._breakTick) {
          this._elem.addClass('jqplot-breakTick');
        }
        
        return this._elem;
    };
        
    $.jqplot.DefaultTickFormatter = function (format, val) {
        if (typeof val == 'number') {
            if (!format) {
                format = $.jqplot.config.defaultTickFormatString;
            }
            return $.jqplot.sprintf(format, val);
        }
        else {
            return String(val);
        }
    };
        
    $.jqplot.PercentTickFormatter = function (format, val) {
        if (typeof val == 'number') {
            val = 100 * val;
            if (!format) {
                format = $.jqplot.config.defaultTickFormatString;
            }
            return $.jqplot.sprintf(format, val);
        }
        else {
            return String(val);
        }
    };
    
    $.jqplot.AxisTickRenderer.prototype.pack = function() {
    };
     
    // Class: $.jqplot.CanvasGridRenderer
    // The default jqPlot grid renderer, creating a grid on a canvas element.
    // The renderer has no additional options beyond the <Grid> class.
    $.jqplot.CanvasGridRenderer = function(){
        this.shadowRenderer = new $.jqplot.ShadowRenderer();
    };
    
    // called with context of Grid object
    $.jqplot.CanvasGridRenderer.prototype.init = function(options) {
        this._ctx;
        $.extend(true, this, options);
        // set the shadow renderer options
        var sopts = {lineJoin:'miter', lineCap:'round', fill:false, isarc:false, angle:this.shadowAngle, offset:this.shadowOffset, alpha:this.shadowAlpha, depth:this.shadowDepth, lineWidth:this.shadowWidth, closePath:false, strokeStyle:this.shadowColor};
        this.renderer.shadowRenderer.init(sopts);
    };
    
    // called with context of Grid.
    $.jqplot.CanvasGridRenderer.prototype.createElement = function(plot) {
        var elem;
        // Memory Leaks patch
        if (this._elem) {
          if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {
            elem = this._elem.get(0);
            window.G_vmlCanvasManager.uninitElement(elem);
            elem = null;
          }
          
          this._elem.emptyForce();
          this._elem = null;
        }
      
        elem = plot.canvasManager.getCanvas();

        var w = this._plotDimensions.width;
        var h = this._plotDimensions.height;
        elem.width = w;
        elem.height = h;
        this._elem = $(elem);
        this._elem.addClass('jqplot-grid-canvas');
        this._elem.css({ position: 'absolute', left: 0, top: 0 });
        
        elem = plot.canvasManager.initCanvas(elem);

        this._top = this._offsets.top;
        this._bottom = h - this._offsets.bottom;
        this._left = this._offsets.left;
        this._right = w - this._offsets.right;
        this._width = this._right - this._left;
        this._height = this._bottom - this._top;
        // avoid memory leak
        elem = null;
        return this._elem;
    };
    
    $.jqplot.CanvasGridRenderer.prototype.draw = function() {
        this._ctx = this._elem.get(0).getContext("2d");
        var ctx = this._ctx;
        var axes = this._axes;
        // Add the grid onto the grid canvas.  This is the bottom most layer.
        ctx.save();
        ctx.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height);
        ctx.fillStyle = this.backgroundColor || this.background;
        ctx.fillRect(this._left, this._top, this._width, this._height);
        
        ctx.save();
        ctx.lineJoin = 'miter';
        ctx.lineCap = 'butt';
        ctx.lineWidth = this.gridLineWidth;
        ctx.strokeStyle = this.gridLineColor;
        var b, e, s, m;
        var ax = ['xaxis', 'yaxis', 'x2axis', 'y2axis'];
        for (var i=4; i>0; i--) {
            var name = ax[i-1];
            var axis = axes[name];
            var ticks = axis._ticks;
            var numticks = ticks.length;
            if (axis.show) {
                if (axis.drawBaseline) {
                    var bopts = {};
                    if (axis.baselineWidth !== null) {
                        bopts.lineWidth = axis.baselineWidth;
                    }
                    if (axis.baselineColor !== null) {
                        bopts.strokeStyle = axis.baselineColor;
                    }
                    switch (name) {
                        case 'xaxis':
                            drawLine (this._left+.5, this._bottom+.5, this._right+.5, this._bottom+.5, bopts);
                            break;
                        case 'yaxis':
                            drawLine (this._left+.5, this._bottom+.5, this._left+.5, this._top+.5, bopts);
                            break;
                        case 'x2axis':
                            drawLine (this._left+.5, this._bottom+.5, this._right+.5, this._bottom+.5, bopts);
                            break;
                        case 'y2axis':
                            drawLine (this._right+.5, this._bottom+.5, this._right+.5, this._top+.5, bopts);
                            break;
                    }
                }
                for (var j=numticks; j>0; j--) {
                    var t = ticks[j-1];
                    if (t.show) {
                        var pos = Math.round(axis.u2p(t.value)) + 0.5;
                        switch (name) {
                            case 'xaxis':
                                // draw the grid line if we should
                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {
                                    drawLine(pos, this._top, pos, this._bottom);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._bottom;
                                            e = this._bottom+s;
                                            break;
                                        case 'inside':
                                            b = this._bottom-s;
                                            e = this._bottom;
                                            break;
                                        case 'cross':
                                            b = this._bottom-s;
                                            e = this._bottom+s;
                                            break;
                                        default:
                                            b = this._bottom;
                                            e = this._bottom+s;
                                            break;
                                    }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[pos,b],[pos,e]], {lineCap:'butt', lineWidth:this.gridLineWidth, offset:this.gridLineWidth*0.75, depth:2, fill:false, closePath:false});
                                    }
                                    // draw the line
                                    drawLine(pos, b, pos, e);
                                }
                                break;
                            case 'yaxis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {
                                    drawLine(this._right, pos, this._left, pos);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._left-s;
                                            e = this._left;
                                            break;
                                        case 'inside':
                                            b = this._left;
                                            e = this._left+s;
                                            break;
                                        case 'cross':
                                            b = this._left-s;
                                            e = this._left+s;
                                            break;
                                        default:
                                            b = this._left-s;
                                            e = this._left;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                                    }
                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                                }
                                break;
                            case 'x2axis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {
                                    drawLine(pos, this._bottom, pos, this._top);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._top-s;
                                            e = this._top;
                                            break;
                                        case 'inside':
                                            b = this._top;
                                            e = this._top+s;
                                            break;
                                        case 'cross':
                                            b = this._top-s;
                                            e = this._top+s;
                                            break;
                                        default:
                                            b = this._top-s;
                                            e = this._top;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[pos,b],[pos,e]], {lineCap:'butt', lineWidth:this.gridLineWidth, offset:this.gridLineWidth*0.75, depth:2, fill:false, closePath:false});
                                    }
                                    drawLine(pos, b, pos, e);
                                }
                                break;
                            case 'y2axis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {
                                    drawLine(this._left, pos, this._right, pos);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._right;
                                            e = this._right+s;
                                            break;
                                        case 'inside':
                                            b = this._right-s;
                                            e = this._right;
                                            break;
                                        case 'cross':
                                            b = this._right-s;
                                            e = this._right+s;
                                            break;
                                        default:
                                            b = this._right;
                                            e = this._right+s;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                                    }
                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
                t = null;
            }
            axis = null;
            ticks = null;
        }
        // Now draw grid lines for additional y axes
        //////
        // TO DO: handle yMidAxis
        //////
        ax = ['y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
        for (var i=7; i>0; i--) {
            var axis = axes[ax[i-1]];
            var ticks = axis._ticks;
            if (axis.show) {
                var tn = ticks[axis.numberTicks-1];
                var t0 = ticks[0];
                var left = axis.getLeft();
                var points = [[left, tn.getTop() + tn.getHeight()/2], [left, t0.getTop() + t0.getHeight()/2 + 1.0]];
                // draw the shadow
                if (this.shadow) {
                    this.renderer.shadowRenderer.draw(ctx, points, {lineCap:'butt', fill:false, closePath:false});
                }
                // draw the line
                drawLine(points[0][0], points[0][1], points[1][0], points[1][1], {lineCap:'butt', strokeStyle:axis.borderColor, lineWidth:axis.borderWidth});
                // draw the tick marks
                for (var j=ticks.length; j>0; j--) {
                    var t = ticks[j-1];
                    s = t.markSize;
                    m = t.mark;
                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                    if (t.showMark && t.mark) {
                        switch (m) {
                            case 'outside':
                                b = left;
                                e = left+s;
                                break;
                            case 'inside':
                                b = left-s;
                                e = left;
                                break;
                            case 'cross':
                                b = left-s;
                                e = left+s;
                                break;
                            default:
                                b = left;
                                e = left+s;
                                break;
                        }
                        points = [[b,pos], [e,pos]];
                        // draw the shadow
                        if (this.shadow) {
                            this.renderer.shadowRenderer.draw(ctx, points, {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                        }
                        // draw the line
                        drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                    }
                    t = null;
                }
                t0 = null;
            }
            axis = null;
            ticks =  null;
        }
        
        ctx.restore();
        
        function drawLine(bx, by, ex, ey, opts) {
            ctx.save();
            opts = opts || {};
            if (opts.lineWidth == null || opts.lineWidth != 0){
                $.extend(true, ctx, opts);
                ctx.beginPath();
                ctx.moveTo(bx, by);
                ctx.lineTo(ex, ey);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        if (this.shadow) {
            var points = [[this._left, this._bottom], [this._right, this._bottom], [this._right, this._top]];
            this.renderer.shadowRenderer.draw(ctx, points);
        }
        // Now draw border around grid.  Use axis border definitions. start at
        // upper left and go clockwise.
        if (this.borderWidth != 0 && this.drawBorder) {
            drawLine (this._left, this._top, this._right, this._top, {lineCap:'round', strokeStyle:axes.x2axis.borderColor, lineWidth:axes.x2axis.borderWidth});
            drawLine (this._right, this._top, this._right, this._bottom, {lineCap:'round', strokeStyle:axes.y2axis.borderColor, lineWidth:axes.y2axis.borderWidth});
            drawLine (this._right, this._bottom, this._left, this._bottom, {lineCap:'round', strokeStyle:axes.xaxis.borderColor, lineWidth:axes.xaxis.borderWidth});
            drawLine (this._left, this._bottom, this._left, this._top, {lineCap:'round', strokeStyle:axes.yaxis.borderColor, lineWidth:axes.yaxis.borderWidth});
        }
        // ctx.lineWidth = this.borderWidth;
        // ctx.strokeStyle = this.borderColor;
        // ctx.strokeRect(this._left, this._top, this._width, this._height);
        
        ctx.restore();
        ctx =  null;
        axes = null;
    };
 
    // Class: $.jqplot.DivTitleRenderer
    // The default title renderer for jqPlot.  This class has no options beyond the <Title> class. 
    $.jqplot.DivTitleRenderer = function() {
    };
    
    $.jqplot.DivTitleRenderer.prototype.init = function(options) {
        $.extend(true, this, options);
    };
    
    $.jqplot.DivTitleRenderer.prototype.draw = function() {
        // Memory Leaks patch
        if (this._elem) {
            this._elem.emptyForce();
            this._elem = null;
        }

        var r = this.renderer;
        var elem = document.createElement('div');
        this._elem = $(elem);
        this._elem.addClass('jqplot-title');

        if (!this.text) {
            this.show = false;
            this._elem.height(0);
            this._elem.width(0);
        }
        else if (this.text) {
            var color;
            if (this.color) {
                color = this.color;
            }
            else if (this.textColor) {
                color = this.textColor;
            }

            // don't trust that a stylesheet is present, set the position.
            var styles = {position:'absolute', top:'0px', left:'0px'};

            if (this._plotWidth) {
                styles['width'] = this._plotWidth+'px';
            }
            if (this.fontSize) {
                styles['fontSize'] = this.fontSize;
            }
            if (typeof this.textAlign === 'string') {
                styles['textAlign'] = this.textAlign;
            }
            else {
                styles['textAlign'] = 'center';
            }
            if (color) {
                styles['color'] = color;
            }
            if (this.paddingBottom) {
                styles['paddingBottom'] = this.paddingBottom;
            }
            if (this.fontFamily) {
                styles['fontFamily'] = this.fontFamily;
            }

            this._elem.css(styles);
            if (this.escapeHtml) {
                this._elem.text(this.text);
            }
            else {
                this._elem.html(this.text);
            }


            // styletext += (this._plotWidth) ? 'width:'+this._plotWidth+'px;' : '';
            // styletext += (this.fontSize) ? 'font-size:'+this.fontSize+';' : '';
            // styletext += (this.textAlign) ? 'text-align:'+this.textAlign+';' : 'text-align:center;';
            // styletext += (color) ? 'color:'+color+';' : '';
            // styletext += (this.paddingBottom) ? 'padding-bottom:'+this.paddingBottom+';' : '';
            // this._elem = $('<div class="jqplot-title" style="'+styletext+'">'+this.text+'</div>');
            // if (this.fontFamily) {
            //     this._elem.css('font-family', this.fontFamily);
            // }
        }

        elem = null;
        
        return this._elem;
    };
    
    $.jqplot.DivTitleRenderer.prototype.pack = function() {
        // nothing to do here
    };
  

    var dotlen = 0.1;

    $.jqplot.LinePattern = function (ctx, pattern) {

        var defaultLinePatterns = {
            dotted: [ dotlen, $.jqplot.config.dotGapLength ],
            dashed: [ $.jqplot.config.dashLength, $.jqplot.config.gapLength ],
            solid: null
        };

        if (typeof pattern === 'string') {
            if (pattern[0] === '.' || pattern[0] === '-') {
                var s = pattern;
                pattern = [];
                for (var i=0, imax=s.length; i<imax; i++) {
                    if (s[i] === '.') {
                        pattern.push( dotlen );
                    }
                    else if (s[i] === '-') {
                        pattern.push( $.jqplot.config.dashLength );
                    }
                    else {
                        continue;
                    }
                    pattern.push( $.jqplot.config.gapLength );
                }
            }
            else {
                pattern = defaultLinePatterns[pattern];
            }
        }

        if (!(pattern && pattern.length)) {
            return ctx;
        }

        var patternIndex = 0;
        var patternDistance = pattern[0];
        var px = 0;
        var py = 0;
        var pathx0 = 0;
        var pathy0 = 0;

        var moveTo = function (x, y) {
            ctx.moveTo( x, y );
            px = x;
            py = y;
            pathx0 = x;
            pathy0 = y;
        };

        var lineTo = function (x, y) {
            var scale = ctx.lineWidth;
            var dx = x - px;
            var dy = y - py;
            var dist = Math.sqrt(dx*dx+dy*dy);
            if ((dist > 0) && (scale > 0)) {
                dx /= dist;
                dy /= dist;
                while (true) {
                    var dp = scale * patternDistance;
                    if (dp < dist) {
                        px += dp * dx;
                        py += dp * dy;
                        if ((patternIndex & 1) == 0) {
                            ctx.lineTo( px, py );
                        }
                        else {
                            ctx.moveTo( px, py );
                        }
                        dist -= dp;
                        patternIndex++;
                        if (patternIndex >= pattern.length) {
                            patternIndex = 0;
                        }
                        patternDistance = pattern[patternIndex];
                    }
                    else {
                        px = x;
                        py = y;
                        if ((patternIndex & 1) == 0) {
                            ctx.lineTo( px, py );
                        }
                        else {
                            ctx.moveTo( px, py );
                        }
                        patternDistance -= dist / scale;
                        break;
                    }
                }
            }
        };

        var beginPath = function () {
            ctx.beginPath();
        };

        var closePath = function () {
            lineTo( pathx0, pathy0 );
        };

        return {
            moveTo: moveTo,
            lineTo: lineTo,
            beginPath: beginPath,
            closePath: closePath
        };
    };

    // Class: $.jqplot.LineRenderer
    // The default line renderer for jqPlot, this class has no options beyond the <Series> class.
    // Draws series as a line.
    $.jqplot.LineRenderer = function(){
        this.shapeRenderer = new $.jqplot.ShapeRenderer();
        this.shadowRenderer = new $.jqplot.ShadowRenderer();
    };
    
    // called with scope of series.
    $.jqplot.LineRenderer.prototype.init = function(options, plot) {
        // Group: Properties
        //
        options = options || {};
        this._type='line';
        this.renderer.animation = {
            show: false,
            direction: 'left',
            speed: 2500,
            _supported: true
        };
        // prop: smooth
        // True to draw a smoothed (interpolated) line through the data points
        // with automatically computed number of smoothing points.
        // Set to an integer number > 2 to specify number of smoothing points
        // to use between each data point.
        this.renderer.smooth = false;  // true or a number > 2 for smoothing.
        this.renderer.tension = null; // null to auto compute or a number typically > 6.  Fewer points requires higher tension.
        // prop: constrainSmoothing
        // True to use a more accurate smoothing algorithm that will
        // not overshoot any data points.  False to allow overshoot but
        // produce a smoother looking line.
        this.renderer.constrainSmoothing = true;
        // this is smoothed data in grid coordinates, like gridData
        this.renderer._smoothedData = [];
        // this is smoothed data in plot units (plot coordinates), like plotData.
        this.renderer._smoothedPlotData = [];
        this.renderer._hiBandGridData = [];
        this.renderer._lowBandGridData = [];
        this.renderer._hiBandSmoothedData = [];
        this.renderer._lowBandSmoothedData = [];

        // prop: bandData
        // Data used to draw error bands or confidence intervals above/below a line.
        //
        // bandData can be input in 3 forms.  jqPlot will figure out which is the
        // low band line and which is the high band line for all forms:
        // 
        // A 2 dimensional array like [[yl1, yl2, ...], [yu1, yu2, ...]] where
        // [yl1, yl2, ...] are y values of the lower line and
        // [yu1, yu2, ...] are y values of the upper line.
        // In this case there must be the same number of y data points as data points
        // in the series and the bands will inherit the x values of the series.
        //
        // A 2 dimensional array like [[[xl1, yl1], [xl2, yl2], ...], [[xh1, yh1], [xh2, yh2], ...]]
        // where [xl1, yl1] are x,y data points for the lower line and
        // [xh1, yh1] are x,y data points for the high line.
        // x values do not have to correspond to the x values of the series and can
        // be of any arbitrary length.
        //
        // Can be of form [[yl1, yu1], [yl2, yu2], [yl3, yu3], ...] where
        // there must be 3 or more arrays and there must be the same number of arrays
        // as there are data points in the series.  In this case, 
        // [yl1, yu1] specifies the lower and upper y values for the 1st
        // data point and so on.  The bands will inherit the x
        // values from the series.
        this.renderer.bandData = [];

        // Group: bands
        // Banding around line, e.g error bands or confidence intervals.
        this.renderer.bands = {
            // prop: show
            // true to show the bands.  If bandData or interval is
            // supplied, show will be set to true by default.
            show: false,
            hiData: [],
            lowData: [],
            // prop: color
            // color of lines at top and bottom of bands [default: series color].
            color: this.color,
            // prop: showLines
            // True to show lines at top and bottom of bands [default: false].
            showLines: false,
            // prop: fill
            // True to fill area between bands [default: true].
            fill: true,
            // prop: fillColor
            // css color spec for filled area.  [default: series color].
            fillColor: null,
            _min: null,
            _max: null,
            // prop: interval
            // User specified interval above and below line for bands [default: '3%''].
            // Can be a value like 3 or a string like '3%' 
            // or an upper/lower array like [1, -2] or ['2%', '-1.5%']
            interval: '3%'
        };


        var lopts = {highlightMouseOver: options.highlightMouseOver, highlightMouseDown: options.highlightMouseDown, highlightColor: options.highlightColor};
        
        delete (options.highlightMouseOver);
        delete (options.highlightMouseDown);
        delete (options.highlightColor);
        
        $.extend(true, this.renderer, options);

        this.renderer.options = options;

        // if we are given some band data, and bands aren't explicity set to false in options, turn them on.
        if (this.renderer.bandData.length > 1 && (!options.bands || options.bands.show == null)) {
            this.renderer.bands.show = true;
        }

        // if we are given an interval, and bands aren't explicity set to false in options, turn them on.
        else if (options.bands && options.bands.show == null && options.bands.interval != null) {
            this.renderer.bands.show = true;
        }

        // if plot is filled, turn off bands.
        if (this.fill) {
            this.renderer.bands.show = false;
        }

        if (this.renderer.bands.show) {
            this.renderer.initBands.call(this, this.renderer.options, plot);
        }


        // smoothing is not compatible with stacked lines, disable
        if (this._stack) {
            this.renderer.smooth = false;
        }

        // set the shape renderer options
        var opts = {lineJoin:this.lineJoin, lineCap:this.lineCap, fill:this.fill, isarc:false, strokeStyle:this.color, fillStyle:this.fillColor, lineWidth:this.lineWidth, linePattern:this.linePattern, closePath:this.fill};
        this.renderer.shapeRenderer.init(opts);

        var shadow_offset = options.shadowOffset;
        // set the shadow renderer options
        if (shadow_offset == null) {
            // scale the shadowOffset to the width of the line.
            if (this.lineWidth > 2.5) {
                shadow_offset = 1.25 * (1 + (Math.atan((this.lineWidth/2.5))/0.785398163 - 1)*0.6);
                // var shadow_offset = this.shadowOffset;
            }
            // for skinny lines, don't make such a big shadow.
            else {
                shadow_offset = 1.25 * Math.atan((this.lineWidth/2.5))/0.785398163;
            }
        }
        
        var sopts = {lineJoin:this.lineJoin, lineCap:this.lineCap, fill:this.fill, isarc:false, angle:this.shadowAngle, offset:shadow_offset, alpha:this.shadowAlpha, depth:this.shadowDepth, lineWidth:this.lineWidth, linePattern:this.linePattern, closePath:this.fill};
        this.renderer.shadowRenderer.init(sopts);
        this._areaPoints = [];
        this._boundingBox = [[],[]];
        
        if (!this.isTrendline && this.fill || this.renderer.bands.show) {
            // Group: Properties
            //        
            // prop: highlightMouseOver
            // True to highlight area on a filled plot when moused over.
            // This must be false to enable highlightMouseDown to highlight when clicking on an area on a filled plot.
            this.highlightMouseOver = true;
            // prop: highlightMouseDown
            // True to highlight when a mouse button is pressed over an area on a filled plot.
            // This will be disabled if highlightMouseOver is true.
            this.highlightMouseDown = false;
            // prop: highlightColor
            // color to use when highlighting an area on a filled plot.
            this.highlightColor = null;
            // if user has passed in highlightMouseDown option and not set highlightMouseOver, disable highlightMouseOver
            if (lopts.highlightMouseDown && lopts.highlightMouseOver == null) {
                lopts.highlightMouseOver = false;
            }
        
            $.extend(true, this, {highlightMouseOver: lopts.highlightMouseOver, highlightMouseDown: lopts.highlightMouseDown, highlightColor: lopts.highlightColor});
            
            if (!this.highlightColor) {
                var fc = (this.renderer.bands.show) ? this.renderer.bands.fillColor : this.fillColor;
                this.highlightColor = $.jqplot.computeHighlightColors(fc);
            }
            // turn off (disable) the highlighter plugin
            if (this.highlighter) {
                this.highlighter.show = false;
            }
        }
        
        if (!this.isTrendline && plot) {
            plot.plugins.lineRenderer = {};
            plot.postInitHooks.addOnce(postInit);
            plot.postDrawHooks.addOnce(postPlotDraw);
            plot.eventListenerHooks.addOnce('jqplotMouseMove', handleMove);
            plot.eventListenerHooks.addOnce('jqplotMouseDown', handleMouseDown);
            plot.eventListenerHooks.addOnce('jqplotMouseUp', handleMouseUp);
            plot.eventListenerHooks.addOnce('jqplotClick', handleClick);
            plot.eventListenerHooks.addOnce('jqplotRightClick', handleRightClick);
        }

    };

    $.jqplot.LineRenderer.prototype.initBands = function(options, plot) {
        // use bandData if no data specified in bands option
        //var bd = this.renderer.bandData;
        var bd = options.bandData || [];
        var bands = this.renderer.bands;
        bands.hiData = [];
        bands.lowData = [];
        var data = this.data;
        bands._max = null;
        bands._min = null;
        // If 2 arrays, and each array greater than 2 elements, assume it is hi and low data bands of y values.
        if (bd.length == 2) {
            // Do we have an array of x,y values?
            // like [[[1,1], [2,4], [3,3]], [[1,3], [2,6], [3,5]]]
            if ($.isArray(bd[0][0])) {
                // since an arbitrary array of points, spin through all of them to determine max and min lines.

                var p;
                var bdminidx = 0, bdmaxidx = 0;
                for (var i = 0, l = bd[0].length; i<l; i++) {
                    p = bd[0][i];
                    if ((p[1] != null && p[1] > bands._max) || bands._max == null) {
                        bands._max = p[1];
                    }
                    if ((p[1] != null && p[1] < bands._min) || bands._min == null) {
                        bands._min = p[1];
                    }
                }
                for (var i = 0, l = bd[1].length; i<l; i++) {
                    p = bd[1][i];
                    if ((p[1] != null && p[1] > bands._max) || bands._max == null) {
                        bands._max = p[1];
                        bdmaxidx = 1;
                    }
                    if ((p[1] != null && p[1] < bands._min) || bands._min == null) {
                        bands._min = p[1];
                        bdminidx = 1;
                    }
                }

                if (bdmaxidx === bdminidx) {
                    bands.show = false;
                }

                bands.hiData = bd[bdmaxidx];
                bands.lowData = bd[bdminidx];
            }
            // else data is arrays of y values
            // like [[1,4,3], [3,6,5]]
            // must have same number of band data points as points in series
            else if (bd[0].length === data.length && bd[1].length === data.length) {
                var hi = (bd[0][0] > bd[1][0]) ? 0 : 1;
                var low = (hi) ? 0 : 1;
                for (var i=0, l=data.length; i < l; i++) {
                    bands.hiData.push([data[i][0], bd[hi][i]]);
                    bands.lowData.push([data[i][0], bd[low][i]]);
                }
            }

            // we don't have proper data array, don't show bands.
            else {
                bands.show = false;
            }
        }

        // if more than 2 arrays, have arrays of [ylow, yhi] values.
        // note, can't distinguish case of [[ylow, yhi], [ylow, yhi]] from [[ylow, ylow], [yhi, yhi]]
        // this is assumed to be of the latter form.
        else if (bd.length > 2 && !$.isArray(bd[0][0])) {
            var hi = (bd[0][0] > bd[0][1]) ? 0 : 1;
            var low = (hi) ? 0 : 1;
            for (var i=0, l=bd.length; i<l; i++) {
                bands.hiData.push([data[i][0], bd[i][hi]]);
                bands.lowData.push([data[i][0], bd[i][low]]);
            }
        }

        // don't have proper data, auto calculate
        else {
            var intrv = bands.interval;
            var a = null;
            var b = null;
            var afunc = null;
            var bfunc = null;

            if ($.isArray(intrv)) {
                a = intrv[0];
                b = intrv[1];
            }
            else {
                a = intrv;
            }

            if (isNaN(a)) {
                // we have a string
                if (a.charAt(a.length - 1) === '%') {
                    afunc = 'multiply';
                    a = parseFloat(a)/100 + 1;
                }
            }

            else {
                a = parseFloat(a);
                afunc = 'add';
            }

            if (b !== null && isNaN(b)) {
                // we have a string
                if (b.charAt(b.length - 1) === '%') {
                    bfunc = 'multiply';
                    b = parseFloat(b)/100 + 1;
                }
            }

            else if (b !== null) {
                b = parseFloat(b);
                bfunc = 'add';
            }

            if (a !== null) {
                if (b === null) {
                    b = -a;
                    bfunc = afunc;
                    if (bfunc === 'multiply') {
                        b += 2;
                    }
                }

                // make sure a always applies to hi band.
                if (a < b) {
                    var temp = a;
                    a = b;
                    b = temp;
                    temp = afunc;
                    afunc = bfunc;
                    bfunc = temp;
                }

                for (var i=0, l = data.length; i < l; i++) {
                    switch (afunc) {
                        case 'add':
                            bands.hiData.push([data[i][0], data[i][1] + a]);
                            break;
                        case 'multiply':
                            bands.hiData.push([data[i][0], data[i][1] * a]);
                            break;
                    }
                    switch (bfunc) {
                        case 'add':
                            bands.lowData.push([data[i][0], data[i][1] + b]);
                            break;
                        case 'multiply':
                            bands.lowData.push([data[i][0], data[i][1] * b]);
                            break;
                    }
                }
            }

            else {
                bands.show = false;
            }
        }

        var hd = bands.hiData;
        var ld = bands.lowData;
        for (var i = 0, l = hd.length; i<l; i++) {
            if ((hd[i][1] != null && hd[i][1] > bands._max) || bands._max == null) {
                bands._max = hd[i][1];
            }
        }
        for (var i = 0, l = ld.length; i<l; i++) {
            if ((ld[i][1] != null && ld[i][1] < bands._min) || bands._min == null) {
                bands._min = ld[i][1];
            }
        }

        // one last check for proper data
        // these don't apply any more since allowing arbitrary x,y values
        // if (bands.hiData.length != bands.lowData.length) {
        //     bands.show = false;
        // }

        // if (bands.hiData.length != this.data.length) {
        //     bands.show = false;
        // }

        if (bands.fillColor === null) {
            var c = $.jqplot.getColorComponents(bands.color);
            // now adjust alpha to differentiate fill
            c[3] = c[3] * 0.5;
            bands.fillColor = 'rgba(' + c[0] +', '+ c[1] +', '+ c[2] +', '+ c[3] + ')';
        }
    };

    function getSteps (d, f) {
        return (3.4182054+f) * Math.pow(d, -0.3534992);
    }

    function computeSteps (d1, d2) {
        var s = Math.sqrt(Math.pow((d2[0]- d1[0]), 2) + Math.pow ((d2[1] - d1[1]), 2));
        return 5.7648 * Math.log(s) + 7.4456;
    }

    function tanh (x) {
        var a = (Math.exp(2*x) - 1) / (Math.exp(2*x) + 1);
        return a;
    }

    //////////
    // computeConstrainedSmoothedData
    // An implementation of the constrained cubic spline interpolation
    // method as presented in:
    //
    // Kruger, CJC, Constrained Cubic Spine Interpolation for Chemical Engineering Applications
    // http://www.korf.co.uk/spline.pdf
    //
    // The implementation below borrows heavily from the sample Visual Basic
    // implementation by CJC Kruger found in http://www.korf.co.uk/spline.xls
    //
    /////////

    // called with scope of series
    function computeConstrainedSmoothedData (gd) {
        var smooth = this.renderer.smooth;
        var dim = this.canvas.getWidth();
        var xp = this._xaxis.series_p2u;
        var yp = this._yaxis.series_p2u; 
        var steps =null;
        var _steps = null;
        var dist = gd.length/dim;
        var _smoothedData = [];
        var _smoothedPlotData = [];

        if (!isNaN(parseFloat(smooth))) {
            steps = parseFloat(smooth);
        }
        else {
            steps = getSteps(dist, 0.5);
        }

        var yy = [];
        var xx = [];

        for (var i=0, l = gd.length; i<l; i++) {
            yy.push(gd[i][1]);
            xx.push(gd[i][0]);
        }

        function dxx(x1, x0) {
            if (x1 - x0 == 0) {
                return Math.pow(10,10);
            }
            else {
                return x1 - x0;
            }
        }

        var A, B, C, D;
        // loop through each line segment.  Have # points - 1 line segments.  Nmber segments starting at 1.
        var nmax = gd.length - 1;
        for (var num = 1, gdl = gd.length; num<gdl; num++) {
            var gxx = [];
            var ggxx = [];
            // point at each end of segment.
            for (var j = 0; j < 2; j++) {
                var i = num - 1 + j; // point number, 0 to # points.

                if (i == 0 || i == nmax) {
                    gxx[j] = Math.pow(10, 10);
                }
                else if (yy[i+1] - yy[i] == 0 || yy[i] - yy[i-1] == 0) {
                    gxx[j] = 0;
                }
                else if (((xx[i+1] - xx[i]) / (yy[i+1] - yy[i]) + (xx[i] - xx[i-1]) / (yy[i] - yy[i-1])) == 0 ) {
                    gxx[j] = 0;
                }
                else if ( (yy[i+1] - yy[i]) * (yy[i] - yy[i-1]) < 0 ) {
                    gxx[j] = 0;
                }

                else {
                    gxx[j] = 2 / (dxx(xx[i + 1], xx[i]) / (yy[i + 1] - yy[i]) + dxx(xx[i], xx[i - 1]) / (yy[i] - yy[i - 1]));
                }
            }

            // Reset first derivative (slope) at first and last point
            if (num == 1) {
                // First point has 0 2nd derivative
                gxx[0] = 3 / 2 * (yy[1] - yy[0]) / dxx(xx[1], xx[0]) - gxx[1] / 2;
            }
            else if (num == nmax) {
                // Last point has 0 2nd derivative
                gxx[1] = 3 / 2 * (yy[nmax] - yy[nmax - 1]) / dxx(xx[nmax], xx[nmax - 1]) - gxx[0] / 2;
            }   

            // Calc second derivative at points
            ggxx[0] = -2 * (gxx[1] + 2 * gxx[0]) / dxx(xx[num], xx[num - 1]) + 6 * (yy[num] - yy[num - 1]) / Math.pow(dxx(xx[num], xx[num - 1]), 2);
            ggxx[1] = 2 * (2 * gxx[1] + gxx[0]) / dxx(xx[num], xx[num - 1]) - 6 * (yy[num] - yy[num - 1]) / Math.pow(dxx(xx[num], xx[num - 1]), 2);

            // Calc constants for cubic interpolation
            D = 1 / 6 * (ggxx[1] - ggxx[0]) / dxx(xx[num], xx[num - 1]);
            C = 1 / 2 * (xx[num] * ggxx[0] - xx[num - 1] * ggxx[1]) / dxx(xx[num], xx[num - 1]);
            B = (yy[num] - yy[num - 1] - C * (Math.pow(xx[num], 2) - Math.pow(xx[num - 1], 2)) - D * (Math.pow(xx[num], 3) - Math.pow(xx[num - 1], 3))) / dxx(xx[num], xx[num - 1]);
            A = yy[num - 1] - B * xx[num - 1] - C * Math.pow(xx[num - 1], 2) - D * Math.pow(xx[num - 1], 3);

            var increment = (xx[num] - xx[num - 1]) / steps;
            var temp, tempx;

            for (var j = 0, l = steps; j < l; j++) {
                temp = [];
                tempx = xx[num - 1] + j * increment;
                temp.push(tempx);
                temp.push(A + B * tempx + C * Math.pow(tempx, 2) + D * Math.pow(tempx, 3));
                _smoothedData.push(temp);
                _smoothedPlotData.push([xp(temp[0]), yp(temp[1])]);
            }
        }

        _smoothedData.push(gd[i]);
        _smoothedPlotData.push([xp(gd[i][0]), yp(gd[i][1])]);

        return [_smoothedData, _smoothedPlotData];
    }

    ///////
    // computeHermiteSmoothedData
    // A hermite spline smoothing of the plot data.
    // This implementation is derived from the one posted
    // by krypin on the jqplot-users mailing list:
    //
    // http://groups.google.com/group/jqplot-users/browse_thread/thread/748be6a445723cea?pli=1
    //
    // with a blog post:
    //
    // http://blog.statscollector.com/a-plugin-renderer-for-jqplot-to-draw-a-hermite-spline/
    //
    // and download of the original plugin:
    //
    // http://blog.statscollector.com/wp-content/uploads/2010/02/jqplot.hermiteSplineRenderer.js
    //////////

    // called with scope of series
    function computeHermiteSmoothedData (gd) {
        var smooth = this.renderer.smooth;
        var tension = this.renderer.tension;
        var dim = this.canvas.getWidth();
        var xp = this._xaxis.series_p2u;
        var yp = this._yaxis.series_p2u; 
        var steps =null;
        var _steps = null;
        var a = null;
        var a1 = null;
        var a2 = null;
        var slope = null;
        var slope2 = null;
        var temp = null;
        var t, s, h1, h2, h3, h4;
        var TiX, TiY, Ti1X, Ti1Y;
        var pX, pY, p;
        var sd = [];
        var spd = [];
        var dist = gd.length/dim;
        var min, max, stretch, scale, shift;
        var _smoothedData = [];
        var _smoothedPlotData = [];
        if (!isNaN(parseFloat(smooth))) {
            steps = parseFloat(smooth);
        }
        else {
            steps = getSteps(dist, 0.5);
        }
        if (!isNaN(parseFloat(tension))) {
            tension = parseFloat(tension);
        }

        for (var i=0, l = gd.length-1; i < l; i++) {

            if (tension === null) {
                slope = Math.abs((gd[i+1][1] - gd[i][1]) / (gd[i+1][0] - gd[i][0]));

                min = 0.3;
                max = 0.6;
                stretch = (max - min)/2.0;
                scale = 2.5;
                shift = -1.4;

                temp = slope/scale + shift;

                a1 = stretch * tanh(temp) - stretch * tanh(shift) + min;

                // if have both left and right line segments, will use  minimum tension. 
                if (i > 0) {
                    slope2 = Math.abs((gd[i][1] - gd[i-1][1]) / (gd[i][0] - gd[i-1][0]));
                }
                temp = slope2/scale + shift;

                a2 = stretch * tanh(temp) - stretch * tanh(shift) + min;

                a = (a1 + a2)/2.0;

            }
            else {
                a = tension;
            }
            for (t=0; t < steps; t++) {
                s = t / steps;
                h1 = (1 + 2*s)*Math.pow((1-s),2);
                h2 = s*Math.pow((1-s),2);
                h3 = Math.pow(s,2)*(3-2*s);
                h4 = Math.pow(s,2)*(s-1);     
                
                if (gd[i-1]) {  
                    TiX = a * (gd[i+1][0] - gd[i-1][0]); 
                    TiY = a * (gd[i+1][1] - gd[i-1][1]);
                } else {
                    TiX = a * (gd[i+1][0] - gd[i][0]); 
                    TiY = a * (gd[i+1][1] - gd[i][1]);                                  
                }
                if (gd[i+2]) {  
                    Ti1X = a * (gd[i+2][0] - gd[i][0]); 
                    Ti1Y = a * (gd[i+2][1] - gd[i][1]);
                } else {
                    Ti1X = a * (gd[i+1][0] - gd[i][0]); 
                    Ti1Y = a * (gd[i+1][1] - gd[i][1]);                                 
                }
                
                pX = h1*gd[i][0] + h3*gd[i+1][0] + h2*TiX + h4*Ti1X;
                pY = h1*gd[i][1] + h3*gd[i+1][1] + h2*TiY + h4*Ti1Y;
                p = [pX, pY];

                _smoothedData.push(p);
                _smoothedPlotData.push([xp(pX), yp(pY)]);
            }
        }
        _smoothedData.push(gd[l]);
        _smoothedPlotData.push([xp(gd[l][0]), yp(gd[l][1])]);

        return [_smoothedData, _smoothedPlotData];
    }
    
    // setGridData
    // converts the user data values to grid coordinates and stores them
    // in the gridData array.
    // Called with scope of a series.
    $.jqplot.LineRenderer.prototype.setGridData = function(plot) {
        // recalculate the grid data
        var xp = this._xaxis.series_u2p;
        var yp = this._yaxis.series_u2p;
        var data = this._plotData;
        var pdata = this._prevPlotData;
        this.gridData = [];
        this._prevGridData = [];
        this.renderer._smoothedData = [];
        this.renderer._smoothedPlotData = [];
        this.renderer._hiBandGridData = [];
        this.renderer._lowBandGridData = [];
        this.renderer._hiBandSmoothedData = [];
        this.renderer._lowBandSmoothedData = [];
        var bands = this.renderer.bands;
        var hasNull = false;
        for (var i=0, l=data.length; i < l; i++) {
            // if not a line series or if no nulls in data, push the converted point onto the array.
            if (data[i][0] != null && data[i][1] != null) {
                this.gridData.push([xp.call(this._xaxis, data[i][0]), yp.call(this._yaxis, data[i][1])]);
            }
            // else if there is a null, preserve it.
            else if (data[i][0] == null) {
                hasNull = true;
                this.gridData.push([null, yp.call(this._yaxis, data[i][1])]);
            }
            else if (data[i][1] == null) {
                hasNull = true;
                this.gridData.push([xp.call(this._xaxis, data[i][0]), null]);
            }
            // if not a line series or if no nulls in data, push the converted point onto the array.
            if (pdata[i] != null && pdata[i][0] != null && pdata[i][1] != null) {
                this._prevGridData.push([xp.call(this._xaxis, pdata[i][0]), yp.call(this._yaxis, pdata[i][1])]);
            }
            // else if there is a null, preserve it.
            else if (pdata[i] != null && pdata[i][0] == null) {
                this._prevGridData.push([null, yp.call(this._yaxis, pdata[i][1])]);
            }  
            else if (pdata[i] != null && pdata[i][0] != null && pdata[i][1] == null) {
                this._prevGridData.push([xp.call(this._xaxis, pdata[i][0]), null]);
            }
        }

        // don't do smoothing or bands on broken lines.
        if (hasNull) {
            this.renderer.smooth = false;
            if (this._type === 'line') {
                bands.show = false;
            }
        }

        if (this._type === 'line' && bands.show) {
            for (var i=0, l=bands.hiData.length; i<l; i++) {
                this.renderer._hiBandGridData.push([xp.call(this._xaxis, bands.hiData[i][0]), yp.call(this._yaxis, bands.hiData[i][1])]);
            }
            for (var i=0, l=bands.lowData.length; i<l; i++) {
                this.renderer._lowBandGridData.push([xp.call(this._xaxis, bands.lowData[i][0]), yp.call(this._yaxis, bands.lowData[i][1])]);
            }
        }

        // calculate smoothed data if enough points and no nulls
        if (this._type === 'line' && this.renderer.smooth && this.gridData.length > 2) {
            var ret;
            if (this.renderer.constrainSmoothing) {
                ret = computeConstrainedSmoothedData.call(this, this.gridData);
                this.renderer._smoothedData = ret[0];
                this.renderer._smoothedPlotData = ret[1];

                if (bands.show) {
                    ret = computeConstrainedSmoothedData.call(this, this.renderer._hiBandGridData);
                    this.renderer._hiBandSmoothedData = ret[0];
                    ret = computeConstrainedSmoothedData.call(this, this.renderer._lowBandGridData);
                    this.renderer._lowBandSmoothedData = ret[0];
                }

                ret = null;
            }
            else {
                ret = computeHermiteSmoothedData.call(this, this.gridData);
                this.renderer._smoothedData = ret[0];
                this.renderer._smoothedPlotData = ret[1];

                if (bands.show) {
                    ret = computeHermiteSmoothedData.call(this, this.renderer._hiBandGridData);
                    this.renderer._hiBandSmoothedData = ret[0];
                    ret = computeHermiteSmoothedData.call(this, this.renderer._lowBandGridData);
                    this.renderer._lowBandSmoothedData = ret[0];
                }

                ret = null;
            }
        }
    };
    
    // makeGridData
    // converts any arbitrary data values to grid coordinates and
    // returns them.  This method exists so that plugins can use a series'
    // linerenderer to generate grid data points without overwriting the
    // grid data associated with that series.
    // Called with scope of a series.
    $.jqplot.LineRenderer.prototype.makeGridData = function(data, plot) {
        // recalculate the grid data
        var xp = this._xaxis.series_u2p;
        var yp = this._yaxis.series_u2p;
        var gd = [];
        var pgd = [];
        this.renderer._smoothedData = [];
        this.renderer._smoothedPlotData = [];
        this.renderer._hiBandGridData = [];
        this.renderer._lowBandGridData = [];
        this.renderer._hiBandSmoothedData = [];
        this.renderer._lowBandSmoothedData = [];
        var bands = this.renderer.bands;
        var hasNull = false;
        for (var i=0; i<data.length; i++) {
            // if not a line series or if no nulls in data, push the converted point onto the array.
            if (data[i][0] != null && data[i][1] != null) {
                gd.push([xp.call(this._xaxis, data[i][0]), yp.call(this._yaxis, data[i][1])]);
            }
            // else if there is a null, preserve it.
            else if (data[i][0] == null) {
                hasNull = true;
                gd.push([null, yp.call(this._yaxis, data[i][1])]);
            }
            else if (data[i][1] == null) {
                hasNull = true;
                gd.push([xp.call(this._xaxis, data[i][0]), null]);
            }
        }

        // don't do smoothing or bands on broken lines.
        if (hasNull) {
            this.renderer.smooth = false;
            if (this._type === 'line') {
                bands.show = false;
            }
        }

        if (this._type === 'line' && bands.show) {
            for (var i=0, l=bands.hiData.length; i<l; i++) {
                this.renderer._hiBandGridData.push([xp.call(this._xaxis, bands.hiData[i][0]), yp.call(this._yaxis, bands.hiData[i][1])]);
            }
            for (var i=0, l=bands.lowData.length; i<l; i++) {
                this.renderer._lowBandGridData.push([xp.call(this._xaxis, bands.lowData[i][0]), yp.call(this._yaxis, bands.lowData[i][1])]);
            }
        }

        if (this._type === 'line' && this.renderer.smooth && gd.length > 2) {
            var ret;
            if (this.renderer.constrainSmoothing) {
                ret = computeConstrainedSmoothedData.call(this, gd);
                this.renderer._smoothedData = ret[0];
                this.renderer._smoothedPlotData = ret[1];

                if (bands.show) {
                    ret = computeConstrainedSmoothedData.call(this, this.renderer._hiBandGridData);
                    this.renderer._hiBandSmoothedData = ret[0];
                    ret = computeConstrainedSmoothedData.call(this, this.renderer._lowBandGridData);
                    this.renderer._lowBandSmoothedData = ret[0];
                }

                ret = null;
            }
            else {
                ret = computeHermiteSmoothedData.call(this, gd);
                this.renderer._smoothedData = ret[0];
                this.renderer._smoothedPlotData = ret[1];

                if (bands.show) {
                    ret = computeHermiteSmoothedData.call(this, this.renderer._hiBandGridData);
                    this.renderer._hiBandSmoothedData = ret[0];
                    ret = computeHermiteSmoothedData.call(this, this.renderer._lowBandGridData);
                    this.renderer._lowBandSmoothedData = ret[0];
                }

                ret = null;
            }
        }
        return gd;
    };
    

    // called within scope of series.
    $.jqplot.LineRenderer.prototype.draw = function(ctx, gd, options, plot) {
        var i;
        // get a copy of the options, so we don't modify the original object.
        var opts = $.extend(true, {}, options);
        var shadow = (opts.shadow != undefined) ? opts.shadow : this.shadow;
        var showLine = (opts.showLine != undefined) ? opts.showLine : this.showLine;
        var fill = (opts.fill != undefined) ? opts.fill : this.fill;
        var fillAndStroke = (opts.fillAndStroke != undefined) ? opts.fillAndStroke : this.fillAndStroke;
        var xmin, ymin, xmax, ymax;
        ctx.save();
        if (gd.length) {
            if (showLine) {
                // if we fill, we'll have to add points to close the curve.
                if (fill) {
                    if (this.fillToZero) { 
                        // have to break line up into shapes at axis crossings
                        var negativeColor = this.negativeColor;
                        if (! this.useNegativeColors) {
                            negativeColor = opts.fillStyle;
                        }
                        var isnegative = false;
                        var posfs = opts.fillStyle;
                    
                        // if stoking line as well as filling, get a copy of line data.
                        if (fillAndStroke) {
                            var fasgd = gd.slice(0);
                        }
                        // if not stacked, fill down to axis
                        if (this.index == 0 || !this._stack) {
                        
                            var tempgd = [];
                            var pd = (this.renderer.smooth) ? this.renderer._smoothedPlotData : this._plotData;
                            this._areaPoints = [];
                            var pyzero = this._yaxis.series_u2p(this.fillToValue);
                            var pxzero = this._xaxis.series_u2p(this.fillToValue);

                            opts.closePath = true;
                            
                            if (this.fillAxis == 'y') {
                                tempgd.push([gd[0][0], pyzero]);
                                this._areaPoints.push([gd[0][0], pyzero]);
                                
                                for (var i=0; i<gd.length-1; i++) {
                                    tempgd.push(gd[i]);
                                    this._areaPoints.push(gd[i]);
                                    // do we have an axis crossing?
                                    if (pd[i][1] * pd[i+1][1] <= 0) {
                                        if (pd[i][1] < 0) {
                                            isnegative = true;
                                            opts.fillStyle = negativeColor;
                                        }
                                        else {
                                            isnegative = false;
                                            opts.fillStyle = posfs;
                                        }
                                        
                                        var xintercept = gd[i][0] + (gd[i+1][0] - gd[i][0]) * (pyzero-gd[i][1])/(gd[i+1][1] - gd[i][1]);
                                        tempgd.push([xintercept, pyzero]);
                                        this._areaPoints.push([xintercept, pyzero]);
                                        // now draw this shape and shadow.
                                        if (shadow) {
                                            this.renderer.shadowRenderer.draw(ctx, tempgd, opts);
                                        }
                                        this.renderer.shapeRenderer.draw(ctx, tempgd, opts);
                                        // now empty temp array and continue
                                        tempgd = [[xintercept, pyzero]];
                                        // this._areaPoints = [[xintercept, pyzero]];
                                    }   
                                }
                                if (pd[gd.length-1][1] < 0) {
                                    isnegative = true;
                                    opts.fillStyle = negativeColor;
                                }
                                else {
                                    isnegative = false;
                                    opts.fillStyle = posfs;
                                }
                                tempgd.push(gd[gd.length-1]);
                                this._areaPoints.push(gd[gd.length-1]);
                                tempgd.push([gd[gd.length-1][0], pyzero]); 
                                this._areaPoints.push([gd[gd.length-1][0], pyzero]); 
                            }
                            // now draw the last area.
                            if (shadow) {
                                this.renderer.shadowRenderer.draw(ctx, tempgd, opts);
                            }
                            this.renderer.shapeRenderer.draw(ctx, tempgd, opts);
                            
                            
                            // var gridymin = this._yaxis.series_u2p(0);
                            // // IE doesn't return new length on unshift
                            // gd.unshift([gd[0][0], gridymin]);
                            // len = gd.length;
                            // gd.push([gd[len - 1][0], gridymin]);                   
                        }
                        // if stacked, fill to line below 
                        else {
                            var prev = this._prevGridData;
                            for (var i=prev.length; i>0; i--) {
                                gd.push(prev[i-1]);
                                // this._areaPoints.push(prev[i-1]);
                            }
                            if (shadow) {
                                this.renderer.shadowRenderer.draw(ctx, gd, opts);
                            }
                            this._areaPoints = gd;
                            this.renderer.shapeRenderer.draw(ctx, gd, opts);
                        }
                    }
                    /////////////////////////
                    // Not filled to zero
                    ////////////////////////
                    else {                    
                        // if stoking line as well as filling, get a copy of line data.
                        if (fillAndStroke) {
                            var fasgd = gd.slice(0);
                        }
                        // if not stacked, fill down to axis
                        if (this.index == 0 || !this._stack) {
                            // var gridymin = this._yaxis.series_u2p(this._yaxis.min) - this.gridBorderWidth / 2;
                            var gridymin = ctx.canvas.height;
                            // IE doesn't return new length on unshift
                            gd.unshift([gd[0][0], gridymin]);
                            var len = gd.length;
                            gd.push([gd[len - 1][0], gridymin]);                   
                        }
                        // if stacked, fill to line below 
                        else {
                            var prev = this._prevGridData;
                            for (var i=prev.length; i>0; i--) {
                                gd.push(prev[i-1]);
                            }
                        }
                        this._areaPoints = gd;
                        
                        if (shadow) {
                            this.renderer.shadowRenderer.draw(ctx, gd, opts);
                        }
            
                        this.renderer.shapeRenderer.draw(ctx, gd, opts);                        
                    }
                    if (fillAndStroke) {
                        var fasopts = $.extend(true, {}, opts, {fill:false, closePath:false});
                        this.renderer.shapeRenderer.draw(ctx, fasgd, fasopts);
                        //////////
                        // TODO: figure out some way to do shadows nicely
                        // if (shadow) {
                        //     this.renderer.shadowRenderer.draw(ctx, fasgd, fasopts);
                        // }
                        // now draw the markers
                        if (this.markerRenderer.show) {
                            if (this.renderer.smooth) {
                                fasgd = this.gridData;
                            }
                            for (i=0; i<fasgd.length; i++) {
                                this.markerRenderer.draw(fasgd[i][0], fasgd[i][1], ctx, opts.markerOptions);
                            }
                        }
                    }
                }
                else {

                    if (this.renderer.bands.show) {
                        var bdat;
                        var bopts = $.extend(true, {}, opts);
                        if (this.renderer.bands.showLines) {
                            bdat = (this.renderer.smooth) ? this.renderer._hiBandSmoothedData : this.renderer._hiBandGridData;
                            this.renderer.shapeRenderer.draw(ctx, bdat, opts);
                            bdat = (this.renderer.smooth) ? this.renderer._lowBandSmoothedData : this.renderer._lowBandGridData;
                            this.renderer.shapeRenderer.draw(ctx, bdat, bopts);
                        }

                        if (this.renderer.bands.fill) {
                            if (this.renderer.smooth) {
                                bdat = this.renderer._hiBandSmoothedData.concat(this.renderer._lowBandSmoothedData.reverse());
                            }
                            else {
                                bdat = this.renderer._hiBandGridData.concat(this.renderer._lowBandGridData.reverse());
                            }
                            this._areaPoints = bdat;
                            bopts.closePath = true;
                            bopts.fill = true;
                            bopts.fillStyle = this.renderer.bands.fillColor;
                            this.renderer.shapeRenderer.draw(ctx, bdat, bopts);
                        }
                    }

                    if (shadow) {
                        this.renderer.shadowRenderer.draw(ctx, gd, opts);
                    }
    
                    this.renderer.shapeRenderer.draw(ctx, gd, opts);
                }
            }
            // calculate the bounding box
            var xmin = xmax = ymin = ymax = null;
            for (i=0; i<this._areaPoints.length; i++) {
                var p = this._areaPoints[i];
                if (xmin > p[0] || xmin == null) {
                    xmin = p[0];
                }
                if (ymax < p[1] || ymax == null) {
                    ymax = p[1];
                }
                if (xmax < p[0] || xmax == null) {
                    xmax = p[0];
                }
                if (ymin > p[1] || ymin == null) {
                    ymin = p[1];
                }
            }

            if (this.type === 'line' && this.renderer.bands.show) {
                ymax = this._yaxis.series_u2p(this.renderer.bands._min);
                ymin = this._yaxis.series_u2p(this.renderer.bands._max);
            }

            this._boundingBox = [[xmin, ymax], [xmax, ymin]];
        
            // now draw the markers
            if (this.markerRenderer.show && !fill) {
                if (this.renderer.smooth) {
                    gd = this.gridData;
                }
                for (i=0; i<gd.length; i++) {
                    if (gd[i][0] != null && gd[i][1] != null) {
                        this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                    }
                }
            }
        }
        
        ctx.restore();
    };  
    
    $.jqplot.LineRenderer.prototype.drawShadow = function(ctx, gd, options) {
        // This is a no-op, shadows drawn with lines.
    };
    
    // called with scope of plot.
    // make sure to not leave anything highlighted.
    function postInit(target, data, options) {
        for (var i=0; i<this.series.length; i++) {
            if (this.series[i].renderer.constructor == $.jqplot.LineRenderer) {
                // don't allow mouseover and mousedown at same time.
                if (this.series[i].highlightMouseOver) {
                    this.series[i].highlightMouseDown = false;
                }
            }
        }
    }  
    
    // called within context of plot
    // create a canvas which we can draw on.
    // insert it before the eventCanvas, so eventCanvas will still capture events.
    function postPlotDraw() {
        // Memory Leaks patch    
        if (this.plugins.lineRenderer && this.plugins.lineRenderer.highlightCanvas) {
          this.plugins.lineRenderer.highlightCanvas.resetCanvas();
          this.plugins.lineRenderer.highlightCanvas = null;
        }
        
        this.plugins.lineRenderer.highlightedSeriesIndex = null;
        this.plugins.lineRenderer.highlightCanvas = new $.jqplot.GenericCanvas();
        
        this.eventCanvas._elem.before(this.plugins.lineRenderer.highlightCanvas.createElement(this._gridPadding, 'jqplot-lineRenderer-highlight-canvas', this._plotDimensions, this));
        this.plugins.lineRenderer.highlightCanvas.setContext();
        this.eventCanvas._elem.bind('mouseleave', {plot:this}, function (ev) { unhighlight(ev.data.plot); });
    } 
    
    function highlight (plot, sidx, pidx, points) {
        var s = plot.series[sidx];
        var canvas = plot.plugins.lineRenderer.highlightCanvas;
        canvas._ctx.clearRect(0,0,canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        s._highlightedPoint = pidx;
        plot.plugins.lineRenderer.highlightedSeriesIndex = sidx;
        var opts = {fillStyle: s.highlightColor};
        if (s.type === 'line' && s.renderer.bands.show) {
            opts.fill = true;
            opts.closePath = true;
        }
        s.renderer.shapeRenderer.draw(canvas._ctx, points, opts);
        canvas = null;
    }
    
    function unhighlight (plot) {
        var canvas = plot.plugins.lineRenderer.highlightCanvas;
        canvas._ctx.clearRect(0,0, canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        for (var i=0; i<plot.series.length; i++) {
            plot.series[i]._highlightedPoint = null;
        }
        plot.plugins.lineRenderer.highlightedSeriesIndex = null;
        plot.target.trigger('jqplotDataUnhighlight');
        canvas = null;
    }
    
    
    function handleMove(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
            var evt1 = jQuery.Event('jqplotDataMouseOver');
            evt1.pageX = ev.pageX;
            evt1.pageY = ev.pageY;
            plot.target.trigger(evt1, ins);
            if (plot.series[ins[0]].highlightMouseOver && !(ins[0] == plot.plugins.lineRenderer.highlightedSeriesIndex)) {
                var evt = jQuery.Event('jqplotDataHighlight');
                evt.which = ev.which;
                evt.pageX = ev.pageX;
                evt.pageY = ev.pageY;
                plot.target.trigger(evt, ins);
                highlight (plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        }
        else if (neighbor == null) {
            unhighlight (plot);
        }
    }
    
    function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
            if (plot.series[ins[0]].highlightMouseDown && !(ins[0] == plot.plugins.lineRenderer.highlightedSeriesIndex)) {
                var evt = jQuery.Event('jqplotDataHighlight');
                evt.which = ev.which;
                evt.pageX = ev.pageX;
                evt.pageY = ev.pageY;
                plot.target.trigger(evt, ins);
                highlight (plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        }
        else if (neighbor == null) {
            unhighlight (plot);
        }
    }
    
    function handleMouseUp(ev, gridpos, datapos, neighbor, plot) {
        var idx = plot.plugins.lineRenderer.highlightedSeriesIndex;
        if (idx != null && plot.series[idx].highlightMouseDown) {
            unhighlight(plot);
        }
    }
    
    function handleClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
            var evt = jQuery.Event('jqplotDataClick');
            evt.which = ev.which;
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            plot.target.trigger(evt, ins);
        }
    }
    
    function handleRightClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
            var idx = plot.plugins.lineRenderer.highlightedSeriesIndex;
            if (idx != null && plot.series[idx].highlightMouseDown) {
                unhighlight(plot);
            }
            var evt = jQuery.Event('jqplotDataRightClick');
            evt.which = ev.which;
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            plot.target.trigger(evt, ins);
        }
    }
    
    
    // class: $.jqplot.LinearAxisRenderer
    // The default jqPlot axis renderer, creating a numeric axis.
    $.jqplot.LinearAxisRenderer = function() {
    };
    
    // called with scope of axis object.
    $.jqplot.LinearAxisRenderer.prototype.init = function(options){
        // prop: breakPoints
        // EXPERIMENTAL!! Use at your own risk!
        // Works only with linear axes and the default tick renderer.
        // Array of [start, stop] points to create a broken axis.
        // Broken axes have a "jump" in them, which is an immediate 
        // transition from a smaller value to a larger value.
        // Currently, axis ticks MUST be manually assigned if using breakPoints
        // by using the axis ticks array option.
        this.breakPoints = null;
        // prop: breakTickLabel
        // Label to use at the axis break if breakPoints are specified.
        this.breakTickLabel = "&asymp;";
        // prop: drawBaseline
        // True to draw the axis baseline.
        this.drawBaseline = true;
        // prop: baselineWidth
        // width of the baseline in pixels.
        this.baselineWidth = null;
        // prop: baselineColor
        // CSS color spec for the baseline.
        this.baselineColor = null;
        // prop: forceTickAt0
        // This will ensure that there is always a tick mark at 0.
        // If data range is strictly positive or negative,
        // this will force 0 to be inside the axis bounds unless
        // the appropriate axis pad (pad, padMin or padMax) is set
        // to 0, then this will force an axis min or max value at 0.
        // This has know effect when any of the following options
        // are set:  autoscale, min, max, numberTicks or tickInterval.
        this.forceTickAt0 = false;
        // prop: forceTickAt100
        // This will ensure that there is always a tick mark at 100.
        // If data range is strictly above or below 100,
        // this will force 100 to be inside the axis bounds unless
        // the appropriate axis pad (pad, padMin or padMax) is set
        // to 0, then this will force an axis min or max value at 100.
        // This has know effect when any of the following options
        // are set:  autoscale, min, max, numberTicks or tickInterval.
        this.forceTickAt100 = false;
        // prop: tickInset
        // Controls the amount to inset the first and last ticks from 
        // the edges of the grid, in multiples of the tick interval.
        // 0 is no inset, 0.5 is one half a tick interval, 1 is a full
        // tick interval, etc.
        this.tickInset = 0;
        // prop: minorTicks
        // Number of ticks to add between "major" ticks.
        // Major ticks are ticks supplied by user or auto computed.
        // Minor ticks cannot be created by user.
        this.minorTicks = 0;
        // prop: alignTicks
        // true to align tick marks across opposed axes
        // such as from the y2axis to yaxis.
        this.alignTicks = false;
        this._autoFormatString = '';
        this._overrideFormatString = false;
        this._scalefact = 1.0;
        $.extend(true, this, options);
        if (this.breakPoints) {
            if (!$.isArray(this.breakPoints)) {
                this.breakPoints = null;
            }
            else if (this.breakPoints.length < 2 || this.breakPoints[1] <= this.breakPoints[0]) {
                this.breakPoints = null;
            }
        }
        if (this.numberTicks != null && this.numberTicks < 2) {
            this.numberTicks = 2;
        }
        this.resetDataBounds();
    };
    
    // called with scope of axis
    $.jqplot.LinearAxisRenderer.prototype.draw = function(ctx, plot) {
        if (this.show) {
            // populate the axis label and value properties.
            // createTicks is a method on the renderer, but
            // call it within the scope of the axis.
            this.renderer.createTicks.call(this, plot);
            // fill a div with axes labels in the right direction.
            // Need to pregenerate each axis to get its bounds and
            // position it and the labels correctly on the plot.
            var dim=0;
            var temp;
            // Added for theming.
            if (this._elem) {
                // Memory Leaks patch
                //this._elem.empty();
                this._elem.emptyForce();
                this._elem = null;
            }
            
            this._elem = $(document.createElement('div'));
            this._elem.addClass('jqplot-axis jqplot-'+this.name);
            this._elem.css('position', 'absolute');

            
            if (this.name == 'xaxis' || this.name == 'x2axis') {
                this._elem.width(this._plotDimensions.width);
            }
            else {
                this._elem.height(this._plotDimensions.height);
            }
            
            // create a _label object.
            this.labelOptions.axis = this.name;
            this._label = new this.labelRenderer(this.labelOptions);
            if (this._label.show) {
                var elem = this._label.draw(ctx, plot);
                elem.appendTo(this._elem);
                elem = null;
            }
    
            var t = this._ticks;
            var tick;
            for (var i=0; i<t.length; i++) {
                tick = t[i];
                if (tick.show && tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {
                    this._elem.append(tick.draw(ctx, plot));
                }
            }
            tick = null;
            t = null;
        }
        return this._elem;
    };
    
    // called with scope of an axis
    $.jqplot.LinearAxisRenderer.prototype.reset = function() {
        this.min = this._options.min;
        this.max = this._options.max;
        this.tickInterval = this._options.tickInterval;
        this.numberTicks = this._options.numberTicks;
        this._autoFormatString = '';
        if (this._overrideFormatString && this.tickOptions && this.tickOptions.formatString) {
            this.tickOptions.formatString = '';
        }

        // this._ticks = this.__ticks;
    };
    
    // called with scope of axis
    $.jqplot.LinearAxisRenderer.prototype.set = function() { 
        var dim = 0;
        var temp;
        var w = 0;
        var h = 0;
        var lshow = (this._label == null) ? false : this._label.show;
        if (this.show) {
            var t = this._ticks;
            var tick;
            for (var i=0; i<t.length; i++) {
                tick = t[i];
                if (!tick._breakTick && tick.show && tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        temp = tick._elem.outerHeight(true);
                    }
                    else {
                        temp = tick._elem.outerWidth(true);
                    }
                    if (temp > dim) {
                        dim = temp;
                    }
                }
            }
            tick = null;
            t = null;
            
            if (lshow) {
                w = this._label._elem.outerWidth(true);
                h = this._label._elem.outerHeight(true); 
            }
            if (this.name == 'xaxis') {
                dim = dim + h;
                this._elem.css({'height':dim+'px', left:'0px', bottom:'0px'});
            }
            else if (this.name == 'x2axis') {
                dim = dim + h;
                this._elem.css({'height':dim+'px', left:'0px', top:'0px'});
            }
            else if (this.name == 'yaxis') {
                dim = dim + w;
                this._elem.css({'width':dim+'px', left:'0px', top:'0px'});
                if (lshow && this._label.constructor == $.jqplot.AxisLabelRenderer) {
                    this._label._elem.css('width', w+'px');
                }
            }
            else {
                dim = dim + w;
                this._elem.css({'width':dim+'px', right:'0px', top:'0px'});
                if (lshow && this._label.constructor == $.jqplot.AxisLabelRenderer) {
                    this._label._elem.css('width', w+'px');
                }
            }
        }  
    };    
    
    // called with scope of axis
    $.jqplot.LinearAxisRenderer.prototype.createTicks = function(plot) {
        // we're are operating on an axis here
        var ticks = this._ticks;
        var userTicks = this.ticks;
        var name = this.name;
        // databounds were set on axis initialization.
        var db = this._dataBounds;
        var dim = (this.name.charAt(0) === 'x') ? this._plotDimensions.width : this._plotDimensions.height;
        var interval;
        var min, max;
        var pos1, pos2;
        var tt, i;
        // get a copy of user's settings for min/max.
        var userMin = this.min;
        var userMax = this.max;
        var userNT = this.numberTicks;
        var userTI = this.tickInterval;

        var threshold = 30;
        this._scalefact =  (Math.max(dim, threshold+1) - threshold)/300.0;
        
        // if we already have ticks, use them.
        // ticks must be in order of increasing value.
        
        if (userTicks.length) {
            // ticks could be 1D or 2D array of [val, val, ,,,] or [[val, label], [val, label], ...] or mixed
            for (i=0; i<userTicks.length; i++){
                var ut = userTicks[i];
                var t = new this.tickRenderer(this.tickOptions);
                if ($.isArray(ut)) {
                    t.value = ut[0];
                    if (this.breakPoints) {
                        if (ut[0] == this.breakPoints[0]) {
                            t.label = this.breakTickLabel;
                            t._breakTick = true;
                            t.showGridline = false;
                            t.showMark = false;
                        }
                        else if (ut[0] > this.breakPoints[0] && ut[0] <= this.breakPoints[1]) {
                            t.show = false;
                            t.showGridline = false;
                            t.label = ut[1];
                        }
                        else {
                            t.label = ut[1];
                        }
                    }
                    else {
                        t.label = ut[1];
                    }
                    t.setTick(ut[0], this.name);
                    this._ticks.push(t);
                }

                else if ($.isPlainObject(ut)) {
                    $.extend(true, t, ut);
                    t.axis = this.name;
                    this._ticks.push(t);
                }
                
                else {
                    t.value = ut;
                    if (this.breakPoints) {
                        if (ut == this.breakPoints[0]) {
                            t.label = this.breakTickLabel;
                            t._breakTick = true;
                            t.showGridline = false;
                            t.showMark = false;
                        }
                        else if (ut > this.breakPoints[0] && ut <= this.breakPoints[1]) {
                            t.show = false;
                            t.showGridline = false;
                        }
                    }
                    t.setTick(ut, this.name);
                    this._ticks.push(t);
                }
            }
            this.numberTicks = userTicks.length;
            this.min = this._ticks[0].value;
            this.max = this._ticks[this.numberTicks-1].value;
            this.tickInterval = (this.max - this.min) / (this.numberTicks - 1);
        }
        
        // we don't have any ticks yet, let's make some!
        else {
            if (name == 'xaxis' || name == 'x2axis') {
                dim = this._plotDimensions.width;
            }
            else {
                dim = this._plotDimensions.height;
            }

            var _numberTicks = this.numberTicks;

            // if aligning this axis, use number of ticks from previous axis.
            // Do I need to reset somehow if alignTicks is changed and then graph is replotted??
            if (this.alignTicks) {
                if (this.name === 'x2axis' && plot.axes.xaxis.show) {
                    _numberTicks = plot.axes.xaxis.numberTicks;
                }
                else if (this.name.charAt(0) === 'y' && this.name !== 'yaxis' && this.name !== 'yMidAxis' && plot.axes.yaxis.show) {
                    _numberTicks = plot.axes.yaxis.numberTicks;
                }
            }
        
            min = ((this.min != null) ? this.min : db.min);
            max = ((this.max != null) ? this.max : db.max);

            var range = max - min;
            var rmin, rmax;
            var temp;

            if (this.tickOptions == null || !this.tickOptions.formatString) {
                this._overrideFormatString = true;
            }

            // Doing complete autoscaling
            if (this.min == null || this.max == null && this.tickInterval == null && !this.autoscale) {
                // Check if user must have tick at 0 or 100 and ensure they are in range.
                // The autoscaling algorithm will always place ticks at 0 and 100 if they are in range.
                if (this.forceTickAt0) {
                    if (min > 0) {
                        min = 0;
                    }
                    if (max < 0) {
                        max = 0;
                    }
                }

                if (this.forceTickAt100) {
                    if (min > 100) {
                        min = 100;
                    }
                    if (max < 100) {
                        max = 100;
                    }
                }

                var keepMin = false,
                    keepMax = false;

                if (this.min != null) {
                    keepMin = true;
                }

                else if (this.max != null) {
                    keepMax = true;
                }

                // var threshold = 30;
                // var tdim = Math.max(dim, threshold+1);
                // this._scalefact =  (tdim-threshold)/300.0;
                var ret = $.jqplot.LinearTickGenerator(min, max, this._scalefact, _numberTicks, keepMin, keepMax); 
                // calculate a padded max and min, points should be less than these
                // so that they aren't too close to the edges of the plot.
                // User can adjust how much padding is allowed with pad, padMin and PadMax options. 
                // If min or max is set, don't pad that end of axis.
                var tumin = (this.min != null) ? min : min + range*(this.padMin - 1);
                var tumax = (this.max != null) ? max : max - range*(this.padMax - 1);

                // if they're equal, we shouldn't have to do anything, right?
                // if (min <=tumin || max >= tumax) {
                if (min <tumin || max > tumax) {
                    tumin = (this.min != null) ? min : min - range*(this.padMin - 1);
                    tumax = (this.max != null) ? max : max + range*(this.padMax - 1);
                    ret = $.jqplot.LinearTickGenerator(tumin, tumax, this._scalefact, _numberTicks, keepMin, keepMax);
                }

                this.min = ret[0];
                this.max = ret[1];
                // if numberTicks specified, it should return the same.
                this.numberTicks = ret[2];
                this._autoFormatString = ret[3];
                this.tickInterval = ret[4];
            }

            // User has specified some axis scale related option, can use auto algorithm
            else {
                
                // if min and max are same, space them out a bit
                if (min == max) {
                    var adj = 0.05;
                    if (min > 0) {
                        adj = Math.max(Math.log(min)/Math.LN10, 0.05);
                    }
                    min -= adj;
                    max += adj;
                }
                
                // autoscale.  Can't autoscale if min or max is supplied.
                // Will use numberTicks and tickInterval if supplied.  Ticks
                // across multiple axes may not line up depending on how
                // bars are to be plotted.
                if (this.autoscale && this.min == null && this.max == null) {
                    var rrange, ti, margin;
                    var forceMinZero = false;
                    var forceZeroLine = false;
                    var intervals = {min:null, max:null, average:null, stddev:null};
                    // if any series are bars, or if any are fill to zero, and if this
                    // is the axis to fill toward, check to see if we can start axis at zero.
                    for (var i=0; i<this._series.length; i++) {
                        var s = this._series[i];
                        var faname = (s.fillAxis == 'x') ? s._xaxis.name : s._yaxis.name;
                        // check to see if this is the fill axis
                        if (this.name == faname) {
                            var vals = s._plotValues[s.fillAxis];
                            var vmin = vals[0];
                            var vmax = vals[0];
                            for (var j=1; j<vals.length; j++) {
                                if (vals[j] < vmin) {
                                    vmin = vals[j];
                                }
                                else if (vals[j] > vmax) {
                                    vmax = vals[j];
                                }
                            }
                            var dp = (vmax - vmin) / vmax;
                            // is this sries a bar?
                            if (s.renderer.constructor == $.jqplot.BarRenderer) {
                                // if no negative values and could also check range.
                                if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {
                                    forceMinZero = true;
                                }
                                else {
                                    forceMinZero = false;
                                    if (s.fill && s.fillToZero && vmin < 0 && vmax > 0) {
                                        forceZeroLine = true;
                                    }
                                    else {
                                        forceZeroLine = false;
                                    }
                                }
                            }
                            
                            // if not a bar and filling, use appropriate method.
                            else if (s.fill) {
                                if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {
                                    forceMinZero = true;
                                }
                                else if (vmin < 0 && vmax > 0 && s.fillToZero) {
                                    forceMinZero = false;
                                    forceZeroLine = true;
                                }
                                else {
                                    forceMinZero = false;
                                    forceZeroLine = false;
                                }
                            }
                            
                            // if not a bar and not filling, only change existing state
                            // if it doesn't make sense
                            else if (vmin < 0) {
                                forceMinZero = false;
                            }
                        }
                    }
                    
                    // check if we need make axis min at 0.
                    if (forceMinZero) {
                        // compute number of ticks
                        this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                        this.min = 0;
                        userMin = 0;
                        // what order is this range?
                        // what tick interval does that give us?
                        ti = max/(this.numberTicks-1);
                        temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                        if (ti/temp == parseInt(ti/temp, 10)) {
                            ti += temp;
                        }
                        this.tickInterval = Math.ceil(ti/temp) * temp;
                        this.max = this.tickInterval * (this.numberTicks - 1);
                    }
                    
                    // check if we need to make sure there is a tick at 0.
                    else if (forceZeroLine) {
                        // compute number of ticks
                        this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                        var ntmin = Math.ceil(Math.abs(min)/range*(this.numberTicks-1));
                        var ntmax = this.numberTicks - 1  - ntmin;
                        ti = Math.max(Math.abs(min/ntmin), Math.abs(max/ntmax));
                        temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                        this.tickInterval = Math.ceil(ti/temp) * temp;
                        this.max = this.tickInterval * ntmax;
                        this.min = -this.tickInterval * ntmin;
                    }
                    
                    // if nothing else, do autoscaling which will try to line up ticks across axes.
                    else {  
                        if (this.numberTicks == null){
                            if (this.tickInterval) {
                                this.numberTicks = 3 + Math.ceil(range / this.tickInterval);
                            }
                            else {
                                this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                            }
                        }
                
                        if (this.tickInterval == null) {
                            // get a tick interval
                            ti = range/(this.numberTicks - 1);

                            if (ti < 1) {
                                temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                            }
                            else {
                                temp = 1;
                            }
                            this.tickInterval = Math.ceil(ti*temp*this.pad)/temp;
                        }
                        else {
                            temp = 1 / this.tickInterval;
                        }
                        
                        // try to compute a nicer, more even tick interval
                        // temp = Math.pow(10, Math.floor(Math.log(ti)/Math.LN10));
                        // this.tickInterval = Math.ceil(ti/temp) * temp;
                        rrange = this.tickInterval * (this.numberTicks - 1);
                        margin = (rrange - range)/2;
           
                        if (this.min == null) {
                            this.min = Math.floor(temp*(min-margin))/temp;
                        }
                        if (this.max == null) {
                            this.max = this.min + rrange;
                        }
                    }

                    // Compute a somewhat decent format string if it is needed.
                    // get precision of interval and determine a format string.
                    var sf = $.jqplot.getSignificantFigures(this.tickInterval);

                    var fstr;

                    // if we have only a whole number, use integer formatting
                    if (sf.digitsLeft >= sf.significantDigits) {
                        fstr = '%d';
                    }

                    else {
                        var temp = Math.max(0, 5 - sf.digitsLeft);
                        temp = Math.min(temp, sf.digitsRight);
                        fstr = '%.'+ temp + 'f';
                    }

                    this._autoFormatString = fstr;
                }
                
                // Use the default algorithm which pads each axis to make the chart
                // centered nicely on the grid.
                else {

                    rmin = (this.min != null) ? this.min : min - range*(this.padMin - 1);
                    rmax = (this.max != null) ? this.max : max + range*(this.padMax - 1);
                    range = rmax - rmin;
        
                    if (this.numberTicks == null){
                        // if tickInterval is specified by user, we will ignore computed maximum.
                        // max will be equal or greater to fit even # of ticks.
                        if (this.tickInterval != null) {
                            this.numberTicks = Math.ceil((rmax - rmin)/this.tickInterval)+1;
                        }
                        else if (dim > 100) {
                            this.numberTicks = parseInt(3+(dim-100)/75, 10);
                        }
                        else {
                            this.numberTicks = 2;
                        }
                    }
                
                    if (this.tickInterval == null) {
                        this.tickInterval = range / (this.numberTicks-1);
                    }
                    
                    if (this.max == null) {
                        rmax = rmin + this.tickInterval*(this.numberTicks - 1);
                    }        
                    if (this.min == null) {
                        rmin = rmax - this.tickInterval*(this.numberTicks - 1);
                    }

                    // get precision of interval and determine a format string.
                    var sf = $.jqplot.getSignificantFigures(this.tickInterval);

                    var fstr;

                    // if we have only a whole number, use integer formatting
                    if (sf.digitsLeft >= sf.significantDigits) {
                        fstr = '%d';
                    }

                    else {
                        var temp = Math.max(0, 5 - sf.digitsLeft);
                        temp = Math.min(temp, sf.digitsRight);
                        fstr = '%.'+ temp + 'f';
                    }


                    this._autoFormatString = fstr;

                    this.min = rmin;
                    this.max = rmax;
                }
                
                if (this.renderer.constructor == $.jqplot.LinearAxisRenderer && this._autoFormatString == '') {
                    // fix for misleading tick display with small range and low precision.
                    range = this.max - this.min;
                    // figure out precision
                    var temptick = new this.tickRenderer(this.tickOptions);
                    // use the tick formatString or, the default.
                    var fs = temptick.formatString || $.jqplot.config.defaultTickFormatString; 
                    var fs = fs.match($.jqplot.sprintf.regex)[0];
                    var precision = 0;
                    if (fs) {
                        if (fs.search(/[fFeEgGpP]/) > -1) {
                            var m = fs.match(/\%\.(\d{0,})?[eEfFgGpP]/);
                            if (m) {
                                precision = parseInt(m[1], 10);
                            }
                            else {
                                precision = 6;
                            }
                        }
                        else if (fs.search(/[di]/) > -1) {
                            precision = 0;
                        }
                        // fact will be <= 1;
                        var fact = Math.pow(10, -precision);
                        if (this.tickInterval < fact) {
                            // need to correct underrange
                            if (userNT == null && userTI == null) {
                                this.tickInterval = fact;
                                if (userMax == null && userMin == null) {
                                    // this.min = Math.floor((this._dataBounds.min - this.tickInterval)/fact) * fact;
                                    this.min = Math.floor(this._dataBounds.min/fact) * fact;
                                    if (this.min == this._dataBounds.min) {
                                        this.min = this._dataBounds.min - this.tickInterval;
                                    }
                                    // this.max = Math.ceil((this._dataBounds.max + this.tickInterval)/fact) * fact;
                                    this.max = Math.ceil(this._dataBounds.max/fact) * fact;
                                    if (this.max == this._dataBounds.max) {
                                        this.max = this._dataBounds.max + this.tickInterval;
                                    }
                                    var n = (this.max - this.min)/this.tickInterval;
                                    n = n.toFixed(11);
                                    n = Math.ceil(n);
                                    this.numberTicks = n + 1;
                                }
                                else if (userMax == null) {
                                    // add one tick for top of range.
                                    var n = (this._dataBounds.max - this.min) / this.tickInterval;
                                    n = n.toFixed(11);
                                    this.numberTicks = Math.ceil(n) + 2;
                                    this.max = this.min + this.tickInterval * (this.numberTicks-1);
                                }
                                else if (userMin == null) {
                                    // add one tick for bottom of range.
                                    var n = (this.max - this._dataBounds.min) / this.tickInterval;
                                    n = n.toFixed(11);
                                    this.numberTicks = Math.ceil(n) + 2;
                                    this.min = this.max - this.tickInterval * (this.numberTicks-1);
                                }
                                else {
                                    // calculate a number of ticks so max is within axis scale
                                    this.numberTicks = Math.ceil((userMax - userMin)/this.tickInterval) + 1;
                                    // if user's min and max don't fit evenly in ticks, adjust.
                                    // This takes care of cases such as user min set to 0, max set to 3.5 but tick
                                    // format string set to %d (integer ticks)
                                    this.min =  Math.floor(userMin*Math.pow(10, precision))/Math.pow(10, precision);
                                    this.max =  Math.ceil(userMax*Math.pow(10, precision))/Math.pow(10, precision);
                                    // this.max = this.min + this.tickInterval*(this.numberTicks-1);
                                    this.numberTicks = Math.ceil((this.max - this.min)/this.tickInterval) + 1;
                                }
                            }
                        }
                    }
                }
                
            }
            
            if (this._overrideFormatString && this._autoFormatString != '') {
                this.tickOptions = this.tickOptions || {};
                this.tickOptions.formatString = this._autoFormatString;
            }

            var t, to;
            for (var i=0; i<this.numberTicks; i++){
                tt = this.min + i * this.tickInterval;
                t = new this.tickRenderer(this.tickOptions);
                // var t = new $.jqplot.AxisTickRenderer(this.tickOptions);

                t.setTick(tt, this.name);
                this._ticks.push(t);

                if (i < this.numberTicks - 1) {
                    for (var j=0; j<this.minorTicks; j++) {
                        tt += this.tickInterval/(this.minorTicks+1);
                        to = $.extend(true, {}, this.tickOptions, {name:this.name, value:tt, label:'', isMinorTick:true});
                        t = new this.tickRenderer(to);
                        this._ticks.push(t);
                    }
                }
                t = null;
            }
        }

        if (this.tickInset) {
            this.min = this.min - this.tickInset * this.tickInterval;
            this.max = this.max + this.tickInset * this.tickInterval;
        }

        ticks = null;
    };
    
    // Used to reset just the values of the ticks and then repack, which will
    // recalculate the positioning functions.  It is assuemd that the 
    // number of ticks is the same and the values of the new array are at the
    // proper interval.
    // This method needs to be called with the scope of an axis object, like:
    //
    // > plot.axes.yaxis.renderer.resetTickValues.call(plot.axes.yaxis, yarr);
    //
    $.jqplot.LinearAxisRenderer.prototype.resetTickValues = function(opts) {
        if ($.isArray(opts) && opts.length == this._ticks.length) {
            var t;
            for (var i=0; i<opts.length; i++) {
                t = this._ticks[i];
                t.value = opts[i];
                t.label = t.formatter(t.formatString, opts[i]);
                t.label = t.prefix + t.label;
                t._elem.html(t.label);
            }
            t = null;
            this.min = $.jqplot.arrayMin(opts);
            this.max = $.jqplot.arrayMax(opts);
            this.pack();
        }
        // Not implemented yet.
        // else if ($.isPlainObject(opts)) {
        // 
        // }
    };
    
    // called with scope of axis
    $.jqplot.LinearAxisRenderer.prototype.pack = function(pos, offsets) {
        // Add defaults for repacking from resetTickValues function.
        pos = pos || {};
        offsets = offsets || this._offsets;
        
        var ticks = this._ticks;
        var max = this.max;
        var min = this.min;
        var offmax = offsets.max;
        var offmin = offsets.min;
        var lshow = (this._label == null) ? false : this._label.show;
        
        for (var p in pos) {
            this._elem.css(p, pos[p]);
        }
        
        this._offsets = offsets;
        // pixellength will be + for x axes and - for y axes becasue pixels always measured from top left.
        var pixellength = offmax - offmin;
        var unitlength = max - min;
        
        // point to unit and unit to point conversions references to Plot DOM element top left corner.
        if (this.breakPoints) {
            unitlength = unitlength - this.breakPoints[1] + this.breakPoints[0];
            
            this.p2u = function(p){
                return (p - offmin) * unitlength / pixellength + min;
            };
        
            this.u2p = function(u){
                if (u > this.breakPoints[0] && u < this.breakPoints[1]){
                    u = this.breakPoints[0];
                }
                if (u <= this.breakPoints[0]) {
                    return (u - min) * pixellength / unitlength + offmin;
                }
                else {
                    return (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength + offmin;
                }
            };
                
            if (this.name.charAt(0) == 'x'){
                this.series_u2p = function(u){
                    if (u > this.breakPoints[0] && u < this.breakPoints[1]){
                        u = this.breakPoints[0];
                    }
                    if (u <= this.breakPoints[0]) {
                        return (u - min) * pixellength / unitlength;
                    }
                    else {
                        return (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength;
                    }
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + min;
                };
            }
        
            else {
                this.series_u2p = function(u){
                    if (u > this.breakPoints[0] && u < this.breakPoints[1]){
                        u = this.breakPoints[0];
                    }
                    if (u >= this.breakPoints[1]) {
                        return (u - max) * pixellength / unitlength;
                    }
                    else {
                        return (u + this.breakPoints[1] - this.breakPoints[0] - max) * pixellength / unitlength;
                    }
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + max;
                };
            }
        }
        else {
            this.p2u = function(p){
                return (p - offmin) * unitlength / pixellength + min;
            };
        
            this.u2p = function(u){
                return (u - min) * pixellength / unitlength + offmin;
            };
                
            if (this.name == 'xaxis' || this.name == 'x2axis'){
                this.series_u2p = function(u){
                    return (u - min) * pixellength / unitlength;
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + min;
                };
            }
        
            else {
                this.series_u2p = function(u){
                    return (u - max) * pixellength / unitlength;
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + max;
                };
            }
        }
        
        if (this.show) {
            if (this.name == 'xaxis' || this.name == 'x2axis') {
                for (var i=0; i<ticks.length; i++) {
                    var t = ticks[i];
                    if (t.show && t.showLabel) {
                        var shim;
                        
                        if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) {
                            // will need to adjust auto positioning based on which axis this is.
                            var temp = (this.name == 'xaxis') ? 1 : -1;
                            switch (t.labelPosition) {
                                case 'auto':
                                    // position at end
                                    if (temp * t.angle < 0) {
                                        shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    }
                                    // position at start
                                    else {
                                        shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'end':
                                    shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                                case 'start':
                                    shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    break;
                                case 'middle':
                                    shim = -t.getWidth()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                                default:
                                    shim = -t.getWidth()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                            }
                        }
                        else {
                            shim = -t.getWidth()/2;
                        }
                        var val = this.u2p(t.value) + shim + 'px';
                        t._elem.css('left', val);
                        t.pack();
                    }
                }
                if (lshow) {
                    var w = this._label._elem.outerWidth(true);
                    this._label._elem.css('left', offmin + pixellength/2 - w/2 + 'px');
                    if (this.name == 'xaxis') {
                        this._label._elem.css('bottom', '0px');
                    }
                    else {
                        this._label._elem.css('top', '0px');
                    }
                    this._label.pack();
                }
            }
            else {
                for (var i=0; i<ticks.length; i++) {
                    var t = ticks[i];
                    if (t.show && t.showLabel) {                        
                        var shim;
                        if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) {
                            // will need to adjust auto positioning based on which axis this is.
                            var temp = (this.name == 'yaxis') ? 1 : -1;
                            switch (t.labelPosition) {
                                case 'auto':
                                    // position at end
                                case 'end':
                                    if (temp * t.angle < 0) {
                                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                                    }
                                    else {
                                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'start':
                                    if (t.angle > 0) {
                                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                                    }
                                    else {
                                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'middle':
                                    // if (t.angle > 0) {
                                    //     shim = -t.getHeight()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    // }
                                    // else {
                                    //     shim = -t.getHeight()/2 - t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    // }
                                    shim = -t.getHeight()/2;
                                    break;
                                default:
                                    shim = -t.getHeight()/2;
                                    break;
                            }
                        }
                        else {
                            shim = -t.getHeight()/2;
                        }
                        
                        var val = this.u2p(t.value) + shim + 'px';
                        t._elem.css('top', val);
                        t.pack();
                    }
                }
                if (lshow) {
                    var h = this._label._elem.outerHeight(true);
                    this._label._elem.css('top', offmax - pixellength/2 - h/2 + 'px');
                    if (this.name == 'yaxis') {
                        this._label._elem.css('left', '0px');
                    }
                    else {
                        this._label._elem.css('right', '0px');
                    }   
                    this._label.pack();
                }
            }
        }

        ticks = null;
    };


    /**
    * The following code was generaously given to me a while back by Scott Prahl.
    * He did a good job at computing axes min, max and number of ticks for the 
    * case where the user has not set any scale related parameters (tickInterval,
    * numberTicks, min or max).  I had ignored this use case for a long time,
    * focusing on the more difficult case where user has set some option controlling
    * tick generation.  Anyway, about time I got this into jqPlot.
    * Thanks Scott!!
    */
    
    /**
    * Copyright (c) 2010 Scott Prahl
    * The next three routines are currently available for use in all personal 
    * or commercial projects under both the MIT and GPL version 2.0 licenses. 
    * This means that you can choose the license that best suits your project 
    * and use it accordingly. 
    */

    // A good format string depends on the interval. If the interval is greater 
    // than 1 then there is no need to show any decimal digits. If it is < 1.0, then
    // use the magnitude of the interval to determine the number of digits to show.
    function bestFormatString (interval)
    {
        var fstr;
        interval = Math.abs(interval);
        if (interval >= 10) {
            fstr = '%d';
        }

        else if (interval > 1) {
            if (interval === parseInt(interval, 10)) {
                fstr = '%d';
            }
            else {
                fstr = '%.1f';
            }
        }

        else {
            var expv = -Math.floor(Math.log(interval)/Math.LN10);
            fstr = '%.' + expv + 'f';
        }
        
        return fstr; 
    }

    var _factors = [0.1, 0.2, 0.3, 0.4, 0.5, 0.8, 1, 2, 3, 4, 5];

    var _getLowerFactor = function(f) {
        var i = _factors.indexOf(f);
        if (i > 0) {
            return _factors[i-1];
        }
        else {
            return _factors[_factors.length - 1] / 100;
        }
    };

    var _getHigherFactor = function(f) {
        var i = _factors.indexOf(f);
        if (i < _factors.length-1) {
            return _factors[i+1];
        }
        else {
            return _factors[0] * 100;
        }
    };

    // Given a fixed minimum and maximum and a target number ot ticks
    // figure out the best interval and 
    // return min, max, number ticks, format string and tick interval
    function bestConstrainedInterval(min, max, nttarget) {
        // run through possible number to ticks and see which interval is best
        var low = Math.floor(nttarget/2);
        var hi = Math.ceil(nttarget*1.5);
        var badness = Number.MAX_VALUE;
        var r = (max - min);
        var temp;
        var sd;
        var bestNT;
        var gsf = $.jqplot.getSignificantFigures;
        var fsd;
        var fs;
        var currentNT;
        var bestPrec;

        for (var i=0, l=hi-low+1; i<l; i++) {
            currentNT = low + i;
            temp = r/(currentNT-1);
            sd = gsf(temp);

            temp = Math.abs(nttarget - currentNT) + sd.digitsRight;
            if (temp < badness) {
                badness = temp;
                bestNT = currentNT;
                bestPrec = sd.digitsRight;
            }
            else if (temp === badness) {
                // let nicer ticks trump number ot ticks
                if (sd.digitsRight < bestPrec) {
                    bestNT = currentNT;
                    bestPrec = sd.digitsRight;
                }
            }

        }

        fsd = Math.max(bestPrec, Math.max(gsf(min).digitsRight, gsf(max).digitsRight));
        if (fsd === 0) {
            fs = '%d';
        }
        else {
            fs = '%.' + fsd + 'f';
        }
        temp = r / (bestNT - 1);
        // min, max, number ticks, format string, tick interval
        return [min, max, bestNT, fs, temp];
    }

    // This will return an interval of form 2 * 10^n, 5 * 10^n or 10 * 10^n
    // it is based soley on the range and number of ticks.  So if user specifies
    // number of ticks, use this.
    function bestInterval(range, numberTicks) {
        numberTicks = numberTicks || 7;
        var minimum = range / (numberTicks - 1);
        var magnitude = Math.pow(10, Math.floor(Math.log(minimum) / Math.LN10));
        var residual = minimum / magnitude;
        var interval;
        // "nicest" ranges are 1, 2, 5 or powers of these.
        // for magnitudes below 1, only allow these. 
        if (magnitude < 1) {
            if (residual > 5) {
                interval = 10 * magnitude;
            }
            else if (residual > 2) {
                interval = 5 * magnitude;
            }
            else if (residual > 1) {
                interval = 2 * magnitude;
            }
            else {
                interval = magnitude;
            }
        }
        // for large ranges (whole integers), allow intervals like 3, 4 or powers of these.
        // this helps a lot with poor choices for number of ticks. 
        else {
            if (residual > 5) {
                interval = 10 * magnitude;
            }
            else if (residual > 4) {
                interval = 5 * magnitude;
            }
            else if (residual > 3) {
                interval = 4 * magnitude;
            }
            else if (residual > 2) {
                interval = 3 * magnitude;
            }
            else if (residual > 1) {
                interval = 2 * magnitude;
            }
            else {
                interval = magnitude;
            }
        }

        return interval;
    }

    // This will return an interval of form 2 * 10^n, 5 * 10^n or 10 * 10^n
    // it is based soley on the range of data, number of ticks must be computed later.
    function bestLinearInterval(range, scalefact) {
        scalefact = scalefact || 1;
        var expv = Math.floor(Math.log(range)/Math.LN10);
        var magnitude = Math.pow(10, expv);
        // 0 < f < 10
        var f = range / magnitude;
        var fact;
        // for large plots, scalefact will decrease f and increase number of ticks.
        // for small plots, scalefact will increase f and decrease number of ticks.
        f = f/scalefact;

        // for large plots, smaller interval, more ticks.
        if (f<=0.38) {
            fact = 0.1;
        }
        else if (f<=1.6) {
            fact = 0.2;
        }
        else if (f<=4.0) {
            fact = 0.5;
        }
        else if (f<=8.0) {
            fact = 1.0;
        }
        // for very small plots, larger interval, less ticks in number ticks
        else if (f<=16.0) {
            fact = 2;
        }
        else {
            fact = 5;
        } 

        return fact*magnitude; 
    }

    function bestLinearComponents(range, scalefact) {
        var expv = Math.floor(Math.log(range)/Math.LN10);
        var magnitude = Math.pow(10, expv);
        // 0 < f < 10
        var f = range / magnitude;
        var interval;
        var fact;
        // for large plots, scalefact will decrease f and increase number of ticks.
        // for small plots, scalefact will increase f and decrease number of ticks.
        f = f/scalefact;

        // for large plots, smaller interval, more ticks.
        if (f<=0.38) {
            fact = 0.1;
        }
        else if (f<=1.6) {
            fact = 0.2;
        }
        else if (f<=4.0) {
            fact = 0.5;
        }
        else if (f<=8.0) {
            fact = 1.0;
        }
        // for very small plots, larger interval, less ticks in number ticks
        else if (f<=16.0) {
            fact = 2;
        }
        // else if (f<=20.0) {
        //     fact = 3;
        // }
        // else if (f<=24.0) {
        //     fact = 4;
        // }
        else {
            fact = 5;
        } 

        interval = fact * magnitude;

        return [interval, fact, magnitude];
    }

    // Given the min and max for a dataset, return suitable endpoints
    // for the graphing, a good number for the number of ticks, and a
    // format string so that extraneous digits are not displayed.
    // returned is an array containing [min, max, nTicks, format]
    $.jqplot.LinearTickGenerator = function(axis_min, axis_max, scalefact, numberTicks, keepMin, keepMax) {
        // Set to preserve EITHER min OR max.
        // If min is preserved, max must be free.
        keepMin = (keepMin === null) ? false : keepMin;
        keepMax = (keepMax === null || keepMin) ? false : keepMax;
        // if endpoints are equal try to include zero otherwise include one
        if (axis_min === axis_max) {
            axis_max = (axis_max) ? 0 : 1;
        }

        scalefact = scalefact || 1.0;

        // make sure range is positive
        if (axis_max < axis_min) {
            var a = axis_max;
            axis_max = axis_min;
            axis_min = a;
        }

        var r = [];
        var ss = bestLinearInterval(axis_max - axis_min, scalefact);

        var gsf = $.jqplot.getSignificantFigures;
        
        if (numberTicks == null) {

            // Figure out the axis min, max and number of ticks
            // the min and max will be some multiple of the tick interval,
            // 1*10^n, 2*10^n or 5*10^n.  This gaurantees that, if the
            // axis min is negative, 0 will be a tick.
            if (!keepMin && !keepMax) {
                r[0] = Math.floor(axis_min / ss) * ss;  // min
                r[1] = Math.ceil(axis_max / ss) * ss;   // max
                r[2] = Math.round((r[1]-r[0])/ss+1.0);  // number of ticks
                r[3] = bestFormatString(ss);            // format string
                r[4] = ss;                              // tick Interval
            }

            else if (keepMin) {
                r[0] = axis_min;                                        // min
                r[2] = Math.ceil((axis_max - axis_min) / ss + 1.0);     // number of ticks
                r[1] = axis_min + (r[2] - 1) * ss;                      // max
                var digitsMin = gsf(axis_min).digitsRight;
                var digitsSS = gsf(ss).digitsRight;
                if (digitsMin < digitsSS) {
                    r[3] = bestFormatString(ss);                        // format string
                }
                else {
                    r[3] = '%.' + digitsMin + 'f';
                }
                r[4] = ss;                                              // tick Interval
            }

            else if (keepMax) {
                r[1] = axis_max;                                        // max
                r[2] = Math.ceil((axis_max - axis_min) / ss + 1.0);     // number of ticks
                r[0] = axis_max - (r[2] - 1) * ss;                      // min
                var digitsMax = gsf(axis_max).digitsRight;
                var digitsSS = gsf(ss).digitsRight;
                if (digitsMax < digitsSS) {
                    r[3] = bestFormatString(ss);                        // format string
                }
                else {
                    r[3] = '%.' + digitsMax + 'f';
                }
                r[4] = ss;                                              // tick Interval
            }
        }

        else {
            var tempr = [];

            // Figure out the axis min, max and number of ticks
            // the min and max will be some multiple of the tick interval,
            // 1*10^n, 2*10^n or 5*10^n.  This gaurantees that, if the
            // axis min is negative, 0 will be a tick.
            tempr[0] = Math.floor(axis_min / ss) * ss;  // min
            tempr[1] = Math.ceil(axis_max / ss) * ss;   // max
            tempr[2] = Math.round((tempr[1]-tempr[0])/ss+1.0);    // number of ticks
            tempr[3] = bestFormatString(ss);            // format string
            tempr[4] = ss;                              // tick Interval

            // first, see if we happen to get the right number of ticks
            if (tempr[2] === numberTicks) {
                r = tempr;
            }

            else {

                var newti = bestInterval(tempr[1] - tempr[0], numberTicks);

                r[0] = tempr[0];                        // min
                r[2] = numberTicks;                     // number of ticks
                r[4] = newti;                           // tick interval
                r[3] = bestFormatString(newti);         // format string
                r[1] = r[0] + (r[2] - 1) * r[4];        // max
            }
        }

        return r;
    };

    $.jqplot.LinearTickGenerator.bestLinearInterval = bestLinearInterval;
    $.jqplot.LinearTickGenerator.bestInterval = bestInterval;
    $.jqplot.LinearTickGenerator.bestLinearComponents = bestLinearComponents;
    $.jqplot.LinearTickGenerator.bestConstrainedInterval = bestConstrainedInterval;


    // class: $.jqplot.MarkerRenderer
    // The default jqPlot marker renderer, rendering the points on the line.
    $.jqplot.MarkerRenderer = function(options){
        // Group: Properties
        
        // prop: show
        // whether or not to show the marker.
        this.show = true;
        // prop: style
        // One of diamond, circle, square, x, plus, dash, filledDiamond, filledCircle, filledSquare
        this.style = 'filledCircle';
        // prop: lineWidth
        // size of the line for non-filled markers.
        this.lineWidth = 2;
        // prop: size
        // Size of the marker (diameter or circle, length of edge of square, etc.)
        this.size = 9.0;
        // prop: color
        // color of marker.  Will be set to color of series by default on init.
        this.color = '#666666';
        // prop: shadow
        // whether or not to draw a shadow on the line
        this.shadow = true;
        // prop: shadowAngle
        // Shadow angle in degrees
        this.shadowAngle = 45;
        // prop: shadowOffset
        // Shadow offset from line in pixels
        this.shadowOffset = 1;
        // prop: shadowDepth
        // Number of times shadow is stroked, each stroke offset shadowOffset from the last.
        this.shadowDepth = 3;
        // prop: shadowAlpha
        // Alpha channel transparency of shadow.  0 = transparent.
        this.shadowAlpha = '0.07';
        // prop: shadowRenderer
        // Renderer that will draws the shadows on the marker.
        this.shadowRenderer = new $.jqplot.ShadowRenderer();
        // prop: shapeRenderer
        // Renderer that will draw the marker.
        this.shapeRenderer = new $.jqplot.ShapeRenderer();
        
        $.extend(true, this, options);
    };
    
    $.jqplot.MarkerRenderer.prototype.init = function(options) {
        $.extend(true, this, options);
        var sdopt = {angle:this.shadowAngle, offset:this.shadowOffset, alpha:this.shadowAlpha, lineWidth:this.lineWidth, depth:this.shadowDepth, closePath:true};
        if (this.style.indexOf('filled') != -1) {
            sdopt.fill = true;
        }
        if (this.style.indexOf('ircle') != -1) {
            sdopt.isarc = true;
            sdopt.closePath = false;
        }
        this.shadowRenderer.init(sdopt);
        
        var shopt = {fill:false, isarc:false, strokeStyle:this.color, fillStyle:this.color, lineWidth:this.lineWidth, closePath:true};
        if (this.style.indexOf('filled') != -1) {
            shopt.fill = true;
        }
        if (this.style.indexOf('ircle') != -1) {
            shopt.isarc = true;
            shopt.closePath = false;
        }
        this.shapeRenderer.init(shopt);
    };
    
    $.jqplot.MarkerRenderer.prototype.drawDiamond = function(x, y, ctx, fill, options) {
        var stretch = 1.2;
        var dx = this.size/2/stretch;
        var dy = this.size/2*stretch;
        var points = [[x-dx, y], [x, y+dy], [x+dx, y], [x, y-dy]];
        if (this.shadow) {
            this.shadowRenderer.draw(ctx, points);
        }
        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.MarkerRenderer.prototype.drawPlus = function(x, y, ctx, fill, options) {
        var stretch = 1.0;
        var dx = this.size/2*stretch;
        var dy = this.size/2*stretch;
        var points1 = [[x, y-dy], [x, y+dy]];
        var points2 = [[x+dx, y], [x-dx, y]];
        var opts = $.extend(true, {}, this.options, {closePath:false});
        if (this.shadow) {
            this.shadowRenderer.draw(ctx, points1, {closePath:false});
            this.shadowRenderer.draw(ctx, points2, {closePath:false});
        }
        this.shapeRenderer.draw(ctx, points1, opts);
        this.shapeRenderer.draw(ctx, points2, opts);
    };
    
    $.jqplot.MarkerRenderer.prototype.drawX = function(x, y, ctx, fill, options) {
        var stretch = 1.0;
        var dx = this.size/2*stretch;
        var dy = this.size/2*stretch;
        var opts = $.extend(true, {}, this.options, {closePath:false});
        var points1 = [[x-dx, y-dy], [x+dx, y+dy]];
        var points2 = [[x-dx, y+dy], [x+dx, y-dy]];
        if (this.shadow) {
            this.shadowRenderer.draw(ctx, points1, {closePath:false});
            this.shadowRenderer.draw(ctx, points2, {closePath:false});
        }
        this.shapeRenderer.draw(ctx, points1, opts);
        this.shapeRenderer.draw(ctx, points2, opts);
    };
    
    $.jqplot.MarkerRenderer.prototype.drawDash = function(x, y, ctx, fill, options) {
        var stretch = 1.0;
        var dx = this.size/2*stretch;
        var dy = this.size/2*stretch;
        var points = [[x-dx, y], [x+dx, y]];
        if (this.shadow) {
            this.shadowRenderer.draw(ctx, points);
        }
        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.MarkerRenderer.prototype.drawLine = function(p1, p2, ctx, fill, options) {
        var points = [p1, p2];
        if (this.shadow) {
            this.shadowRenderer.draw(ctx, points);
        }
        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.MarkerRenderer.prototype.drawSquare = function(x, y, ctx, fill, options) {
        var stretch = 1.0;
        var dx = this.size/2/stretch;
        var dy = this.size/2*stretch;
        var points = [[x-dx, y-dy], [x-dx, y+dy], [x+dx, y+dy], [x+dx, y-dy]];
        if (this.shadow) {
            this.shadowRenderer.draw(ctx, points);
        }
        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.MarkerRenderer.prototype.drawCircle = function(x, y, ctx, fill, options) {
        var radius = this.size/2;
        var end = 2*Math.PI;
        var points = [x, y, radius, 0, end, true];
        if (this.shadow) {
            this.shadowRenderer.draw(ctx, points);
        }
        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.MarkerRenderer.prototype.draw = function(x, y, ctx, options) {
        options = options || {};
        // hack here b/c shape renderer uses canvas based color style options
        // and marker uses css style names.
        if (options.show == null || options.show != false) {
            if (options.color && !options.fillStyle) {
                options.fillStyle = options.color;
            }
            if (options.color && !options.strokeStyle) {
                options.strokeStyle = options.color;
            }
            switch (this.style) {
                case 'diamond':
                    this.drawDiamond(x,y,ctx, false, options);
                    break;
                case 'filledDiamond':
                    this.drawDiamond(x,y,ctx, true, options);
                    break;
                case 'circle':
                    this.drawCircle(x,y,ctx, false, options);
                    break;
                case 'filledCircle':
                    this.drawCircle(x,y,ctx, true, options);
                    break;
                case 'square':
                    this.drawSquare(x,y,ctx, false, options);
                    break;
                case 'filledSquare':
                    this.drawSquare(x,y,ctx, true, options);
                    break;
                case 'x':
                    this.drawX(x,y,ctx, true, options);
                    break;
                case 'plus':
                    this.drawPlus(x,y,ctx, true, options);
                    break;
                case 'dash':
                    this.drawDash(x,y,ctx, true, options);
                    break;
                case 'line':
                    this.drawLine(x, y, ctx, false, options);
                    break;
                default:
                    this.drawDiamond(x,y,ctx, false, options);
                    break;
            }
        }
    };
    
    // class: $.jqplot.shadowRenderer
    // The default jqPlot shadow renderer, rendering shadows behind shapes.
    $.jqplot.ShadowRenderer = function(options){ 
        // Group: Properties
        
        // prop: angle
        // Angle of the shadow in degrees.  Measured counter-clockwise from the x axis.
        this.angle = 45;
        // prop: offset
        // Pixel offset at the given shadow angle of each shadow stroke from the last stroke.
        this.offset = 1;
        // prop: alpha
        // alpha transparency of shadow stroke.
        this.alpha = 0.07;
        // prop: lineWidth
        // width of the shadow line stroke.
        this.lineWidth = 1.5;
        // prop: lineJoin
        // How line segments of the shadow are joined.
        this.lineJoin = 'miter';
        // prop: lineCap
        // how ends of the shadow line are rendered.
        this.lineCap = 'round';
        // prop; closePath
        // whether line path segment is closed upon itself.
        this.closePath = false;
        // prop: fill
        // whether to fill the shape.
        this.fill = false;
        // prop: depth
        // how many times the shadow is stroked.  Each stroke will be offset by offset at angle degrees.
        this.depth = 3;
        this.strokeStyle = 'rgba(0,0,0,0.1)';
        // prop: isarc
        // whether the shadow is an arc or not.
        this.isarc = false;
        
        $.extend(true, this, options);
    };
    
    $.jqplot.ShadowRenderer.prototype.init = function(options) {
        $.extend(true, this, options);
    };
    
    // function: draw
    // draws an transparent black (i.e. gray) shadow.
    //
    // ctx - canvas drawing context
    // points - array of points or [x, y, radius, start angle (rad), end angle (rad)]
    $.jqplot.ShadowRenderer.prototype.draw = function(ctx, points, options) {
        ctx.save();
        var opts = (options != null) ? options : {};
        var fill = (opts.fill != null) ? opts.fill : this.fill;
        var fillRect = (opts.fillRect != null) ? opts.fillRect : this.fillRect;
        var closePath = (opts.closePath != null) ? opts.closePath : this.closePath;
        var offset = (opts.offset != null) ? opts.offset : this.offset;
        var alpha = (opts.alpha != null) ? opts.alpha : this.alpha;
        var depth = (opts.depth != null) ? opts.depth : this.depth;
        var isarc = (opts.isarc != null) ? opts.isarc : this.isarc;
        var linePattern = (opts.linePattern != null) ? opts.linePattern : this.linePattern;
        ctx.lineWidth = (opts.lineWidth != null) ? opts.lineWidth : this.lineWidth;
        ctx.lineJoin = (opts.lineJoin != null) ? opts.lineJoin : this.lineJoin;
        ctx.lineCap = (opts.lineCap != null) ? opts.lineCap : this.lineCap;
        ctx.strokeStyle = opts.strokeStyle || this.strokeStyle || 'rgba(0,0,0,'+alpha+')';
        ctx.fillStyle = opts.fillStyle || this.fillStyle || 'rgba(0,0,0,'+alpha+')';
        for (var j=0; j<depth; j++) {
            var ctxPattern = $.jqplot.LinePattern(ctx, linePattern);
            ctx.translate(Math.cos(this.angle*Math.PI/180)*offset, Math.sin(this.angle*Math.PI/180)*offset);
            ctxPattern.beginPath();
            if (isarc) {
                ctx.arc(points[0], points[1], points[2], points[3], points[4], true);                
            }
            else if (fillRect) {
                if (fillRect) {
                    ctx.fillRect(points[0], points[1], points[2], points[3]);
                }
            }
            else if (points && points.length){
                var move = true;
                for (var i=0; i<points.length; i++) {
                    // skip to the first non-null point and move to it.
                    if (points[i][0] != null && points[i][1] != null) {
                        if (move) {
                            ctxPattern.moveTo(points[i][0], points[i][1]);
                            move = false;
                        }
                        else {
                            ctxPattern.lineTo(points[i][0], points[i][1]);
                        }
                    }
                    else {
                        move = true;
                    }
                }
                
            }
            if (closePath) {
                ctxPattern.closePath();
            }
            if (fill) {
                ctx.fill();
            }
            else {
                ctx.stroke();
            }
        }
        ctx.restore();
    };
    
    // class: $.jqplot.shapeRenderer
    // The default jqPlot shape renderer.  Given a set of points will
    // plot them and either stroke a line (fill = false) or fill them (fill = true).
    // If a filled shape is desired, closePath = true must also be set to close
    // the shape.
    $.jqplot.ShapeRenderer = function(options){
        
        this.lineWidth = 1.5;
        // prop: linePattern
        // line pattern 'dashed', 'dotted', 'solid', some combination
        // of '-' and '.' characters such as '.-.' or a numerical array like 
        // [draw, skip, draw, skip, ...] such as [1, 10] to draw a dotted line, 
        // [1, 10, 20, 10] to draw a dot-dash line, and so on.
        this.linePattern = 'solid';
        // prop: lineJoin
        // How line segments of the shadow are joined.
        this.lineJoin = 'miter';
        // prop: lineCap
        // how ends of the shadow line are rendered.
        this.lineCap = 'round';
        // prop; closePath
        // whether line path segment is closed upon itself.
        this.closePath = false;
        // prop: fill
        // whether to fill the shape.
        this.fill = false;
        // prop: isarc
        // whether the shadow is an arc or not.
        this.isarc = false;
        // prop: fillRect
        // true to draw shape as a filled rectangle.
        this.fillRect = false;
        // prop: strokeRect
        // true to draw shape as a stroked rectangle.
        this.strokeRect = false;
        // prop: clearRect
        // true to cear a rectangle.
        this.clearRect = false;
        // prop: strokeStyle
        // css color spec for the stoke style
        this.strokeStyle = '#999999';
        // prop: fillStyle
        // css color spec for the fill style.
        this.fillStyle = '#999999'; 
        
        $.extend(true, this, options);
    };
    
    $.jqplot.ShapeRenderer.prototype.init = function(options) {
        $.extend(true, this, options);
    };
    
    // function: draw
    // draws the shape.
    //
    // ctx - canvas drawing context
    // points - array of points for shapes or 
    // [x, y, width, height] for rectangles or
    // [x, y, radius, start angle (rad), end angle (rad)] for circles and arcs.
    $.jqplot.ShapeRenderer.prototype.draw = function(ctx, points, options) {
        ctx.save();
        var opts = (options != null) ? options : {};
        var fill = (opts.fill != null) ? opts.fill : this.fill;
        var closePath = (opts.closePath != null) ? opts.closePath : this.closePath;
        var fillRect = (opts.fillRect != null) ? opts.fillRect : this.fillRect;
        var strokeRect = (opts.strokeRect != null) ? opts.strokeRect : this.strokeRect;
        var clearRect = (opts.clearRect != null) ? opts.clearRect : this.clearRect;
        var isarc = (opts.isarc != null) ? opts.isarc : this.isarc;
        var linePattern = (opts.linePattern != null) ? opts.linePattern : this.linePattern;
        var ctxPattern = $.jqplot.LinePattern(ctx, linePattern);
        ctx.lineWidth = opts.lineWidth || this.lineWidth;
        ctx.lineJoin = opts.lineJoin || this.lineJoin;
        ctx.lineCap = opts.lineCap || this.lineCap;
        ctx.strokeStyle = (opts.strokeStyle || opts.color) || this.strokeStyle;
        ctx.fillStyle = opts.fillStyle || this.fillStyle;
        ctx.beginPath();
        if (isarc) {
            ctx.arc(points[0], points[1], points[2], points[3], points[4], true);   
            if (closePath) {
                ctx.closePath();
            }
            if (fill) {
                ctx.fill();
            }
            else {
                ctx.stroke();
            }
            ctx.restore();
            return;
        }
        else if (clearRect) {
            ctx.clearRect(points[0], points[1], points[2], points[3]);
            ctx.restore();
            return;
        }
        else if (fillRect || strokeRect) {
            if (fillRect) {
                ctx.fillRect(points[0], points[1], points[2], points[3]);
            }
            if (strokeRect) {
                ctx.strokeRect(points[0], points[1], points[2], points[3]);
                ctx.restore();
                return;
            }
        }
        else if (points && points.length){
            var move = true;
            for (var i=0; i<points.length; i++) {
                // skip to the first non-null point and move to it.
                if (points[i][0] != null && points[i][1] != null) {
                    if (move) {
                        ctxPattern.moveTo(points[i][0], points[i][1]);
                        move = false;
                    }
                    else {
                        ctxPattern.lineTo(points[i][0], points[i][1]);
                    }
                }
                else {
                    move = true;
                }
            }
            if (closePath) {
                ctxPattern.closePath();
            }
            if (fill) {
                ctx.fill();
            }
            else {
                ctx.stroke();
            }
        }
        ctx.restore();
    };
    
    // class $.jqplot.TableLegendRenderer
    // The default legend renderer for jqPlot.
    $.jqplot.TableLegendRenderer = function(){
        //
    };
    
    $.jqplot.TableLegendRenderer.prototype.init = function(options) {
        $.extend(true, this, options);
    };
        
    $.jqplot.TableLegendRenderer.prototype.addrow = function (label, color, pad, reverse) {
        var rs = (pad) ? this.rowSpacing+'px' : '0px';
        var tr;
        var td;
        var elem;
        var div0;
        var div1;
        elem = document.createElement('tr');
        tr = $(elem);
        tr.addClass('jqplot-table-legend');
        elem = null;

        if (reverse){
            tr.prependTo(this._elem);
        }

        else{
            tr.appendTo(this._elem);
        }

        if (this.showSwatches) {
            td = $(document.createElement('td'));
            td.addClass('jqplot-table-legend jqplot-table-legend-swatch');
            td.css({textAlign: 'center', paddingTop: rs});

            div0 = $(document.createElement('div'));
            div0.addClass('jqplot-table-legend-swatch-outline');
            div1 = $(document.createElement('div'));
            div1.addClass('jqplot-table-legend-swatch');
            div1.css({backgroundColor: color, borderColor: color});

            tr.append(td.append(div0.append(div1)));

            // $('<td class="jqplot-table-legend" style="text-align:center;padding-top:'+rs+';">'+
            // '<div><div class="jqplot-table-legend-swatch" style="background-color:'+color+';border-color:'+color+';"></div>'+
            // '</div></td>').appendTo(tr);
        }
        if (this.showLabels) {
            td = $(document.createElement('td'));
            td.addClass('jqplot-table-legend jqplot-table-legend-label');
            td.css('paddingTop', rs);
            tr.append(td);

            // elem = $('<td class="jqplot-table-legend" style="padding-top:'+rs+';"></td>');
            // elem.appendTo(tr);
            if (this.escapeHtml) {
                td.text(label);
            }
            else {
                td.html(label);
            }
        }
        td = null;
        div0 = null;
        div1 = null;
        tr = null;
        elem = null;
    };
    
    // called with scope of legend
    $.jqplot.TableLegendRenderer.prototype.draw = function() {
        if (this._elem) {
            this._elem.emptyForce();
            this._elem = null;
        }

        if (this.show) {
            var series = this._series;
            // make a table.  one line label per row.
            var elem = document.createElement('table');
            this._elem = $(elem);
            this._elem.addClass('jqplot-table-legend');

            var ss = {position:'absolute'};
            if (this.background) {
                ss['background'] = this.background;
            }
            if (this.border) {
                ss['border'] = this.border;
            }
            if (this.fontSize) {
                ss['fontSize'] = this.fontSize;
            }
            if (this.fontFamily) {
                ss['fontFamily'] = this.fontFamily;
            }
            if (this.textColor) {
                ss['textColor'] = this.textColor;
            }
            if (this.marginTop != null) {
                ss['marginTop'] = this.marginTop;
            }
            if (this.marginBottom != null) {
                ss['marginBottom'] = this.marginBottom;
            }
            if (this.marginLeft != null) {
                ss['marginLeft'] = this.marginLeft;
            }
            if (this.marginRight != null) {
                ss['marginRight'] = this.marginRight;
            }
            
        
            var pad = false, 
                reverse = false,
                s;
            for (var i = 0; i< series.length; i++) {
                s = series[i];
                if (s._stack || s.renderer.constructor == $.jqplot.BezierCurveRenderer){
                    reverse = true;
                }
                if (s.show && s.showLabel) {
                    var lt = this.labels[i] || s.label.toString();
                    if (lt) {
                        var color = s.color;
                        if (reverse && i < series.length - 1){
                            pad = true;
                        }
                        else if (reverse && i == series.length - 1){
                            pad = false;
                        }
                        this.renderer.addrow.call(this, lt, color, pad, reverse);
                        pad = true;
                    }
                    // let plugins add more rows to legend.  Used by trend line plugin.
                    for (var j=0; j<$.jqplot.addLegendRowHooks.length; j++) {
                        var item = $.jqplot.addLegendRowHooks[j].call(this, s);
                        if (item) {
                            this.renderer.addrow.call(this, item.label, item.color, pad);
                            pad = true;
                        } 
                    }
                    lt = null;
                }
            }
        }
        return this._elem;
    };
    
    $.jqplot.TableLegendRenderer.prototype.pack = function(offsets) {
        if (this.show) {       
            if (this.placement == 'insideGrid') {
                switch (this.location) {
                    case 'nw':
                        var a = offsets.left;
                        var b = offsets.top;
                        this._elem.css('left', a);
                        this._elem.css('top', b);
                        break;
                    case 'n':
                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;
                        var b = offsets.top;
                        this._elem.css('left', a);
                        this._elem.css('top', b);
                        break;
                    case 'ne':
                        var a = offsets.right;
                        var b = offsets.top;
                        this._elem.css({right:a, top:b});
                        break;
                    case 'e':
                        var a = offsets.right;
                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;
                        this._elem.css({right:a, top:b});
                        break;
                    case 'se':
                        var a = offsets.right;
                        var b = offsets.bottom;
                        this._elem.css({right:a, bottom:b});
                        break;
                    case 's':
                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;
                        var b = offsets.bottom;
                        this._elem.css({left:a, bottom:b});
                        break;
                    case 'sw':
                        var a = offsets.left;
                        var b = offsets.bottom;
                        this._elem.css({left:a, bottom:b});
                        break;
                    case 'w':
                        var a = offsets.left;
                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;
                        this._elem.css({left:a, top:b});
                        break;
                    default:  // same as 'se'
                        var a = offsets.right;
                        var b = offsets.bottom;
                        this._elem.css({right:a, bottom:b});
                        break;
                }
                
            }
            else if (this.placement == 'outside'){
                switch (this.location) {
                    case 'nw':
                        var a = this._plotDimensions.width - offsets.left;
                        var b = offsets.top;
                        this._elem.css('right', a);
                        this._elem.css('top', b);
                        break;
                    case 'n':
                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;
                        var b = this._plotDimensions.height - offsets.top;
                        this._elem.css('left', a);
                        this._elem.css('bottom', b);
                        break;
                    case 'ne':
                        var a = this._plotDimensions.width - offsets.right;
                        var b = offsets.top;
                        this._elem.css({left:a, top:b});
                        break;
                    case 'e':
                        var a = this._plotDimensions.width - offsets.right;
                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;
                        this._elem.css({left:a, top:b});
                        break;
                    case 'se':
                        var a = this._plotDimensions.width - offsets.right;
                        var b = offsets.bottom;
                        this._elem.css({left:a, bottom:b});
                        break;
                    case 's':
                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;
                        var b = this._plotDimensions.height - offsets.bottom;
                        this._elem.css({left:a, top:b});
                        break;
                    case 'sw':
                        var a = this._plotDimensions.width - offsets.left;
                        var b = offsets.bottom;
                        this._elem.css({right:a, bottom:b});
                        break;
                    case 'w':
                        var a = this._plotDimensions.width - offsets.left;
                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;
                        this._elem.css({right:a, top:b});
                        break;
                    default:  // same as 'se'
                        var a = offsets.right;
                        var b = offsets.bottom;
                        this._elem.css({right:a, bottom:b});
                        break;
                }
            }
            else {
                switch (this.location) {
                    case 'nw':
                        this._elem.css({left:0, top:offsets.top});
                        break;
                    case 'n':
                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;
                        this._elem.css({left: a, top:offsets.top});
                        break;
                    case 'ne':
                        this._elem.css({right:0, top:offsets.top});
                        break;
                    case 'e':
                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;
                        this._elem.css({right:offsets.right, top:b});
                        break;
                    case 'se':
                        this._elem.css({right:offsets.right, bottom:offsets.bottom});
                        break;
                    case 's':
                        var a = (offsets.left + (this._plotDimensions.width - offsets.right))/2 - this.getWidth()/2;
                        this._elem.css({left: a, bottom:offsets.bottom});
                        break;
                    case 'sw':
                        this._elem.css({left:offsets.left, bottom:offsets.bottom});
                        break;
                    case 'w':
                        var b = (offsets.top + (this._plotDimensions.height - offsets.bottom))/2 - this.getHeight()/2;
                        this._elem.css({left:offsets.left, top:b});
                        break;
                    default:  // same as 'se'
                        this._elem.css({right:offsets.right, bottom:offsets.bottom});
                        break;
                }
            }
        } 
    };

    /**
     * Class: $.jqplot.ThemeEngine
     * Theme Engine provides a programatic way to change some of the  more
     * common jqplot styling options such as fonts, colors and grid options.
     * A theme engine instance is created with each plot.  The theme engine
     * manages a collection of themes which can be modified, added to, or 
     * applied to the plot.
     * 
     * The themeEngine class is not instantiated directly.
     * When a plot is initialized, the current plot options are scanned
     * an a default theme named "Default" is created.  This theme is
     * used as the basis for other themes added to the theme engine and
     * is always available.
     * 
     * A theme is a simple javascript object with styling parameters for
     * various entities of the plot.  A theme has the form:
     * 
     * 
     * > {
     * >     _name:f "Default",
     * >     target: {
     * >         backgroundColor: "transparent"
     * >     },
     * >     legend: {
     * >         textColor: null,
     * >         fontFamily: null,
     * >         fontSize: null,
     * >         border: null,
     * >         background: null
     * >     },
     * >     title: {
     * >         textColor: "rgb(102, 102, 102)",
     * >         fontFamily: "'Trebuchet MS',Arial,Helvetica,sans-serif",
     * >         fontSize: "19.2px",
     * >         textAlign: "center"
     * >     },
     * >     seriesStyles: {},
     * >     series: [{
     * >         color: "#4bb2c5",
     * >         lineWidth: 2.5,
     * >         linePattern: "solid",
     * >         shadow: true,
     * >         fillColor: "#4bb2c5",
     * >         showMarker: true,
     * >         markerOptions: {
     * >             color: "#4bb2c5",
     * >             show: true,
     * >             style: 'filledCircle',
     * >             lineWidth: 1.5,
     * >             size: 4,
     * >             shadow: true
     * >         }
     * >     }],
     * >     grid: {
     * >         drawGridlines: true,
     * >         gridLineColor: "#cccccc",
     * >         gridLineWidth: 1,
     * >         backgroundColor: "#fffdf6",
     * >         borderColor: "#999999",
     * >         borderWidth: 2,
     * >         shadow: true
     * >     },
     * >     axesStyles: {
     * >         label: {},
     * >         ticks: {}
     * >     },
     * >     axes: {
     * >         xaxis: {
     * >             borderColor: "#999999",
     * >             borderWidth: 2,
     * >             ticks: {
     * >                 show: true,
     * >                 showGridline: true,
     * >                 showLabel: true,
     * >                 showMark: true,
     * >                 size: 4,
     * >                 textColor: "",
     * >                 whiteSpace: "nowrap",
     * >                 fontSize: "12px",
     * >                 fontFamily: "'Trebuchet MS',Arial,Helvetica,sans-serif"
     * >             },
     * >             label: {
     * >                 textColor: "rgb(102, 102, 102)",
     * >                 whiteSpace: "normal",
     * >                 fontSize: "14.6667px",
     * >                 fontFamily: "'Trebuchet MS',Arial,Helvetica,sans-serif",
     * >                 fontWeight: "400"
     * >             }
     * >         },
     * >         yaxis: {
     * >             borderColor: "#999999",
     * >             borderWidth: 2,
     * >             ticks: {
     * >                 show: true,
     * >                 showGridline: true,
     * >                 showLabel: true,
     * >                 showMark: true,
     * >                 size: 4,
     * >                 textColor: "",
     * >                 whiteSpace: "nowrap",
     * >                 fontSize: "12px",
     * >                 fontFamily: "'Trebuchet MS',Arial,Helvetica,sans-serif"
     * >             },
     * >             label: {
     * >                 textColor: null,
     * >                 whiteSpace: null,
     * >                 fontSize: null,
     * >                 fontFamily: null,
     * >                 fontWeight: null
     * >             }
     * >         },
     * >         x2axis: {...
     * >         },
     * >         ...
     * >         y9axis: {...
     * >         }
     * >     }
     * > }
     * 
     * "seriesStyles" is a style object that will be applied to all series in the plot.
     * It will forcibly override any styles applied on the individual series.  "axesStyles" is
     * a style object that will be applied to all axes in the plot.  It will also forcibly
     * override any styles on the individual axes.
     * 
     * The example shown above has series options for a line series.  Options for other
     * series types are shown below:
     * 
     * Bar Series:
     * 
     * > {
     * >     color: "#4bb2c5",
     * >     seriesColors: ["#4bb2c5", "#EAA228", "#c5b47f", "#579575", "#839557", "#958c12", "#953579", "#4b5de4", "#d8b83f", "#ff5800", "#0085cc", "#c747a3", "#cddf54", "#FBD178", "#26B4E3", "#bd70c7"],
     * >     lineWidth: 2.5,
     * >     shadow: true,
     * >     barPadding: 2,
     * >     barMargin: 10,
     * >     barWidth: 15.09375,
     * >     highlightColors: ["rgb(129,201,214)", "rgb(129,201,214)", "rgb(129,201,214)", "rgb(129,201,214)", "rgb(129,201,214)", "rgb(129,201,214)", "rgb(129,201,214)", "rgb(129,201,214)"]
     * > }
     * 
     * Pie Series:
     * 
     * > {
     * >     seriesColors: ["#4bb2c5", "#EAA228", "#c5b47f", "#579575", "#839557", "#958c12", "#953579", "#4b5de4", "#d8b83f", "#ff5800", "#0085cc", "#c747a3", "#cddf54", "#FBD178", "#26B4E3", "#bd70c7"],
     * >     padding: 20,
     * >     sliceMargin: 0,
     * >     fill: true,
     * >     shadow: true,
     * >     startAngle: 0,
     * >     lineWidth: 2.5,
     * >     highlightColors: ["rgb(129,201,214)", "rgb(240,189,104)", "rgb(214,202,165)", "rgb(137,180,158)", "rgb(168,180,137)", "rgb(180,174,89)", "rgb(180,113,161)", "rgb(129,141,236)", "rgb(227,205,120)", "rgb(255,138,76)", "rgb(76,169,219)", "rgb(215,126,190)", "rgb(220,232,135)", "rgb(200,167,96)", "rgb(103,202,235)", "rgb(208,154,215)"]
     * > }
     * 
     * Funnel Series:
     * 
     * > {
     * >     color: "#4bb2c5",
     * >     lineWidth: 2,
     * >     shadow: true,
     * >     padding: {
     * >         top: 20,
     * >         right: 20,
     * >         bottom: 20,
     * >         left: 20
     * >     },
     * >     sectionMargin: 6,
     * >     seriesColors: ["#4bb2c5", "#EAA228", "#c5b47f", "#579575", "#839557", "#958c12", "#953579", "#4b5de4", "#d8b83f", "#ff5800", "#0085cc", "#c747a3", "#cddf54", "#FBD178", "#26B4E3", "#bd70c7"],
     * >     highlightColors: ["rgb(147,208,220)", "rgb(242,199,126)", "rgb(220,210,178)", "rgb(154,191,172)", "rgb(180,191,154)", "rgb(191,186,112)", "rgb(191,133,174)", "rgb(147,157,238)", "rgb(231,212,139)", "rgb(255,154,102)", "rgb(102,181,224)", "rgb(221,144,199)", "rgb(225,235,152)", "rgb(200,167,96)", "rgb(124,210,238)", "rgb(215,169,221)"]
     * > }
     * 
     */
    $.jqplot.ThemeEngine = function(){
        // Group: Properties
        //
        // prop: themes
        // hash of themes managed by the theme engine.  
        // Indexed by theme name.
        this.themes = {};
        // prop: activeTheme
        // Pointer to currently active theme
        this.activeTheme=null;
        
    };
    
    // called with scope of plot
    $.jqplot.ThemeEngine.prototype.init = function() {
        // get the Default theme from the current plot settings.
        var th = new $.jqplot.Theme({_name:'Default'});
        var n, i, nn;
        
        for (n in th.target) {
            if (n == "textColor") {
                th.target[n] = this.target.css('color');
            }
            else {
                th.target[n] = this.target.css(n);
            }
        }
        
        if (this.title.show && this.title._elem) {
            for (n in th.title) {
                if (n == "textColor") {
                    th.title[n] = this.title._elem.css('color');
                }
                else {
                    th.title[n] = this.title._elem.css(n);
                }
            }
        }
        
        for (n in th.grid) {
            th.grid[n] = this.grid[n];
        }
        if (th.grid.backgroundColor == null && this.grid.background != null) {
            th.grid.backgroundColor = this.grid.background;
        }
        if (this.legend.show && this.legend._elem) {
            for (n in th.legend) {
                if (n == 'textColor') {
                    th.legend[n] = this.legend._elem.css('color');
                }
                else {
                    th.legend[n] = this.legend._elem.css(n);
                }
            }
        }
        var s;
        
        for (i=0; i<this.series.length; i++) {
            s = this.series[i];
            if (s.renderer.constructor == $.jqplot.LineRenderer) {
                th.series.push(new LineSeriesProperties());
            }
            else if (s.renderer.constructor == $.jqplot.BarRenderer) {
                th.series.push(new BarSeriesProperties());
            }
            else if (s.renderer.constructor == $.jqplot.PieRenderer) {
                th.series.push(new PieSeriesProperties());
            }
            else if (s.renderer.constructor == $.jqplot.DonutRenderer) {
                th.series.push(new DonutSeriesProperties());
            }
            else if (s.renderer.constructor == $.jqplot.FunnelRenderer) {
                th.series.push(new FunnelSeriesProperties());
            }
            else if (s.renderer.constructor == $.jqplot.MeterGaugeRenderer) {
                th.series.push(new MeterSeriesProperties());
            }
            else {
                th.series.push({});
            }
            for (n in th.series[i]) {
                th.series[i][n] = s[n];
            }
        }
        var a, ax;
        for (n in this.axes) {
            ax = this.axes[n];
            a = th.axes[n] = new AxisProperties();
            a.borderColor = ax.borderColor;
            a.borderWidth = ax.borderWidth;
            if (ax._ticks && ax._ticks[0]) {
                for (nn in a.ticks) {
                    if (ax._ticks[0].hasOwnProperty(nn)) {
                        a.ticks[nn] = ax._ticks[0][nn];
                    }
                    else if (ax._ticks[0]._elem){
                        a.ticks[nn] = ax._ticks[0]._elem.css(nn);
                    }
                }
            }
            if (ax._label && ax._label.show) {
                for (nn in a.label) {
                    // a.label[nn] = ax._label._elem.css(nn);
                    if (ax._label[nn]) {
                        a.label[nn] = ax._label[nn];
                    }
                    else if (ax._label._elem){
                        if (nn == 'textColor') {
                            a.label[nn] = ax._label._elem.css('color');
                        }
                        else {
                            a.label[nn] = ax._label._elem.css(nn);
                        }
                    }
                }
            }
        }
        this.themeEngine._add(th);
        this.themeEngine.activeTheme  = this.themeEngine.themes[th._name];
    };
    /**
     * Group: methods
     * 
     * method: get
     * 
     * Get and return the named theme or the active theme if no name given.
     * 
     * parameter:
     * 
     * name - name of theme to get.
     * 
     * returns:
     * 
     * Theme instance of given name.
     */   
    $.jqplot.ThemeEngine.prototype.get = function(name) {
        if (!name) {
            // return the active theme
            return this.activeTheme;
        }
        else {
            return this.themes[name];
        }
    };
    
    function numericalOrder(a,b) { return a-b; }
    
    /**
     * method: getThemeNames
     * 
     * Return the list of theme names in this manager in alpha-numerical order.
     * 
     * parameter:
     * 
     * None
     * 
     * returns:
     * 
     * A the list of theme names in this manager in alpha-numerical order.
     */       
    $.jqplot.ThemeEngine.prototype.getThemeNames = function() {
        var tn = [];
        for (var n in this.themes) {
            tn.push(n);
        }
        return tn.sort(numericalOrder);
    };

    /**
     * method: getThemes
     * 
     * Return a list of themes in alpha-numerical order by name.
     * 
     * parameter:
     * 
     * None
     * 
     * returns:
     * 
     * A list of themes in alpha-numerical order by name.
     */ 
    $.jqplot.ThemeEngine.prototype.getThemes = function() {
        var tn = [];
        var themes = [];
        for (var n in this.themes) {
            tn.push(n);
        }
        tn.sort(numericalOrder);
        for (var i=0; i<tn.length; i++) {
            themes.push(this.themes[tn[i]]);
        }
        return themes;
    };
    
    $.jqplot.ThemeEngine.prototype.activate = function(plot, name) {
        // sometimes need to redraw whole plot.
        var redrawPlot = false;
        if (!name && this.activeTheme && this.activeTheme._name) {
            name = this.activeTheme._name;
        }
        if (!this.themes.hasOwnProperty(name)) {
            throw new Error("No theme of that name");
        }
        else {
            var th = this.themes[name];
            this.activeTheme = th;
            var val, checkBorderColor = false, checkBorderWidth = false;
            var arr = ['xaxis', 'x2axis', 'yaxis', 'y2axis'];
            
            for (i=0; i<arr.length; i++) {
                var ax = arr[i];
                if (th.axesStyles.borderColor != null) {
                    plot.axes[ax].borderColor = th.axesStyles.borderColor;
                }
                if (th.axesStyles.borderWidth != null) {
                    plot.axes[ax].borderWidth = th.axesStyles.borderWidth;
                }
            }
            
            for (var axname in plot.axes) {
                var axis = plot.axes[axname];
                if (axis.show) {
                    var thaxis = th.axes[axname] || {};
                    var thaxstyle = th.axesStyles;
                    var thax = $.jqplot.extend(true, {}, thaxis, thaxstyle);
                    val = (th.axesStyles.borderColor != null) ? th.axesStyles.borderColor : thax.borderColor;
                    if (thax.borderColor != null) {
                        axis.borderColor = thax.borderColor;
                        redrawPlot = true;
                    }
                    val = (th.axesStyles.borderWidth != null) ? th.axesStyles.borderWidth : thax.borderWidth;
                    if (thax.borderWidth != null) {
                        axis.borderWidth = thax.borderWidth;
                        redrawPlot = true;
                    }
                    if (axis._ticks && axis._ticks[0]) {
                        for (var nn in thax.ticks) {
                            // val = null;
                            // if (th.axesStyles.ticks && th.axesStyles.ticks[nn] != null) {
                            //     val = th.axesStyles.ticks[nn];
                            // }
                            // else if (thax.ticks[nn] != null){
                            //     val = thax.ticks[nn]
                            // }
                            val = thax.ticks[nn];
                            if (val != null) {
                                axis.tickOptions[nn] = val;
                                axis._ticks = [];
                                redrawPlot = true;
                            }
                        }
                    }
                    if (axis._label && axis._label.show) {
                        for (var nn in thax.label) {
                            // val = null;
                            // if (th.axesStyles.label && th.axesStyles.label[nn] != null) {
                            //     val = th.axesStyles.label[nn];
                            // }
                            // else if (thax.label && thax.label[nn] != null){
                            //     val = thax.label[nn]
                            // }
                            val = thax.label[nn];
                            if (val != null) {
                                axis.labelOptions[nn] = val;
                                redrawPlot = true;
                            }
                        }
                    }
                    
                }
            }            
            
            for (var n in th.grid) {
                if (th.grid[n] != null) {
                    plot.grid[n] = th.grid[n];
                }
            }
            if (!redrawPlot) {
                plot.grid.draw();
            }
            
            if (plot.legend.show) { 
                for (n in th.legend) {
                    if (th.legend[n] != null) {
                        plot.legend[n] = th.legend[n];
                    }
                }
            }
            if (plot.title.show) {
                for (n in th.title) {
                    if (th.title[n] != null) {
                        plot.title[n] = th.title[n];
                    }
                }
            }
            
            var i;
            for (i=0; i<th.series.length; i++) {
                var opts = {};
                var redrawSeries = false;
                for (n in th.series[i]) {
                    val = (th.seriesStyles[n] != null) ? th.seriesStyles[n] : th.series[i][n];
                    if (val != null) {
                        opts[n] = val;
                        if (n == 'color') {
                            plot.series[i].renderer.shapeRenderer.fillStyle = val;
                            plot.series[i].renderer.shapeRenderer.strokeStyle = val;
                            plot.series[i][n] = val;
                        }
                        else if ((n == 'lineWidth') || (n == 'linePattern')) {
                            plot.series[i].renderer.shapeRenderer[n] = val;
                            plot.series[i][n] = val;
                        }
                        else if (n == 'markerOptions') {
                            merge (plot.series[i].markerOptions, val);
                            merge (plot.series[i].markerRenderer, val);
                        }
                        else {
                            plot.series[i][n] = val;
                        }
                        redrawPlot = true;
                    }
                }
            }
            
            if (redrawPlot) {
                plot.target.empty();
                plot.draw();
            }
            
            for (n in th.target) {
                if (th.target[n] != null) {
                    plot.target.css(n, th.target[n]);
                }
            }
        }
        
    };
    
    $.jqplot.ThemeEngine.prototype._add = function(theme, name) {
        if (name) {
            theme._name = name;
        }
        if (!theme._name) {
            theme._name = Date.parse(new Date());
        }
        if (!this.themes.hasOwnProperty(theme._name)) {
            this.themes[theme._name] = theme;
        }
        else {
            throw new Error("jqplot.ThemeEngine Error: Theme already in use");
        }
    };
    
    // method remove
    // Delete the named theme, return true on success, false on failure.
    

    /**
     * method: remove
     * 
     * Remove the given theme from the themeEngine.
     * 
     * parameters:
     * 
     * name - name of the theme to remove.
     * 
     * returns:
     * 
     * true on success, false on failure.
     */
    $.jqplot.ThemeEngine.prototype.remove = function(name) {
        if (name == 'Default') {
            return false;
        }
        return delete this.themes[name];
    };

    /**
     * method: newTheme
     * 
     * Create a new theme based on the default theme, adding it the themeEngine.
     * 
     * parameters:
     * 
     * name - name of the new theme.
     * obj - optional object of styles to be applied to this new theme.
     * 
     * returns:
     * 
     * new Theme object.
     */
    $.jqplot.ThemeEngine.prototype.newTheme = function(name, obj) {
        if (typeof(name) == 'object') {
            obj = obj || name;
            name = null;
        }
        if (obj && obj._name) {
            name = obj._name;
        }
        else {
            name = name || Date.parse(new Date());
        }
        // var th = new $.jqplot.Theme(name);
        var th = this.copy(this.themes['Default']._name, name);
        $.jqplot.extend(th, obj);
        return th;
    };
    
    // function clone(obj) {
    //     return eval(obj.toSource());
    // }
    
    function clone(obj){
        if(obj == null || typeof(obj) != 'object'){
            return obj;
        }
    
        var temp = new obj.constructor();
        for(var key in obj){
            temp[key] = clone(obj[key]);
        }   
        return temp;
    }
    
    $.jqplot.clone = clone;
    
    function merge(obj1, obj2) {
        if (obj2 ==  null || typeof(obj2) != 'object') {
            return;
        }
        for (var key in obj2) {
            if (key == 'highlightColors') {
                obj1[key] = clone(obj2[key]);
            }
            if (obj2[key] != null && typeof(obj2[key]) == 'object') {
                if (!obj1.hasOwnProperty(key)) {
                    obj1[key] = {};
                }
                merge(obj1[key], obj2[key]);
            }
            else {
                obj1[key] = obj2[key];
            }
        }
    }
    
    $.jqplot.merge = merge;
    
        // Use the jQuery 1.3.2 extend function since behaviour in jQuery 1.4 seems problematic
    $.jqplot.extend = function() {
        // copy reference to target object
        var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;
            target = arguments[1] || {};
            // skip the boolean and the target
            i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !toString.call(target) === "[object Function]" ) {
            target = {};
        }

        for ( ; i < length; i++ ){
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( var name in options ) {
                    var src = target[ name ], copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging object values
                    if ( deep && copy && typeof copy === "object" && !copy.nodeType ) {
                        target[ name ] = $.jqplot.extend( deep, 
                            // Never move original objects, clone them
                            src || ( copy.length != null ? [ ] : { } )
                        , copy );
                    }
                    // Don't bring in undefined values
                    else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }
        // Return the modified object
        return target;
    };

    /**
     * method: rename
     * 
     * Rename a theme.
     * 
     * parameters:
     * 
     * oldName - current name of the theme.
     * newName - desired name of the theme.
     * 
     * returns:
     * 
     * new Theme object.
     */
    $.jqplot.ThemeEngine.prototype.rename = function (oldName, newName) {
        if (oldName == 'Default' || newName == 'Default') {
            throw new Error ("jqplot.ThemeEngine Error: Cannot rename from/to Default");
        }
        if (this.themes.hasOwnProperty(newName)) {
            throw new Error ("jqplot.ThemeEngine Error: New name already in use.");
        }
        else if (this.themes.hasOwnProperty(oldName)) {
            var th = this.copy (oldName, newName);
            this.remove(oldName);
            return th;
        }
        throw new Error("jqplot.ThemeEngine Error: Old name or new name invalid");
    };

    /**
     * method: copy
     * 
     * Create a copy of an existing theme in the themeEngine, adding it the themeEngine.
     * 
     * parameters:
     * 
     * sourceName - name of the existing theme.
     * targetName - name of the copy.
     * obj - optional object of style parameter to apply to the new theme.
     * 
     * returns:
     * 
     * new Theme object.
     */
    $.jqplot.ThemeEngine.prototype.copy = function (sourceName, targetName, obj) {
        if (targetName == 'Default') {
            throw new Error ("jqplot.ThemeEngine Error: Cannot copy over Default theme");
        }
        if (!this.themes.hasOwnProperty(sourceName)) {
            var s = "jqplot.ThemeEngine Error: Source name invalid";
            throw new Error(s);
        }
        if (this.themes.hasOwnProperty(targetName)) {
            var s = "jqplot.ThemeEngine Error: Target name invalid";
            throw new Error(s);
        }
        else {
            var th = clone(this.themes[sourceName]);
            th._name = targetName;
            $.jqplot.extend(true, th, obj);
            this._add(th);
            return th;
        }
    };
    
    
    $.jqplot.Theme = function(name, obj) {
        if (typeof(name) == 'object') {
            obj = obj || name;
            name = null;
        }
        name = name || Date.parse(new Date());
        this._name = name;
        this.target = {
            backgroundColor: null
        };
        this.legend = {
            textColor: null,
            fontFamily: null,
            fontSize: null,
            border: null,
            background: null
        };
        this.title = {
            textColor: null,
            fontFamily: null,
            fontSize: null,
            textAlign: null
        };
        this.seriesStyles = {};
        this.series = [];
        this.grid = {
            drawGridlines: null,
            gridLineColor: null,
            gridLineWidth: null,
            backgroundColor: null,
            borderColor: null,
            borderWidth: null,
            shadow: null
        };
        this.axesStyles = {label:{}, ticks:{}};
        this.axes = {};
        if (typeof(obj) == 'string') {
            this._name = obj;
        }
        else if(typeof(obj) == 'object') {
            $.jqplot.extend(true, this, obj);
        }
    };
    
    var AxisProperties = function() {
        this.borderColor = null;
        this.borderWidth = null;
        this.ticks = new AxisTicks();
        this.label = new AxisLabel();
    };
    
    var AxisTicks = function() {
        this.show = null;
        this.showGridline = null;
        this.showLabel = null;
        this.showMark = null;
        this.size = null;
        this.textColor = null;
        this.whiteSpace = null;
        this.fontSize = null;
        this.fontFamily = null;
    };
    
    var AxisLabel = function() {
        this.textColor = null;
        this.whiteSpace = null;
        this.fontSize = null;
        this.fontFamily = null;
        this.fontWeight = null;
    };
    
    var LineSeriesProperties = function() {
        this.color=null;
        this.lineWidth=null;
        this.linePattern=null;
        this.shadow=null;
        this.fillColor=null;
        this.showMarker=null;
        this.markerOptions = new MarkerOptions();
    };
    
    var MarkerOptions = function() {
        this.show = null;
        this.style = null;
        this.lineWidth = null;
        this.size = null;
        this.color = null;
        this.shadow = null;
    };
    
    var BarSeriesProperties = function() {
        this.color=null;
        this.seriesColors=null;
        this.lineWidth=null;
        this.shadow=null;
        this.barPadding=null;
        this.barMargin=null;
        this.barWidth=null;
        this.highlightColors=null;
    };
    
    var PieSeriesProperties = function() {
        this.seriesColors=null;
        this.padding=null;
        this.sliceMargin=null;
        this.fill=null;
        this.shadow=null;
        this.startAngle=null;
        this.lineWidth=null;
        this.highlightColors=null;
    };
    
    var DonutSeriesProperties = function() {
        this.seriesColors=null;
        this.padding=null;
        this.sliceMargin=null;
        this.fill=null;
        this.shadow=null;
        this.startAngle=null;
        this.lineWidth=null;
        this.innerDiameter=null;
        this.thickness=null;
        this.ringMargin=null;
        this.highlightColors=null;
    };
    
    var FunnelSeriesProperties = function() {
        this.color=null;
        this.lineWidth=null;
        this.shadow=null;
        this.padding=null;
        this.sectionMargin=null;
        this.seriesColors=null;
        this.highlightColors=null;
    };
    
    var MeterSeriesProperties = function() {
        this.padding=null;
        this.backgroundColor=null;
        this.ringColor=null;
        this.tickColor=null;
        this.ringWidth=null;
        this.intervalColors=null;
        this.intervalInnerRadius=null;
        this.intervalOuterRadius=null;
        this.hubRadius=null;
        this.needleThickness=null;
        this.needlePad=null;
    };
        



    $.fn.jqplotChildText = function() {
        return $(this).contents().filter(function() {
            return this.nodeType == 3;  // Node.TEXT_NODE not defined in I7
        }).text();
    };

    // Returns font style as abbreviation for "font" property.
    $.fn.jqplotGetComputedFontStyle = function() {
        var css = window.getComputedStyle ?  window.getComputedStyle(this[0], "") : this[0].currentStyle;
        var attrs = css['font-style'] ? ['font-style', 'font-weight', 'font-size', 'font-family'] : ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily'];
        var style = [];

        for (var i=0 ; i < attrs.length; ++i) {
            var attr = String(css[attrs[i]]);

            if (attr && attr != 'normal') {
                style.push(attr);
            }
        }
        return style.join(' ');
    };

    /**
     * Namespace: $.fn
     * jQuery namespace to attach functions to jQuery elements.
     *  
     */

    $.fn.jqplotToImageCanvas = function(options) {

        options = options || {};
        var x_offset = (options.x_offset == null) ? 0 : options.x_offset;
        var y_offset = (options.y_offset == null) ? 0 : options.y_offset;
        var backgroundColor = (options.backgroundColor == null) ? 'rgb(255,255,255)' : options.backgroundColor;

        if ($(this).width() == 0 || $(this).height() == 0) {
            return null;
        }

        // excanvas and hence IE < 9 do not support toDataURL and cannot export images.
        if ($.jqplot.use_excanvas) {
            return null;
        }
        
        var newCanvas = document.createElement("canvas");
        var h = $(this).outerHeight(true);
        var w = $(this).outerWidth(true);
        var offs = $(this).offset();
        var plotleft = offs.left;
        var plottop = offs.top;
        var transx = 0, transy = 0;

        // have to check if any elements are hanging outside of plot area before rendering,
        // since changing width of canvas will erase canvas.

        var clses = ['jqplot-table-legend', 'jqplot-xaxis-tick', 'jqplot-x2axis-tick', 'jqplot-yaxis-tick', 'jqplot-y2axis-tick', 'jqplot-y3axis-tick', 
        'jqplot-y4axis-tick', 'jqplot-y5axis-tick', 'jqplot-y6axis-tick', 'jqplot-y7axis-tick', 'jqplot-y8axis-tick', 'jqplot-y9axis-tick',
        'jqplot-xaxis-label', 'jqplot-x2axis-label', 'jqplot-yaxis-label', 'jqplot-y2axis-label', 'jqplot-y3axis-label', 'jqplot-y4axis-label', 
        'jqplot-y5axis-label', 'jqplot-y6axis-label', 'jqplot-y7axis-label', 'jqplot-y8axis-label', 'jqplot-y9axis-label' ];

        var temptop, templeft, tempbottom, tempright;

        for (var i = 0; i < clses.length; i++) {
            $(this).find('.'+clses[i]).each(function() {
                temptop = $(this).offset().top - plottop;
                templeft = $(this).offset().left - plotleft;
                tempright = templeft + $(this).outerWidth(true) + transx;
                tempbottom = temptop + $(this).outerHeight(true) + transy;
                if (templeft < -transx) {
                    w = w - transx - templeft;
                    transx = -templeft;
                }
                if (temptop < -transy) {
                    h = h - transy - temptop;
                    transy = - temptop;
                }
                if (tempright > w) {
                    w = tempright;
                }
                if (tempbottom > h) {
                    h =  tempbottom;
                }
            });
        }

        newCanvas.width = w + Number(x_offset);
        newCanvas.height = h + Number(y_offset);

        var newContext = newCanvas.getContext("2d"); 

        newContext.save();
        newContext.fillStyle = backgroundColor;
        newContext.fillRect(0,0, newCanvas.width, newCanvas.height);
        newContext.restore();

        newContext.translate(transx, transy);
        newContext.textAlign = 'left';
        newContext.textBaseline = 'top';

        function getLineheight(el) {
            var lineheight = parseInt($(el).css('line-height'), 10);

            if (isNaN(lineheight)) {
                lineheight = parseInt($(el).css('font-size'), 10) * 1.2;
            }
            return lineheight;
        }

        function writeWrappedText (el, context, text, left, top, canvasWidth) {
            var lineheight = getLineheight(el);
            var tagwidth = $(el).innerWidth();
            var tagheight = $(el).innerHeight();
            var words = text.split(/\s+/);
            var wl = words.length;
            var w = '';
            var breaks = [];
            var temptop = top;
            var templeft = left;

            for (var i=0; i<wl; i++) {
                w += words[i];
                if (context.measureText(w).width > tagwidth) {
                    breaks.push(i);
                    w = '';
                    i--;
                }   
            }
            if (breaks.length === 0) {
                // center text if necessary
                if ($(el).css('textAlign') === 'center') {
                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;
                }
                context.fillText(text, templeft, top);
            }
            else {
                w = words.slice(0, breaks[0]).join(' ');
                // center text if necessary
                if ($(el).css('textAlign') === 'center') {
                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;
                }
                context.fillText(w, templeft, temptop);
                temptop += lineheight;
                for (var i=1, l=breaks.length; i<l; i++) {
                    w = words.slice(breaks[i-1], breaks[i]).join(' ');
                    // center text if necessary
                    if ($(el).css('textAlign') === 'center') {
                        templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;
                    }
                    context.fillText(w, templeft, temptop);
                    temptop += lineheight;
                }
                w = words.slice(breaks[i-1], words.length).join(' ');
                // center text if necessary
                if ($(el).css('textAlign') === 'center') {
                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;
                }
                context.fillText(w, templeft, temptop);
            }

        }

        function _jqpToImage(el, x_offset, y_offset) {
            var tagname = el.tagName.toLowerCase();
            var p = $(el).position();
            var css = window.getComputedStyle ?  window.getComputedStyle(el, "") : el.currentStyle; // for IE < 9
            var left = x_offset + p.left + parseInt(css.marginLeft, 10) + parseInt(css.borderLeftWidth, 10) + parseInt(css.paddingLeft, 10);
            var top = y_offset + p.top + parseInt(css.marginTop, 10) + parseInt(css.borderTopWidth, 10)+ parseInt(css.paddingTop, 10);
            var w = newCanvas.width;
            // var left = x_offset + p.left + $(el).css('marginLeft') + $(el).css('borderLeftWidth') 

            // somehow in here, for divs within divs, the width of the inner div should be used instead of the canvas.

            if ((tagname == 'div' || tagname == 'span') && !$(el).hasClass('jqplot-highlighter-tooltip')) {
                $(el).children().each(function() {
                    _jqpToImage(this, left, top);
                });
                var text = $(el).jqplotChildText();

                if (text) {
                    newContext.font = $(el).jqplotGetComputedFontStyle();
                    newContext.fillStyle = $(el).css('color');

                    writeWrappedText(el, newContext, text, left, top, w);
                }
            }

            // handle the standard table legend

            else if (tagname === 'table' && $(el).hasClass('jqplot-table-legend')) {
                newContext.strokeStyle = $(el).css('border-top-color');
                newContext.fillStyle = $(el).css('background-color');
                newContext.fillRect(left, top, $(el).innerWidth(), $(el).innerHeight());
                if (parseInt($(el).css('border-top-width'), 10) > 0) {
                    newContext.strokeRect(left, top, $(el).innerWidth(), $(el).innerHeight());
                }

                // find all the swatches
                $(el).find('div.jqplot-table-legend-swatch-outline').each(function() {
                    // get the first div and stroke it
                    var elem = $(this);
                    newContext.strokeStyle = elem.css('border-top-color');
                    var l = left + elem.position().left;
                    var t = top + elem.position().top;
                    newContext.strokeRect(l, t, elem.innerWidth(), elem.innerHeight());

                    // now fill the swatch
                    
                    l += parseInt(elem.css('padding-left'), 10);
                    t += parseInt(elem.css('padding-top'), 10);
                    var h = elem.innerHeight() - 2 * parseInt(elem.css('padding-top'), 10);
                    var w = elem.innerWidth() - 2 * parseInt(elem.css('padding-left'), 10);

                    var swatch = elem.children('div.jqplot-table-legend-swatch');
                    newContext.fillStyle = swatch.css('background-color');
                    newContext.fillRect(l, t, w, h);
                });

                // now add text

                $(el).find('td.jqplot-table-legend-label').each(function(){
                    var elem = $(this);
                    var l = left + elem.position().left;
                    var t = top + elem.position().top + parseInt(elem.css('padding-top'), 10);
                    newContext.font = elem.jqplotGetComputedFontStyle();
                    newContext.fillStyle = elem.css('color');
                    writeWrappedText(elem, newContext, elem.text(), l, t, w);
                });

                var elem = null;
            }

            else if (tagname == 'canvas') {
                newContext.drawImage(el, left, top);
            }
        }
        $(this).children().each(function() {
            _jqpToImage(this, x_offset, y_offset);
        });
        return newCanvas;
    };

    // return the raw image data string.
    // Should work on canvas supporting browsers.
    $.fn.jqplotToImageStr = function(options) {
        var imgCanvas = $(this).jqplotToImageCanvas(options);
        if (imgCanvas) {
            return imgCanvas.toDataURL("image/png");
        }
        else {
            return null;
        }
    };

    // return a DOM <img> element and return it.
    // Should work on canvas supporting browsers.
    $.fn.jqplotToImageElem = function(options) {
        var elem = document.createElement("img");
        var str = $(this).jqplotToImageStr(options);
        elem.src = str;
        return elem;
    };

    // return a string for an <img> element and return it.
    // Should work on canvas supporting browsers.
    $.fn.jqplotToImageElemStr = function(options) {
        var str = '<img src='+$(this).jqplotToImageStr(options)+' />';
        return str;
    };

    // Not guaranteed to work, even on canvas supporting browsers due to 
    // limitations with location.href and browser support.
    $.fn.jqplotSaveImage = function() {
        var imgData = $(this).jqplotToImageStr({});
        if (imgData) {
            window.location.href = imgData.replace("image/png", "image/octet-stream");
        }

    };

    // Not guaranteed to work, even on canvas supporting browsers due to
    // limitations with window.open and arbitrary data.
    $.fn.jqplotViewImage = function() {
        var imgStr = $(this).jqplotToImageElemStr({});
        var imgData = $(this).jqplotToImageStr({});
        if (imgStr) {
            var w = window.open('');
            w.document.open("image/png");
            w.document.write(imgStr);
            w.document.close();
            w = null;
        }
    };
    



    /** 
     * @description
     * <p>Object with extended date parsing and formatting capabilities.
     * This library borrows many concepts and ideas from the Date Instance 
     * Methods by Ken Snyder along with some parts of Ken's actual code.</p>
     *
     * <p>jsDate takes a different approach by not extending the built-in 
     * Date Object, improving date parsing, allowing for multiple formatting 
     * syntaxes and multiple and more easily expandable localization.</p>
     * 
     * @author Chris Leonello
     * @date #date#
     * @version #VERSION#
     * @copyright (c) 2010-2013 Chris Leonello
     * jsDate is currently available for use in all personal or commercial projects 
     * under both the MIT and GPL version 2.0 licenses. This means that you can 
     * choose the license that best suits your project and use it accordingly.
     * 
     * <p>Ken's original Date Instance Methods and copyright notice:</p>
     * <pre>
     * Ken Snyder (ken d snyder at gmail dot com)
     * 2008-09-10
     * version 2.0.2 (http://kendsnyder.com/sandbox/date/)     
     * Creative Commons Attribution License 3.0 (http://creativecommons.org/licenses/by/3.0/)
     * </pre>
     * 
     * @class
     * @name jsDate
     * @param  {String | Number | Array | Date&nbsp;Object | Options&nbsp;Object} arguments Optional arguments, either a parsable date/time string,
     * a JavaScript timestamp, an array of numbers of form [year, month, day, hours, minutes, seconds, milliseconds],
     * a Date object, or an options object of form {syntax: "perl", date:some Date} where all options are optional.
     */
     
    var jsDate = function () {
    
        this.syntax = jsDate.config.syntax;
        this._type = "jsDate";
        this.proxy = new Date();
        this.options = {};
        this.locale = jsDate.regional.getLocale();
        this.formatString = '';
        this.defaultCentury = jsDate.config.defaultCentury;

        switch ( arguments.length ) {
            case 0:
                break;
            case 1:
                // other objects either won't have a _type property or,
                // if they do, it shouldn't be set to "jsDate", so
                // assume it is an options argument.
                if (get_type(arguments[0]) == "[object Object]" && arguments[0]._type != "jsDate") {
                    var opts = this.options = arguments[0];
                    this.syntax = opts.syntax || this.syntax;
                    this.defaultCentury = opts.defaultCentury || this.defaultCentury;
                    this.proxy = jsDate.createDate(opts.date);
                }
                else {
                    this.proxy = jsDate.createDate(arguments[0]);
                }
                break;
            default:
                var a = [];
                for ( var i=0; i<arguments.length; i++ ) {
                    a.push(arguments[i]);
                }
                // this should be the current date/time?
                this.proxy = new Date();
                this.proxy.setFullYear.apply( this.proxy, a.slice(0,3) );
                if ( a.slice(3).length ) {
                    this.proxy.setHours.apply( this.proxy, a.slice(3) );
                }
                break;
        }
    };
    
    /**
     * @namespace Configuration options that will be used as defaults for all instances on the page.
     * @property {String} defaultLocale The default locale to use [en].
     * @property {String} syntax The default syntax to use [perl].
     * @property {Number} defaultCentury The default centry for 2 digit dates.
     */
    jsDate.config = {
        defaultLocale: 'en',
        syntax: 'perl',
        defaultCentury: 1900
    };
        
    /**
     * Add an arbitrary amount to the currently stored date
     * 
     * @param {Number} number      
     * @param {String} unit
     * @returns {jsDate}       
     */
     
    jsDate.prototype.add = function(number, unit) {
        var factor = multipliers[unit] || multipliers.day;
        if (typeof factor == 'number') {
            this.proxy.setTime(this.proxy.getTime() + (factor * number));
        } else {
            factor.add(this, number);
        }
        return this;
    };
        
    /**
     * Create a new jqplot.date object with the same date
     * 
     * @returns {jsDate}
     */  
     
    jsDate.prototype.clone = function() {
            return new jsDate(this.proxy.getTime());
    };

    /**
     * Get the UTC TimeZone Offset of this date in milliseconds.
     *
     * @returns {Number}
     */

    jsDate.prototype.getUtcOffset = function() {
        return this.proxy.getTimezoneOffset() * 60000;
    };

    /**
     * Find the difference between this jsDate and another date.
     * 
     * @param {String| Number| Array| jsDate&nbsp;Object| Date&nbsp;Object} dateObj
     * @param {String} unit
     * @param {Boolean} allowDecimal
     * @returns {Number} Number of units difference between dates.
     */
     
    jsDate.prototype.diff = function(dateObj, unit, allowDecimal) {
        // ensure we have a Date object
        dateObj = new jsDate(dateObj);
        if (dateObj === null) {
            return null;
        }
        // get the multiplying factor integer or factor function
        var factor = multipliers[unit] || multipliers.day;
        if (typeof factor == 'number') {
            // multiply
            var unitDiff = (this.proxy.getTime() - dateObj.proxy.getTime()) / factor;
        } else {
            // run function
            var unitDiff = factor.diff(this.proxy, dateObj.proxy);
        }
        // if decimals are not allowed, round toward zero
        return (allowDecimal ? unitDiff : Math[unitDiff > 0 ? 'floor' : 'ceil'](unitDiff));          
    };
    
    /**
     * Get the abbreviated name of the current week day
     * 
     * @returns {String}
     */   
     
    jsDate.prototype.getAbbrDayName = function() {
        return jsDate.regional[this.locale]["dayNamesShort"][this.proxy.getDay()];
    };
    
    /**
     * Get the abbreviated name of the current month
     * 
     * @returns {String}
     */
     
    jsDate.prototype.getAbbrMonthName = function() {
        return jsDate.regional[this.locale]["monthNamesShort"][this.proxy.getMonth()];
    };
    
    /**
     * Get UPPER CASE AM or PM for the current time
     * 
     * @returns {String}
     */
     
    jsDate.prototype.getAMPM = function() {
        return this.proxy.getHours() >= 12 ? 'PM' : 'AM';
    };
    
    /**
     * Get lower case am or pm for the current time
     * 
     * @returns {String}
     */
     
    jsDate.prototype.getAmPm = function() {
        return this.proxy.getHours() >= 12 ? 'pm' : 'am';
    };
    
    /**
     * Get the century (19 for 20th Century)
     *
     * @returns {Integer} Century (19 for 20th century).
     */
    jsDate.prototype.getCentury = function() { 
        return parseInt(this.proxy.getFullYear()/100, 10);
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getDate = function() {
        return this.proxy.getDate();
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getDay = function() {
        return this.proxy.getDay();
    };
    
    /**
     * Get the Day of week 1 (Monday) thru 7 (Sunday)
     * 
     * @returns {Integer} Day of week 1 (Monday) thru 7 (Sunday)
     */
    jsDate.prototype.getDayOfWeek = function() { 
        var dow = this.proxy.getDay(); 
        return dow===0?7:dow; 
    };
    
    /**
     * Get the day of the year
     * 
     * @returns {Integer} 1 - 366, day of the year
     */
    jsDate.prototype.getDayOfYear = function() {
        var d = this.proxy;
        var ms = d - new Date('' + d.getFullYear() + '/1/1 GMT');
        ms += d.getTimezoneOffset()*60000;
        d = null;
        return parseInt(ms/60000/60/24, 10)+1;
    };
    
    /**
     * Get the name of the current week day
     * 
     * @returns {String}
     */  
     
    jsDate.prototype.getDayName = function() {
        return jsDate.regional[this.locale]["dayNames"][this.proxy.getDay()];
    };
    
    /**
     * Get the week number of the given year, starting with the first Sunday as the first week
     * @returns {Integer} Week number (13 for the 13th full week of the year).
     */
    jsDate.prototype.getFullWeekOfYear = function() {
        var d = this.proxy;
        var doy = this.getDayOfYear();
        var rdow = 6-d.getDay();
        var woy = parseInt((doy+rdow)/7, 10);
        return woy;
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getFullYear = function() {
        return this.proxy.getFullYear();
    };
    
    /**
     * Get the GMT offset in hours and minutes (e.g. +06:30)
     * 
     * @returns {String}
     */
     
    jsDate.prototype.getGmtOffset = function() {
        // divide the minutes offset by 60
        var hours = this.proxy.getTimezoneOffset() / 60;
        // decide if we are ahead of or behind GMT
        var prefix = hours < 0 ? '+' : '-';
        // remove the negative sign if any
        hours = Math.abs(hours);
        // add the +/- to the padded number of hours to : to the padded minutes
        return prefix + addZeros(Math.floor(hours), 2) + ':' + addZeros((hours % 1) * 60, 2);
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getHours = function() {
        return this.proxy.getHours();
    };
    
    /**
     * Get the current hour on a 12-hour scheme
     * 
     * @returns {Integer}
     */
     
    jsDate.prototype.getHours12  = function() {
        var hours = this.proxy.getHours();
        return hours > 12 ? hours - 12 : (hours == 0 ? 12 : hours);
    };
    
    
    jsDate.prototype.getIsoWeek = function() {
        var d = this.proxy;
        var woy = this.getWeekOfYear();
        var dow1_1 = (new Date('' + d.getFullYear() + '/1/1')).getDay();
        // First week is 01 and not 00 as in the case of %U and %W,
        // so we add 1 to the final result except if day 1 of the year
        // is a Monday (then %W returns 01).
        // We also need to subtract 1 if the day 1 of the year is 
        // Friday-Sunday, so the resulting equation becomes:
        var idow = woy + (dow1_1 > 4 || dow1_1 <= 1 ? 0 : 1);
        if(idow == 53 && (new Date('' + d.getFullYear() + '/12/31')).getDay() < 4)
        {
            idow = 1;
        }
        else if(idow === 0)
        {
            d = new jsDate(new Date('' + (d.getFullYear()-1) + '/12/31'));
            idow = d.getIsoWeek();
        }
        d = null;
        return idow;
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getMilliseconds = function() {
        return this.proxy.getMilliseconds();
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getMinutes = function() {
        return this.proxy.getMinutes();
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getMonth = function() {
        return this.proxy.getMonth();
    };
    
    /**
     * Get the name of the current month
     * 
     * @returns {String}
     */
     
    jsDate.prototype.getMonthName = function() {
        return jsDate.regional[this.locale]["monthNames"][this.proxy.getMonth()];
    };
    
    /**
     * Get the number of the current month, 1-12
     * 
     * @returns {Integer}
     */
     
    jsDate.prototype.getMonthNumber = function() {
        return this.proxy.getMonth() + 1;
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getSeconds = function() {
        return this.proxy.getSeconds();
    };
    
    /**
     * Return a proper two-digit year integer
     * 
     * @returns {Integer}
     */
     
    jsDate.prototype.getShortYear = function() {
        return this.proxy.getYear() % 100;
    };
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getTime = function() {
        return this.proxy.getTime();
    };
    
    /**
     * Get the timezone abbreviation
     *
     * @returns {String} Abbreviation for the timezone
     */
    jsDate.prototype.getTimezoneAbbr = function() {
        return this.proxy.toString().replace(/^.*\(([^)]+)\)$/, '$1'); 
    };
    
    /**
     * Get the browser-reported name for the current timezone (e.g. MDT, Mountain Daylight Time)
     * 
     * @returns {String}
     */
    jsDate.prototype.getTimezoneName = function() {
        var match = /(?:\((.+)\)$| ([A-Z]{3}) )/.exec(this.toString());
        return match[1] || match[2] || 'GMT' + this.getGmtOffset();
    }; 
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getTimezoneOffset = function() {
        return this.proxy.getTimezoneOffset();
    };
    
    
    /**
     * Get the week number of the given year, starting with the first Monday as the first week
     * @returns {Integer} Week number (13 for the 13th week of the year).
     */
    jsDate.prototype.getWeekOfYear = function() {
        var doy = this.getDayOfYear();
        var rdow = 7 - this.getDayOfWeek();
        var woy = parseInt((doy+rdow)/7, 10);
        return woy;
    };
    
    /**
     * Get the current date as a Unix timestamp
     * 
     * @returns {Integer}
     */
     
    jsDate.prototype.getUnix = function() {
        return Math.round(this.proxy.getTime() / 1000, 0);
    }; 
    
    /**
     * Implements Date functionality
     */
    jsDate.prototype.getYear = function() {
        return this.proxy.getYear();
    };
    
    /**
     * Return a date one day ahead (or any other unit)
     * 
     * @param {String} unit Optional, year | month | day | week | hour | minute | second | millisecond
     * @returns {jsDate}
     */
     
    jsDate.prototype.next = function(unit) {
        unit = unit || 'day';
        return this.clone().add(1, unit);
    };
    
    /**
     * Set the jsDate instance to a new date.
     *
     * @param  {String | Number | Array | Date Object | jsDate Object | Options Object} arguments Optional arguments, 
     * either a parsable date/time string,
     * a JavaScript timestamp, an array of numbers of form [year, month, day, hours, minutes, seconds, milliseconds],
     * a Date object, jsDate Object or an options object of form {syntax: "perl", date:some Date} where all options are optional.
     */
    jsDate.prototype.set = function() {
        switch ( arguments.length ) {
            case 0:
                this.proxy = new Date();
                break;
            case 1:
                // other objects either won't have a _type property or,
                // if they do, it shouldn't be set to "jsDate", so
                // assume it is an options argument.
                if (get_type(arguments[0]) == "[object Object]" && arguments[0]._type != "jsDate") {
                    var opts = this.options = arguments[0];
                    this.syntax = opts.syntax || this.syntax;
                    this.defaultCentury = opts.defaultCentury || this.defaultCentury;
                    this.proxy = jsDate.createDate(opts.date);
                }
                else {
                    this.proxy = jsDate.createDate(arguments[0]);
                }
                break;
            default:
                var a = [];
                for ( var i=0; i<arguments.length; i++ ) {
                    a.push(arguments[i]);
                }
                // this should be the current date/time
                this.proxy = new Date();
                this.proxy.setFullYear.apply( this.proxy, a.slice(0,3) );
                if ( a.slice(3).length ) {
                    this.proxy.setHours.apply( this.proxy, a.slice(3) );
                }
                break;
        }
        return this;
    };
    
    /**
     * Sets the day of the month for a specified date according to local time.
     * @param {Integer} dayValue An integer from 1 to 31, representing the day of the month. 
     */
    jsDate.prototype.setDate = function(n) {
        this.proxy.setDate(n);
        return this;
    };
    
    /**
     * Sets the full year for a specified date according to local time.
     * @param {Integer} yearValue The numeric value of the year, for example, 1995.  
     * @param {Integer} monthValue Optional, between 0 and 11 representing the months January through December.  
     * @param {Integer} dayValue Optional, between 1 and 31 representing the day of the month. If you specify the dayValue parameter, you must also specify the monthValue. 
     */
    jsDate.prototype.setFullYear = function() {
        this.proxy.setFullYear.apply(this.proxy, arguments);
        return this;
    };
    
    /**
     * Sets the hours for a specified date according to local time.
     * 
     * @param {Integer} hoursValue An integer between 0 and 23, representing the hour.  
     * @param {Integer} minutesValue Optional, An integer between 0 and 59, representing the minutes.  
     * @param {Integer} secondsValue Optional, An integer between 0 and 59, representing the seconds. 
     * If you specify the secondsValue parameter, you must also specify the minutesValue.  
     * @param {Integer} msValue Optional, A number between 0 and 999, representing the milliseconds. 
     * If you specify the msValue parameter, you must also specify the minutesValue and secondsValue. 
     */
    jsDate.prototype.setHours = function() {
        this.proxy.setHours.apply(this.proxy, arguments);
        return this;
    };
    
    /**
     * Implements Date functionality
     */ 
    jsDate.prototype.setMilliseconds = function(n) {
        this.proxy.setMilliseconds(n);
        return this;
    };
    
    /**
     * Implements Date functionality
     */ 
    jsDate.prototype.setMinutes = function() {
        this.proxy.setMinutes.apply(this.proxy, arguments);
        return this;
    };
    
    /**
     * Implements Date functionality
     */ 
    jsDate.prototype.setMonth = function() {
        this.proxy.setMonth.apply(this.proxy, arguments);
        return this;
    };
    
    /**
     * Implements Date functionality
     */ 
    jsDate.prototype.setSeconds = function() {
        this.proxy.setSeconds.apply(this.proxy, arguments);
        return this;
    };
    
    /**
     * Implements Date functionality
     */ 
    jsDate.prototype.setTime = function(n) {
        this.proxy.setTime(n);
        return this;
    };
    
    /**
     * Implements Date functionality
     */ 
    jsDate.prototype.setYear = function() {
        this.proxy.setYear.apply(this.proxy, arguments);
        return this;
    };
    
    /**
     * Provide a formatted string representation of this date.
     * 
     * @param {String} formatString A format string.  
     * See: {@link jsDate.formats}.
     * @returns {String} Date String.
     */
            
    jsDate.prototype.strftime = function(formatString) {
        formatString = formatString || this.formatString || jsDate.regional[this.locale]['formatString'];
        return jsDate.strftime(this, formatString, this.syntax);
    };
        
    /**
     * Return a String representation of this jsDate object.
     * @returns {String} Date string.
     */
    
    jsDate.prototype.toString = function() {
        return this.proxy.toString();
    };
        
    /**
     * Convert the current date to an 8-digit integer (%Y%m%d)
     * 
     * @returns {Integer}
     */
     
    jsDate.prototype.toYmdInt = function() {
        return (this.proxy.getFullYear() * 10000) + (this.getMonthNumber() * 100) + this.proxy.getDate();
    };
    
    /**
     * @namespace Holds localizations for month/day names.
     * <p>jsDate attempts to detect locale when loaded and defaults to 'en'.
     * If a localization is detected which is not available, jsDate defaults to 'en'.
     * Additional localizations can be added after jsDate loads.  After adding a localization,
     * call the jsDate.regional.getLocale() method.  Currently, en, fr and de are defined.</p>
     * 
     * <p>Localizations must be an object and have the following properties defined:  monthNames, monthNamesShort, dayNames, dayNamesShort and Localizations are added like:</p>
     * <pre class="code">
     * jsDate.regional['en'] = {
     * monthNames      : 'January February March April May June July August September October November December'.split(' '),
     * monthNamesShort : 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' '),
     * dayNames        : 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' '),
     * dayNamesShort   : 'Sun Mon Tue Wed Thu Fri Sat'.split(' ')
     * };
     * </pre>
     * <p>After adding localizations, call <code>jsDate.regional.getLocale();</code> to update the locale setting with the
     * new localizations.</p>
     */
     
    jsDate.regional = {
        'en': {
            monthNames: ['January','February','March','April','May','June','July','August','September','October','November','December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun','Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            formatString: '%Y-%m-%d %H:%M:%S'
        },
        
        'fr': {
            monthNames: ['Janvier','Fvrier','Mars','Avril','Mai','Juin','Juillet','Aot','Septembre','Octobre','Novembre','Dcembre'],
            monthNamesShort: ['Jan','Fv','Mar','Avr','Mai','Jun','Jul','Ao','Sep','Oct','Nov','Dc'],
            dayNames: ['Dimanche','Lundi','Mardi','Mercredi','Jeudi','Vendredi','Samedi'],
            dayNamesShort: ['Dim','Lun','Mar','Mer','Jeu','Ven','Sam'],
            formatString: '%Y-%m-%d %H:%M:%S'
        },
        
        'de': {
            monthNames: ['Januar','Februar','Mrz','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember'],
            monthNamesShort: ['Jan','Feb','Mr','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez'],
            dayNames: ['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],
            dayNamesShort: ['So','Mo','Di','Mi','Do','Fr','Sa'],
            formatString: '%Y-%m-%d %H:%M:%S'
        },
        
        'es': {
            monthNames: ['Enero','Febrero','Marzo','Abril','Mayo','Junio', 'Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'],
            monthNamesShort: ['Ene','Feb','Mar','Abr','May','Jun', 'Jul','Ago','Sep','Oct','Nov','Dic'],
            dayNames: ['Domingo','Lunes','Martes','Mi&eacute;rcoles','Jueves','Viernes','S&aacute;bado'],
            dayNamesShort: ['Dom','Lun','Mar','Mi&eacute;','Juv','Vie','S&aacute;b'],
            formatString: '%Y-%m-%d %H:%M:%S'
        },
        
        'ru': {
            monthNames: ['','','','','','','','','','','',''],
            monthNamesShort: ['','','','','','','','','','','',''],
            dayNames: ['','','','','','',''],
            dayNamesShort: ['','','','','','',''],
            formatString: '%Y-%m-%d %H:%M:%S'
        },
        
        'ar': {
            monthNames: [' ', '', '', '', '', '','', '', '',   ' ', ' ', ' '],
            monthNamesShort: ['1','2','3','4','5','6','7','8','9','10','11','12'],
            dayNames: ['', '', '', '', '', '', ''],
            dayNamesShort: ['', '', '', '', '', '', ''],
            formatString: '%Y-%m-%d %H:%M:%S'
        },
        
        'pt': {
            monthNames: ['Janeiro','Fevereiro','Mar&ccedil;o','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],
            monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'],
            dayNames: ['Domingo','Segunda-feira','Ter&ccedil;a-feira','Quarta-feira','Quinta-feira','Sexta-feira','S&aacute;bado'],
            dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','S&aacute;b'],
            formatString: '%Y-%m-%d %H:%M:%S'   
        },
        
        'pt-BR': {
            monthNames: ['Janeiro','Fevereiro','Mar&ccedil;o','Abril','Maio','Junho', 'Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'],
            monthNamesShort: ['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'],
            dayNames: ['Domingo','Segunda-feira','Ter&ccedil;a-feira','Quarta-feira','Quinta-feira','Sexta-feira','S&aacute;bado'],
            dayNamesShort: ['Dom','Seg','Ter','Qua','Qui','Sex','S&aacute;b'],
            formatString: '%Y-%m-%d %H:%M:%S'
        },
        
        'pl': {
            monthNames: ['Stycze','Luty','Marzec','Kwiecie','Maj','Czerwiec','Lipiec','Sierpie','Wrzesie','Padziernik','Listopad','Grudzie'],
            monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze','Lip', 'Sie', 'Wrz', 'Pa', 'Lis', 'Gru'],
            dayNames: ['Niedziela', 'Poniedziaek', 'Wtorek', 'roda', 'Czwartek', 'Pitek', 'Sobota'],
            dayNamesShort: ['Ni', 'Pn', 'Wt', 'r', 'Cz', 'Pt', 'Sb'],
            formatString: '%Y-%m-%d %H:%M:%S'
        },

        'nl': {
            monthNames: ['Januari','Februari','Maart','April','Mei','Juni','July','Augustus','September','Oktober','November','December'],
            monthNamesShort: ['Jan','Feb','Mar','Apr','Mei','Jun','Jul','Aug','Sep','Okt','Nov','Dec'],
            dayNames:','['Zondag','Maandag','Dinsdag','Woensdag','Donderdag','Vrijdag','Zaterdag'],
            dayNamesShort: ['Zo','Ma','Di','Wo','Do','Vr','Za'],
            formatString: '%Y-%m-%d %H:%M:%S'
        },

        'sv': {
            monthNames: ['januari','februari','mars','april','maj','juni','juli','augusti','september','oktober','november','december'],
          monthNamesShort: ['jan','feb','mar','apr','maj','jun','jul','aug','sep','okt','nov','dec'],
            dayNames: ['sndag','mndag','tisdag','onsdag','torsdag','fredag','lrdag'],
            dayNamesShort: ['sn','mn','tis','ons','tor','fre','lr'],
            formatString: '%Y-%m-%d %H:%M:%S'
        }
    
    };
    
    // Set english variants to 'en'
    jsDate.regional['en-US'] = jsDate.regional['en-GB'] = jsDate.regional['en'];
    
    /**
     * Try to determine the users locale based on the lang attribute of the html page.  Defaults to 'en'
     * if it cannot figure out a locale of if the locale does not have a localization defined.
     * @returns {String} locale
     */
     
    jsDate.regional.getLocale = function () {
        var l = jsDate.config.defaultLocale;
        
        if ( document && document.getElementsByTagName('html') && document.getElementsByTagName('html')[0].lang ) {
            l = document.getElementsByTagName('html')[0].lang;
            if (!jsDate.regional.hasOwnProperty(l)) {
                l = jsDate.config.defaultLocale;
            }
        }
        
        return l;
    };
    
    // ms in day
    var day = 24 * 60 * 60 * 1000;
    
    // padd a number with zeros
    var addZeros = function(num, digits) {
        num = String(num);
        var i = digits - num.length;
        var s = String(Math.pow(10, i)).slice(1);
        return s.concat(num);
    };

    // representations used for calculating differences between dates.
    // This borrows heavily from Ken Snyder's work.
    var multipliers = {
        millisecond: 1,
        second: 1000,
        minute: 60 * 1000,
        hour: 60 * 60 * 1000,
        day: day,
        week: 7 * day,
        month: {
            // add a number of months
            add: function(d, number) {
                // add any years needed (increments of 12)
                multipliers.year.add(d, Math[number > 0 ? 'floor' : 'ceil'](number / 12));
                // ensure that we properly wrap betwen December and January
                // 11 % 12 = 11
                // 12 % 12 = 0
                var prevMonth = d.getMonth() + (number % 12);
                if (prevMonth == 12) {
                    prevMonth = 0;
                    d.setYear(d.getFullYear() + 1);
                } else if (prevMonth == -1) {
                    prevMonth = 11;
                    d.setYear(d.getFullYear() - 1);
                }
                d.setMonth(prevMonth);
            },
            // get the number of months between two Date objects (decimal to the nearest day)
            diff: function(d1, d2) {
                // get the number of years
                var diffYears = d1.getFullYear() - d2.getFullYear();
                // get the number of remaining months
                var diffMonths = d1.getMonth() - d2.getMonth() + (diffYears * 12);
                // get the number of remaining days
                var diffDays = d1.getDate() - d2.getDate();
                // return the month difference with the days difference as a decimal
                return diffMonths + (diffDays / 30);
            }
        },
        year: {
            // add a number of years
            add: function(d, number) {
                d.setYear(d.getFullYear() + Math[number > 0 ? 'floor' : 'ceil'](number));
            },
            // get the number of years between two Date objects (decimal to the nearest day)
            diff: function(d1, d2) {
                return multipliers.month.diff(d1, d2) / 12;
            }
        }        
    };
    //
    // Alias each multiplier with an 's' to allow 'year' and 'years' for example.
    // This comes from Ken Snyders work.
    //
    for (var unit in multipliers) {
        if (unit.substring(unit.length - 1) != 's') { // IE will iterate newly added properties :|
            multipliers[unit + 's'] = multipliers[unit];
        }
    }
    
    //
    // take a jsDate instance and a format code and return the formatted value.
    // This is a somewhat modified version of Ken Snyder's method.
    //
    var format = function(d, code, syntax) {
        // if shorcut codes are used, recursively expand those.
        if (jsDate.formats[syntax]["shortcuts"][code]) {
            return jsDate.strftime(d, jsDate.formats[syntax]["shortcuts"][code], syntax);
        } else {
            // get the format code function and addZeros() argument
            var getter = (jsDate.formats[syntax]["codes"][code] || '').split('.');
            var nbr = d['get' + getter[0]] ? d['get' + getter[0]]() : '';
            if (getter[1]) {
                nbr = addZeros(nbr, getter[1]);
            }
            return nbr;
        }       
    };
    
    /**
     * @static
     * Static function for convert a date to a string according to a given format.  Also acts as namespace for strftime format codes.
     * <p>strftime formatting can be accomplished without creating a jsDate object by calling jsDate.strftime():</p>
     * <pre class="code">
     * var formattedDate = jsDate.strftime('Feb 8, 2006 8:48:32', '%Y-%m-%d %H:%M:%S');
     * </pre>
     * @param {String | Number | Array | jsDate&nbsp;Object | Date&nbsp;Object} date A parsable date string, JavaScript time stamp, Array of form [year, month, day, hours, minutes, seconds, milliseconds], jsDate Object or Date object.
     * @param {String} formatString String with embedded date formatting codes.  
     * See: {@link jsDate.formats}. 
     * @param {String} syntax Optional syntax to use [default perl].
     * @param {String} locale Optional locale to use.
     * @returns {String} Formatted representation of the date.
    */
    //
    // Logic as implemented here is very similar to Ken Snyder's Date Instance Methods.
    //
    jsDate.strftime = function(d, formatString, syntax, locale) {
        var syn = 'perl';
        var loc = jsDate.regional.getLocale();
        
        // check if syntax and locale are available or reversed
        if (syntax && jsDate.formats.hasOwnProperty(syntax)) {
            syn = syntax;
        }
        else if (syntax && jsDate.regional.hasOwnProperty(syntax)) {
            loc = syntax;
        }
        
        if (locale && jsDate.formats.hasOwnProperty(locale)) {
            syn = locale;
        }
        else if (locale && jsDate.regional.hasOwnProperty(locale)) {
            loc = locale;
        }
        
        if (get_type(d) != "[object Object]" || d._type != "jsDate") {
            d = new jsDate(d);
            d.locale = loc;
        }
        if (!formatString) {
            formatString = d.formatString || jsDate.regional[loc]['formatString'];
        }
        // default the format string to year-month-day
        var source = formatString || '%Y-%m-%d', 
            result = '', 
            match;
        // replace each format code
        while (source.length > 0) {
            if (match = source.match(jsDate.formats[syn].codes.matcher)) {
                result += source.slice(0, match.index);
                result += (match[1] || '') + format(d, match[2], syn);
                source = source.slice(match.index + match[0].length);
            } else {
                result += source;
                source = '';
            }
        }
        return result;
    };
    
    /**
     * @namespace
     * Namespace to hold format codes and format shortcuts.  "perl" and "php" format codes 
     * and shortcuts are defined by default.  Additional codes and shortcuts can be
     * added like:
     * 
     * <pre class="code">
     * jsDate.formats["perl"] = {
     *     "codes": {
     *         matcher: /someregex/,
     *         Y: "fullYear",  // name of "get" method without the "get",
     *         ...,            // more codes
     *     },
     *     "shortcuts": {
     *         F: '%Y-%m-%d',
     *         ...,            // more shortcuts
     *     }
     * };
     * </pre>
     * 
     * <p>Additionally, ISO and SQL shortcuts are defined and can be accesses via:
     * <code>jsDate.formats.ISO</code> and <code>jsDate.formats.SQL</code>
     */
    
    jsDate.formats = {
        ISO:'%Y-%m-%dT%H:%M:%S.%N%G',
        SQL:'%Y-%m-%d %H:%M:%S'
    };
    
    /**
     * Perl format codes and shortcuts for strftime.
     * 
     * A hash (object) of codes where each code must be an array where the first member is 
     * the name of a Date.prototype or jsDate.prototype function to call
     * and optionally a second member indicating the number to pass to addZeros()
     * 
     * <p>The following format codes are defined:</p>
     * 
     * <pre class="code">
     * Code    Result                    Description
     * == Years ==           
     * %Y      2008                      Four-digit year
     * %y      08                        Two-digit year
     * 
     * == Months ==          
     * %m      09                        Two-digit month
     * %#m     9                         One or two-digit month
     * %B      September                 Full month name
     * %b      Sep                       Abbreviated month name
     * 
     * == Days ==            
     * %d      05                        Two-digit day of month
     * %#d     5                         One or two-digit day of month
     * %e      5                         One or two-digit day of month
     * %A      Sunday                    Full name of the day of the week
     * %a      Sun                       Abbreviated name of the day of the week
     * %w      0                         Number of the day of the week (0 = Sunday, 6 = Saturday)
     * 
     * == Hours ==           
     * %H      23                        Hours in 24-hour format (two digits)
     * %#H     3                         Hours in 24-hour integer format (one or two digits)
     * %I      11                        Hours in 12-hour format (two digits)
     * %#I     3                         Hours in 12-hour integer format (one or two digits)
     * %p      PM                        AM or PM
     * 
     * == Minutes ==         
     * %M      09                        Minutes (two digits)
     * %#M     9                         Minutes (one or two digits)
     * 
     * == Seconds ==         
     * %S      02                        Seconds (two digits)
     * %#S     2                         Seconds (one or two digits)
     * %s      1206567625723             Unix timestamp (Seconds past 1970-01-01 00:00:00)
     * 
     * == Milliseconds ==    
     * %N      008                       Milliseconds (three digits)
     * %#N     8                         Milliseconds (one to three digits)
     * 
     * == Timezone ==        
     * %O      360                       difference in minutes between local time and GMT
     * %Z      Mountain Standard Time    Name of timezone as reported by browser
     * %G      06:00                     Hours and minutes between GMT
     * 
     * == Shortcuts ==       
     * %F      2008-03-26                %Y-%m-%d
     * %T      05:06:30                  %H:%M:%S
     * %X      05:06:30                  %H:%M:%S
     * %x      03/26/08                  %m/%d/%y
     * %D      03/26/08                  %m/%d/%y
     * %#c     Wed Mar 26 15:31:00 2008  %a %b %e %H:%M:%S %Y
     * %v      3-Sep-2008                %e-%b-%Y
     * %R      15:31                     %H:%M
     * %r      03:31:00 PM               %I:%M:%S %p
     * 
     * == Characters ==      
     * %n      \n                        Newline
     * %t      \t                        Tab
     * %%      %                         Percent Symbol
     * </pre>
     * 
     * <p>Formatting shortcuts that will be translated into their longer version.
     * Be sure that format shortcuts do not refer to themselves: this will cause an infinite loop.</p>
     * 
     * <p>Format codes and format shortcuts can be redefined after the jsDate
     * module is imported.</p>
     * 
     * <p>Note that if you redefine the whole hash (object), you must supply a "matcher"
     * regex for the parser.  The default matcher is:</p>
     * 
     * <code>/()%(#?(%|[a-z]))/i</code>
     * 
     * <p>which corresponds to the Perl syntax used by default.</p>
     * 
     * <p>By customizing the matcher and format codes, nearly any strftime functionality is possible.</p>
     */
     
    jsDate.formats.perl = {
        codes: {
            //
            // 2-part regex matcher for format codes
            //
            // first match must be the character before the code (to account for escaping)
            // second match must be the format code character(s)
            //
            matcher: /()%(#?(%|[a-z]))/i,
            // year
            Y: 'FullYear',
            y: 'ShortYear.2',
            // month
            m: 'MonthNumber.2',
            '#m': 'MonthNumber',
            B: 'MonthName',
            b: 'AbbrMonthName',
            // day
            d: 'Date.2',
            '#d': 'Date',
            e: 'Date',
            A: 'DayName',
            a: 'AbbrDayName',
            w: 'Day',
            // hours
            H: 'Hours.2',
            '#H': 'Hours',
            I: 'Hours12.2',
            '#I': 'Hours12',
            p: 'AMPM',
            // minutes
            M: 'Minutes.2',
            '#M': 'Minutes',
            // seconds
            S: 'Seconds.2',
            '#S': 'Seconds',
            s: 'Unix',
            // milliseconds
            N: 'Milliseconds.3',
            '#N': 'Milliseconds',
            // timezone
            O: 'TimezoneOffset',
            Z: 'TimezoneName',
            G: 'GmtOffset'  
        },
        
        shortcuts: {
            // date
            F: '%Y-%m-%d',
            // time
            T: '%H:%M:%S',
            X: '%H:%M:%S',
            // local format date
            x: '%m/%d/%y',
            D: '%m/%d/%y',
            // local format extended
            '#c': '%a %b %e %H:%M:%S %Y',
            // local format short
            v: '%e-%b-%Y',
            R: '%H:%M',
            r: '%I:%M:%S %p',
            // tab and newline
            t: '\t',
            n: '\n',
            '%': '%'
        }
    };
    
    /**
     * PHP format codes and shortcuts for strftime.
     * 
     * A hash (object) of codes where each code must be an array where the first member is 
     * the name of a Date.prototype or jsDate.prototype function to call
     * and optionally a second member indicating the number to pass to addZeros()
     * 
     * <p>The following format codes are defined:</p>
     * 
     * <pre class="code">
     * Code    Result                    Description
     * === Days ===        
     * %a      Sun through Sat           An abbreviated textual representation of the day
     * %A      Sunday - Saturday         A full textual representation of the day
     * %d      01 to 31                  Two-digit day of the month (with leading zeros)
     * %e      1 to 31                   Day of the month, with a space preceding single digits.
     * %j      001 to 366                Day of the year, 3 digits with leading zeros
     * %u      1 - 7 (Mon - Sun)         ISO-8601 numeric representation of the day of the week
     * %w      0 - 6 (Sun - Sat)         Numeric representation of the day of the week
     *                                  
     * === Week ===                     
     * %U      13                        Full Week number, starting with the first Sunday as the first week
     * %V      01 through 53             ISO-8601:1988 week number, starting with the first week of the year 
     *                                   with at least 4 weekdays, with Monday being the start of the week
     * %W      46                        A numeric representation of the week of the year, 
     *                                   starting with the first Monday as the first week
     * === Month ===                    
     * %b      Jan through Dec           Abbreviated month name, based on the locale
     * %B      January - December        Full month name, based on the locale
     * %h      Jan through Dec           Abbreviated month name, based on the locale (an alias of %b)
     * %m      01 - 12 (Jan - Dec)       Two digit representation of the month
     * 
     * === Year ===                     
     * %C      19                        Two digit century (year/100, truncated to an integer)
     * %y      09 for 2009               Two digit year
     * %Y      2038                      Four digit year
     * 
     * === Time ===                     
     * %H      00 through 23             Two digit representation of the hour in 24-hour format
     * %I      01 through 12             Two digit representation of the hour in 12-hour format
     * %l      1 through 12              Hour in 12-hour format, with a space preceeding single digits
     * %M      00 through 59             Two digit representation of the minute
     * %p      AM/PM                     UPPER-CASE 'AM' or 'PM' based on the given time
     * %P      am/pm                     lower-case 'am' or 'pm' based on the given time
     * %r      09:34:17 PM               Same as %I:%M:%S %p
     * %R      00:35                     Same as %H:%M
     * %S      00 through 59             Two digit representation of the second
     * %T      21:34:17                  Same as %H:%M:%S
     * %X      03:59:16                  Preferred time representation based on locale, without the date
     * %z      -0500 or EST              Either the time zone offset from UTC or the abbreviation
     * %Z      -0500 or EST              The time zone offset/abbreviation option NOT given by %z
     * 
     * === Time and Date ===            
     * %D      02/05/09                  Same as %m/%d/%y
     * %F      2009-02-05                Same as %Y-%m-%d (commonly used in database datestamps)
     * %s      305815200                 Unix Epoch Time timestamp (same as the time() function)
     * %x      02/05/09                  Preferred date representation, without the time
     * 
     * === Miscellaneous ===            
     * %n        ---                     A newline character (\n)
     * %t        ---                     A Tab character (\t)
     * %%        ---                     A literal percentage character (%)
     * </pre>
     */
 
    jsDate.formats.php = {
        codes: {
            //
            // 2-part regex matcher for format codes
            //
            // first match must be the character before the code (to account for escaping)
            // second match must be the format code character(s)
            //
            matcher: /()%((%|[a-z]))/i,
            // day
            a: 'AbbrDayName',
            A: 'DayName',
            d: 'Date.2',
            e: 'Date',
            j: 'DayOfYear.3',
            u: 'DayOfWeek',
            w: 'Day',
            // week
            U: 'FullWeekOfYear.2',
            V: 'IsoWeek.2',
            W: 'WeekOfYear.2',
            // month
            b: 'AbbrMonthName',
            B: 'MonthName',
            m: 'MonthNumber.2',
            h: 'AbbrMonthName',
            // year
            C: 'Century.2',
            y: 'ShortYear.2',
            Y: 'FullYear',
            // time
            H: 'Hours.2',
            I: 'Hours12.2',
            l: 'Hours12',
            p: 'AMPM',
            P: 'AmPm',
            M: 'Minutes.2',
            S: 'Seconds.2',
            s: 'Unix',
            O: 'TimezoneOffset',
            z: 'GmtOffset',
            Z: 'TimezoneAbbr'
        },
        
        shortcuts: {
            D: '%m/%d/%y',
            F: '%Y-%m-%d',
            T: '%H:%M:%S',
            X: '%H:%M:%S',
            x: '%m/%d/%y',
            R: '%H:%M',
            r: '%I:%M:%S %p',
            t: '\t',
            n: '\n',
            '%': '%'
        }
    };   
    //
    // Conceptually, the logic implemented here is similar to Ken Snyder's Date Instance Methods.
    // I use his idea of a set of parsers which can be regular expressions or functions,
    // iterating through those, and then seeing if Date.parse() will create a date.
    // The parser expressions and functions are a little different and some bugs have been
    // worked out.  Also, a lot of "pre-parsing" is done to fix implementation
    // variations of Date.parse() between browsers.
    //
    jsDate.createDate = function(date) {
        // if passing in multiple arguments, try Date constructor
        if (date == null) {
            return new Date();
        }
        // If the passed value is already a date object, return it
        if (date instanceof Date) {
            return date;
        }
        // if (typeof date == 'number') return new Date(date * 1000);
        // If the passed value is an integer, interpret it as a javascript timestamp
        if (typeof date == 'number') {
            return new Date(date);
        }
        
        // Before passing strings into Date.parse(), have to normalize them for certain conditions.
        // If strings are not formatted staccording to the EcmaScript spec, results from Date parse will be implementation dependent.  
        // 
        // For example: 
        //  * FF and Opera assume 2 digit dates are pre y2k, Chome assumes <50 is pre y2k, 50+ is 21st century.  
        //  * Chrome will correctly parse '1984-1-25' into localtime, FF and Opera will not parse.
        //  * Both FF, Chrome and Opera will parse '1984/1/25' into localtime.
        
        // remove leading and trailing spaces
        var parsable = String(date).replace(/^\s*(.+)\s*$/g, '$1');
        
        // replace dahses (-) with slashes (/) in dates like n[nnn]/n[n]/n[nnn]
        parsable = parsable.replace(/^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,4})/, "$1/$2/$3");
        
        /////////
        // Need to check for '15-Dec-09' also.
        // FF will not parse, but Chrome will.
        // Chrome will set date to 2009 as well.
        /////////
        
        // first check for 'dd-mmm-yyyy' or 'dd/mmm/yyyy' like '15-Dec-2010'
        parsable = parsable.replace(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{4})/i, "$1 $2 $3");
        
        // Now check for 'dd-mmm-yy' or 'dd/mmm/yy' and normalize years to default century.
        var match = parsable.match(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{2})\D*/i);
        if (match && match.length > 3) {
            var m3 = parseFloat(match[3]);
            var ny = jsDate.config.defaultCentury + m3;
            ny = String(ny);
            
            // now replace 2 digit year with 4 digit year
            parsable = parsable.replace(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{2})\D*/i, match[1] +' '+ match[2] +' '+ ny);
            
        }
        
        // Check for '1/19/70 8:14PM'
        // where starts with mm/dd/yy or yy/mm/dd and have something after
        // Check if 1st postiion is greater than 31, assume it is year.
        // Assme all 2 digit years are 1900's.
        // Finally, change them into US style mm/dd/yyyy representations.
        match = parsable.match(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})[^0-9]/);
        
        function h1(parsable, match) {
            var m1 = parseFloat(match[1]);
            var m2 = parseFloat(match[2]);
            var m3 = parseFloat(match[3]);
            var cent = jsDate.config.defaultCentury;
            var ny, nd, nm, str;
            
            if (m1 > 31) { // first number is a year
                nd = m3;
                nm = m2;
                ny = cent + m1;
            }
            
            else { // last number is the year
                nd = m2;
                nm = m1;
                ny = cent + m3;
            }
            
            str = nm+'/'+nd+'/'+ny;
            
            // now replace 2 digit year with 4 digit year
            return  parsable.replace(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})/, str);
        
        }
        
        if (match && match.length > 3) {
            parsable = h1(parsable, match);
        }
        
        // Now check for '1/19/70' with nothing after and do as above
        var match = parsable.match(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})$/);
        
        if (match && match.length > 3) {
            parsable = h1(parsable, match);
        }
                
        
        var i = 0;
        var length = jsDate.matchers.length;
        var pattern,
            ms,
            current = parsable,
            obj;
        while (i < length) {
            ms = Date.parse(current);
            if (!isNaN(ms)) {
                return new Date(ms);
            }
            pattern = jsDate.matchers[i];
            if (typeof pattern == 'function') {
                obj = pattern.call(jsDate, current);
                if (obj instanceof Date) {
                    return obj;
                }
            } else {
                current = parsable.replace(pattern[0], pattern[1]);
            }
            i++;
        }
        return NaN;
    };
    

    /**
     * @static
     * Handy static utility function to return the number of days in a given month.
     * @param {Integer} year Year
     * @param {Integer} month Month (1-12)
     * @returns {Integer} Number of days in the month.
    */
    //
    // handy utility method Borrowed right from Ken Snyder's Date Instance Mehtods.
    // 
    jsDate.daysInMonth = function(year, month) {
        if (month == 2) {
            return new Date(year, 1, 29).getDate() == 29 ? 29 : 28;
        }
        return [undefined,31,undefined,31,30,31,30,31,31,30,31,30,31][month];
    };


    //
    // An Array of regular expressions or functions that will attempt to match the date string.
    // Functions are called with scope of a jsDate instance.
    //
    jsDate.matchers = [
        // convert dd.mmm.yyyy to mm/dd/yyyy (world date to US date).
        [/(3[01]|[0-2]\d)\s*\.\s*(1[0-2]|0\d)\s*\.\s*([1-9]\d{3})/, '$2/$1/$3'],
        // convert yyyy-mm-dd to mm/dd/yyyy (ISO date to US date).
        [/([1-9]\d{3})\s*-\s*(1[0-2]|0\d)\s*-\s*(3[01]|[0-2]\d)/, '$2/$3/$1'],
        // Handle 12 hour or 24 hour time with milliseconds am/pm and optional date part.
        function(str) { 
            var match = str.match(/^(?:(.+)\s+)?([012]?\d)(?:\s*\:\s*(\d\d))?(?:\s*\:\s*(\d\d(\.\d*)?))?\s*(am|pm)?\s*$/i);
            //                   opt. date      hour       opt. minute     opt. second       opt. msec   opt. am or pm
            if (match) {
                if (match[1]) {
                    var d = this.createDate(match[1]);
                    if (isNaN(d)) {
                        return;
                    }
                } else {
                    var d = new Date();
                    d.setMilliseconds(0);
                }
                var hour = parseFloat(match[2]);
                if (match[6]) {
                    hour = match[6].toLowerCase() == 'am' ? (hour == 12 ? 0 : hour) : (hour == 12 ? 12 : hour + 12);
                }
                d.setHours(hour, parseInt(match[3] || 0, 10), parseInt(match[4] || 0, 10), ((parseFloat(match[5] || 0)) || 0)*1000);
                return d;
            }
            else {
                return str;
            }
        },
        // Handle ISO timestamp with time zone.
        function(str) {
            var match = str.match(/^(?:(.+))[T|\s+]([012]\d)(?:\:(\d\d))(?:\:(\d\d))(?:\.\d+)([\+\-]\d\d\:\d\d)$/i);
            if (match) {
                if (match[1]) {
                    var d = this.createDate(match[1]);
                    if (isNaN(d)) {
                        return;
                    }
                } else {
                    var d = new Date();
                    d.setMilliseconds(0);
                }
                var hour = parseFloat(match[2]);
                d.setHours(hour, parseInt(match[3], 10), parseInt(match[4], 10), parseFloat(match[5])*1000);
                return d;
            }
            else {
                    return str;
            }
        },
        // Try to match ambiguous strings like 12/8/22.
        // Use FF date assumption that 2 digit years are 20th century (i.e. 1900's).
        // This may be redundant with pre processing of date already performed.
        function(str) {
            var match = str.match(/^([0-3]?\d)\s*[-\/.\s]{1}\s*([a-zA-Z]{3,9})\s*[-\/.\s]{1}\s*([0-3]?\d)$/);
            if (match) {
                var d = new Date();
                var cent = jsDate.config.defaultCentury;
                var m1 = parseFloat(match[1]);
                var m3 = parseFloat(match[3]);
                var ny, nd, nm;
                if (m1 > 31) { // first number is a year
                    nd = m3;
                    ny = cent + m1;
                }
                
                else { // last number is the year
                    nd = m1;
                    ny = cent + m3;
                }
                
                var nm = inArray(match[2], jsDate.regional[jsDate.regional.getLocale()]["monthNamesShort"]);
                
                if (nm == -1) {
                    nm = inArray(match[2], jsDate.regional[jsDate.regional.getLocale()]["monthNames"]);
                }
            
                d.setFullYear(ny, nm, nd);
                d.setHours(0,0,0,0);
                return d;
            }
            
            else {
                return str;
            }
        }      
    ];

    //
    // I think John Reisig published this method on his blog, ejohn.
    //
    function inArray( elem, array ) {
        if ( array.indexOf ) {
            return array.indexOf( elem );
        }

        for ( var i = 0, length = array.length; i < length; i++ ) {
            if ( array[ i ] === elem ) {
                return i;
            }
        }

        return -1;
    }
    
    //
    // Thanks to Kangax, Christian Sciberras and Stack Overflow for this method.
    //
    function get_type(thing){
        if(thing===null) return "[object Null]"; // special case
        return Object.prototype.toString.call(thing);
    }
    
    $.jsDate = jsDate;

      
    /**
     * JavaScript printf/sprintf functions.
     * 
     * This code has been adapted from the publicly available sprintf methods
     * by Ash Searle. His original header follows:
     *
     *     This code is unrestricted: you are free to use it however you like.
     *     
     *     The functions should work as expected, performing left or right alignment,
     *     truncating strings, outputting numbers with a required precision etc.
     *
     *     For complex cases, these functions follow the Perl implementations of
     *     (s)printf, allowing arguments to be passed out-of-order, and to set the
     *     precision or length of the output based on arguments instead of fixed
     *     numbers.
     *
     *     See http://perldoc.perl.org/functions/sprintf.html for more information.
     *
     *     Implemented:
     *     - zero and space-padding
     *     - right and left-alignment,
     *     - base X prefix (binary, octal and hex)
     *     - positive number prefix
     *     - (minimum) width
     *     - precision / truncation / maximum width
     *     - out of order arguments
     *
     *     Not implemented (yet):
     *     - vector flag
     *     - size (bytes, words, long-words etc.)
     *     
     *     Will not implement:
     *     - %n or %p (no pass-by-reference in JavaScript)
     *
     *     @version 2007.04.27
     *     @author Ash Searle 
     * 
     * You can see the original work and comments on his blog:
     * http://hexmen.com/blog/2007/03/printf-sprintf/
     * http://hexmen.com/js/sprintf.js
     */
     
     /**
      * @Modifications 2009.05.26
      * @author Chris Leonello
      * 
      * Added %p %P specifier
      * Acts like %g or %G but will not add more significant digits to the output than present in the input.
      * Example:
      * Format: '%.3p', Input: 0.012, Output: 0.012
      * Format: '%.3g', Input: 0.012, Output: 0.0120
      * Format: '%.4p', Input: 12.0, Output: 12.0
      * Format: '%.4g', Input: 12.0, Output: 12.00
      * Format: '%.4p', Input: 4.321e-5, Output: 4.321e-5
      * Format: '%.4g', Input: 4.321e-5, Output: 4.3210e-5
      * 
      * Example:
      * >>> $.jqplot.sprintf('%.2f, %d', 23.3452, 43.23)
      * "23.35, 43"
      * >>> $.jqplot.sprintf("no value: %n, decimal with thousands separator: %'d", 23.3452, 433524)
      * "no value: , decimal with thousands separator: 433,524"
      */
    $.jqplot.sprintf = function() {
        function pad(str, len, chr, leftJustify) {
            var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);
            return leftJustify ? str + padding : padding + str;

        }

        function thousand_separate(value) {
            var value_str = new String(value);
            for (var i=10; i>0; i--) {
                if (value_str == (value_str = value_str.replace(/^(\d+)(\d{3})/, "$1"+$.jqplot.sprintf.thousandsSeparator+"$2"))) break;
            }
            return value_str; 
        }

        function justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace) {
            var diff = minWidth - value.length;
            if (diff > 0) {
                var spchar = ' ';
                if (htmlSpace) { spchar = '&nbsp;'; }
                if (leftJustify || !zeroPad) {
                    value = pad(value, minWidth, spchar, leftJustify);
                } else {
                    value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
                }
            }
            return value;
        }

        function formatBaseX(value, base, prefix, leftJustify, minWidth, precision, zeroPad, htmlSpace) {
            // Note: casts negative numbers to positive ones
            var number = value >>> 0;
            prefix = prefix && number && {'2': '0b', '8': '0', '16': '0x'}[base] || '';
            value = prefix + pad(number.toString(base), precision || 0, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);
        }

        function formatString(value, leftJustify, minWidth, precision, zeroPad, htmlSpace) {
            if (precision != null) {
                value = value.slice(0, precision);
            }
            return justify(value, '', leftJustify, minWidth, zeroPad, htmlSpace);
        }

        var a = arguments, i = 0, format = a[i++];

        return format.replace($.jqplot.sprintf.regex, function(substring, valueIndex, flags, minWidth, _, precision, type) {
            if (substring == '%%') { return '%'; }

            // parse flags
            var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false, htmlSpace = false, thousandSeparation = false;
            for (var j = 0; flags && j < flags.length; j++) switch (flags.charAt(j)) {
                case ' ': positivePrefix = ' '; break;
                case '+': positivePrefix = '+'; break;
                case '-': leftJustify = true; break;
                case '0': zeroPad = true; break;
                case '#': prefixBaseX = true; break;
                case '&': htmlSpace = true; break;
                case '\'': thousandSeparation = true; break;
            }

            // parameters may be null, undefined, empty-string or real valued
            // we want to ignore null, undefined and empty-string values

            if (!minWidth) {
                minWidth = 0;
            } 
            else if (minWidth == '*') {
                minWidth = +a[i++];
            } 
            else if (minWidth.charAt(0) == '*') {
                minWidth = +a[minWidth.slice(1, -1)];
            } 
            else {
                minWidth = +minWidth;
            }

            // Note: undocumented perl feature:
            if (minWidth < 0) {
                minWidth = -minWidth;
                leftJustify = true;
            }

            if (!isFinite(minWidth)) {
                throw new Error('$.jqplot.sprintf: (minimum-)width must be finite');
            }

            if (!precision) {
                precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : void(0);
            } 
            else if (precision == '*') {
                precision = +a[i++];
            } 
            else if (precision.charAt(0) == '*') {
                precision = +a[precision.slice(1, -1)];
            } 
            else {
                precision = +precision;
            }

            // grab value using valueIndex if required?
            var value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

            switch (type) {
            case 's': {
                if (value == null) {
                    return '';
                }
                return formatString(String(value), leftJustify, minWidth, precision, zeroPad, htmlSpace);
            }
            case 'c': return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case 'b': return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad,htmlSpace);
            case 'o': return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case 'x': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case 'X': return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace).toUpperCase();
            case 'u': return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);
            case 'i': {
              var number = parseInt(+value, 10);
              if (isNaN(number)) {
                return '';
              }
              var prefix = number < 0 ? '-' : positivePrefix;
              var number_str = thousandSeparation ? thousand_separate(String(Math.abs(number))): String(Math.abs(number));
              value = prefix + pad(number_str, precision, '0', false);
              //value = prefix + pad(String(Math.abs(number)), precision, '0', false);
              return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);
                  }
            case 'd': {
              var number = Math.round(+value);
              if (isNaN(number)) {
                return '';
              }
              var prefix = number < 0 ? '-' : positivePrefix;
              var number_str = thousandSeparation ? thousand_separate(String(Math.abs(number))): String(Math.abs(number));
              value = prefix + pad(number_str, precision, '0', false);
              return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);
                  }
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                      {
                      var number = +value;
                      if (isNaN(number)) {
                          return '';
                      }
                      var prefix = number < 0 ? '-' : positivePrefix;
                      var method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                      var textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                      var number_str = Math.abs(number)[method](precision);
                      
                      // Apply the decimal mark properly by splitting the number by the
                      //   decimalMark, applying thousands separator, and then placing it
                      //   back in.
                      var parts = number_str.toString().split('.');
                      parts[0] = thousandSeparation ? thousand_separate(parts[0]) : parts[0];
                      number_str = parts.join($.jqplot.sprintf.decimalMark);
                      
                      value = prefix + number_str;
                      var justified = justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace)[textTransform]();
                      
                      return justified;
                  }
            case 'p':
            case 'P':
            {
                // make sure number is a number
                var number = +value;
                if (isNaN(number)) {
                    return '';
                }
                var prefix = number < 0 ? '-' : positivePrefix;

                var parts = String(Number(Math.abs(number)).toExponential()).split(/e|E/);
                var sd = (parts[0].indexOf('.') != -1) ? parts[0].length - 1 : String(number).length;
                var zeros = (parts[1] < 0) ? -parts[1] - 1 : 0;
                
                if (Math.abs(number) < 1) {
                    if (sd + zeros  <= precision) {
                        value = prefix + Math.abs(number).toPrecision(sd);
                    }
                    else {
                        if (sd  <= precision - 1) {
                            value = prefix + Math.abs(number).toExponential(sd-1);
                        }
                        else {
                            value = prefix + Math.abs(number).toExponential(precision-1);
                        }
                    }
                }
                else {
                    var prec = (sd <= precision) ? sd : precision;
                    value = prefix + Math.abs(number).toPrecision(prec);
                }
                var textTransform = ['toString', 'toUpperCase']['pP'.indexOf(type) % 2];
                return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace)[textTransform]();
            }
            case 'n': return '';
            default: return substring;
            }
        });
    };

    $.jqplot.sprintf.thousandsSeparator = ',';
    // Specifies the decimal mark for floating point values. By default a period '.'
    // is used. If you change this value to for example a comma be sure to also
    // change the thousands separator or else this won't work since a simple String
    // replace is used (replacing all periods with the mark specified here).
    $.jqplot.sprintf.decimalMark = '.';
    
    $.jqplot.sprintf.regex = /%%|%(\d+\$)?([-+#0&\' ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([nAscboxXuidfegpEGP])/g;

    $.jqplot.getSignificantFigures = function(number) {
        var parts = String(Number(Math.abs(number)).toExponential()).split(/e|E/);
        // total significant digits
        var sd = (parts[0].indexOf('.') != -1) ? parts[0].length - 1 : parts[0].length;
        var zeros = (parts[1] < 0) ? -parts[1] - 1 : 0;
        // exponent
        var expn = parseInt(parts[1], 10);
        // digits to the left of the decimal place
        var dleft = (expn + 1 > 0) ? expn + 1 : 0;
        // digits to the right of the decimal place
        var dright = (sd <= dleft) ? 0 : sd - expn - 1;
        return {significantDigits: sd, digitsLeft: dleft, digitsRight: dright, zeros: zeros, exponent: expn} ;
    };

    $.jqplot.getPrecision = function(number) {
        return $.jqplot.getSignificantFigures(number).digitsRight;
    };

  


    var backCompat = $.uiBackCompat !== false;

    $.jqplot.effects = {
        effect: {}
    };

    // prefix used for storing data on .data()
    var dataSpace = "jqplot.storage.";

    /******************************************************************************/
    /*********************************** EFFECTS **********************************/
    /******************************************************************************/

    $.extend( $.jqplot.effects, {
        version: "1.9pre",

        // Saves a set of properties in a data storage
        save: function( element, set ) {
            for( var i=0; i < set.length; i++ ) {
                if ( set[ i ] !== null ) {
                    element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
                }
            }
        },

        // Restores a set of previously saved properties from a data storage
        restore: function( element, set ) {
            for( var i=0; i < set.length; i++ ) {
                if ( set[ i ] !== null ) {
                    element.css( set[ i ], element.data( dataSpace + set[ i ] ) );
                }
            }
        },

        setMode: function( el, mode ) {
            if (mode === "toggle") {
                mode = el.is( ":hidden" ) ? "show" : "hide";
            }
            return mode;
        },

        // Wraps the element around a wrapper that copies position properties
        createWrapper: function( element ) {

            // if the element is already wrapped, return it
            if ( element.parent().is( ".ui-effects-wrapper" )) {
                return element.parent();
            }

            // wrap the element
            var props = {
                    width: element.outerWidth(true),
                    height: element.outerHeight(true),
                    "float": element.css( "float" )
                },
                wrapper = $( "<div></div>" )
                    .addClass( "ui-effects-wrapper" )
                    .css({
                        fontSize: "100%",
                        background: "transparent",
                        border: "none",
                        margin: 0,
                        padding: 0
                    }),
                // Store the size in case width/height are defined in % - Fixes #5245
                size = {
                    width: element.width(),
                    height: element.height()
                },
                active = document.activeElement;

            element.wrap( wrapper );

            // Fixes #7595 - Elements lose focus when wrapped.
            if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
                $( active ).focus();
            }

            wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element

            // transfer positioning properties to the wrapper
            if ( element.css( "position" ) === "static" ) {
                wrapper.css({ position: "relative" });
                element.css({ position: "relative" });
            } else {
                $.extend( props, {
                    position: element.css( "position" ),
                    zIndex: element.css( "z-index" )
                });
                $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                    props[ pos ] = element.css( pos );
                    if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
                        props[ pos ] = "auto";
                    }
                });
                element.css({
                    position: "relative",
                    top: 0,
                    left: 0,
                    right: "auto",
                    bottom: "auto"
                });
            }
            element.css(size);

            return wrapper.css( props ).show();
        },

        removeWrapper: function( element ) {
            var active = document.activeElement;

            if ( element.parent().is( ".ui-effects-wrapper" ) ) {
                element.parent().replaceWith( element );

                // Fixes #7595 - Elements lose focus when wrapped.
                if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
                    $( active ).focus();
                }
            }


            return element;
        }
    });

    // return an effect options object for the given parameters:
    function _normalizeArguments( effect, options, speed, callback ) {

        // short path for passing an effect options object:
        if ( $.isPlainObject( effect ) ) {
            return effect;
        }

        // convert to an object
        effect = { effect: effect };

        // catch (effect)
        if ( options === undefined ) {
            options = {};
        }

        // catch (effect, callback)
        if ( $.isFunction( options ) ) {
            callback = options;
            speed = null;
            options = {};
        }

        // catch (effect, speed, ?)
        if ( $.type( options ) === "number" || $.fx.speeds[ options ]) {
            callback = speed;
            speed = options;
            options = {};
        }

        // catch (effect, options, callback)
        if ( $.isFunction( speed ) ) {
            callback = speed;
            speed = null;
        }

        // add options to effect
        if ( options ) {
            $.extend( effect, options );
        }

        speed = speed || options.duration;
        effect.duration = $.fx.off ? 0 : typeof speed === "number"
            ? speed : speed in $.fx.speeds ? $.fx.speeds[ speed ] : $.fx.speeds._default;

        effect.complete = callback || options.complete;

        return effect;
    }

    function standardSpeed( speed ) {
        // valid standard speeds
        if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
            return true;
        }

        // invalid strings - treat as "normal" speed
        if ( typeof speed === "string" && !$.jqplot.effects.effect[ speed ] ) {
            // TODO: remove in 2.0 (#7115)
            if ( backCompat && $.jqplot.effects[ speed ] ) {
                return false;
            }
            return true;
        }

        return false;
    }

    $.fn.extend({
        jqplotEffect: function( effect, options, speed, callback ) {
            var args = _normalizeArguments.apply( this, arguments ),
                mode = args.mode,
                queue = args.queue,
                effectMethod = $.jqplot.effects.effect[ args.effect ],

                // DEPRECATED: remove in 2.0 (#7115)
                oldEffectMethod = !effectMethod && backCompat && $.jqplot.effects[ args.effect ];

            if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {
                // delegate to the original method (e.g., .show()) if possible
                if ( mode ) {
                    return this[ mode ]( args.duration, args.complete );
                } else {
                    return this.each( function() {
                        if ( args.complete ) {
                            args.complete.call( this );
                        }
                    });
                }
            }

            function run( next ) {
                var elem = $( this ),
                    complete = args.complete,
                    mode = args.mode;

                function done() {
                    if ( $.isFunction( complete ) ) {
                        complete.call( elem[0] );
                    }
                    if ( $.isFunction( next ) ) {
                        next();
                    }
                }

                // if the element is hiddden and mode is hide,
                // or element is visible and mode is show
                if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
                    done();
                } else {
                    effectMethod.call( elem[0], args, done );
                }
            }

            // TODO: remove this check in 2.0, effectMethod will always be true
            if ( effectMethod ) {
                return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
            } else {
                // DEPRECATED: remove in 2.0 (#7115)
                return oldEffectMethod.call(this, {
                    options: args,
                    duration: args.duration,
                    callback: args.complete,
                    mode: args.mode
                });
            }
        }
    });




    var rvertical = /up|down|vertical/,
        rpositivemotion = /up|left|vertical|horizontal/;

    $.jqplot.effects.effect.blind = function( o, done ) {
        // Create element
        var el = $( this ),
            props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
            mode = $.jqplot.effects.setMode( el, o.mode || "hide" ),
            direction = o.direction || "up",
            vertical = rvertical.test( direction ),
            ref = vertical ? "height" : "width",
            ref2 = vertical ? "top" : "left",
            motion = rpositivemotion.test( direction ),
            animation = {},
            show = mode === "show",
            wrapper, distance, top;

        // // if already wrapped, the wrapper's properties are my property. #6245
        if ( el.parent().is( ".ui-effects-wrapper" ) ) {
            $.jqplot.effects.save( el.parent(), props );
        } else {
            $.jqplot.effects.save( el, props );
        }
        el.show();
        top = parseInt(el.css('top'), 10);
        wrapper = $.jqplot.effects.createWrapper( el ).css({
            overflow: "hidden"
        });

        distance = vertical ? wrapper[ ref ]() + top : wrapper[ ref ]();

        animation[ ref ] = show ? String(distance) : '0';
        if ( !motion ) {
            el
                .css( vertical ? "bottom" : "right", 0 )
                .css( vertical ? "top" : "left", "" )
                .css({ position: "absolute" });
            animation[ ref2 ] = show ? '0' : String(distance);
        }

        // // start at 0 if we are showing
        if ( show ) {
            wrapper.css( ref, 0 );
            if ( ! motion ) {
                wrapper.css( ref2, distance );
            }
        }

        // // Animate
        wrapper.animate( animation, {
            duration: o.duration,
            easing: o.easing,
            queue: false,
            complete: function() {
                if ( mode === "hide" ) {
                    el.hide();
                }
                $.jqplot.effects.restore( el, props );
                $.jqplot.effects.removeWrapper( el );
                done();
            }
        });

    };
		
		// Apply enhancement - Roy (2014-04-09)
	  var enhanceFunctions = {'Axis': Axis, 'Series': Series, 'jqPlot': jqPlot};
	  
    $.jqplot.applyEnhance = function(newFunctions) {
    	var getName = function(func) {
			  var ret = func.toString();
			  ret = ret.substr('function '.length);
			  ret = ret.substr(0, ret.indexOf('('));
			  return ret;
			};
			
  		var ret = {};
      $.each(newFunctions, function(key, enhancedFunction){
      	var enhancedName = getName(enhancedFunction);
          if (0 > $.inArray(key, Object.keys(enhanceFunctions))) {
          	ret[enhancedName] = enhanceFunctions[key];
          } else {
          	temp = function() {
	              enhanceFunctions[key].apply(this, arguments);
	              enhancedFunction.apply(this, arguments);
	          };
	          temp.prototype = $.extend(true, enhanceFunctions[key].prototype, enhancedFunction.prototype);
	          temp.constructor = enhanceFunctions[key];
	          eval(getName(enhanceFunctions[key])+' = temp;');
	          ret[enhancedName] = temp;
          }
      });
      
      return ret;
    };
})(jQuery);

/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function($) {
    
    // Class: $.jqplot.BarRenderer
    // A plugin renderer for jqPlot to draw a bar plot.
    // Draws series as a line.
    
    $.jqplot.BarRenderer = function(){
        $.jqplot.LineRenderer.call(this);
    };
    
    $.jqplot.BarRenderer.prototype = new $.jqplot.LineRenderer();
    $.jqplot.BarRenderer.prototype.constructor = $.jqplot.BarRenderer;
    
    // called with scope of series.
    $.jqplot.BarRenderer.prototype.init = function(options, plot) {
        // Group: Properties
        //
        // prop: barPadding
        // Number of pixels between adjacent bars at the same axis value.
        this.barPadding = 8;
        // prop: barMargin
        // Number of pixels between groups of bars at adjacent axis values.
        this.barMargin = 10;
        // prop: barDirection
        // 'vertical' = up and down bars, 'horizontal' = side to side bars
        this.barDirection = 'vertical';
        // prop: barWidth
        // Width of the bar in pixels (auto by devaul).  null = calculated automatically.
        this.barWidth = null;
        // prop: shadowOffset
        // offset of the shadow from the slice and offset of 
        // each succesive stroke of the shadow from the last.
        this.shadowOffset = 2;
        // prop: shadowDepth
        // number of strokes to apply to the shadow, 
        // each stroke offset shadowOffset from the last.
        this.shadowDepth = 5;
        // prop: shadowAlpha
        // transparency of the shadow (0 = transparent, 1 = opaque)
        this.shadowAlpha = 0.08;
        // prop: waterfall
        // true to enable waterfall plot.
        this.waterfall = false;
        // prop: groups
        // group bars into this many groups
        this.groups = 1;
        // prop: varyBarColor
        // true to color each bar of a series separately rather than
        // have every bar of a given series the same color.
        // If used for non-stacked multiple series bar plots, user should
        // specify a separate 'seriesColors' array for each series.
        // Otherwise, each series will set their bars to the same color array.
        // This option has no Effect for stacked bar charts and is disabled.
        this.varyBarColor = false;
        // prop: highlightMouseOver
        // True to highlight slice when moused over.
        // This must be false to enable highlightMouseDown to highlight when clicking on a slice.
        this.highlightMouseOver = true;
        // prop: highlightMouseDown
        // True to highlight when a mouse button is pressed over a slice.
        // This will be disabled if highlightMouseOver is true.
        this.highlightMouseDown = false;
        // prop: highlightColors
        // an array of colors to use when highlighting a bar.
        this.highlightColors = [];
        // prop: transposedData
        // NOT IMPLEMENTED YET.  True if this is a horizontal bar plot and 
        // x and y values are "transposed".  Tranposed, or "swapped", data is 
        // required prior to rev. 894 builds of jqPlot with horizontal bars. 
        // Allows backward compatability of bar renderer horizontal bars with 
        // old style data sets.
        this.transposedData = true;
        this.renderer.animation = {
            show: false,
            direction: 'down',
            speed: 3000,
            _supported: true
        };
        this._type = 'bar';
        
        // if user has passed in highlightMouseDown option and not set highlightMouseOver, disable highlightMouseOver
        if (options.highlightMouseDown && options.highlightMouseOver == null) {
            options.highlightMouseOver = false;
        }
        
        //////
        // This is probably wrong here.
        // After going back and forth on whether renderer should be the thing
        // or extend the thing, it seems that it it best if it is a property
        // on the thing.  This should be something that is commonized 
        // among series renderers in the future.
        //////
        $.extend(true, this, options);

        // really should probably do this
        $.extend(true, this.renderer, options);
        // fill is still needed to properly draw the legend.
        // bars have to be filled.
        this.fill = true;

        // if horizontal bar and animating, reset the default direction
        if (this.barDirection === 'horizontal' && this.rendererOptions.animation && this.rendererOptions.animation.direction == null) {
            this.renderer.animation.direction = 'left';
        }
        
        if (this.waterfall) {
            this.fillToZero = false;
            this.disableStack = true;
        }
        
        if (this.barDirection == 'vertical' ) {
            this._primaryAxis = '_xaxis';
            this._stackAxis = 'y';
            this.fillAxis = 'y';
        }
        else {
            this._primaryAxis = '_yaxis';
            this._stackAxis = 'x';
            this.fillAxis = 'x';
        }
        // index of the currenty highlighted point, if any
        this._highlightedPoint = null;
        // total number of values for all bar series, total number of bar series, and position of this series
        this._plotSeriesInfo = null;
        // Array of actual data colors used for each data point.
        this._dataColors = [];
        this._barPoints = [];
        
        // set the shape renderer options
        var opts = {lineJoin:'miter', lineCap:'round', fill:true, isarc:false, strokeStyle:this.color, fillStyle:this.color, closePath:this.fill};
        this.renderer.shapeRenderer.init(opts);
        // set the shadow renderer options
        var sopts = {lineJoin:'miter', lineCap:'round', fill:true, isarc:false, angle:this.shadowAngle, offset:this.shadowOffset, alpha:this.shadowAlpha, depth:this.shadowDepth, closePath:this.fill};
        this.renderer.shadowRenderer.init(sopts);
        
        plot.postInitHooks.addOnce(postInit);
        plot.postDrawHooks.addOnce(postPlotDraw);
        plot.eventListenerHooks.addOnce('jqplotMouseMove', handleMove);
        plot.eventListenerHooks.addOnce('jqplotMouseDown', handleMouseDown);
        plot.eventListenerHooks.addOnce('jqplotMouseUp', handleMouseUp);
        plot.eventListenerHooks.addOnce('jqplotClick', handleClick);
        plot.eventListenerHooks.addOnce('jqplotRightClick', handleRightClick); 
    };
    
    // called with scope of series
    function barPreInit(target, data, seriesDefaults, options) {
        if (this.rendererOptions.barDirection == 'horizontal') {
            this._stackAxis = 'x';
            this._primaryAxis = '_yaxis';
        }
        if (this.rendererOptions.waterfall == true) {
            this._data = $.extend(true, [], this.data);
            var sum = 0;
            var pos = (!this.rendererOptions.barDirection || this.rendererOptions.barDirection === 'vertical' || this.transposedData === false) ? 1 : 0;
            for(var i=0; i<this.data.length; i++) {
                sum += this.data[i][pos];
                if (i>0) {
                    this.data[i][pos] += this.data[i-1][pos];
                }
            }
            this.data[this.data.length] = (pos == 1) ? [this.data.length+1, sum] : [sum, this.data.length+1];
            this._data[this._data.length] = (pos == 1) ? [this._data.length+1, sum] : [sum, this._data.length+1];
        }
        if (this.rendererOptions.groups > 1) {
            this.breakOnNull = true;
            var l = this.data.length;
            var skip = parseInt(l/this.rendererOptions.groups, 10);
            var count = 0;
            for (var i=skip; i<l; i+=skip) {
                this.data.splice(i+count, 0, [null, null]);
                this._plotData.splice(i+count, 0, [null, null]);
                this._stackData.splice(i+count, 0, [null, null]);
                count++;
            }
            for (i=0; i<this.data.length; i++) {
                if (this._primaryAxis == '_xaxis') {
                    this.data[i][0] = i+1;
                    this._plotData[i][0] = i+1;
                    this._stackData[i][0] = i+1;
                }
                else {
                    this.data[i][1] = i+1;
                    this._plotData[i][1] = i+1;
                    this._stackData[i][1] = i+1;
                }
            }
        }
    }
    
    $.jqplot.preSeriesInitHooks.push(barPreInit);
    
    // needs to be called with scope of series, not renderer.
    $.jqplot.BarRenderer.prototype.calcSeriesNumbers = function() {
        var nvals = 0;
        var nseries = 0;
        var paxis = this[this._primaryAxis];
        var s, series, pos;
        // loop through all series on this axis
        for (var i=0; i < paxis._series.length; i++) {
            series = paxis._series[i];
            if (series === this) {
                pos = i;
            }
            // is the series rendered as a bar?
            if (series.renderer.constructor == $.jqplot.BarRenderer) {
                // gridData may not be computed yet, use data length insted
                nvals += series.data.length;
                nseries += 1;
            }
        }
        // return total number of values for all bar series, total number of bar series, and position of this series
        return [nvals, nseries, pos];
    };

    $.jqplot.BarRenderer.prototype.setBarWidth = function() {
        // need to know how many data values we have on the approprate axis and figure it out.
        var i;
        var nvals = 0;
        var nseries = 0;
        var paxis = this[this._primaryAxis];
        var s, series, pos;
        var temp = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this);
        nvals = temp[0];
        nseries = temp[1];
        var nticks = paxis.numberTicks;
        var nbins = (nticks-1)/2;
        // so, now we have total number of axis values.
        if (paxis.name == 'xaxis' || paxis.name == 'x2axis') {
            if (this._stack) {
                this.barWidth = (paxis._offsets.max - paxis._offsets.min) / nvals * nseries - this.barMargin;
            }
            else {
                this.barWidth = ((paxis._offsets.max - paxis._offsets.min)/nbins  - this.barPadding * (nseries-1) - this.barMargin*2)/nseries;
                // this.barWidth = (paxis._offsets.max - paxis._offsets.min) / nvals - this.barPadding - this.barMargin/nseries;
            }
        }
        else {
            if (this._stack) {
                this.barWidth = (paxis._offsets.min - paxis._offsets.max) / nvals * nseries - this.barMargin;
            }
            else {
                this.barWidth = ((paxis._offsets.min - paxis._offsets.max)/nbins  - this.barPadding * (nseries-1) - this.barMargin*2)/nseries;
                // this.barWidth = (paxis._offsets.min - paxis._offsets.max) / nvals - this.barPadding - this.barMargin/nseries;
            }
        }
        return [nvals, nseries];
    };

    function computeHighlightColors (colors) {
        var ret = [];
        for (var i=0; i<colors.length; i++){
            var rgba = $.jqplot.getColorComponents(colors[i]);
            var newrgb = [rgba[0], rgba[1], rgba[2]];
            var sum = newrgb[0] + newrgb[1] + newrgb[2];
            for (var j=0; j<3; j++) {
                // when darkening, lowest color component can be is 60.
                newrgb[j] = (sum > 570) ?  newrgb[j] * 0.8 : newrgb[j] + 0.3 * (255 - newrgb[j]);
                newrgb[j] = parseInt(newrgb[j], 10);
            }
            ret.push('rgb('+newrgb[0]+','+newrgb[1]+','+newrgb[2]+')');
        }
        return ret;
    }

    function getStart(sidx, didx, comp, plot, axis) {
        // check if sign change
        var seriesIndex = sidx,
            prevSeriesIndex = sidx - 1,
            start,
            prevVal,
            aidx = (axis === 'x') ? 0 : 1;

        // is this not the first series?
        if (seriesIndex > 0) {
            prevVal = plot.series[prevSeriesIndex]._plotData[didx][aidx];

            // is there a sign change
            if ((comp * prevVal) < 0) {
                start = getStart(prevSeriesIndex, didx, comp, plot, axis);
            }

            // no sign change.
            else {
                start = plot.series[prevSeriesIndex].gridData[didx][aidx];
            }

        }

        // if first series, return value at 0
        else {

            start = (aidx === 0) ? plot.series[seriesIndex]._xaxis.series_u2p(0) : plot.series[seriesIndex]._yaxis.series_u2p(0);
        }

        return start;
    }

    
    $.jqplot.BarRenderer.prototype.draw = function(ctx, gridData, options, plot) {
        var i;
        // Ughhh, have to make a copy of options b/c it may be modified later.
        var opts = $.extend({}, options);
        var shadow = (opts.shadow != undefined) ? opts.shadow : this.shadow;
        var showLine = (opts.showLine != undefined) ? opts.showLine : this.showLine;
        var fill = (opts.fill != undefined) ? opts.fill : this.fill;
        var xaxis = this.xaxis;
        var yaxis = this.yaxis;
        var xp = this._xaxis.series_u2p;
        var yp = this._yaxis.series_u2p;
        var pointx, pointy;
        // clear out data colors.
        this._dataColors = [];
        this._barPoints = [];
        
        if (this.barWidth == null) {
            this.renderer.setBarWidth.call(this);
        }
        
        var temp = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this);
        var nvals = temp[0];
        var nseries = temp[1];
        var pos = temp[2];
        var points = [];
        
        if (this._stack) {
            this._barNudge = 0;
        }
        else {
            this._barNudge = (-Math.abs(nseries/2 - 0.5) + pos) * (this.barWidth + this.barPadding);
        }
        if (showLine) {
            var negativeColors = new $.jqplot.ColorGenerator(this.negativeSeriesColors);
            var positiveColors = new $.jqplot.ColorGenerator(this.seriesColors);
            var negativeColor = negativeColors.get(this.index);
            if (! this.useNegativeColors) {
                negativeColor = opts.fillStyle;
            }
            var positiveColor = opts.fillStyle;
            var base;
            var xstart; 
            var ystart;
            
            if (this.barDirection == 'vertical') {
                for (var i=0; i<gridData.length; i++) {
                    if (!this._stack && this.data[i][1] == null) {
                        continue;
                    }
                    points = [];
                    base = gridData[i][0] + this._barNudge;
                    
                    // stacked
                    if (this._stack && this._prevGridData.length) {
                        ystart = getStart(this.index, i, this._plotData[i][1], plot, 'y');
                    }

                    // not stacked
                    else {
                        if (this.fillToZero) {
                            ystart = this._yaxis.series_u2p(0);
                        }
                        else if (this.waterfall && i > 0 && i < this.gridData.length-1) {
                            ystart = this.gridData[i-1][1];
                        }
                        else if (this.waterfall && i == 0 && i < this.gridData.length-1) {
                            if (this._yaxis.min <= 0 && this._yaxis.max >= 0) {
                                ystart = this._yaxis.series_u2p(0);
                            }
                            else if (this._yaxis.min > 0) {
                                ystart = ctx.canvas.height;
                            }
                            else {
                                ystart = 0;
                            }
                        }
                        else if (this.waterfall && i == this.gridData.length - 1) {
                            if (this._yaxis.min <= 0 && this._yaxis.max >= 0) {
                                ystart = this._yaxis.series_u2p(0);
                            }
                            else if (this._yaxis.min > 0) {
                                ystart = ctx.canvas.height;
                            }
                            else {
                                ystart = 0;
                            }
                        }
                        else {
                            ystart = ctx.canvas.height;
                        }
                    }
                    if ((this.fillToZero && this._plotData[i][1] < 0) || (this.waterfall && this._data[i][1] < 0)) {
                        if (this.varyBarColor && !this._stack) {
                            if (this.useNegativeColors) {
                                opts.fillStyle = negativeColors.next();
                            }
                            else {
                                opts.fillStyle = positiveColors.next();
                            }
                        }
                        else {
                            opts.fillStyle = negativeColor;
                        }
                    }
                    else {
                        if (this.varyBarColor && !this._stack) {
                            opts.fillStyle = positiveColors.next();
                        }
                        else {
                            opts.fillStyle = positiveColor;
                        }
                    }
                    
                    if (!this.fillToZero || this._plotData[i][1] >= 0) { 
                        points.push([base-this.barWidth/2, ystart]);
                        points.push([base-this.barWidth/2, gridData[i][1]]);
                        points.push([base+this.barWidth/2, gridData[i][1]]);
                        points.push([base+this.barWidth/2, ystart]);
                    }
                    // for negative bars make sure points are always ordered clockwise
                    else {              
                        points.push([base-this.barWidth/2, gridData[i][1]]);
                        points.push([base-this.barWidth/2, ystart]);
                        points.push([base+this.barWidth/2, ystart]);
                        points.push([base+this.barWidth/2, gridData[i][1]]);
                    }
                    this._barPoints.push(points);
                    // now draw the shadows if not stacked.
                    // for stacked plots, they are predrawn by drawShadow
                    if (shadow && !this._stack) {
                        var sopts = $.extend(true, {}, opts);
                        // need to get rid of fillStyle on shadow.
                        delete sopts.fillStyle;
                        this.renderer.shadowRenderer.draw(ctx, points, sopts);
                    }
                    var clr = opts.fillStyle || this.color;
                    this._dataColors.push(clr);
                    this.renderer.shapeRenderer.draw(ctx, points, opts); 
                }
            }
            
            else if (this.barDirection == 'horizontal'){
                for (var i=0; i<gridData.length; i++) {
                    if (!this._stack && this.data[i][0] == null) {
                        continue;
                    }
                    points = [];
                    base = gridData[i][1] - this._barNudge;
                    xstart;
                    
                    if (this._stack && this._prevGridData.length) {
                        xstart = getStart(this.index, i, this._plotData[i][0], plot, 'x');
                    }
                    // not stacked
                    else {
                        if (this.fillToZero) {
                            xstart = this._xaxis.series_u2p(0);
                        }
                        else if (this.waterfall && i > 0 && i < this.gridData.length-1) {
                            xstart = this.gridData[i-1][0];
                        }
                        else if (this.waterfall && i == 0 && i < this.gridData.length-1) {
                            if (this._xaxis.min <= 0 && this._xaxis.max >= 0) {
                                xstart = this._xaxis.series_u2p(0);
                            }
                            else if (this._xaxis.min > 0) {
                                xstart = 0;
                            }
                            else {
                                xstart = 0;
                            }
                        }
                        else if (this.waterfall && i == this.gridData.length - 1) {
                            if (this._xaxis.min <= 0 && this._xaxis.max >= 0) {
                                xstart = this._xaxis.series_u2p(0);
                            }
                            else if (this._xaxis.min > 0) {
                                xstart = 0;
                            }
                            else {
                                xstart = ctx.canvas.width;
                            }
                        }
                        else {
                            xstart = 0;
                        }
                    }
                    if ((this.fillToZero && this._plotData[i][0] < 0) || (this.waterfall && this._data[i][0] < 0)) {
                        if (this.varyBarColor && !this._stack) {
                            if (this.useNegativeColors) {
                                opts.fillStyle = negativeColors.next();
                            }
                            else {
                                opts.fillStyle = positiveColors.next();
                            }
                        }
                        else {
                            opts.fillStyle = negativeColor;
                        }
                    }
                    else {
                        if (this.varyBarColor && !this._stack) {
                            opts.fillStyle = positiveColors.next();
                        }
                        else {
                            opts.fillStyle = positiveColor;
                        }                    
                    }
                    

                    if (!this.fillToZero || this._plotData[i][0] >= 0) {
                        points.push([xstart, base + this.barWidth / 2]);
                        points.push([xstart, base - this.barWidth / 2]);
                        points.push([gridData[i][0], base - this.barWidth / 2]);
                        points.push([gridData[i][0], base + this.barWidth / 2]);
                    }
                    else {
                        points.push([gridData[i][0], base + this.barWidth / 2]);
                        points.push([gridData[i][0], base - this.barWidth / 2]);
                        points.push([xstart, base - this.barWidth / 2]);
                        points.push([xstart, base + this.barWidth / 2]);
                    }

                    this._barPoints.push(points);
                    // now draw the shadows if not stacked.
                    // for stacked plots, they are predrawn by drawShadow
                    if (shadow && !this._stack) {
                        var sopts = $.extend(true, {}, opts);
                        delete sopts.fillStyle;
                        this.renderer.shadowRenderer.draw(ctx, points, sopts);
                    }
                    var clr = opts.fillStyle || this.color;
                    this._dataColors.push(clr);
                    this.renderer.shapeRenderer.draw(ctx, points, opts);
                } 
            }
        }                
        
        if (this.highlightColors.length == 0) {
            this.highlightColors = $.jqplot.computeHighlightColors(this._dataColors);
        }
        
        else if (typeof(this.highlightColors) == 'string') {
            var temp = this.highlightColors;
            this.highlightColors = [];
            for (var i=0; i<this._dataColors.length; i++) {
                this.highlightColors.push(temp);
            }
        }
        
    };
    
     
    // for stacked plots, shadows will be pre drawn by drawShadow.
    $.jqplot.BarRenderer.prototype.drawShadow = function(ctx, gridData, options, plot) {
        var i;
        var opts = (options != undefined) ? options : {};
        var shadow = (opts.shadow != undefined) ? opts.shadow : this.shadow;
        var showLine = (opts.showLine != undefined) ? opts.showLine : this.showLine;
        var fill = (opts.fill != undefined) ? opts.fill : this.fill;
        var xaxis = this.xaxis;
        var yaxis = this.yaxis;
        var xp = this._xaxis.series_u2p;
        var yp = this._yaxis.series_u2p;
        var pointx, points, pointy, nvals, nseries, pos;
        
        if (this._stack && this.shadow) {
            if (this.barWidth == null) {
                this.renderer.setBarWidth.call(this);
            }
        
            var temp = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this);
            nvals = temp[0];
            nseries = temp[1];
            pos = temp[2];
        
            if (this._stack) {
                this._barNudge = 0;
            }
            else {
                this._barNudge = (-Math.abs(nseries/2 - 0.5) + pos) * (this.barWidth + this.barPadding);
            }
            if (showLine) {
            
                if (this.barDirection == 'vertical') {
                    for (var i=0; i<gridData.length; i++) {
                        if (this.data[i][1] == null) {
                            continue;
                        }
                        points = [];
                        var base = gridData[i][0] + this._barNudge;
                        var ystart;
                    
                        if (this._stack && this._prevGridData.length) {
                            ystart = getStart(this.index, i, this._plotData[i][1], plot, 'y');
                        }
                        else {
                            if (this.fillToZero) {
                                ystart = this._yaxis.series_u2p(0);
                            }
                            else {
                                ystart = ctx.canvas.height;
                            }
                        }
                    
                        points.push([base-this.barWidth/2, ystart]);
                        points.push([base-this.barWidth/2, gridData[i][1]]);
                        points.push([base+this.barWidth/2, gridData[i][1]]);
                        points.push([base+this.barWidth/2, ystart]);
                        this.renderer.shadowRenderer.draw(ctx, points, opts);
                    }
                }
            
                else if (this.barDirection == 'horizontal'){
                    for (var i=0; i<gridData.length; i++) {
                        if (this.data[i][0] == null) {
                            continue;
                        }
                        points = [];
                        var base = gridData[i][1] - this._barNudge;
                        var xstart;
                    
                        if (this._stack && this._prevGridData.length) {
                            xstart = getStart(this.index, i, this._plotData[i][0], plot, 'x');
                        }
                        else {
                            if (this.fillToZero) {
                                xstart = this._xaxis.series_u2p(0);
                            }
                            else {
                                xstart = 0;
                            }
                        }
                    
                        points.push([xstart, base+this.barWidth/2]);
                        points.push([gridData[i][0], base+this.barWidth/2]);
                        points.push([gridData[i][0], base-this.barWidth/2]);
                        points.push([xstart, base-this.barWidth/2]);
                        this.renderer.shadowRenderer.draw(ctx, points, opts);
                    }  
                }
            }   
            
        }
    };
    
    function postInit(target, data, options) {
        for (var i=0; i<this.series.length; i++) {
            if (this.series[i].renderer.constructor == $.jqplot.BarRenderer) {
                // don't allow mouseover and mousedown at same time.
                if (this.series[i].highlightMouseOver) {
                    this.series[i].highlightMouseDown = false;
                }
            }
        }
    }
    
    // called within context of plot
    // create a canvas which we can draw on.
    // insert it before the eventCanvas, so eventCanvas will still capture events.
    function postPlotDraw() {
        // Memory Leaks patch    
        if (this.plugins.barRenderer && this.plugins.barRenderer.highlightCanvas) {

            this.plugins.barRenderer.highlightCanvas.resetCanvas();
            this.plugins.barRenderer.highlightCanvas = null;
        }
         
        this.plugins.barRenderer = {highlightedSeriesIndex:null};
        this.plugins.barRenderer.highlightCanvas = new $.jqplot.GenericCanvas();
        
        this.eventCanvas._elem.before(this.plugins.barRenderer.highlightCanvas.createElement(this._gridPadding, 'jqplot-barRenderer-highlight-canvas', this._plotDimensions, this));
        this.plugins.barRenderer.highlightCanvas.setContext();
        this.eventCanvas._elem.bind('mouseleave', {plot:this}, function (ev) { unhighlight(ev.data.plot); });
    }   
    
    function highlight (plot, sidx, pidx, points) {
        var s = plot.series[sidx];
        var canvas = plot.plugins.barRenderer.highlightCanvas;
        canvas._ctx.clearRect(0,0,canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        s._highlightedPoint = pidx;
        plot.plugins.barRenderer.highlightedSeriesIndex = sidx;
        var opts = {fillStyle: s.highlightColors[pidx]};
        s.renderer.shapeRenderer.draw(canvas._ctx, points, opts);
        canvas = null;
    }
    
    function unhighlight (plot) {
        var canvas = plot.plugins.barRenderer.highlightCanvas;
        canvas._ctx.clearRect(0,0, canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        for (var i=0; i<plot.series.length; i++) {
            plot.series[i]._highlightedPoint = null;
        }
        plot.plugins.barRenderer.highlightedSeriesIndex = null;
        plot.target.trigger('jqplotDataUnhighlight');
        canvas =  null;
    }
    
    
    function handleMove(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
            var evt1 = jQuery.Event('jqplotDataMouseOver');
            evt1.pageX = ev.pageX;
            evt1.pageY = ev.pageY;
            plot.target.trigger(evt1, ins);
            if (plot.series[ins[0]].show && plot.series[ins[0]].highlightMouseOver &&
                !(ins[0] == plot.plugins.barRenderer.highlightedSeriesIndex && ins[1] == plot.series[ins[0]]._highlightedPoint)) {
                var evt = jQuery.Event('jqplotDataHighlight');
                evt.which = ev.which;
                evt.pageX = ev.pageX;
                evt.pageY = ev.pageY;
                plot.target.trigger(evt, ins);
                highlight (plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        }
        else if (neighbor == null) {
            unhighlight (plot);
        }
    }
    
    function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
            if (plot.series[ins[0]].highlightMouseDown && !(ins[0] == plot.plugins.barRenderer.highlightedSeriesIndex && ins[1] == plot.series[ins[0]]._highlightedPoint)) {
                var evt = jQuery.Event('jqplotDataHighlight');
                evt.which = ev.which;
                evt.pageX = ev.pageX;
                evt.pageY = ev.pageY;
                plot.target.trigger(evt, ins);
                highlight (plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        }
        else if (neighbor == null) {
            unhighlight (plot);
        }
    }
    
    function handleMouseUp(ev, gridpos, datapos, neighbor, plot) {
        var idx = plot.plugins.barRenderer.highlightedSeriesIndex;
        if (idx != null && plot.series[idx].highlightMouseDown) {
            unhighlight(plot);
        }
    }
    
    function handleClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
            var evt = jQuery.Event('jqplotDataClick');
            evt.which = ev.which;
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            plot.target.trigger(evt, ins);
        }
    }
    
    function handleRightClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [neighbor.seriesIndex, neighbor.pointIndex, neighbor.data];
            var idx = plot.plugins.barRenderer.highlightedSeriesIndex;
            if (idx != null && plot.series[idx].highlightMouseDown) {
                unhighlight(plot);
            }
            var evt = jQuery.Event('jqplotDataRightClick');
            evt.which = ev.which;
            evt.pageX = ev.pageX;
            evt.pageY = ev.pageY;
            plot.target.trigger(evt, ins);
        }
    }
    
    
})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(b){b.jqplot.BezierCurveRenderer=function(){b.jqplot.LineRenderer.call(this)};b.jqplot.BezierCurveRenderer.prototype=new b.jqplot.LineRenderer();b.jqplot.BezierCurveRenderer.prototype.constructor=b.jqplot.BezierCurveRenderer;b.jqplot.BezierCurveRenderer.prototype.setGridData=function(h){var e=this._xaxis.series_u2p;var g=this._yaxis.series_u2p;var f=this.data;this.gridData=[];this._prevGridData=[];var d=this.index;if(f.length==2){if(d==0){this.gridData=[[e.call(this._xaxis,f[0][0]),g.call(this._yaxis,f[0][1])],[e.call(this._xaxis,f[1][0]),g.call(this._yaxis,f[1][1]),e.call(this._xaxis,f[1][2]),g.call(this._yaxis,f[1][3]),e.call(this._xaxis,f[1][4]),g.call(this._yaxis,f[1][5])],[e.call(this._xaxis,f[1][4]),g.call(this._yaxis,this._yaxis.min)],[e.call(this._xaxis,f[0][0]),g.call(this._yaxis,this._yaxis.min)]]}else{var c=h.series[d-1].data;this.gridData=[[e.call(this._xaxis,f[0][0]),g.call(this._yaxis,f[0][1])],[e.call(this._xaxis,f[1][0]),g.call(this._yaxis,f[1][1]),e.call(this._xaxis,f[1][2]),g.call(this._yaxis,f[1][3]),e.call(this._xaxis,f[1][4]),g.call(this._yaxis,f[1][5])],[e.call(this._xaxis,c[1][4]),g.call(this._yaxis,c[1][5])],[e.call(this._xaxis,c[1][2]),g.call(this._yaxis,c[1][3]),e.call(this._xaxis,c[1][0]),g.call(this._yaxis,c[1][1]),e.call(this._xaxis,c[0][0]),g.call(this._yaxis,c[0][1])]]}}else{if(d==0){this.gridData=[[e.call(this._xaxis,f[0][0]),g.call(this._yaxis,f[0][1])],[e.call(this._xaxis,f[1][0]),g.call(this._yaxis,f[1][1]),e.call(this._xaxis,f[2][0]),g.call(this._yaxis,f[2][1]),e.call(this._xaxis,f[3][0]),g.call(this._yaxis,f[3][1])],[e.call(this._xaxis,f[3][1]),g.call(this._yaxis,this._yaxis.min)],[e.call(this._xaxis,f[0][0]),g.call(this._yaxis,this._yaxis.min)]]}else{var c=h.series[d-1].data;this.gridData=[[e.call(this._xaxis,f[0][0]),g.call(this._yaxis,f[0][1])],[e.call(this._xaxis,f[1][0]),g.call(this._yaxis,f[1][1]),e.call(this._xaxis,f[2][0]),g.call(this._yaxis,f[2][1]),e.call(this._xaxis,f[3][0]),g.call(this._yaxis,f[3][1])],[e.call(this._xaxis,c[3][0]),g.call(this._yaxis,c[3][1])],[e.call(this._xaxis,c[2][0]),g.call(this._yaxis,c[2][1]),e.call(this._xaxis,c[1][0]),g.call(this._yaxis,c[1][1]),e.call(this._xaxis,c[0][0]),g.call(this._yaxis,c[0][1])]]}}};b.jqplot.BezierCurveRenderer.prototype.makeGridData=function(g,i){var f=this._xaxis.series_u2p;var h=this._yaxis.series_u2p;var e=[];var j=[];var d=this.index;if(g.length==2){if(d==0){e=[[f.call(this._xaxis,g[0][0]),h.call(this._yaxis,g[0][1])],[f.call(this._xaxis,g[1][0]),h.call(this._yaxis,g[1][1]),f.call(this._xaxis,g[1][2]),h.call(this._yaxis,g[1][3]),f.call(this._xaxis,g[1][4]),h.call(this._yaxis,g[1][5])],[f.call(this._xaxis,g[1][4]),h.call(this._yaxis,this._yaxis.min)],[f.call(this._xaxis,g[0][0]),h.call(this._yaxis,this._yaxis.min)]]}else{var c=i.series[d-1].data;e=[[f.call(this._xaxis,g[0][0]),h.call(this._yaxis,g[0][1])],[f.call(this._xaxis,g[1][0]),h.call(this._yaxis,g[1][1]),f.call(this._xaxis,g[1][2]),h.call(this._yaxis,g[1][3]),f.call(this._xaxis,g[1][4]),h.call(this._yaxis,g[1][5])],[f.call(this._xaxis,c[1][4]),h.call(this._yaxis,c[1][5])],[f.call(this._xaxis,c[1][2]),h.call(this._yaxis,c[1][3]),f.call(this._xaxis,c[1][0]),h.call(this._yaxis,c[1][1]),f.call(this._xaxis,c[0][0]),h.call(this._yaxis,c[0][1])]]}}else{if(d==0){e=[[f.call(this._xaxis,g[0][0]),h.call(this._yaxis,g[0][1])],[f.call(this._xaxis,g[1][0]),h.call(this._yaxis,g[1][1]),f.call(this._xaxis,g[2][0]),h.call(this._yaxis,g[2][1]),f.call(this._xaxis,g[3][0]),h.call(this._yaxis,g[3][1])],[f.call(this._xaxis,g[3][1]),h.call(this._yaxis,this._yaxis.min)],[f.call(this._xaxis,g[0][0]),h.call(this._yaxis,this._yaxis.min)]]}else{var c=i.series[d-1].data;e=[[f.call(this._xaxis,g[0][0]),h.call(this._yaxis,g[0][1])],[f.call(this._xaxis,g[1][0]),h.call(this._yaxis,g[1][1]),f.call(this._xaxis,g[2][0]),h.call(this._yaxis,g[2][1]),f.call(this._xaxis,g[3][0]),h.call(this._yaxis,g[3][1])],[f.call(this._xaxis,c[3][0]),h.call(this._yaxis,c[3][1])],[f.call(this._xaxis,c[2][0]),h.call(this._yaxis,c[2][1]),f.call(this._xaxis,c[1][0]),h.call(this._yaxis,c[1][1]),f.call(this._xaxis,c[0][0]),h.call(this._yaxis,c[0][1])]]}}return e};b.jqplot.BezierCurveRenderer.prototype.draw=function(c,g,d){var e;c.save();if(g.length){if(this.showLine){c.save();var f=(d!=null)?d:{};c.fillStyle=f.fillStyle||this.color;c.beginPath();c.moveTo(g[0][0],g[0][1]);c.bezierCurveTo(g[1][0],g[1][1],g[1][2],g[1][3],g[1][4],g[1][5]);c.lineTo(g[2][0],g[2][1]);if(g[3].length==2){c.lineTo(g[3][0],g[3][1])}else{c.bezierCurveTo(g[3][0],g[3][1],g[3][2],g[3][3],g[3][4],g[3][5])}c.closePath();c.fill();c.restore()}}c.restore()};b.jqplot.BezierCurveRenderer.prototype.drawShadow=function(c,e,d){};b.jqplot.BezierAxisRenderer=function(){b.jqplot.LinearAxisRenderer.call(this)};b.jqplot.BezierAxisRenderer.prototype=new b.jqplot.LinearAxisRenderer();b.jqplot.BezierAxisRenderer.prototype.constructor=b.jqplot.BezierAxisRenderer;b.jqplot.BezierAxisRenderer.prototype.init=function(f){b.extend(true,this,f);var c=this._dataBounds;for(var g=0;g<this._series.length;g++){var h=this._series[g];var k=h.data;if(k.length==4){for(var e=0;e<k.length;e++){if(this.name=="xaxis"||this.name=="x2axis"){if(k[e][0]<c.min||c.min==null){c.min=k[e][0]}if(k[e][0]>c.max||c.max==null){c.max=k[e][0]}}else{if(k[e][1]<c.min||c.min==null){c.min=k[e][1]}if(k[e][1]>c.max||c.max==null){c.max=k[e][1]}}}}else{if(this.name=="xaxis"||this.name=="x2axis"){if(k[0][0]<c.min||c.min==null){c.min=k[0][0]}if(k[0][0]>c.max||c.max==null){c.max=k[0][0]}for(var e=0;e<5;e+=2){if(k[1][e]<c.min||c.min==null){c.min=k[1][e]}if(k[1][e]>c.max||c.max==null){c.max=k[1][e]}}}else{if(k[0][1]<c.min||c.min==null){c.min=k[0][1]}if(k[0][1]>c.max||c.max==null){c.max=k[0][1]}for(var e=1;e<6;e+=2){if(k[1][e]<c.min||c.min==null){c.min=k[1][e]}if(k[1][e]>c.max||c.max==null){c.max=k[1][e]}}}}}};function a(g,f,d){d=d||{};d.axesDefaults=b.extend(true,{pad:0},d.axesDefaults);d.seriesDefaults=d.seriesDefaults||{};d.legend=b.extend(true,{placement:"outside"},d.legend);var c=false;if(d.seriesDefaults.renderer==b.jqplot.BezierCurveRenderer){c=true}else{if(d.series){for(var e=0;e<d.series.length;e++){if(d.series[e].renderer==b.jqplot.BezierCurveRenderer){c=true}}}}if(c){d.axesDefaults.renderer=b.jqplot.BezierAxisRenderer}}b.jqplot.preInitHooks.push(a)})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(a){a.jqplot.BlockRenderer=function(){a.jqplot.LineRenderer.call(this)};a.jqplot.BlockRenderer.prototype=new a.jqplot.LineRenderer();a.jqplot.BlockRenderer.prototype.constructor=a.jqplot.BlockRenderer;a.jqplot.BlockRenderer.prototype.init=function(b){this.css={padding:"2px",border:"1px solid #999",textAlign:"center"};this.escapeHtml=false;this.insertBreaks=true;this.varyBlockColors=false;a.extend(true,this,b);if(this.css.backgroundColor){this.color=this.css.backgroundColor}else{if(this.css.background){this.color=this.css.background}else{if(!this.varyBlockColors){this.css.background=this.color}}}this.canvas=new a.jqplot.BlockCanvas();this.shadowCanvas=new a.jqplot.BlockCanvas();this.canvas._plotDimensions=this._plotDimensions;this.shadowCanvas._plotDimensions=this._plotDimensions;this._type="block";this.moveBlock=function(l,j,i,e){var c=this.canvas._elem.children(":eq("+l+")");this.data[l][0]=j;this.data[l][1]=i;this._plotData[l][0]=j;this._plotData[l][1]=i;this._stackData[l][0]=j;this._stackData[l][1]=i;this.gridData[l][0]=this._xaxis.series_u2p(j);this.gridData[l][1]=this._yaxis.series_u2p(i);var k=c.outerWidth();var f=c.outerHeight();var d=this.gridData[l][0]-k/2+"px";var g=this.gridData[l][1]-f/2+"px";if(e){if(parseInt(e,10)){e=parseInt(e,10)}c.animate({left:d,top:g},e)}else{c.css({left:d,top:g})}c=null}};a.jqplot.BlockRenderer.prototype.draw=function(q,o,r){if(this.plugins.pointLabels){this.plugins.pointLabels.show=false}var f,c,l,o,p,k,n,g,e,m;var b=(r!=undefined)?r:{};var j=new a.jqplot.ColorGenerator(this.seriesColors);this.canvas._elem.empty();for(f=0;f<this.gridData.length;f++){l=this.data[f];o=this.gridData[f];p="";k={};if(typeof l[2]=="string"){p=l[2]}else{if(typeof l[2]=="object"){k=l[2]}}if(typeof l[3]=="object"){k=l[3]}if(this.insertBreaks){p=p.replace(/ /g,"<br />")}k=a.extend(true,{},this.css,k);c=a('<div style="position:absolute;margin-left:auto;margin-right:auto;"></div>');this.canvas._elem.append(c);this.escapeHtml?c.text(p):c.html(p);delete k.position;delete k.marginRight;delete k.marginLeft;if(!k.background&&!k.backgroundColor&&!k.backgroundImage){k.background=j.next()}c.css(k);n=c.outerWidth();g=c.outerHeight();e=o[0]-n/2+"px";m=o[1]-g/2+"px";c.css({left:e,top:m});c=null}};a.jqplot.BlockCanvas=function(){a.jqplot.ElemContainer.call(this);this._ctx};a.jqplot.BlockCanvas.prototype=new a.jqplot.ElemContainer();a.jqplot.BlockCanvas.prototype.constructor=a.jqplot.BlockCanvas;a.jqplot.BlockCanvas.prototype.createElement=function(i,e,c){this._offsets=i;var b="jqplot-blockCanvas";if(e!=undefined){b=e}var g;if(this._elem){g=this._elem.get(0)}else{g=document.createElement("div")}if(c!=undefined){this._plotDimensions=c}var d=this._plotDimensions.width-this._offsets.left-this._offsets.right+"px";var f=this._plotDimensions.height-this._offsets.top-this._offsets.bottom+"px";this._elem=a(g);this._elem.css({position:"absolute",width:d,height:f,left:this._offsets.left,top:this._offsets.top});this._elem.addClass(b);return this._elem};a.jqplot.BlockCanvas.prototype.setContext=function(){this._ctx={canvas:{width:0,height:0},clearRect:function(){return null}};return this._ctx}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(f){var d=function(m){return Math.max.apply(Math,m)};var j=function(m){return Math.min.apply(Math,m)};f.jqplot.BubbleRenderer=function(){f.jqplot.LineRenderer.call(this)};f.jqplot.BubbleRenderer.prototype=new f.jqplot.LineRenderer();f.jqplot.BubbleRenderer.prototype.constructor=f.jqplot.BubbleRenderer;f.jqplot.BubbleRenderer.prototype.init=function(w,t){this.varyBubbleColors=true;this.autoscaleBubbles=true;this.autoscaleMultiplier=1;this.autoscalePointsFactor=-0.07;this.escapeHtml=true;this.highlightMouseOver=true;this.highlightMouseDown=false;this.highlightColors=[];this.bubbleAlpha=1;this.highlightAlpha=null;this.bubbleGradients=false;this.showLabels=true;this.radii=[];this.maxRadius=0;this._highlightedPoint=null;this.labels=[];this.bubbleCanvases=[];this._type="bubble";if(w.highlightMouseDown&&w.highlightMouseOver==null){w.highlightMouseOver=false}f.extend(true,this,w);if(this.highlightAlpha==null){this.highlightAlpha=this.bubbleAlpha;if(this.bubbleGradients){this.highlightAlpha=0.35}}this.autoscaleMultiplier=this.autoscaleMultiplier*Math.pow(this.data.length,this.autoscalePointsFactor);this._highlightedPoint=null;var n;for(var r=0;r<this.data.length;r++){var p=null;var v=this.data[r];this.maxRadius=Math.max(this.maxRadius,v[2]);if(v[3]){if(typeof(v[3])=="object"){p=v[3]["color"]}}if(p==null){if(this.seriesColors[r]!=null){p=this.seriesColors[r]}}if(p&&this.bubbleAlpha<1){n=f.jqplot.getColorComponents(p);p="rgba("+n[0]+", "+n[1]+", "+n[2]+", "+this.bubbleAlpha+")"}if(p){this.seriesColors[r]=p}}if(!this.varyBubbleColors){this.seriesColors=[this.color]}this.colorGenerator=new f.jqplot.ColorGenerator(this.seriesColors);if(this.highlightColors.length==0){for(var r=0;r<this.seriesColors.length;r++){var o=f.jqplot.getColorComponents(this.seriesColors[r]);var u=[o[0],o[1],o[2]];var s=u[0]+u[1]+u[2];for(var q=0;q<3;q++){u[q]=(s>570)?u[q]*0.8:u[q]+0.3*(255-u[q]);u[q]=parseInt(u[q],10)}this.highlightColors.push("rgba("+u[0]+","+u[1]+","+u[2]+", "+this.highlightAlpha+")")}}this.highlightColorGenerator=new f.jqplot.ColorGenerator(this.highlightColors);var m={fill:true,isarc:true,angle:this.shadowAngle,alpha:this.shadowAlpha,closePath:true};this.renderer.shadowRenderer.init(m);this.canvas=new f.jqplot.DivCanvas();this.canvas._plotDimensions=this._plotDimensions;t.eventListenerHooks.addOnce("jqplotMouseMove",a);t.eventListenerHooks.addOnce("jqplotMouseDown",b);t.eventListenerHooks.addOnce("jqplotMouseUp",k);t.eventListenerHooks.addOnce("jqplotClick",g);t.eventListenerHooks.addOnce("jqplotRightClick",l);t.postDrawHooks.addOnce(h)};f.jqplot.BubbleRenderer.prototype.setGridData=function(w){var q=this._xaxis.series_u2p;var m=this._yaxis.series_u2p;var t=this._plotData;this.gridData=[];var s=[];this.radii=[];var v=Math.min(w._height,w._width);for(var u=0;u<this.data.length;u++){if(t[u]!=null){this.gridData.push([q.call(this._xaxis,t[u][0]),m.call(this._yaxis,t[u][1]),t[u][2]]);this.radii.push([u,t[u][2]]);s.push(t[u][2])}}var n,o,x=this.maxRadius=d(s);var p=this.gridData.length;if(this.autoscaleBubbles){for(var u=0;u<p;u++){o=s[u]/x;n=this.autoscaleMultiplier*v/6;this.gridData[u][2]=n*o}}this.radii.sort(function(y,r){return r[1]-y[1]})};f.jqplot.BubbleRenderer.prototype.makeGridData=function(t,w){var q=this._xaxis.series_u2p;var n=this._yaxis.series_u2p;var x=[];var s=[];this.radii=[];var v=Math.min(w._height,w._width);for(var u=0;u<t.length;u++){if(t[u]!=null){x.push([q.call(this._xaxis,t[u][0]),n.call(this._yaxis,t[u][1]),t[u][2]]);s.push(t[u][2]);this.radii.push([u,t[u][2]])}}var m,o,y=this.maxRadius=d(s);var p=this.gridData.length;if(this.autoscaleBubbles){for(var u=0;u<p;u++){o=s[u]/y;m=this.autoscaleMultiplier*v/6;x[u][2]=m*o}}this.radii.sort(function(z,r){return r[1]-z[1]});return x};f.jqplot.BubbleRenderer.prototype.draw=function(D,J,n){if(this.plugins.pointLabels){this.plugins.pointLabels.show=false}var A=(n!=undefined)?n:{};var r=(A.shadow!=undefined)?A.shadow:this.shadow;this.canvas._elem.empty();for(var G=0;G<this.radii.length;G++){var C=this.radii[G][0];var z=null;var F=null;var m=null;var p=null;var I=this.data[C];var J=this.gridData[C];if(I[3]){if(typeof(I[3])=="object"){z=I[3]["label"]}else{if(typeof(I[3])=="string"){z=I[3]}}}F=this.colorGenerator.get(C);var E=J[2];var q,K;if(this.shadow){q=(0.7+J[2]/40).toFixed(1);K=1+Math.ceil(J[2]/15);E+=q*K}this.bubbleCanvases[C]=new f.jqplot.BubbleCanvas();this.canvas._elem.append(this.bubbleCanvases[C].createElement(J[0],J[1],E));this.bubbleCanvases[C].setContext();var D=this.bubbleCanvases[C]._ctx;var u=D.canvas.width/2;var s=D.canvas.height/2;if(this.shadow){this.renderer.shadowRenderer.draw(D,[u,s,J[2],0,2*Math.PI],{offset:q,depth:K})}this.bubbleCanvases[C].draw(J[2],F,this.bubbleGradients,this.shadowAngle/180*Math.PI);if(z&&this.showLabels){p=f('<div style="position:absolute;" class="jqplot-bubble-label"></div>');if(this.escapeHtml){p.text(z)}else{p.html(z)}this.canvas._elem.append(p);var H=f(p).outerHeight();var v=f(p).outerWidth();var B=J[1]-0.5*H;var o=J[0]-0.5*v;p.css({top:B,left:o});this.labels[C]=f(p)}}};f.jqplot.DivCanvas=function(){f.jqplot.ElemContainer.call(this);this._ctx};f.jqplot.DivCanvas.prototype=new f.jqplot.ElemContainer();f.jqplot.DivCanvas.prototype.constructor=f.jqplot.DivCanvas;f.jqplot.DivCanvas.prototype.createElement=function(s,p,n){this._offsets=s;var m="jqplot-DivCanvas";if(p!=undefined){m=p}var r;if(this._elem){r=this._elem.get(0)}else{r=document.createElement("div")}if(n!=undefined){this._plotDimensions=n}var o=this._plotDimensions.width-this._offsets.left-this._offsets.right+"px";var q=this._plotDimensions.height-this._offsets.top-this._offsets.bottom+"px";this._elem=f(r);this._elem.css({position:"absolute",width:o,height:q,left:this._offsets.left,top:this._offsets.top});this._elem.addClass(m);return this._elem};f.jqplot.DivCanvas.prototype.setContext=function(){this._ctx={canvas:{width:0,height:0},clearRect:function(){return null}};return this._ctx};f.jqplot.BubbleCanvas=function(){f.jqplot.ElemContainer.call(this);this._ctx};f.jqplot.BubbleCanvas.prototype=new f.jqplot.ElemContainer();f.jqplot.BubbleCanvas.prototype.constructor=f.jqplot.BubbleCanvas;f.jqplot.BubbleCanvas.prototype.createElement=function(n,u,s){var m="jqplot-bubble-point";var q;if(this._elem){q=this._elem.get(0)}else{q=document.createElement("canvas")}q.width=(s!=null)?2*s:q.width;q.height=(s!=null)?2*s:q.height;this._elem=f(q);var o=(n!=null&&s!=null)?n-s:this._elem.css("left");var p=(u!=null&&s!=null)?u-s:this._elem.css("top");this._elem.css({position:"absolute",left:o,top:p});this._elem.addClass(m);if(f.jqplot.use_excanvas){window.G_vmlCanvasManager.init_(document);q=window.G_vmlCanvasManager.initElement(q)}return this._elem};f.jqplot.BubbleCanvas.prototype.draw=function(m,s,v,p){var D=this._ctx;var B=D.canvas.width/2;var z=D.canvas.height/2;D.save();if(v&&!f.jqplot.use_excanvas){m=m*1.04;var o=f.jqplot.getColorComponents(s);var u="rgba("+Math.round(o[0]+0.8*(255-o[0]))+", "+Math.round(o[1]+0.8*(255-o[1]))+", "+Math.round(o[2]+0.8*(255-o[2]))+", "+o[3]+")";var t="rgba("+o[0]+", "+o[1]+", "+o[2]+", 0)";var C=0.35*m;var A=B-Math.cos(p)*0.33*m;var n=z-Math.sin(p)*0.33*m;var w=D.createRadialGradient(A,n,C,B,z,m);w.addColorStop(0,u);w.addColorStop(0.93,s);w.addColorStop(0.96,t);w.addColorStop(1,t);D.fillStyle=w;D.fillRect(0,0,D.canvas.width,D.canvas.height)}else{D.fillStyle=s;D.strokeStyle=s;D.lineWidth=1;D.beginPath();var q=2*Math.PI;D.arc(B,z,m,0,q,0);D.closePath();D.fill()}D.restore()};f.jqplot.BubbleCanvas.prototype.setContext=function(){this._ctx=this._elem.get(0).getContext("2d");return this._ctx};f.jqplot.BubbleAxisRenderer=function(){f.jqplot.LinearAxisRenderer.call(this)};f.jqplot.BubbleAxisRenderer.prototype=new f.jqplot.LinearAxisRenderer();f.jqplot.BubbleAxisRenderer.prototype.constructor=f.jqplot.BubbleAxisRenderer;f.jqplot.BubbleAxisRenderer.prototype.init=function(n){f.extend(true,this,n);var I=this._dataBounds;var H=0,v=0,m=0,y=0,q=0,r=0,D=0,t=0,F=0,z=0;for(var E=0;E<this._series.length;E++){var x=this._series[E];var G=x._plotData;for(var B=0;B<G.length;B++){if(this.name=="xaxis"||this.name=="x2axis"){if(G[B][0]<I.min||I.min==null){I.min=G[B][0];H=E;v=B;r=G[B][2];D=x.maxRadius;z=x.autoscaleMultiplier}if(G[B][0]>I.max||I.max==null){I.max=G[B][0];m=E;y=B;q=G[B][2];t=x.maxRadius;F=x.autoscaleMultiplier}}else{if(G[B][1]<I.min||I.min==null){I.min=G[B][1];H=E;v=B;r=G[B][2];D=x.maxRadius;z=x.autoscaleMultiplier}if(G[B][1]>I.max||I.max==null){I.max=G[B][1];m=E;y=B;q=G[B][2];t=x.maxRadius;F=x.autoscaleMultiplier}}}}var o=r/D;var w=q/t;var C=I.max-I.min;var A=Math.min(this._plotDimensions.width,this._plotDimensions.height);var p=o*z/3*C;var u=w*F/3*C;I.max+=u;I.min-=p};function e(p,v,q){p.plugins.bubbleRenderer.highlightLabelCanvas.empty();var z=p.series[v];var n=p.plugins.bubbleRenderer.highlightCanvas;var w=n._ctx;w.clearRect(0,0,w.canvas.width,w.canvas.height);z._highlightedPoint=q;p.plugins.bubbleRenderer.highlightedSeriesIndex=v;var o=z.highlightColorGenerator.get(q);var u=z.gridData[q][0],t=z.gridData[q][1],m=z.gridData[q][2];w.save();w.fillStyle=o;w.strokeStyle=o;w.lineWidth=1;w.beginPath();w.arc(u,t,m,0,2*Math.PI,0);w.closePath();w.fill();w.restore();if(z.labels[q]){p.plugins.bubbleRenderer.highlightLabel=z.labels[q].clone();p.plugins.bubbleRenderer.highlightLabel.appendTo(p.plugins.bubbleRenderer.highlightLabelCanvas);p.plugins.bubbleRenderer.highlightLabel.addClass("jqplot-bubble-label-highlight")}}function i(p){var m=p.plugins.bubbleRenderer.highlightCanvas;var o=p.plugins.bubbleRenderer.highlightedSeriesIndex;p.plugins.bubbleRenderer.highlightLabelCanvas.empty();m._ctx.clearRect(0,0,m._ctx.canvas.width,m._ctx.canvas.height);for(var n=0;n<p.series.length;n++){p.series[n]._highlightedPoint=null}p.plugins.bubbleRenderer.highlightedSeriesIndex=null;p.target.trigger("jqplotDataUnhighlight")}function a(s,p,m,v,r){if(v){var n=v.seriesIndex;var o=v.pointIndex;var q=[n,o,v.data,r.series[n].gridData[o][2]];var t=jQuery.Event("jqplotDataMouseOver");t.pageX=s.pageX;t.pageY=s.pageY;r.target.trigger(t,q);if(r.series[q[0]].highlightMouseOver&&!(q[0]==r.plugins.bubbleRenderer.highlightedSeriesIndex&&q[1]==r.series[q[0]]._highlightedPoint)){var u=jQuery.Event("jqplotDataHighlight");u.which=s.which;u.pageX=s.pageX;u.pageY=s.pageY;r.target.trigger(u,q);e(r,q[0],q[1])}}else{if(v==null){i(r)}}}function b(s,p,m,u,r){if(u){var n=u.seriesIndex;var o=u.pointIndex;var q=[n,o,u.data,r.series[n].gridData[o][2]];if(r.series[q[0]].highlightMouseDown&&!(q[0]==r.plugins.bubbleRenderer.highlightedSeriesIndex&&q[1]==r.series[q[0]]._highlightedPoint)){var t=jQuery.Event("jqplotDataHighlight");t.which=s.which;t.pageX=s.pageX;t.pageY=s.pageY;r.target.trigger(t,q);e(r,q[0],q[1])}}else{if(u==null){i(r)}}}function k(o,n,r,q,p){var m=p.plugins.bubbleRenderer.highlightedSeriesIndex;if(m!=null&&p.series[m].highlightMouseDown){i(p)}}function g(s,p,m,u,r){if(u){var n=u.seriesIndex;var o=u.pointIndex;var q=[n,o,u.data,r.series[n].gridData[o][2]];var t=jQuery.Event("jqplotDataClick");t.which=s.which;t.pageX=s.pageX;t.pageY=s.pageY;r.target.trigger(t,q)}}function l(s,p,m,v,r){if(v){var n=v.seriesIndex;var o=v.pointIndex;var q=[n,o,v.data,r.series[n].gridData[o][2]];var t=r.plugins.bubbleRenderer.highlightedSeriesIndex;if(t!=null&&r.series[t].highlightMouseDown){i(r)}var u=jQuery.Event("jqplotDataRightClick");u.which=s.which;u.pageX=s.pageX;u.pageY=s.pageY;r.target.trigger(u,q)}}function h(){if(this.plugins.bubbleRenderer&&this.plugins.bubbleRenderer.highlightCanvas){this.plugins.bubbleRenderer.highlightCanvas.resetCanvas();this.plugins.bubbleRenderer.highlightCanvas=null}this.plugins.bubbleRenderer={highlightedSeriesIndex:null};this.plugins.bubbleRenderer.highlightCanvas=new f.jqplot.GenericCanvas();this.plugins.bubbleRenderer.highlightLabel=null;this.plugins.bubbleRenderer.highlightLabelCanvas=f('<div style="position:absolute;"></div>');var q=this._gridPadding.top;var p=this._gridPadding.left;var n=this._plotDimensions.width-this._gridPadding.left-this._gridPadding.right;var m=this._plotDimensions.height-this._gridPadding.top-this._gridPadding.bottom;this.plugins.bubbleRenderer.highlightLabelCanvas.css({top:q,left:p,width:n+"px",height:m+"px"});this.eventCanvas._elem.before(this.plugins.bubbleRenderer.highlightCanvas.createElement(this._gridPadding,"jqplot-bubbleRenderer-highlight-canvas",this._plotDimensions,this));this.eventCanvas._elem.before(this.plugins.bubbleRenderer.highlightLabelCanvas);var o=this.plugins.bubbleRenderer.highlightCanvas.setContext()}function c(q,p,n){n=n||{};n.axesDefaults=n.axesDefaults||{};n.seriesDefaults=n.seriesDefaults||{};var m=false;if(n.seriesDefaults.renderer==f.jqplot.BubbleRenderer){m=true}else{if(n.series){for(var o=0;o<n.series.length;o++){if(n.series[o].renderer==f.jqplot.BubbleRenderer){m=true}}}}if(m){n.axesDefaults.renderer=f.jqplot.BubbleAxisRenderer;n.sortData=false}}f.jqplot.preInitHooks.push(c)})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(a){a.jqplot.CanvasAxisLabelRenderer=function(b){this.angle=0;this.axis;this.show=true;this.showLabel=true;this.label="";this.fontFamily='"Trebuchet MS", Arial, Helvetica, sans-serif';this.fontSize="11pt";this.fontWeight="normal";this.fontStretch=1;this.textColor="#666666";this.enableFontSupport=true;this.pt2px=null;this._elem;this._ctx;this._plotWidth;this._plotHeight;this._plotDimensions={height:null,width:null};a.extend(true,this,b);if(b.angle==null&&this.axis!="xaxis"&&this.axis!="x2axis"){this.angle=-90}var c={fontSize:this.fontSize,fontWeight:this.fontWeight,fontStretch:this.fontStretch,fillStyle:this.textColor,angle:this.getAngleRad(),fontFamily:this.fontFamily};if(this.pt2px){c.pt2px=this.pt2px}if(this.enableFontSupport){if(a.jqplot.support_canvas_text()){this._textRenderer=new a.jqplot.CanvasFontRenderer(c)}else{this._textRenderer=new a.jqplot.CanvasTextRenderer(c)}}else{this._textRenderer=new a.jqplot.CanvasTextRenderer(c)}};a.jqplot.CanvasAxisLabelRenderer.prototype.init=function(b){a.extend(true,this,b);this._textRenderer.init({fontSize:this.fontSize,fontWeight:this.fontWeight,fontStretch:this.fontStretch,fillStyle:this.textColor,angle:this.getAngleRad(),fontFamily:this.fontFamily})};a.jqplot.CanvasAxisLabelRenderer.prototype.getWidth=function(d){if(this._elem){return this._elem.outerWidth(true)}else{var f=this._textRenderer;var c=f.getWidth(d);var e=f.getHeight(d);var b=Math.abs(Math.sin(f.angle)*e)+Math.abs(Math.cos(f.angle)*c);return b}};a.jqplot.CanvasAxisLabelRenderer.prototype.getHeight=function(d){if(this._elem){return this._elem.outerHeight(true)}else{var f=this._textRenderer;var c=f.getWidth(d);var e=f.getHeight(d);var b=Math.abs(Math.cos(f.angle)*e)+Math.abs(Math.sin(f.angle)*c);return b}};a.jqplot.CanvasAxisLabelRenderer.prototype.getAngleRad=function(){var b=this.angle*Math.PI/180;return b};a.jqplot.CanvasAxisLabelRenderer.prototype.draw=function(c,f){if(this._elem){if(a.jqplot.use_excanvas&&window.G_vmlCanvasManager.uninitElement!==undefined){window.G_vmlCanvasManager.uninitElement(this._elem.get(0))}this._elem.emptyForce();this._elem=null}var e=f.canvasManager.getCanvas();this._textRenderer.setText(this.label,c);var b=this.getWidth(c);var d=this.getHeight(c);e.width=b;e.height=d;e.style.width=b;e.style.height=d;e=f.canvasManager.initCanvas(e);this._elem=a(e);this._elem.css({position:"absolute"});this._elem.addClass("jqplot-"+this.axis+"-label");e=null;return this._elem};a.jqplot.CanvasAxisLabelRenderer.prototype.pack=function(){this._textRenderer.draw(this._elem.get(0).getContext("2d"),this.label)}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(a){a.jqplot.CanvasAxisTickRenderer=function(b){this.mark="outside";this.showMark=true;this.showGridline=true;this.isMinorTick=false;this.angle=0;this.markSize=4;this.show=true;this.showLabel=true;this.labelPosition="auto";this.label="";this.value=null;this._styles={};this.formatter=a.jqplot.DefaultTickFormatter;this.formatString="";this.prefix="";this.fontFamily='"Trebuchet MS", Arial, Helvetica, sans-serif';this.fontSize="10pt";this.fontWeight="normal";this.fontStretch=1;this.textColor="#666666";this.enableFontSupport=true;this.pt2px=null;this._elem;this._ctx;this._plotWidth;this._plotHeight;this._plotDimensions={height:null,width:null};a.extend(true,this,b);var c={fontSize:this.fontSize,fontWeight:this.fontWeight,fontStretch:this.fontStretch,fillStyle:this.textColor,angle:this.getAngleRad(),fontFamily:this.fontFamily};if(this.pt2px){c.pt2px=this.pt2px}if(this.enableFontSupport){if(a.jqplot.support_canvas_text()){this._textRenderer=new a.jqplot.CanvasFontRenderer(c)}else{this._textRenderer=new a.jqplot.CanvasTextRenderer(c)}}else{this._textRenderer=new a.jqplot.CanvasTextRenderer(c)}};a.jqplot.CanvasAxisTickRenderer.prototype.init=function(b){a.extend(true,this,b);this._textRenderer.init({fontSize:this.fontSize,fontWeight:this.fontWeight,fontStretch:this.fontStretch,fillStyle:this.textColor,angle:this.getAngleRad(),fontFamily:this.fontFamily})};a.jqplot.CanvasAxisTickRenderer.prototype.getWidth=function(d){if(this._elem){return this._elem.outerWidth(true)}else{var f=this._textRenderer;var c=f.getWidth(d);var e=f.getHeight(d);var b=Math.abs(Math.sin(f.angle)*e)+Math.abs(Math.cos(f.angle)*c);return b}};a.jqplot.CanvasAxisTickRenderer.prototype.getHeight=function(d){if(this._elem){return this._elem.outerHeight(true)}else{var f=this._textRenderer;var c=f.getWidth(d);var e=f.getHeight(d);var b=Math.abs(Math.cos(f.angle)*e)+Math.abs(Math.sin(f.angle)*c);return b}};a.jqplot.CanvasAxisTickRenderer.prototype.getTop=function(b){if(this._elem){return this._elem.position().top}else{return null}};a.jqplot.CanvasAxisTickRenderer.prototype.getAngleRad=function(){var b=this.angle*Math.PI/180;return b};a.jqplot.CanvasAxisTickRenderer.prototype.setTick=function(b,d,c){this.value=b;if(c){this.isMinorTick=true}return this};a.jqplot.CanvasAxisTickRenderer.prototype.draw=function(c,f){if(!this.label){this.label=this.prefix+this.formatter(this.formatString,this.value)}if(this._elem){if(a.jqplot.use_excanvas&&window.G_vmlCanvasManager.uninitElement!==undefined){window.G_vmlCanvasManager.uninitElement(this._elem.get(0))}this._elem.emptyForce();this._elem=null}var e=f.canvasManager.getCanvas();this._textRenderer.setText(this.label,c);var b=this.getWidth(c);var d=this.getHeight(c);e.width=b;e.height=d;e.style.width=b;e.style.height=d;e.style.textAlign="left";e.style.position="absolute";e=f.canvasManager.initCanvas(e);this._elem=a(e);this._elem.css(this._styles);this._elem.addClass("jqplot-"+this.axis+"-tick");e=null;return this._elem};a.jqplot.CanvasAxisTickRenderer.prototype.pack=function(){this._textRenderer.draw(this._elem.get(0).getContext("2d"),this.label)}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(a){a.jqplot.CanvasTextRenderer=function(b){this.fontStyle="normal";this.fontVariant="normal";this.fontWeight="normal";this.fontSize="10px";this.fontFamily="sans-serif";this.fontStretch=1;this.fillStyle="#666666";this.angle=0;this.textAlign="start";this.textBaseline="alphabetic";this.text;this.width;this.height;this.pt2px=1.28;a.extend(true,this,b);this.normalizedFontSize=this.normalizeFontSize(this.fontSize);this.setHeight()};a.jqplot.CanvasTextRenderer.prototype.init=function(b){a.extend(true,this,b);this.normalizedFontSize=this.normalizeFontSize(this.fontSize);this.setHeight()};a.jqplot.CanvasTextRenderer.prototype.normalizeFontSize=function(b){b=String(b);var c=parseFloat(b);if(b.indexOf("px")>-1){return c/this.pt2px}else{if(b.indexOf("pt")>-1){return c}else{if(b.indexOf("em")>-1){return c*12}else{if(b.indexOf("%")>-1){return c*12/100}else{return c/this.pt2px}}}}};a.jqplot.CanvasTextRenderer.prototype.fontWeight2Float=function(b){if(Number(b)){return b/400}else{switch(b){case"normal":return 1;break;case"bold":return 1.75;break;case"bolder":return 2.25;break;case"lighter":return 0.75;break;default:return 1;break}}};a.jqplot.CanvasTextRenderer.prototype.getText=function(){return this.text};a.jqplot.CanvasTextRenderer.prototype.setText=function(c,b){this.text=c;this.setWidth(b);return this};a.jqplot.CanvasTextRenderer.prototype.getWidth=function(b){return this.width};a.jqplot.CanvasTextRenderer.prototype.setWidth=function(c,b){if(!b){this.width=this.measure(c,this.text)}else{this.width=b}return this};a.jqplot.CanvasTextRenderer.prototype.getHeight=function(b){return this.height};a.jqplot.CanvasTextRenderer.prototype.setHeight=function(b){if(!b){this.height=this.normalizedFontSize*this.pt2px}else{this.height=b}return this};a.jqplot.CanvasTextRenderer.prototype.letter=function(b){return this.letters[b]};a.jqplot.CanvasTextRenderer.prototype.ascent=function(){return this.normalizedFontSize};a.jqplot.CanvasTextRenderer.prototype.descent=function(){return 7*this.normalizedFontSize/25};a.jqplot.CanvasTextRenderer.prototype.measure=function(d,g){var f=0;var b=g.length;for(var e=0;e<b;e++){var h=this.letter(g.charAt(e));if(h){f+=h.width*this.normalizedFontSize/25*this.fontStretch}}return f};a.jqplot.CanvasTextRenderer.prototype.draw=function(s,n){var r=0;var o=this.height*0.72;var p=0;var l=n.length;var k=this.normalizedFontSize/25;s.save();var h,f;if((-Math.PI/2<=this.angle&&this.angle<=0)||(Math.PI*3/2<=this.angle&&this.angle<=Math.PI*2)){h=0;f=-Math.sin(this.angle)*this.width}else{if((0<this.angle&&this.angle<=Math.PI/2)||(-Math.PI*2<=this.angle&&this.angle<=-Math.PI*3/2)){h=Math.sin(this.angle)*this.height;f=0}else{if((-Math.PI<this.angle&&this.angle<-Math.PI/2)||(Math.PI<=this.angle&&this.angle<=Math.PI*3/2)){h=-Math.cos(this.angle)*this.width;f=-Math.sin(this.angle)*this.width-Math.cos(this.angle)*this.height}else{if((-Math.PI*3/2<this.angle&&this.angle<Math.PI)||(Math.PI/2<this.angle&&this.angle<Math.PI)){h=Math.sin(this.angle)*this.height-Math.cos(this.angle)*this.width;f=-Math.cos(this.angle)*this.height}}}}s.strokeStyle=this.fillStyle;s.fillStyle=this.fillStyle;s.translate(h,f);s.rotate(this.angle);s.lineCap="round";var t=(this.normalizedFontSize>30)?2:2+(30-this.normalizedFontSize)/20;s.lineWidth=t*k*this.fontWeight2Float(this.fontWeight);for(var g=0;g<l;g++){var m=this.letter(n.charAt(g));if(!m){continue}s.beginPath();var e=1;var b=0;for(var d=0;d<m.points.length;d++){var q=m.points[d];if(q[0]==-1&&q[1]==-1){e=1;continue}if(e){s.moveTo(r+q[0]*k*this.fontStretch,o-q[1]*k);e=false}else{s.lineTo(r+q[0]*k*this.fontStretch,o-q[1]*k)}}s.stroke();r+=m.width*k*this.fontStretch}s.restore();return p};a.jqplot.CanvasTextRenderer.prototype.letters={" ":{width:16,points:[]},"!":{width:10,points:[[5,21],[5,7],[-1,-1],[5,2],[4,1],[5,0],[6,1],[5,2]]},'"':{width:16,points:[[4,21],[4,14],[-1,-1],[12,21],[12,14]]},"#":{width:21,points:[[11,25],[4,-7],[-1,-1],[17,25],[10,-7],[-1,-1],[4,12],[18,12],[-1,-1],[3,6],[17,6]]},"$":{width:20,points:[[8,25],[8,-4],[-1,-1],[12,25],[12,-4],[-1,-1],[17,18],[15,20],[12,21],[8,21],[5,20],[3,18],[3,16],[4,14],[5,13],[7,12],[13,10],[15,9],[16,8],[17,6],[17,3],[15,1],[12,0],[8,0],[5,1],[3,3]]},"%":{width:24,points:[[21,21],[3,0],[-1,-1],[8,21],[10,19],[10,17],[9,15],[7,14],[5,14],[3,16],[3,18],[4,20],[6,21],[8,21],[10,20],[13,19],[16,19],[19,20],[21,21],[-1,-1],[17,7],[15,6],[14,4],[14,2],[16,0],[18,0],[20,1],[21,3],[21,5],[19,7],[17,7]]},"&":{width:26,points:[[23,12],[23,13],[22,14],[21,14],[20,13],[19,11],[17,6],[15,3],[13,1],[11,0],[7,0],[5,1],[4,2],[3,4],[3,6],[4,8],[5,9],[12,13],[13,14],[14,16],[14,18],[13,20],[11,21],[9,20],[8,18],[8,16],[9,13],[11,10],[16,3],[18,1],[20,0],[22,0],[23,1],[23,2]]},"'":{width:10,points:[[5,19],[4,20],[5,21],[6,20],[6,18],[5,16],[4,15]]},"(":{width:14,points:[[11,25],[9,23],[7,20],[5,16],[4,11],[4,7],[5,2],[7,-2],[9,-5],[11,-7]]},")":{width:14,points:[[3,25],[5,23],[7,20],[9,16],[10,11],[10,7],[9,2],[7,-2],[5,-5],[3,-7]]},"*":{width:16,points:[[8,21],[8,9],[-1,-1],[3,18],[13,12],[-1,-1],[13,18],[3,12]]},"+":{width:26,points:[[13,18],[13,0],[-1,-1],[4,9],[22,9]]},",":{width:10,points:[[6,1],[5,0],[4,1],[5,2],[6,1],[6,-1],[5,-3],[4,-4]]},"-":{width:18,points:[[6,9],[12,9]]},".":{width:10,points:[[5,2],[4,1],[5,0],[6,1],[5,2]]},"/":{width:22,points:[[20,25],[2,-7]]},"0":{width:20,points:[[9,21],[6,20],[4,17],[3,12],[3,9],[4,4],[6,1],[9,0],[11,0],[14,1],[16,4],[17,9],[17,12],[16,17],[14,20],[11,21],[9,21]]},"1":{width:20,points:[[6,17],[8,18],[11,21],[11,0]]},"2":{width:20,points:[[4,16],[4,17],[5,19],[6,20],[8,21],[12,21],[14,20],[15,19],[16,17],[16,15],[15,13],[13,10],[3,0],[17,0]]},"3":{width:20,points:[[5,21],[16,21],[10,13],[13,13],[15,12],[16,11],[17,8],[17,6],[16,3],[14,1],[11,0],[8,0],[5,1],[4,2],[3,4]]},"4":{width:20,points:[[13,21],[3,7],[18,7],[-1,-1],[13,21],[13,0]]},"5":{width:20,points:[[15,21],[5,21],[4,12],[5,13],[8,14],[11,14],[14,13],[16,11],[17,8],[17,6],[16,3],[14,1],[11,0],[8,0],[5,1],[4,2],[3,4]]},"6":{width:20,points:[[16,18],[15,20],[12,21],[10,21],[7,20],[5,17],[4,12],[4,7],[5,3],[7,1],[10,0],[11,0],[14,1],[16,3],[17,6],[17,7],[16,10],[14,12],[11,13],[10,13],[7,12],[5,10],[4,7]]},"7":{width:20,points:[[17,21],[7,0],[-1,-1],[3,21],[17,21]]},"8":{width:20,points:[[8,21],[5,20],[4,18],[4,16],[5,14],[7,13],[11,12],[14,11],[16,9],[17,7],[17,4],[16,2],[15,1],[12,0],[8,0],[5,1],[4,2],[3,4],[3,7],[4,9],[6,11],[9,12],[13,13],[15,14],[16,16],[16,18],[15,20],[12,21],[8,21]]},"9":{width:20,points:[[16,14],[15,11],[13,9],[10,8],[9,8],[6,9],[4,11],[3,14],[3,15],[4,18],[6,20],[9,21],[10,21],[13,20],[15,18],[16,14],[16,9],[15,4],[13,1],[10,0],[8,0],[5,1],[4,3]]},":":{width:10,points:[[5,14],[4,13],[5,12],[6,13],[5,14],[-1,-1],[5,2],[4,1],[5,0],[6,1],[5,2]]},";":{width:10,points:[[5,14],[4,13],[5,12],[6,13],[5,14],[-1,-1],[6,1],[5,0],[4,1],[5,2],[6,1],[6,-1],[5,-3],[4,-4]]},"<":{width:24,points:[[20,18],[4,9],[20,0]]},"=":{width:26,points:[[4,12],[22,12],[-1,-1],[4,6],[22,6]]},">":{width:24,points:[[4,18],[20,9],[4,0]]},"?":{width:18,points:[[3,16],[3,17],[4,19],[5,20],[7,21],[11,21],[13,20],[14,19],[15,17],[15,15],[14,13],[13,12],[9,10],[9,7],[-1,-1],[9,2],[8,1],[9,0],[10,1],[9,2]]},"@":{width:27,points:[[18,13],[17,15],[15,16],[12,16],[10,15],[9,14],[8,11],[8,8],[9,6],[11,5],[14,5],[16,6],[17,8],[-1,-1],[12,16],[10,14],[9,11],[9,8],[10,6],[11,5],[-1,-1],[18,16],[17,8],[17,6],[19,5],[21,5],[23,7],[24,10],[24,12],[23,15],[22,17],[20,19],[18,20],[15,21],[12,21],[9,20],[7,19],[5,17],[4,15],[3,12],[3,9],[4,6],[5,4],[7,2],[9,1],[12,0],[15,0],[18,1],[20,2],[21,3],[-1,-1],[19,16],[18,8],[18,6],[19,5]]},A:{width:18,points:[[9,21],[1,0],[-1,-1],[9,21],[17,0],[-1,-1],[4,7],[14,7]]},B:{width:21,points:[[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,15],[17,13],[16,12],[13,11],[-1,-1],[4,11],[13,11],[16,10],[17,9],[18,7],[18,4],[17,2],[16,1],[13,0],[4,0]]},C:{width:21,points:[[18,16],[17,18],[15,20],[13,21],[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5]]},D:{width:21,points:[[4,21],[4,0],[-1,-1],[4,21],[11,21],[14,20],[16,18],[17,16],[18,13],[18,8],[17,5],[16,3],[14,1],[11,0],[4,0]]},E:{width:19,points:[[4,21],[4,0],[-1,-1],[4,21],[17,21],[-1,-1],[4,11],[12,11],[-1,-1],[4,0],[17,0]]},F:{width:18,points:[[4,21],[4,0],[-1,-1],[4,21],[17,21],[-1,-1],[4,11],[12,11]]},G:{width:21,points:[[18,16],[17,18],[15,20],[13,21],[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[18,8],[-1,-1],[13,8],[18,8]]},H:{width:22,points:[[4,21],[4,0],[-1,-1],[18,21],[18,0],[-1,-1],[4,11],[18,11]]},I:{width:8,points:[[4,21],[4,0]]},J:{width:16,points:[[12,21],[12,5],[11,2],[10,1],[8,0],[6,0],[4,1],[3,2],[2,5],[2,7]]},K:{width:21,points:[[4,21],[4,0],[-1,-1],[18,21],[4,7],[-1,-1],[9,12],[18,0]]},L:{width:17,points:[[4,21],[4,0],[-1,-1],[4,0],[16,0]]},M:{width:24,points:[[4,21],[4,0],[-1,-1],[4,21],[12,0],[-1,-1],[20,21],[12,0],[-1,-1],[20,21],[20,0]]},N:{width:22,points:[[4,21],[4,0],[-1,-1],[4,21],[18,0],[-1,-1],[18,21],[18,0]]},O:{width:22,points:[[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[19,8],[19,13],[18,16],[17,18],[15,20],[13,21],[9,21]]},P:{width:21,points:[[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,14],[17,12],[16,11],[13,10],[4,10]]},Q:{width:22,points:[[9,21],[7,20],[5,18],[4,16],[3,13],[3,8],[4,5],[5,3],[7,1],[9,0],[13,0],[15,1],[17,3],[18,5],[19,8],[19,13],[18,16],[17,18],[15,20],[13,21],[9,21],[-1,-1],[12,4],[18,-2]]},R:{width:21,points:[[4,21],[4,0],[-1,-1],[4,21],[13,21],[16,20],[17,19],[18,17],[18,15],[17,13],[16,12],[13,11],[4,11],[-1,-1],[11,11],[18,0]]},S:{width:20,points:[[17,18],[15,20],[12,21],[8,21],[5,20],[3,18],[3,16],[4,14],[5,13],[7,12],[13,10],[15,9],[16,8],[17,6],[17,3],[15,1],[12,0],[8,0],[5,1],[3,3]]},T:{width:16,points:[[8,21],[8,0],[-1,-1],[1,21],[15,21]]},U:{width:22,points:[[4,21],[4,6],[5,3],[7,1],[10,0],[12,0],[15,1],[17,3],[18,6],[18,21]]},V:{width:18,points:[[1,21],[9,0],[-1,-1],[17,21],[9,0]]},W:{width:24,points:[[2,21],[7,0],[-1,-1],[12,21],[7,0],[-1,-1],[12,21],[17,0],[-1,-1],[22,21],[17,0]]},X:{width:20,points:[[3,21],[17,0],[-1,-1],[17,21],[3,0]]},Y:{width:18,points:[[1,21],[9,11],[9,0],[-1,-1],[17,21],[9,11]]},Z:{width:20,points:[[17,21],[3,0],[-1,-1],[3,21],[17,21],[-1,-1],[3,0],[17,0]]},"[":{width:14,points:[[4,25],[4,-7],[-1,-1],[5,25],[5,-7],[-1,-1],[4,25],[11,25],[-1,-1],[4,-7],[11,-7]]},"\\":{width:14,points:[[0,21],[14,-3]]},"]":{width:14,points:[[9,25],[9,-7],[-1,-1],[10,25],[10,-7],[-1,-1],[3,25],[10,25],[-1,-1],[3,-7],[10,-7]]},"^":{width:16,points:[[6,15],[8,18],[10,15],[-1,-1],[3,12],[8,17],[13,12],[-1,-1],[8,17],[8,0]]},_:{width:16,points:[[0,-2],[16,-2]]},"`":{width:10,points:[[6,21],[5,20],[4,18],[4,16],[5,15],[6,16],[5,17]]},a:{width:19,points:[[15,14],[15,0],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},b:{width:19,points:[[4,21],[4,0],[-1,-1],[4,11],[6,13],[8,14],[11,14],[13,13],[15,11],[16,8],[16,6],[15,3],[13,1],[11,0],[8,0],[6,1],[4,3]]},c:{width:18,points:[[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},d:{width:19,points:[[15,21],[15,0],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},e:{width:18,points:[[3,8],[15,8],[15,10],[14,12],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},f:{width:12,points:[[10,21],[8,21],[6,20],[5,17],[5,0],[-1,-1],[2,14],[9,14]]},g:{width:19,points:[[15,14],[15,-2],[14,-5],[13,-6],[11,-7],[8,-7],[6,-6],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},h:{width:19,points:[[4,21],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0]]},i:{width:8,points:[[3,21],[4,20],[5,21],[4,22],[3,21],[-1,-1],[4,14],[4,0]]},j:{width:10,points:[[5,21],[6,20],[7,21],[6,22],[5,21],[-1,-1],[6,14],[6,-3],[5,-6],[3,-7],[1,-7]]},k:{width:17,points:[[4,21],[4,0],[-1,-1],[14,14],[4,4],[-1,-1],[8,8],[15,0]]},l:{width:8,points:[[4,21],[4,0]]},m:{width:30,points:[[4,14],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0],[-1,-1],[15,10],[18,13],[20,14],[23,14],[25,13],[26,10],[26,0]]},n:{width:19,points:[[4,14],[4,0],[-1,-1],[4,10],[7,13],[9,14],[12,14],[14,13],[15,10],[15,0]]},o:{width:19,points:[[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3],[16,6],[16,8],[15,11],[13,13],[11,14],[8,14]]},p:{width:19,points:[[4,14],[4,-7],[-1,-1],[4,11],[6,13],[8,14],[11,14],[13,13],[15,11],[16,8],[16,6],[15,3],[13,1],[11,0],[8,0],[6,1],[4,3]]},q:{width:19,points:[[15,14],[15,-7],[-1,-1],[15,11],[13,13],[11,14],[8,14],[6,13],[4,11],[3,8],[3,6],[4,3],[6,1],[8,0],[11,0],[13,1],[15,3]]},r:{width:13,points:[[4,14],[4,0],[-1,-1],[4,8],[5,11],[7,13],[9,14],[12,14]]},s:{width:17,points:[[14,11],[13,13],[10,14],[7,14],[4,13],[3,11],[4,9],[6,8],[11,7],[13,6],[14,4],[14,3],[13,1],[10,0],[7,0],[4,1],[3,3]]},t:{width:12,points:[[5,21],[5,4],[6,1],[8,0],[10,0],[-1,-1],[2,14],[9,14]]},u:{width:19,points:[[4,14],[4,4],[5,1],[7,0],[10,0],[12,1],[15,4],[-1,-1],[15,14],[15,0]]},v:{width:16,points:[[2,14],[8,0],[-1,-1],[14,14],[8,0]]},w:{width:22,points:[[3,14],[7,0],[-1,-1],[11,14],[7,0],[-1,-1],[11,14],[15,0],[-1,-1],[19,14],[15,0]]},x:{width:17,points:[[3,14],[14,0],[-1,-1],[14,14],[3,0]]},y:{width:16,points:[[2,14],[8,0],[-1,-1],[14,14],[8,0],[6,-4],[4,-6],[2,-7],[1,-7]]},z:{width:17,points:[[14,14],[3,0],[-1,-1],[3,14],[14,14],[-1,-1],[3,0],[14,0]]},"{":{width:14,points:[[9,25],[7,24],[6,23],[5,21],[5,19],[6,17],[7,16],[8,14],[8,12],[6,10],[-1,-1],[7,24],[6,22],[6,20],[7,18],[8,17],[9,15],[9,13],[8,11],[4,9],[8,7],[9,5],[9,3],[8,1],[7,0],[6,-2],[6,-4],[7,-6],[-1,-1],[6,8],[8,6],[8,4],[7,2],[6,1],[5,-1],[5,-3],[6,-5],[7,-6],[9,-7]]},"|":{width:8,points:[[4,25],[4,-7]]},"}":{width:14,points:[[5,25],[7,24],[8,23],[9,21],[9,19],[8,17],[7,16],[6,14],[6,12],[8,10],[-1,-1],[7,24],[8,22],[8,20],[7,18],[6,17],[5,15],[5,13],[6,11],[10,9],[6,7],[5,5],[5,3],[6,1],[7,0],[8,-2],[8,-4],[7,-6],[-1,-1],[8,8],[6,6],[6,4],[7,2],[8,1],[9,-1],[9,-3],[8,-5],[7,-6],[5,-7]]},"~":{width:24,points:[[3,6],[3,8],[4,11],[6,12],[8,12],[10,11],[14,8],[16,7],[18,7],[20,8],[21,10],[-1,-1],[3,8],[4,10],[6,11],[8,11],[10,10],[14,7],[16,6],[18,6],[20,7],[21,10],[21,12]]}};a.jqplot.CanvasFontRenderer=function(b){b=b||{};if(!b.pt2px){b.pt2px=1.5}a.jqplot.CanvasTextRenderer.call(this,b)};a.jqplot.CanvasFontRenderer.prototype=new a.jqplot.CanvasTextRenderer({});a.jqplot.CanvasFontRenderer.prototype.constructor=a.jqplot.CanvasFontRenderer;a.jqplot.CanvasFontRenderer.prototype.measure=function(c,e){var d=this.fontSize+" "+this.fontFamily;c.save();c.font=d;var b=c.measureText(e).width;c.restore();return b};a.jqplot.CanvasFontRenderer.prototype.draw=function(e,g){var c=0;var h=this.height*0.72;e.save();var d,b;if((-Math.PI/2<=this.angle&&this.angle<=0)||(Math.PI*3/2<=this.angle&&this.angle<=Math.PI*2)){d=0;b=-Math.sin(this.angle)*this.width}else{if((0<this.angle&&this.angle<=Math.PI/2)||(-Math.PI*2<=this.angle&&this.angle<=-Math.PI*3/2)){d=Math.sin(this.angle)*this.height;b=0}else{if((-Math.PI<this.angle&&this.angle<-Math.PI/2)||(Math.PI<=this.angle&&this.angle<=Math.PI*3/2)){d=-Math.cos(this.angle)*this.width;b=-Math.sin(this.angle)*this.width-Math.cos(this.angle)*this.height}else{if((-Math.PI*3/2<this.angle&&this.angle<Math.PI)||(Math.PI/2<this.angle&&this.angle<Math.PI)){d=Math.sin(this.angle)*this.height-Math.cos(this.angle)*this.width;b=-Math.cos(this.angle)*this.height}}}}e.strokeStyle=this.fillStyle;e.fillStyle=this.fillStyle;var f=this.fontSize+" "+this.fontFamily;e.font=f;e.translate(d,b);e.rotate(this.angle);e.fillText(g,c,h);e.restore()}})(jQuery);
/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function($) {   
    /**
    *  class: $.jqplot.CategoryAxisRenderer
    *  A plugin for jqPlot to render a category style axis, with equal pixel spacing between y data values of a series.
    *  
    *  To use this renderer, include the plugin in your source
    *  > <script type="text/javascript" language="javascript" src="plugins/jqplot.categoryAxisRenderer.js"></script>
    *  
    *  and supply the appropriate options to your plot
    *  
    *  > {axes:{xaxis:{renderer:$.jqplot.CategoryAxisRenderer}}}
    **/
    $.jqplot.CategoryAxisRenderer = function(options) {
        $.jqplot.LinearAxisRenderer.call(this);
        // prop: sortMergedLabels
        // True to sort tick labels when labels are created by merging
        // x axis values from multiple series.  That is, say you have
        // two series like:
        // > line1 = [[2006, 4],            [2008, 9], [2009, 16]];
        // > line2 = [[2006, 3], [2007, 7], [2008, 6]];
        // If no label array is specified, tick labels will be collected
        // from the x values of the series.  With sortMergedLabels
        // set to true, tick labels will be:
        // > [2006, 2007, 2008, 2009]
        // With sortMergedLabels set to false, tick labels will be:
        // > [2006, 2008, 2009, 2007]
        //
        // Note, this property is specified on the renderOptions for the 
        // axes when creating a plot:
        // > axes:{xaxis:{renderer:$.jqplot.CategoryAxisRenderer, rendererOptions:{sortMergedLabels:true}}}
        this.sortMergedLabels = false;
    };
    
    $.jqplot.CategoryAxisRenderer.prototype = new $.jqplot.LinearAxisRenderer();
    $.jqplot.CategoryAxisRenderer.prototype.constructor = $.jqplot.CategoryAxisRenderer;
    
    $.jqplot.CategoryAxisRenderer.prototype.init = function(options){
        this.groups = 1;
        this.groupLabels = [];
        this._groupLabels = [];
        this._grouped = false;
        this._barsPerGroup = null;
        this.reverse = false;
        // prop: tickRenderer
        // A class of a rendering engine for creating the ticks labels displayed on the plot, 
        // See <$.jqplot.AxisTickRenderer>.
        // this.tickRenderer = $.jqplot.AxisTickRenderer;
        // this.labelRenderer = $.jqplot.AxisLabelRenderer;
        $.extend(true, this, {tickOptions:{formatString:'%d'}}, options);
        var db = this._dataBounds;
        // Go through all the series attached to this axis and find
        // the min/max bounds for this axis.
        for (var i=0; i<this._series.length; i++) {
            var s = this._series[i];
            if (s.groups) {
                this.groups = s.groups;
            }
            var d = s.data;
            
            for (var j=0; j<d.length; j++) { 
                if (this.name == 'xaxis' || this.name == 'x2axis') {
                    if (d[j][0] < db.min || db.min == null) {
                        db.min = d[j][0];
                    }
                    if (d[j][0] > db.max || db.max == null) {
                        db.max = d[j][0];
                    }
                }              
                else {
                    if (d[j][1] < db.min || db.min == null) {
                        db.min = d[j][1];
                    }
                    if (d[j][1] > db.max || db.max == null) {
                        db.max = d[j][1];
                    }
                }              
            }
        }
        
        if (this.groupLabels.length) {
            this.groups = this.groupLabels.length;
        }
    };
 

    $.jqplot.CategoryAxisRenderer.prototype.createTicks = function() {
        // we're are operating on an axis here
        var ticks = this._ticks;
        var userTicks = this.ticks;
        var name = this.name;
        // databounds were set on axis initialization.
        var db = this._dataBounds;
        var dim, interval;
        var min, max;
        var pos1, pos2;
        var tt, i;

        // if we already have ticks, use them.
        if (userTicks.length) {
            // adjust with blanks if we have groups
            if (this.groups > 1 && !this._grouped) {
                var l = userTicks.length;
                var skip = parseInt(l/this.groups, 10);
                var count = 0;
                for (var i=skip; i<l; i+=skip) {
                    userTicks.splice(i+count, 0, ' ');
                    count++;
                }
                this._grouped = true;
            }
            this.min = 0.5;
            this.max = userTicks.length + 0.5;
            var range = this.max - this.min;
            this.numberTicks = 2*userTicks.length + 1;
            for (i=0; i<userTicks.length; i++){
                tt = this.min + 2 * i * range / (this.numberTicks-1);
                // need a marker before and after the tick
                var t = new this.tickRenderer(this.tickOptions);
                t.showLabel = false;
                // t.showMark = true;
                t.setTick(tt, this.name);
                this._ticks.push(t);
                var t = new this.tickRenderer(this.tickOptions);
                t.label = userTicks[i];
                // t.showLabel = true;
                t.showMark = false;
                t.showGridline = false;
                t.setTick(tt+0.5, this.name);
                this._ticks.push(t);
            }
            // now add the last tick at the end
            var t = new this.tickRenderer(this.tickOptions);
            t.showLabel = false;
            // t.showMark = true;
            t.setTick(tt+1, this.name);
            this._ticks.push(t);
        }

        // we don't have any ticks yet, let's make some!
        else {
            if (name == 'xaxis' || name == 'x2axis') {
                dim = this._plotDimensions.width;
            }
            else {
                dim = this._plotDimensions.height;
            }
            
            // if min, max and number of ticks specified, user can't specify interval.
            if (this.min != null && this.max != null && this.numberTicks != null) {
                this.tickInterval = null;
            }
            
            // if max, min, and interval specified and interval won't fit, ignore interval.
            if (this.min != null && this.max != null && this.tickInterval != null) {
                if (parseInt((this.max-this.min)/this.tickInterval, 10) != (this.max-this.min)/this.tickInterval) {
                    this.tickInterval = null;
                }
            }
        
            // find out how many categories are in the lines and collect labels
            var labels = [];
            var numcats = 0;
            var min = 0.5;
            var max, val;
            var isMerged = false;
            for (var i=0; i<this._series.length; i++) {
                var s = this._series[i];
                for (var j=0; j<s.data.length; j++) {
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        val = s.data[j][0];
                    }
                    else {
                        val = s.data[j][1];
                    }
                    if ($.inArray(val, labels) == -1) {
                        isMerged = true;
                        numcats += 1;      
                        labels.push(val);
                    }
                }
            }
            
            if (isMerged && this.sortMergedLabels) {
                if (typeof labels[0] == "string") {
                    labels.sort();
                } else {
                    labels.sort(function(a,b) { return a - b; });
                }
            }
            
            // keep a reference to these tick labels to use for redrawing plot (see bug #57)
            this.ticks = labels;
            
            // now bin the data values to the right lables.
            for (var i=0; i<this._series.length; i++) {
                var s = this._series[i];
                for (var j=0; j<s.data.length; j++) {
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        val = s.data[j][0];
                    }
                    else {
                        val = s.data[j][1];
                    }
                    // for category axis, force the values into category bins.
                    // we should have the value in the label array now.
                    var idx = $.inArray(val, labels)+1;
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        s.data[j][0] = idx;
                    }
                    else {
                        s.data[j][1] = idx;
                    }
                }
            }
            
            // adjust with blanks if we have groups
            if (this.groups > 1 && !this._grouped) {
                var l = labels.length;
                var skip = parseInt(l/this.groups, 10);
                var count = 0;
                for (var i=skip; i<l; i+=skip+1) {
                    labels[i] = ' ';
                }
                this._grouped = true;
            }
        
            max = numcats + 0.5;
            if (this.numberTicks == null) {
                this.numberTicks = 2*numcats + 1;
            }

            var range = max - min;
            this.min = min;
            this.max = max;
            var track = 0;
            
            // todo: adjust this so more ticks displayed.
            var maxVisibleTicks = parseInt(3+dim/10, 10);
            var skip = parseInt(numcats/maxVisibleTicks, 10);

            if (this.tickInterval == null) {

                this.tickInterval = range / (this.numberTicks-1);

            }
            // if tickInterval is specified, we will ignore any computed maximum.
            for (var i=0; i<this.numberTicks; i++){
                tt = this.min + i * this.tickInterval;
                var t = new this.tickRenderer(this.tickOptions);
                // if even tick, it isn't a category, it's a divider
                if (i/2 == parseInt(i/2, 10)) {
                    t.showLabel = false;
                    t.showMark = true;
                }
                else {
                    if (skip>0 && track<skip) {
                        t.showLabel = false;
                        track += 1;
                    }
                    else {
                        t.showLabel = true;
                        track = 0;
                    } 
                    t.label = t.formatter(t.formatString, labels[(i-1)/2]);
                    t.showMark = false;
                    t.showGridline = false;
                }
                t.setTick(tt, this.name);
                this._ticks.push(t);
            }
        }
        
    };
    
    // called with scope of axis
    $.jqplot.CategoryAxisRenderer.prototype.draw = function(ctx, plot) {
        if (this.show) {
            // populate the axis label and value properties.
            // createTicks is a method on the renderer, but
            // call it within the scope of the axis.
            this.renderer.createTicks.call(this);
            // fill a div with axes labels in the right direction.
            // Need to pregenerate each axis to get its bounds and
            // position it and the labels correctly on the plot.
            var dim=0;
            var temp;
            // Added for theming.
            if (this._elem) {
                // this._elem.empty();
                // Memory Leaks patch
                this._elem.emptyForce();
            }

            this._elem = this._elem || $('<div class="jqplot-axis jqplot-'+this.name+'" style="position:absolute;"></div>');
            
            if (this.name == 'xaxis' || this.name == 'x2axis') {
                this._elem.width(this._plotDimensions.width);
            }
            else {
                this._elem.height(this._plotDimensions.height);
            }
            
            // create a _label object.
            this.labelOptions.axis = this.name;
            this._label = new this.labelRenderer(this.labelOptions);
            if (this._label.show) {
                var elem = this._label.draw(ctx, plot);
                elem.appendTo(this._elem);
            }
    
            var t = this._ticks;
            for (var i=0; i<t.length; i++) {
                var tick = t[i];
                if (tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {
                    var elem = tick.draw(ctx, plot);
                    elem.appendTo(this._elem);
                }
            }
        
            this._groupLabels = [];
            // now make group labels
            for (var i=0; i<this.groupLabels.length; i++)
            {
                var elem = $('<div style="position:absolute;" class="jqplot-'+this.name+'-groupLabel"></div>');
                elem.html(this.groupLabels[i]);
                this._groupLabels.push(elem);
                elem.appendTo(this._elem);
            }
        }
        return this._elem;
    };
    
    // called with scope of axis
    $.jqplot.CategoryAxisRenderer.prototype.set = function() { 
        var dim = 0;
        var temp;
        var w = 0;
        var h = 0;
        var lshow = (this._label == null) ? false : this._label.show;
        if (this.show) {
            var t = this._ticks;
            for (var i=0; i<t.length; i++) {
                var tick = t[i];
                if (tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        temp = tick._elem.outerHeight(true);
                    }
                    else {
                        temp = tick._elem.outerWidth(true);
                    }
                    if (temp > dim) {
                        dim = temp;
                    }
                }
            }
            
            var dim2 = 0;
            for (var i=0; i<this._groupLabels.length; i++) {
                var l = this._groupLabels[i];
                if (this.name == 'xaxis' || this.name == 'x2axis') {
                    temp = l.outerHeight(true);
                }
                else {
                    temp = l.outerWidth(true);
                }
                if (temp > dim2) {
                    dim2 = temp;
                }
            }
            
            if (lshow) {
                w = this._label._elem.outerWidth(true);
                h = this._label._elem.outerHeight(true); 
            }
            if (this.name == 'xaxis') {
                dim += dim2 + h;
                this._elem.css({'height':dim+'px', left:'0px', bottom:'0px'});
            }
            else if (this.name == 'x2axis') {
                dim += dim2 + h;
                this._elem.css({'height':dim+'px', left:'0px', top:'0px'});
            }
            else if (this.name == 'yaxis') {
                dim += dim2 + w;
                this._elem.css({'width':dim+'px', left:'0px', top:'0px'});
                if (lshow && this._label.constructor == $.jqplot.AxisLabelRenderer) {
                    this._label._elem.css('width', w+'px');
                }
            }
            else {
                dim += dim2 + w;
                this._elem.css({'width':dim+'px', right:'0px', top:'0px'});
                if (lshow && this._label.constructor == $.jqplot.AxisLabelRenderer) {
                    this._label._elem.css('width', w+'px');
                }
            }
        }  
    };
    
    // called with scope of axis
    $.jqplot.CategoryAxisRenderer.prototype.pack = function(pos, offsets) {
        var ticks = this._ticks;
        var max = this.max;
        var min = this.min;
        var offmax = offsets.max;
        var offmin = offsets.min;
        var lshow = (this._label == null) ? false : this._label.show;
        var i;

        for (var p in pos) {
            this._elem.css(p, pos[p]);
        }
        
        this._offsets = offsets;
        // pixellength will be + for x axes and - for y axes becasue pixels always measured from top left.
        var pixellength = offmax - offmin;
        var unitlength = max - min;
        
        if (!this.reverse) {
            // point to unit and unit to point conversions references to Plot DOM element top left corner.
            
            this.u2p = function(u){
                return (u - min) * pixellength / unitlength + offmin;
            };

            this.p2u = function(p){
                return (p - offmin) * unitlength / pixellength + min;
            };
                    
            if (this.name == 'xaxis' || this.name == 'x2axis'){
                this.series_u2p = function(u){
                    return (u - min) * pixellength / unitlength;
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + min;
                };
            }
            
            else {
                this.series_u2p = function(u){
                    return (u - max) * pixellength / unitlength;
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + max;
                };
            }
        }

        else {
            // point to unit and unit to point conversions references to Plot DOM element top left corner.
            
            this.u2p = function(u){
                return offmin + (max - u) * pixellength / unitlength;
            };

            this.p2u = function(p){
                return min + (p - offmin) * unitlength / pixellength;
            };
                    
            if (this.name == 'xaxis' || this.name == 'x2axis'){
                this.series_u2p = function(u){
                    return (max - u) * pixellength / unitlength;
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + max;
                };
            }
            
            else {
                this.series_u2p = function(u){
                    return (min - u) * pixellength / unitlength;
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + min;
                };
            }

        }
            
        
        if (this.show) {
            if (this.name == 'xaxis' || this.name == 'x2axis') {
                for (i=0; i<ticks.length; i++) {
                    var t = ticks[i];
                    if (t.show && t.showLabel) {
                        var shim;
                        
                        if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) {
                            // will need to adjust auto positioning based on which axis this is.
                            var temp = (this.name == 'xaxis') ? 1 : -1;
                            switch (t.labelPosition) {
                                case 'auto':
                                    // position at end
                                    if (temp * t.angle < 0) {
                                        shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    }
                                    // position at start
                                    else {
                                        shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'end':
                                    shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                                case 'start':
                                    shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    break;
                                case 'middle':
                                    shim = -t.getWidth()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                                default:
                                    shim = -t.getWidth()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                            }
                        }
                        else {
                            shim = -t.getWidth()/2;
                        }
                        var val = this.u2p(t.value) + shim + 'px';
                        t._elem.css('left', val);
                        t.pack();
                    }
                }
                
                var labeledge=['bottom', 0];
                if (lshow) {
                    var w = this._label._elem.outerWidth(true);
                    this._label._elem.css('left', offmin + pixellength/2 - w/2 + 'px');
                    if (this.name == 'xaxis') {
                        this._label._elem.css('bottom', '0px');
                        labeledge = ['bottom', this._label._elem.outerHeight(true)];
                    }
                    else {
                        this._label._elem.css('top', '0px');
                        labeledge = ['top', this._label._elem.outerHeight(true)];
                    }
                    this._label.pack();
                }
                
                // draw the group labels
                var step = parseInt(this._ticks.length/this.groups, 10) + 1;
                for (i=0; i<this._groupLabels.length; i++) {
                    var mid = 0;
                    var count = 0;
                    for (var j=i*step; j<(i+1)*step; j++) {
                        if (j >= this._ticks.length-1) continue; // the last tick does not exist as there is no other group in order to have an empty one.
                        if (this._ticks[j]._elem && this._ticks[j].label != " ") {
                            var t = this._ticks[j]._elem;
                            var p = t.position();
                            mid += p.left + t.outerWidth(true)/2;
                            count++;
                        }
                    }
                    mid = mid/count;
                    this._groupLabels[i].css({'left':(mid - this._groupLabels[i].outerWidth(true)/2)});
                    this._groupLabels[i].css(labeledge[0], labeledge[1]);
                }
            }
            else {
                for (i=0; i<ticks.length; i++) {
                    var t = ticks[i];
                    if (t.show && t.showLabel) {                        
                        var shim;
                        if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) {
                            // will need to adjust auto positioning based on which axis this is.
                            var temp = (this.name == 'yaxis') ? 1 : -1;
                            switch (t.labelPosition) {
                                case 'auto':
                                    // position at end
                                case 'end':
                                    if (temp * t.angle < 0) {
                                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                                    }
                                    else {
                                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'start':
                                    if (t.angle > 0) {
                                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                                    }
                                    else {
                                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'middle':
                                    // if (t.angle > 0) {
                                    //     shim = -t.getHeight()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    // }
                                    // else {
                                    //     shim = -t.getHeight()/2 - t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    // }
                                    shim = -t.getHeight()/2;
                                    break;
                                default:
                                    shim = -t.getHeight()/2;
                                    break;
                            }
                        }
                        else {
                            shim = -t.getHeight()/2;
                        }
                        
                        var val = this.u2p(t.value) + shim + 'px';
                        t._elem.css('top', val);
                        t.pack();
                    }
                }
                
                var labeledge=['left', 0];
                if (lshow) {
                    var h = this._label._elem.outerHeight(true);
                    this._label._elem.css('top', offmax - pixellength/2 - h/2 + 'px');
                    if (this.name == 'yaxis') {
                        this._label._elem.css('left', '0px');
                        labeledge = ['left', this._label._elem.outerWidth(true)];
                    }
                    else {
                        this._label._elem.css('right', '0px');
                        labeledge = ['right', this._label._elem.outerWidth(true)];
                    }   
                    this._label.pack();
                }
                
                // draw the group labels, position top here, do left after label position.
                var step = parseInt(this._ticks.length/this.groups, 10) + 1; // step is one more than before as we don't want to have overlaps in loops
                for (i=0; i<this._groupLabels.length; i++) {
                    var mid = 0;
                    var count = 0;
                    for (var j=i*step; j<(i+1)*step; j++) { // j must never reach (i+1)*step as we don't want to have overlap between loops
                        if (j >= this._ticks.length-1) continue; // the last tick does not exist as there is no other group in order to have an empty one.
                        if (this._ticks[j]._elem && this._ticks[j].label != " ") {
                            var t = this._ticks[j]._elem;
                            var p = t.position();
                            mid += p.top + t.outerHeight()/2;
                            count++;
                        }
                    }
                    mid = mid/count;
                    this._groupLabels[i].css({'top':mid - this._groupLabels[i].outerHeight()/2});
                    this._groupLabels[i].css(labeledge[0], labeledge[1]);
                    
                }
            }
        }
    };    
    
    
})(jQuery);

/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(a){a.jqplot.ciParser=function(g,l){var m=[],o,n,h,f,e,c;if(typeof(g)=="string"){g=a.jqplot.JSON.parse(g,d)}else{if(typeof(g)=="object"){for(e in g){for(h=0;h<g[e].length;h++){for(c in g[e][h]){g[e][h][c]=d(c,g[e][h][c])}}}}else{return null}}function d(j,k){var i;if(k!=null){if(k.toString().indexOf("Date")>=0){i=/^\/Date\((-?[0-9]+)\)\/$/.exec(k);if(i){return parseInt(i[1],10)}}return k}}for(var b in g){o=[];n=g[b];switch(b){case"PriceTicks":for(h=0;h<n.length;h++){o.push([n[h]["TickDate"],n[h]["Price"]])}break;case"PriceBars":for(h=0;h<n.length;h++){o.push([n[h]["BarDate"],n[h]["Open"],n[h]["High"],n[h]["Low"],n[h]["Close"]])}break}m.push(o)}return m}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(h){h.jqplot.DateAxisRenderer=function(){h.jqplot.LinearAxisRenderer.call(this);this.date=new h.jsDate()};var c=1000;var e=60*c;var f=60*e;var l=24*f;var b=7*l;var j=30.4368499*l;var k=365.242199*l;var g=[31,28,31,30,31,30,31,30,31,30,31,30];var i=["%M:%S.%#N","%M:%S.%#N","%M:%S.%#N","%M:%S","%M:%S","%M:%S","%M:%S","%H:%M:%S","%H:%M:%S","%H:%M","%H:%M","%H:%M","%H:%M","%H:%M","%H:%M","%a %H:%M","%a %H:%M","%b %e %H:%M","%b %e %H:%M","%b %e %H:%M","%b %e %H:%M","%v","%v","%v","%v","%v","%v","%v"];var m=[0.1*c,0.2*c,0.5*c,c,2*c,5*c,10*c,15*c,30*c,e,2*e,5*e,10*e,15*e,30*e,f,2*f,4*f,6*f,8*f,12*f,l,2*l,3*l,4*l,5*l,b,2*b];var d=[];function a(p,s,t){var o=Number.MAX_VALUE;var u,r,v;for(var q=0,n=m.length;q<n;q++){u=Math.abs(t-m[q]);if(u<o){o=u;r=m[q];v=i[q]}}return[r,v]}h.jqplot.DateAxisRenderer.prototype=new h.jqplot.LinearAxisRenderer();h.jqplot.DateAxisRenderer.prototype.constructor=h.jqplot.DateAxisRenderer;h.jqplot.DateTickFormatter=function(n,o){if(!n){n="%Y/%m/%d"}return h.jsDate.strftime(o,n)};h.jqplot.DateAxisRenderer.prototype.init=function(E){this.tickOptions.formatter=h.jqplot.DateTickFormatter;this.tickInset=0;this.drawBaseline=true;this.baselineWidth=null;this.baselineColor=null;this.daTickInterval=null;this._daTickInterval=null;h.extend(true,this,E);var C=this._dataBounds,u,x,D,y,A,z,o;for(var t=0;t<this._series.length;t++){u={intervals:[],frequencies:{},sortedIntervals:[],min:null,max:null,mean:null};x=0;D=this._series[t];y=D.data;A=D._plotData;z=D._stackData;o=0;for(var r=0;r<y.length;r++){if(this.name=="xaxis"||this.name=="x2axis"){y[r][0]=new h.jsDate(y[r][0]).getTime();A[r][0]=new h.jsDate(y[r][0]).getTime();z[r][0]=new h.jsDate(y[r][0]).getTime();if((y[r][0]!=null&&y[r][0]<C.min)||C.min==null){C.min=y[r][0]}if((y[r][0]!=null&&y[r][0]>C.max)||C.max==null){C.max=y[r][0]}if(r>0){o=Math.abs(y[r][0]-y[r-1][0]);u.intervals.push(o);if(u.frequencies.hasOwnProperty(o)){u.frequencies[o]+=1}else{u.frequencies[o]=1}}x+=o}else{y[r][1]=new h.jsDate(y[r][1]).getTime();A[r][1]=new h.jsDate(y[r][1]).getTime();z[r][1]=new h.jsDate(y[r][1]).getTime();if((y[r][1]!=null&&y[r][1]<C.min)||C.min==null){C.min=y[r][1]}if((y[r][1]!=null&&y[r][1]>C.max)||C.max==null){C.max=y[r][1]}if(r>0){o=Math.abs(y[r][1]-y[r-1][1]);u.intervals.push(o);if(u.frequencies.hasOwnProperty(o)){u.frequencies[o]+=1}else{u.frequencies[o]=1}}}x+=o}if(D.renderer.bands){if(D.renderer.bands.hiData.length){var w=D.renderer.bands.hiData;for(var r=0,q=w.length;r<q;r++){if(this.name==="xaxis"||this.name==="x2axis"){w[r][0]=new h.jsDate(w[r][0]).getTime();if((w[r][0]!=null&&w[r][0]>C.max)||C.max==null){C.max=w[r][0]}}else{w[r][1]=new h.jsDate(w[r][1]).getTime();if((w[r][1]!=null&&w[r][1]>C.max)||C.max==null){C.max=w[r][1]}}}}if(D.renderer.bands.lowData.length){var w=D.renderer.bands.lowData;for(var r=0,q=w.length;r<q;r++){if(this.name==="xaxis"||this.name==="x2axis"){w[r][0]=new h.jsDate(w[r][0]).getTime();if((w[r][0]!=null&&w[r][0]<C.min)||C.min==null){C.min=w[r][0]}}else{w[r][1]=new h.jsDate(w[r][1]).getTime();if((w[r][1]!=null&&w[r][1]<C.min)||C.min==null){C.min=w[r][1]}}}}}var B=0,v=0;for(var p in u.frequencies){u.sortedIntervals.push({interval:p,frequency:u.frequencies[p]})}u.sortedIntervals.sort(function(s,n){return n.frequency-s.frequency});u.min=h.jqplot.arrayMin(u.intervals);u.max=h.jqplot.arrayMax(u.intervals);u.mean=x/y.length;this._intervalStats.push(u);u=x=D=y=A=z=null}C=null};h.jqplot.DateAxisRenderer.prototype.reset=function(){this.min=this._options.min;this.max=this._options.max;this.tickInterval=this._options.tickInterval;this.numberTicks=this._options.numberTicks;this._autoFormatString="";if(this._overrideFormatString&&this.tickOptions&&this.tickOptions.formatString){this.tickOptions.formatString=""}this.daTickInterval=this._daTickInterval};h.jqplot.DateAxisRenderer.prototype.createTicks=function(p){var X=this._ticks;var L=this.ticks;var F=this.name;var H=this._dataBounds;var M=this._intervalStats;var n=(this.name.charAt(0)==="x")?this._plotDimensions.width:this._plotDimensions.height;var w;var ae,J;var y,x;var ad,aa;var s=30;var O=1;var U=null;if(this.tickInterval!=null){if(Number(this.tickInterval)){U=[Number(this.tickInterval),"seconds"]}else{if(typeof this.tickInterval=="string"){var ac=this.tickInterval.split(" ");if(ac.length==1){U=[1,ac[0]]}else{if(ac.length==2){U=[ac[0],ac[1]]}}}}}var v=this.tickInterval;ae=new h.jsDate((this.min!=null)?this.min:H.min).getTime();J=new h.jsDate((this.max!=null)?this.max:H.max).getTime();var A=p.plugins.cursor;if(A&&A._zoom&&A._zoom.zooming){this.min=null;this.max=null}var B=J-ae;if(this.tickOptions==null||!this.tickOptions.formatString){this._overrideFormatString=true}if(L.length){for(aa=0;aa<L.length;aa++){var P=L[aa];var Y=new this.tickRenderer(this.tickOptions);if(P.constructor==Array){Y.value=new h.jsDate(P[0]).getTime();Y.label=P[1];if(!this.showTicks){Y.showLabel=false;Y.showMark=false}else{if(!this.showTickMarks){Y.showMark=false}}Y.setTick(Y.value,this.name);this._ticks.push(Y)}else{Y.value=new h.jsDate(P).getTime();if(!this.showTicks){Y.showLabel=false;Y.showMark=false}else{if(!this.showTickMarks){Y.showMark=false}}Y.setTick(Y.value,this.name);this._ticks.push(Y)}}this.numberTicks=L.length;this.min=this._ticks[0].value;this.max=this._ticks[this.numberTicks-1].value;this.daTickInterval=[(this.max-this.min)/(this.numberTicks-1)/1000,"seconds"]}else{if(this.min==null&&this.max==null&&H.min==H.max){var E=h.extend(true,{},this.tickOptions,{name:this.name,value:null});var T=300000;this.min=H.min-T;this.max=H.max+T;this.numberTicks=3;for(var aa=this.min;aa<=this.max;aa+=T){E.value=aa;var Y=new this.tickRenderer(E);if(this._overrideFormatString&&this._autoFormatString!=""){Y.formatString=this._autoFormatString}Y.showLabel=false;Y.showMark=false;this._ticks.push(Y)}if(this.showTicks){this._ticks[1].showLabel=true}if(this.showTickMarks){this._ticks[1].showTickMarks=true}}else{if(this.min==null&&this.max==null){var N=h.extend(true,{},this.tickOptions,{name:this.name,value:null});var ab,I;if(!this.tickInterval&&!this.numberTicks){var R=Math.max(n,s+1);var Z=115;if(this.tickRenderer===h.jqplot.CanvasAxisTickRenderer&&this.tickOptions.angle){Z=115-40*Math.abs(Math.sin(this.tickOptions.angle/180*Math.PI))}ab=Math.ceil((R-s)/Z+1);I=(J-ae)/(ab-1)}else{if(this.tickInterval){I=new h.jsDate(0).add(U[0],U[1]).getTime()}else{if(this.numberTicks){ab=this.numberTicks;I=(J-ae)/(ab-1)}}}if(I<=19*l){var Q=a(ae,J,I);var r=Q[0];this._autoFormatString=Q[1];ae=new h.jsDate(ae);ae=Math.floor((ae.getTime()-ae.getUtcOffset())/r)*r+ae.getUtcOffset();ab=Math.ceil((J-ae)/r)+1;this.min=ae;this.max=ae+(ab-1)*r;if(this.max<J){this.max+=r;ab+=1}this.tickInterval=r;this.numberTicks=ab;for(var aa=0;aa<ab;aa++){N.value=this.min+aa*r;Y=new this.tickRenderer(N);if(this._overrideFormatString&&this._autoFormatString!=""){Y.formatString=this._autoFormatString}if(!this.showTicks){Y.showLabel=false;Y.showMark=false}else{if(!this.showTickMarks){Y.showMark=false}}this._ticks.push(Y)}O=this.tickInterval}else{if(I<=9*j){this._autoFormatString="%v";var D=Math.round(I/j);if(D<1){D=1}else{if(D>6){D=6}}var V=new h.jsDate(ae).setDate(1).setHours(0,0,0,0);var q=new h.jsDate(J);var z=new h.jsDate(J).setDate(1).setHours(0,0,0,0);if(q.getTime()!==z.getTime()){z=z.add(1,"month")}var S=z.diff(V,"month");ab=Math.ceil(S/D)+1;this.min=V.getTime();this.max=V.clone().add((ab-1)*D,"month").getTime();this.numberTicks=ab;for(var aa=0;aa<ab;aa++){if(aa===0){N.value=V.getTime()}else{N.value=V.add(D,"month").getTime()}Y=new this.tickRenderer(N);if(this._overrideFormatString&&this._autoFormatString!=""){Y.formatString=this._autoFormatString}if(!this.showTicks){Y.showLabel=false;Y.showMark=false}else{if(!this.showTickMarks){Y.showMark=false}}this._ticks.push(Y)}O=D*j}else{this._autoFormatString="%v";var D=Math.round(I/k);if(D<1){D=1}var V=new h.jsDate(ae).setMonth(0,1).setHours(0,0,0,0);var z=new h.jsDate(J).add(1,"year").setMonth(0,1).setHours(0,0,0,0);var K=z.diff(V,"year");ab=Math.ceil(K/D)+1;this.min=V.getTime();this.max=V.clone().add((ab-1)*D,"year").getTime();this.numberTicks=ab;for(var aa=0;aa<ab;aa++){if(aa===0){N.value=V.getTime()}else{N.value=V.add(D,"year").getTime()}Y=new this.tickRenderer(N);if(this._overrideFormatString&&this._autoFormatString!=""){Y.formatString=this._autoFormatString}if(!this.showTicks){Y.showLabel=false;Y.showMark=false}else{if(!this.showTickMarks){Y.showMark=false}}this._ticks.push(Y)}O=D*k}}}else{if(F=="xaxis"||F=="x2axis"){n=this._plotDimensions.width}else{n=this._plotDimensions.height}if(this.min!=null&&this.max!=null&&this.numberTicks!=null){this.tickInterval=null}if(this.tickInterval!=null&&U!=null){this.daTickInterval=U}if(ae==J){var o=24*60*60*500;ae-=o;J+=o}B=J-ae;var G=2+parseInt(Math.max(0,n-100)/100,10);var W,C;W=(this.min!=null)?new h.jsDate(this.min).getTime():ae-B/2*(this.padMin-1);C=(this.max!=null)?new h.jsDate(this.max).getTime():J+B/2*(this.padMax-1);this.min=W;this.max=C;B=this.max-this.min;if(this.numberTicks==null){if(this.daTickInterval!=null){var u=new h.jsDate(this.max).diff(this.min,this.daTickInterval[1],true);this.numberTicks=Math.ceil(u/this.daTickInterval[0])+1;this.max=new h.jsDate(this.min).add((this.numberTicks-1)*this.daTickInterval[0],this.daTickInterval[1]).getTime()}else{if(n>200){this.numberTicks=parseInt(3+(n-200)/100,10)}else{this.numberTicks=2}}}O=B/(this.numberTicks-1)/1000;if(this.daTickInterval==null){this.daTickInterval=[O,"seconds"]}for(var aa=0;aa<this.numberTicks;aa++){var ae=new h.jsDate(this.min);ad=ae.add(aa*this.daTickInterval[0],this.daTickInterval[1]).getTime();var Y=new this.tickRenderer(this.tickOptions);if(!this.showTicks){Y.showLabel=false;Y.showMark=false}else{if(!this.showTickMarks){Y.showMark=false}}Y.setTick(ad,this.name);this._ticks.push(Y)}}}}if(this.tickInset){this.min=this.min-this.tickInset*O;this.max=this.max+this.tickInset*O}if(this._daTickInterval==null){this._daTickInterval=this.daTickInterval}X=null}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(e){e.jqplot.DonutRenderer=function(){e.jqplot.LineRenderer.call(this)};e.jqplot.DonutRenderer.prototype=new e.jqplot.LineRenderer();e.jqplot.DonutRenderer.prototype.constructor=e.jqplot.DonutRenderer;e.jqplot.DonutRenderer.prototype.init=function(p,t){this.diameter=null;this.innerDiameter=null;this.thickness=null;this.padding=20;this.sliceMargin=0;this.ringMargin=null;this.fill=true;this.shadowOffset=2;this.shadowAlpha=0.07;this.shadowDepth=5;this.highlightMouseOver=true;this.highlightMouseDown=false;this.highlightColors=[];this.dataLabels="percent";this.showDataLabels=false;this.dataLabelFormatString=null;this.dataLabelThreshold=3;this.dataLabelPositionFactor=0.4;this.dataLabelNudge=0;this.startAngle=0;this.tickRenderer=e.jqplot.DonutTickRenderer;this._drawData=true;this._type="donut";if(p.highlightMouseDown&&p.highlightMouseOver==null){p.highlightMouseOver=false}e.extend(true,this,p);if(this.diameter!=null){this.diameter=this.diameter-this.sliceMargin}this._diameter=null;this._innerDiameter=null;this._radius=null;this._innerRadius=null;this._thickness=null;this._previousSeries=[];this._numberSeries=1;this._sliceAngles=[];this._highlightedPoint=null;if(this.highlightColors.length==0){for(var r=0;r<this.seriesColors.length;r++){var q=e.jqplot.getColorComponents(this.seriesColors[r]);var n=[q[0],q[1],q[2]];var s=n[0]+n[1]+n[2];for(var o=0;o<3;o++){n[o]=(s>570)?n[o]*0.8:n[o]+0.3*(255-n[o]);n[o]=parseInt(n[o],10)}this.highlightColors.push("rgb("+n[0]+","+n[1]+","+n[2]+")")}}t.postParseOptionsHooks.addOnce(l);t.postInitHooks.addOnce(g);t.eventListenerHooks.addOnce("jqplotMouseMove",b);t.eventListenerHooks.addOnce("jqplotMouseDown",a);t.eventListenerHooks.addOnce("jqplotMouseUp",j);t.eventListenerHooks.addOnce("jqplotClick",f);t.eventListenerHooks.addOnce("jqplotRightClick",m);t.postDrawHooks.addOnce(h)};e.jqplot.DonutRenderer.prototype.setGridData=function(s){var o=[];var t=[];var n=this.startAngle/180*Math.PI;var r=0;this._drawData=false;for(var q=0;q<this.data.length;q++){if(this.data[q][1]!=0){this._drawData=true}o.push(this.data[q][1]);t.push([this.data[q][0]]);if(q>0){o[q]+=o[q-1]}r+=this.data[q][1]}var p=Math.PI*2/o[o.length-1];for(var q=0;q<o.length;q++){t[q][1]=o[q]*p;t[q][2]=this.data[q][1]/r}this.gridData=t};e.jqplot.DonutRenderer.prototype.makeGridData=function(s,t){var o=[];var u=[];var r=0;var n=this.startAngle/180*Math.PI;this._drawData=false;for(var q=0;q<s.length;q++){if(this.data[q][1]!=0){this._drawData=true}o.push(s[q][1]);u.push([s[q][0]]);if(q>0){o[q]+=o[q-1]}r+=s[q][1]}var p=Math.PI*2/o[o.length-1];for(var q=0;q<o.length;q++){u[q][1]=o[q]*p;u[q][2]=s[q][1]/r}return u};e.jqplot.DonutRenderer.prototype.drawSlice=function(x,u,t,p,s){var n=this._diameter/2;var v=n-this._thickness;var w=this.fill;x.save();x.translate(this._center[0],this._center[1]);if(s){for(var q=0;q<this.shadowDepth;q++){x.save();x.translate(this.shadowOffset*Math.cos(this.shadowAngle/180*Math.PI),this.shadowOffset*Math.sin(this.shadowAngle/180*Math.PI));o()}}else{o()}function o(){if(t>6.282+this.startAngle){t=6.282+this.startAngle;if(u>t){u=6.281+this.startAngle}}if(u>=t){return}x.beginPath();x.fillStyle=p;x.strokeStyle=p;x.arc(0,0,n,u,t,false);x.lineTo(v*Math.cos(t),v*Math.sin(t));x.arc(0,0,v,t,u,true);x.closePath();if(w){x.fill()}else{x.stroke()}}if(s){for(var q=0;q<this.shadowDepth;q++){x.restore()}}x.restore()};e.jqplot.DonutRenderer.prototype.draw=function(N,V,t,P){var Q;var J=(t!=undefined)?t:{};var q=0;var p=0;var u=1;if(t.legendInfo&&t.legendInfo.placement=="insideGrid"){var I=t.legendInfo;switch(I.location){case"nw":q=I.width+I.xoffset;break;case"w":q=I.width+I.xoffset;break;case"sw":q=I.width+I.xoffset;break;case"ne":q=I.width+I.xoffset;u=-1;break;case"e":q=I.width+I.xoffset;u=-1;break;case"se":q=I.width+I.xoffset;u=-1;break;case"n":p=I.height+I.yoffset;break;case"s":p=I.height+I.yoffset;u=-1;break;default:break}}var B=(J.shadow!=undefined)?J.shadow:this.shadow;var W=(J.showLine!=undefined)?J.showLine:this.showLine;var O=(J.fill!=undefined)?J.fill:this.fill;var s=N.canvas.width;var H=N.canvas.height;var G=s-q-2*this.padding;var R=H-p-2*this.padding;var v=Math.min(G,R);var T=v;var X=(this.ringMargin==null)?this.sliceMargin*2:this.ringMargin;for(var Q=0;Q<this._previousSeries.length;Q++){T-=2*this._previousSeries[Q]._thickness+2*X}this._diameter=this.diameter||T;if(this.innerDiameter!=null){var M=(this._numberSeries>1&&this.index>0)?this._previousSeries[0]._diameter:this._diameter;this._thickness=this.thickness||(M-this.innerDiameter-2*X*this._numberSeries)/this._numberSeries/2}else{this._thickness=this.thickness||v/2/(this._numberSeries+1)*0.85}var K=this._radius=this._diameter/2;this._innerRadius=this._radius-this._thickness;var o=this.startAngle/180*Math.PI;this._center=[(s-u*q)/2+u*q,(H-u*p)/2+u*p];if(this.shadow){var L="rgba(0,0,0,"+this.shadowAlpha+")";for(var Q=0;Q<V.length;Q++){var A=(Q==0)?o:V[Q-1][1]+o;A+=this.sliceMargin/180*Math.PI;this.renderer.drawSlice.call(this,N,A,V[Q][1]+o,L,true)}}for(var Q=0;Q<V.length;Q++){var A=(Q==0)?o:V[Q-1][1]+o;A+=this.sliceMargin/180*Math.PI;var z=V[Q][1]+o;this._sliceAngles.push([A,z]);this.renderer.drawSlice.call(this,N,A,z,this.seriesColors[Q],false);if(this.showDataLabels&&V[Q][2]*100>=this.dataLabelThreshold){var S,U=(A+z)/2,C;if(this.dataLabels=="label"){S=this.dataLabelFormatString||"%s";C=e.jqplot.sprintf(S,V[Q][0])}else{if(this.dataLabels=="value"){S=this.dataLabelFormatString||"%d";C=e.jqplot.sprintf(S,this.data[Q][1])}else{if(this.dataLabels=="percent"){S=this.dataLabelFormatString||"%d%%";C=e.jqplot.sprintf(S,V[Q][2]*100)}else{if(this.dataLabels.constructor==Array){S=this.dataLabelFormatString||"%s";C=e.jqplot.sprintf(S,this.dataLabels[Q])}}}}var n=this._innerRadius+this._thickness*this.dataLabelPositionFactor+this.sliceMargin+this.dataLabelNudge;var F=this._center[0]+Math.cos(U)*n+this.canvas._offsets.left;var E=this._center[1]+Math.sin(U)*n+this.canvas._offsets.top;var D=e('<span class="jqplot-donut-series jqplot-data-label" style="position:absolute;">'+C+"</span>").insertBefore(P.eventCanvas._elem);F-=D.width()/2;E-=D.height()/2;F=Math.round(F);E=Math.round(E);D.css({left:F,top:E})}}};e.jqplot.DonutAxisRenderer=function(){e.jqplot.LinearAxisRenderer.call(this)};e.jqplot.DonutAxisRenderer.prototype=new e.jqplot.LinearAxisRenderer();e.jqplot.DonutAxisRenderer.prototype.constructor=e.jqplot.DonutAxisRenderer;e.jqplot.DonutAxisRenderer.prototype.init=function(n){this.tickRenderer=e.jqplot.DonutTickRenderer;e.extend(true,this,n);this._dataBounds={min:0,max:100};this.min=0;this.max=100;this.showTicks=false;this.ticks=[];this.showMark=false;this.show=false};e.jqplot.DonutLegendRenderer=function(){e.jqplot.TableLegendRenderer.call(this)};e.jqplot.DonutLegendRenderer.prototype=new e.jqplot.TableLegendRenderer();e.jqplot.DonutLegendRenderer.prototype.constructor=e.jqplot.DonutLegendRenderer;e.jqplot.DonutLegendRenderer.prototype.init=function(n){this.numberRows=null;this.numberColumns=null;e.extend(true,this,n)};e.jqplot.DonutLegendRenderer.prototype.draw=function(){var q=this;if(this.show){var y=this._series;var B="position:absolute;";B+=(this.background)?"background:"+this.background+";":"";B+=(this.border)?"border:"+this.border+";":"";B+=(this.fontSize)?"font-size:"+this.fontSize+";":"";B+=(this.fontFamily)?"font-family:"+this.fontFamily+";":"";B+=(this.textColor)?"color:"+this.textColor+";":"";B+=(this.marginTop!=null)?"margin-top:"+this.marginTop+";":"";B+=(this.marginBottom!=null)?"margin-bottom:"+this.marginBottom+";":"";B+=(this.marginLeft!=null)?"margin-left:"+this.marginLeft+";":"";B+=(this.marginRight!=null)?"margin-right:"+this.marginRight+";":"";this._elem=e('<table class="jqplot-table-legend" style="'+B+'"></table>');var F=false,x=false,n,v;var z=y[0];var o=new e.jqplot.ColorGenerator(z.seriesColors);if(z.show){var G=z.data;if(this.numberRows){n=this.numberRows;if(!this.numberColumns){v=Math.ceil(G.length/n)}else{v=this.numberColumns}}else{if(this.numberColumns){v=this.numberColumns;n=Math.ceil(G.length/this.numberColumns)}else{n=G.length;v=1}}var E,D,p,t,r,u,w,C;var A=0;for(E=0;E<n;E++){if(x){p=e('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem)}else{p=e('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem)}for(D=0;D<v;D++){if(A<G.length){u=this.labels[A]||G[A][0].toString();C=o.next();if(!x){if(E>0){F=true}else{F=false}}else{if(E==n-1){F=false}else{F=true}}w=(F)?this.rowSpacing:"0";t=e('<td class="jqplot-table-legend" style="text-align:center;padding-top:'+w+';"><div><div class="jqplot-table-legend-swatch" style="border-color:'+C+';"></div></div></td>');r=e('<td class="jqplot-table-legend" style="padding-top:'+w+';"></td>');if(this.escapeHtml){r.text(u)}else{r.html(u)}if(x){r.prependTo(p);t.prependTo(p)}else{t.appendTo(p);r.appendTo(p)}F=true}A++}}}}return this._elem};function c(r,q,o){o=o||{};o.axesDefaults=o.axesDefaults||{};o.legend=o.legend||{};o.seriesDefaults=o.seriesDefaults||{};var n=false;if(o.seriesDefaults.renderer==e.jqplot.DonutRenderer){n=true}else{if(o.series){for(var p=0;p<o.series.length;p++){if(o.series[p].renderer==e.jqplot.DonutRenderer){n=true}}}}if(n){o.axesDefaults.renderer=e.jqplot.DonutAxisRenderer;o.legend.renderer=e.jqplot.DonutLegendRenderer;o.legend.preDraw=true;o.seriesDefaults.pointLabels={show:false}}}function g(r,q,o){for(var p=1;p<this.series.length;p++){if(!this.series[p]._previousSeries.length){for(var n=0;n<p;n++){if(this.series[p].renderer.constructor==e.jqplot.DonutRenderer&&this.series[n].renderer.constructor==e.jqplot.DonutRenderer){this.series[p]._previousSeries.push(this.series[n])}}}}for(p=0;p<this.series.length;p++){if(this.series[p].renderer.constructor==e.jqplot.DonutRenderer){this.series[p]._numberSeries=this.series.length;if(this.series[p].highlightMouseOver){this.series[p].highlightMouseDown=false}}}}var k=false;function l(n){for(var o=0;o<this.series.length;o++){this.series[o].seriesColors=this.seriesColors;this.series[o].colorGenerator=e.jqplot.colorGenerator}}function d(r,q,p){var o=r.series[q];var n=r.plugins.donutRenderer.highlightCanvas;n._ctx.clearRect(0,0,n._ctx.canvas.width,n._ctx.canvas.height);o._highlightedPoint=p;r.plugins.donutRenderer.highlightedSeriesIndex=q;o.renderer.drawSlice.call(o,n._ctx,o._sliceAngles[p][0],o._sliceAngles[p][1],o.highlightColors[p],false)}function i(p){var n=p.plugins.donutRenderer.highlightCanvas;n._ctx.clearRect(0,0,n._ctx.canvas.width,n._ctx.canvas.height);for(var o=0;o<p.series.length;o++){p.series[o]._highlightedPoint=null}p.plugins.donutRenderer.highlightedSeriesIndex=null;p.target.trigger("jqplotDataUnhighlight")}function b(r,q,u,t,s){if(t){var p=[t.seriesIndex,t.pointIndex,t.data];var o=jQuery.Event("jqplotDataMouseOver");o.pageX=r.pageX;o.pageY=r.pageY;s.target.trigger(o,p);if(s.series[p[0]].highlightMouseOver&&!(p[0]==s.plugins.donutRenderer.highlightedSeriesIndex&&p[1]==s.series[p[0]]._highlightedPoint)){var n=jQuery.Event("jqplotDataHighlight");n.which=r.which;n.pageX=r.pageX;n.pageY=r.pageY;s.target.trigger(n,p);d(s,p[0],p[1])}}else{if(t==null){i(s)}}}function a(q,p,t,s,r){if(s){var o=[s.seriesIndex,s.pointIndex,s.data];if(r.series[o[0]].highlightMouseDown&&!(o[0]==r.plugins.donutRenderer.highlightedSeriesIndex&&o[1]==r.series[o[0]]._highlightedPoint)){var n=jQuery.Event("jqplotDataHighlight");n.which=q.which;n.pageX=q.pageX;n.pageY=q.pageY;r.target.trigger(n,o);d(r,o[0],o[1])}}else{if(s==null){i(r)}}}function j(p,o,s,r,q){var n=q.plugins.donutRenderer.highlightedSeriesIndex;if(n!=null&&q.series[n].highlightMouseDown){i(q)}}function f(q,p,t,s,r){if(s){var o=[s.seriesIndex,s.pointIndex,s.data];var n=jQuery.Event("jqplotDataClick");n.which=q.which;n.pageX=q.pageX;n.pageY=q.pageY;r.target.trigger(n,o)}}function m(r,q,u,t,s){if(t){var p=[t.seriesIndex,t.pointIndex,t.data];var n=s.plugins.donutRenderer.highlightedSeriesIndex;if(n!=null&&s.series[n].highlightMouseDown){i(s)}var o=jQuery.Event("jqplotDataRightClick");o.which=r.which;o.pageX=r.pageX;o.pageY=r.pageY;s.target.trigger(o,p)}}function h(){if(this.plugins.donutRenderer&&this.plugins.donutRenderer.highlightCanvas){this.plugins.donutRenderer.highlightCanvas.resetCanvas();this.plugins.donutRenderer.highlightCanvas=null}this.plugins.donutRenderer={highlightedSeriesIndex:null};this.plugins.donutRenderer.highlightCanvas=new e.jqplot.GenericCanvas();var o=e(this.targetId+" .jqplot-data-label");if(o.length){e(o[0]).before(this.plugins.donutRenderer.highlightCanvas.createElement(this._gridPadding,"jqplot-donutRenderer-highlight-canvas",this._plotDimensions,this))}else{this.eventCanvas._elem.before(this.plugins.donutRenderer.highlightCanvas.createElement(this._gridPadding,"jqplot-donutRenderer-highlight-canvas",this._plotDimensions,this))}var n=this.plugins.donutRenderer.highlightCanvas.setContext();this.eventCanvas._elem.bind("mouseleave",{plot:this},function(p){i(p.data.plot)})}e.jqplot.preInitHooks.push(c);e.jqplot.DonutTickRenderer=function(){e.jqplot.AxisTickRenderer.call(this)};e.jqplot.DonutTickRenderer.prototype=new e.jqplot.AxisTickRenderer();e.jqplot.DonutTickRenderer.prototype.constructor=e.jqplot.DonutTickRenderer})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(d){d.jqplot.Dragable=function(g){this.markerRenderer=new d.jqplot.MarkerRenderer({shadow:false});this.shapeRenderer=new d.jqplot.ShapeRenderer();this.isDragging=false;this.isOver=false;this._ctx;this._elem;this._point;this._gridData;this.color;this.constrainTo="none";d.extend(true,this,g)};function b(){d.jqplot.GenericCanvas.call(this);this.isDragging=false;this.isOver=false;this._neighbor;this._cursors=[]}b.prototype=new d.jqplot.GenericCanvas();b.prototype.constructor=b;d.jqplot.Dragable.parseOptions=function(i,h){var g=h||{};this.plugins.dragable=new d.jqplot.Dragable(g.dragable);this.isDragable=d.jqplot.config.enablePlugins};d.jqplot.Dragable.postPlotDraw=function(){if(this.plugins.dragable&&this.plugins.dragable.highlightCanvas){this.plugins.dragable.highlightCanvas.resetCanvas();this.plugins.dragable.highlightCanvas=null}this.plugins.dragable={previousCursor:"auto",isOver:false};this.plugins.dragable.dragCanvas=new b();this.eventCanvas._elem.before(this.plugins.dragable.dragCanvas.createElement(this._gridPadding,"jqplot-dragable-canvas",this._plotDimensions,this));var g=this.plugins.dragable.dragCanvas.setContext()};d.jqplot.preParseSeriesOptionsHooks.push(d.jqplot.Dragable.parseOptions);d.jqplot.postDrawHooks.push(d.jqplot.Dragable.postPlotDraw);d.jqplot.eventListenerHooks.push(["jqplotMouseMove",e]);d.jqplot.eventListenerHooks.push(["jqplotMouseDown",c]);d.jqplot.eventListenerHooks.push(["jqplotMouseUp",a]);function f(n,p){var q=n.series[p.seriesIndex];var m=q.plugins.dragable;var h=q.markerRenderer;var i=m.markerRenderer;i.style=h.style;i.lineWidth=h.lineWidth+2.5;i.size=h.size+5;if(!m.color){var l=d.jqplot.getColorComponents(h.color);var o=[l[0],l[1],l[2]];var k=(l[3]>=0.6)?l[3]*0.6:l[3]*(2-l[3]);m.color="rgba("+o[0]+","+o[1]+","+o[2]+","+k+")"}i.color=m.color;i.init();var g=(p.pointIndex>0)?p.pointIndex-1:0;var j=p.pointIndex+2;m._gridData=q.gridData.slice(g,j)}function e(o,l,h,t,m){if(m.plugins.dragable.dragCanvas.isDragging){var u=m.plugins.dragable.dragCanvas;var i=u._neighbor;var w=m.series[i.seriesIndex];var k=w.plugins.dragable;var r=w.gridData;var p=(k.constrainTo=="y")?i.gridData[0]:l.x;var n=(k.constrainTo=="x")?i.gridData[1]:l.y;var g=w._xaxis.series_p2u(p);var q=w._yaxis.series_p2u(n);var v=u._ctx;v.clearRect(0,0,v.canvas.width,v.canvas.height);if(i.pointIndex>0){k._gridData[1]=[p,n]}else{k._gridData[0]=[p,n]}m.series[i.seriesIndex].draw(u._ctx,{gridData:k._gridData,shadow:false,preventJqPlotSeriesDrawTrigger:true,color:k.color,markerOptions:{color:k.color,shadow:false},trendline:{show:false}});m.target.trigger("jqplotSeriesPointChange",[i.seriesIndex,i.pointIndex,[g,q],[p,n]])}else{if(t!=null){var j=m.series[t.seriesIndex];if(j.isDragable){var u=m.plugins.dragable.dragCanvas;if(!u.isOver){u._cursors.push(o.target.style.cursor);o.target.style.cursor="pointer"}u.isOver=true}}else{if(t==null){var u=m.plugins.dragable.dragCanvas;if(u.isOver){o.target.style.cursor=u._cursors.pop();u.isOver=false}}}}}function c(k,i,g,l,j){var m=j.plugins.dragable.dragCanvas;m._cursors.push(k.target.style.cursor);if(l!=null){var o=j.series[l.seriesIndex];var h=o.plugins.dragable;if(o.isDragable&&!m.isDragging){m._neighbor=l;m.isDragging=true;f(j,l);h.markerRenderer.draw(o.gridData[l.pointIndex][0],o.gridData[l.pointIndex][1],m._ctx);k.target.style.cursor="move";j.target.trigger("jqplotDragStart",[l.seriesIndex,l.pointIndex,i,g])}}else{var n=m._ctx;n.clearRect(0,0,n.canvas.width,n.canvas.height);m.isDragging=false}}function a(m,j,g,o,k){if(k.plugins.dragable.dragCanvas.isDragging){var p=k.plugins.dragable.dragCanvas;var q=p._ctx;q.clearRect(0,0,q.canvas.width,q.canvas.height);p.isDragging=false;var h=p._neighbor;var r=k.series[h.seriesIndex];var i=r.plugins.dragable;var n=(i.constrainTo=="y")?h.data[0]:g[r.xaxis];var l=(i.constrainTo=="x")?h.data[1]:g[r.yaxis];r.data[h.pointIndex][0]=n;r.data[h.pointIndex][1]=l;k.drawSeries({preventJqPlotSeriesDrawTrigger:true},h.seriesIndex);p._neighbor=null;m.target.style.cursor=p._cursors.pop();k.target.trigger("jqplotDragStop",[j,g])}}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(c){c.jqplot.EnhancedLegendRenderer=function(){c.jqplot.TableLegendRenderer.call(this)};c.jqplot.EnhancedLegendRenderer.prototype=new c.jqplot.TableLegendRenderer();c.jqplot.EnhancedLegendRenderer.prototype.constructor=c.jqplot.EnhancedLegendRenderer;c.jqplot.EnhancedLegendRenderer.prototype.init=function(d){this.numberRows=null;this.numberColumns=null;this.seriesToggle="normal";this.seriesToggleReplot=false;this.disableIEFading=true;c.extend(true,this,d);if(this.seriesToggle){c.jqplot.postDrawHooks.push(b)}};c.jqplot.EnhancedLegendRenderer.prototype.draw=function(m,y){var f=this;if(this.show){var r=this._series;var u;var w="position:absolute;";w+=(this.background)?"background:"+this.background+";":"";w+=(this.border)?"border:"+this.border+";":"";w+=(this.fontSize)?"font-size:"+this.fontSize+";":"";w+=(this.fontFamily)?"font-family:"+this.fontFamily+";":"";w+=(this.textColor)?"color:"+this.textColor+";":"";w+=(this.marginTop!=null)?"margin-top:"+this.marginTop+";":"";w+=(this.marginBottom!=null)?"margin-bottom:"+this.marginBottom+";":"";w+=(this.marginLeft!=null)?"margin-left:"+this.marginLeft+";":"";w+=(this.marginRight!=null)?"margin-right:"+this.marginRight+";":"";this._elem=c('<table class="jqplot-table-legend" style="'+w+'"></table>');if(this.seriesToggle){this._elem.css("z-index","3")}var C=false,q=false,d,o;if(this.numberRows){d=this.numberRows;if(!this.numberColumns){o=Math.ceil(r.length/d)}else{o=this.numberColumns}}else{if(this.numberColumns){o=this.numberColumns;d=Math.ceil(r.length/this.numberColumns)}else{d=r.length;o=1}}var B,z,e,l,k,n,p,t,h,g;var v=0;for(B=r.length-1;B>=0;B--){if(o==1&&r[B]._stack||r[B].renderer.constructor==c.jqplot.BezierCurveRenderer){q=true}}for(B=0;B<d;B++){e=c(document.createElement("tr"));e.addClass("jqplot-table-legend");if(q){e.prependTo(this._elem)}else{e.appendTo(this._elem)}for(z=0;z<o;z++){if(v<r.length&&(r[v].show||r[v].showLabel)){u=r[v];n=this.labels[v]||u.label.toString();if(n){var x=u.color;if(!q){if(B>0){C=true}else{C=false}}else{if(B==d-1){C=false}else{C=true}}p=(C)?this.rowSpacing:"0";l=c(document.createElement("td"));l.addClass("jqplot-table-legend jqplot-table-legend-swatch");l.css({textAlign:"center",paddingTop:p});h=c(document.createElement("div"));h.addClass("jqplot-table-legend-swatch-outline");g=c(document.createElement("div"));g.addClass("jqplot-table-legend-swatch");g.css({backgroundColor:x,borderColor:x});l.append(h.append(g));k=c(document.createElement("td"));k.addClass("jqplot-table-legend jqplot-table-legend-label");k.css("paddingTop",p);if(this.escapeHtml){k.text(n)}else{k.html(n)}if(q){if(this.showLabels){k.prependTo(e)}if(this.showSwatches){l.prependTo(e)}}else{if(this.showSwatches){l.appendTo(e)}if(this.showLabels){k.appendTo(e)}}if(this.seriesToggle){var A;if(typeof(this.seriesToggle)==="string"||typeof(this.seriesToggle)==="number"){if(!c.jqplot.use_excanvas||!this.disableIEFading){A=this.seriesToggle}}if(this.showSwatches){l.bind("click",{series:u,speed:A,plot:y,replot:this.seriesToggleReplot},a);l.addClass("jqplot-seriesToggle")}if(this.showLabels){k.bind("click",{series:u,speed:A,plot:y,replot:this.seriesToggleReplot},a);k.addClass("jqplot-seriesToggle")}if(!u.show&&u.showLabel){l.addClass("jqplot-series-hidden");k.addClass("jqplot-series-hidden")}}C=true}}v++}l=k=h=g=null}}return this._elem};var a=function(j){var i=j.data,m=i.series,k=i.replot,h=i.plot,f=i.speed,l=m.index,g=false;if(m.canvas._elem.is(":hidden")||!m.show){g=true}var e=function(){if(k){var n={};if(c.isPlainObject(k)){c.extend(true,n,k)}h.replot(n);if(g&&f){var d=h.series[l];if(d.shadowCanvas._elem){d.shadowCanvas._elem.hide().fadeIn(f)}d.canvas._elem.hide().fadeIn(f);d.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-"+d.index).hide().fadeIn(f)}}else{var d=h.series[l];if(d.canvas._elem.is(":hidden")||!d.show){if(typeof h.options.legend.showSwatches==="undefined"||h.options.legend.showSwatches===true){h.legend._elem.find("td").eq(l*2).addClass("jqplot-series-hidden")}if(typeof h.options.legend.showLabels==="undefined"||h.options.legend.showLabels===true){h.legend._elem.find("td").eq((l*2)+1).addClass("jqplot-series-hidden")}}else{if(typeof h.options.legend.showSwatches==="undefined"||h.options.legend.showSwatches===true){h.legend._elem.find("td").eq(l*2).removeClass("jqplot-series-hidden")}if(typeof h.options.legend.showLabels==="undefined"||h.options.legend.showLabels===true){h.legend._elem.find("td").eq((l*2)+1).removeClass("jqplot-series-hidden")}}}};m.toggleDisplay(j,e)};var b=function(){if(this.legend.renderer.constructor==c.jqplot.EnhancedLegendRenderer&&this.legend.seriesToggle){var d=this.legend._elem.detach();this.eventCanvas._elem.after(d)}}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(e){e.jqplot.FunnelRenderer=function(){e.jqplot.LineRenderer.call(this)};e.jqplot.FunnelRenderer.prototype=new e.jqplot.LineRenderer();e.jqplot.FunnelRenderer.prototype.constructor=e.jqplot.FunnelRenderer;e.jqplot.FunnelRenderer.prototype.init=function(p,t){this.padding={top:20,right:20,bottom:20,left:20};this.sectionMargin=6;this.fill=true;this.shadowOffset=2;this.shadowAlpha=0.07;this.shadowDepth=5;this.highlightMouseOver=true;this.highlightMouseDown=false;this.highlightColors=[];this.widthRatio=0.2;this.lineWidth=2;this.dataLabels="percent";this.showDataLabels=false;this.dataLabelFormatString=null;this.dataLabelThreshold=3;this._type="funnel";this.tickRenderer=e.jqplot.FunnelTickRenderer;if(p.highlightMouseDown&&p.highlightMouseOver==null){p.highlightMouseOver=false}e.extend(true,this,p);this._highlightedPoint=null;this._bases=[];this._atot;this._areas=[];this._lengths=[];this._angle;this._dataIndices=[];this._unorderedData=e.extend(true,[],this.data);var o=e.extend(true,[],this.data);for(var r=0;r<o.length;r++){o[r].push(r)}this.data.sort(function(v,u){return u[1]-v[1]});o.sort(function(v,u){return u[1]-v[1]});for(var r=0;r<o.length;r++){this._dataIndices.push(o[r][2])}if(this.highlightColors.length==0){for(var r=0;r<this.seriesColors.length;r++){var q=e.jqplot.getColorComponents(this.seriesColors[r]);var m=[q[0],q[1],q[2]];var s=m[0]+m[1]+m[2];for(var n=0;n<3;n++){m[n]=(s>570)?m[n]*0.8:m[n]+0.4*(255-m[n]);m[n]=parseInt(m[n],10)}this.highlightColors.push("rgb("+m[0]+","+m[1]+","+m[2]+")")}}t.postParseOptionsHooks.addOnce(k);t.postInitHooks.addOnce(g);t.eventListenerHooks.addOnce("jqplotMouseMove",a);t.eventListenerHooks.addOnce("jqplotMouseDown",b);t.eventListenerHooks.addOnce("jqplotMouseUp",j);t.eventListenerHooks.addOnce("jqplotClick",f);t.eventListenerHooks.addOnce("jqplotRightClick",l);t.postDrawHooks.addOnce(h)};e.jqplot.FunnelRenderer.prototype.setGridData=function(o){var n=0;var p=[];for(var m=0;m<this.data.length;m++){n+=this.data[m][1];p.push([this.data[m][0],this.data[m][1]])}for(var m=0;m<p.length;m++){p[m][1]=p[m][1]/n}this._bases=new Array(p.length+1);this._lengths=new Array(p.length);this.gridData=p};e.jqplot.FunnelRenderer.prototype.makeGridData=function(o,p){var n=0;var q=[];for(var m=0;m<this.data.length;m++){n+=this.data[m][1];q.push([this.data[m][0],this.data[m][1]])}for(var m=0;m<q.length;m++){q[m][1]=q[m][1]/n}this._bases=new Array(q.length+1);this._lengths=new Array(q.length);return q};e.jqplot.FunnelRenderer.prototype.drawSection=function(n,p,o,s){var t=this.fill;var m=this.lineWidth;n.save();if(s){for(var r=0;r<this.shadowDepth;r++){n.save();n.translate(this.shadowOffset*Math.cos(this.shadowAngle/180*Math.PI),this.shadowOffset*Math.sin(this.shadowAngle/180*Math.PI));q()}}else{q()}function q(){n.beginPath();n.fillStyle=o;n.strokeStyle=o;n.lineWidth=m;n.moveTo(p[0][0],p[0][1]);for(var u=1;u<4;u++){n.lineTo(p[u][0],p[u][1])}n.closePath();if(t){n.fill()}else{n.stroke()}}if(s){for(var r=0;r<this.shadowDepth;r++){n.restore()}}n.restore()};e.jqplot.FunnelRenderer.prototype.draw=function(G,B,J,p){var Y;var L=(J!=undefined)?J:{};var w=0;var u=0;var R=1;this._areas=[];if(J.legendInfo&&J.legendInfo.placement=="insideGrid"){var O=J.legendInfo;switch(O.location){case"nw":w=O.width+O.xoffset;break;case"w":w=O.width+O.xoffset;break;case"sw":w=O.width+O.xoffset;break;case"ne":w=O.width+O.xoffset;R=-1;break;case"e":w=O.width+O.xoffset;R=-1;break;case"se":w=O.width+O.xoffset;R=-1;break;case"n":u=O.height+O.yoffset;break;case"s":u=O.height+O.yoffset;R=-1;break;default:break}}var t=(R==1)?this.padding.left+w:this.padding.left;var F=(R==1)?this.padding.top+u:this.padding.top;var M=(R==-1)?this.padding.right+w:this.padding.right;var o=(R==-1)?this.padding.bottom+u:this.padding.bottom;var P=(L.shadow!=undefined)?L.shadow:this.shadow;var q=(L.showLine!=undefined)?L.showLine:this.showLine;var C=(L.fill!=undefined)?L.fill:this.fill;var H=G.canvas.width;var N=G.canvas.height;this._bases[0]=H-t-M;var I=this._length=N-F-o;var r=this._bases[0]*this.widthRatio;this._atot=I/2*(this._bases[0]+this._bases[0]*this.widthRatio);this._angle=Math.atan((this._bases[0]-r)/2/I);for(Y=0;Y<B.length;Y++){this._areas.push(B[Y][1]*this._atot)}var E,aa,W,Q=0;var n=0.0001;for(Y=0;Y<this._areas.length;Y++){E=this._areas[Y]/this._bases[Y];aa=999999;this._lengths[Y]=E;W=0;while(aa>this._lengths[Y]*n&&W<100){this._lengths[Y]=this._areas[Y]/(this._bases[Y]-this._lengths[Y]*Math.tan(this._angle));aa=Math.abs(this._lengths[Y]-E);this._bases[Y+1]=this._bases[Y]-(2*this._lengths[Y]*Math.tan(this._angle));E=this._lengths[Y];W++}Q+=this._lengths[Y]}this._vertices=new Array(B.length);var ae=[t,F],ad=[t+this._bases[0],F],ac=[t+(this._bases[0]-this._bases[this._bases.length-1])/2,F+this._length],ab=[ac[0]+this._bases[this._bases.length-1],ac[1]];function V(ag){var x=(ae[1]-ac[1])/(ae[0]-ac[0]);var v=ae[1]-x*ae[0];var ah=ag+ae[1];return[(ah-v)/x,ah]}function D(ag){var x=(ad[1]-ab[1])/(ad[0]-ab[0]);var v=ad[1]-x*ad[0];var ah=ag+ad[1];return[(ah-v)/x,ah]}var T=w,S=u;var Z=0,m=0;for(Y=0;Y<B.length;Y++){this._vertices[Y]=new Array();var U=this._vertices[Y];var A=this.sectionMargin;if(Y==0){m=0}if(Y==1){m=A/3}else{if(Y>0&&Y<B.length-1){m=A/2}else{if(Y==B.length-1){m=2*A/3}}}U.push(V(Z+m));U.push(D(Z+m));Z+=this._lengths[Y];if(Y==0){m=-2*A/3}else{if(Y>0&&Y<B.length-1){m=-A/2}else{if(Y==B.length-1){m=0}}}U.push(D(Z+m));U.push(V(Z+m))}if(this.shadow){var af="rgba(0,0,0,"+this.shadowAlpha+")";for(var Y=0;Y<B.length;Y++){this.renderer.drawSection.call(this,G,this._vertices[Y],af,true)}}for(var Y=0;Y<B.length;Y++){var U=this._vertices[Y];this.renderer.drawSection.call(this,G,U,this.seriesColors[Y]);if(this.showDataLabels&&B[Y][1]*100>=this.dataLabelThreshold){var K,X;if(this.dataLabels=="label"){K=this.dataLabelFormatString||"%s";X=e.jqplot.sprintf(K,B[Y][0])}else{if(this.dataLabels=="value"){K=this.dataLabelFormatString||"%d";X=e.jqplot.sprintf(K,this.data[Y][1])}else{if(this.dataLabels=="percent"){K=this.dataLabelFormatString||"%d%%";X=e.jqplot.sprintf(K,B[Y][1]*100)}else{if(this.dataLabels.constructor==Array){K=this.dataLabelFormatString||"%s";X=e.jqplot.sprintf(K,this.dataLabels[this._dataIndices[Y]])}}}}var s=(this._radius)*this.dataLabelPositionFactor+this.sliceMargin+this.dataLabelNudge;var T=(U[0][0]+U[1][0])/2+this.canvas._offsets.left;var S=(U[1][1]+U[2][1])/2+this.canvas._offsets.top;var z=e('<span class="jqplot-funnel-series jqplot-data-label" style="position:absolute;">'+X+"</span>").insertBefore(p.eventCanvas._elem);T-=z.width()/2;S-=z.height()/2;T=Math.round(T);S=Math.round(S);z.css({left:T,top:S})}}};e.jqplot.FunnelAxisRenderer=function(){e.jqplot.LinearAxisRenderer.call(this)};e.jqplot.FunnelAxisRenderer.prototype=new e.jqplot.LinearAxisRenderer();e.jqplot.FunnelAxisRenderer.prototype.constructor=e.jqplot.FunnelAxisRenderer;e.jqplot.FunnelAxisRenderer.prototype.init=function(m){this.tickRenderer=e.jqplot.FunnelTickRenderer;e.extend(true,this,m);this._dataBounds={min:0,max:100};this.min=0;this.max=100;this.showTicks=false;this.ticks=[];this.showMark=false;this.show=false};e.jqplot.FunnelLegendRenderer=function(){e.jqplot.TableLegendRenderer.call(this)};e.jqplot.FunnelLegendRenderer.prototype=new e.jqplot.TableLegendRenderer();e.jqplot.FunnelLegendRenderer.prototype.constructor=e.jqplot.FunnelLegendRenderer;e.jqplot.FunnelLegendRenderer.prototype.init=function(m){this.numberRows=null;this.numberColumns=null;e.extend(true,this,m)};e.jqplot.FunnelLegendRenderer.prototype.draw=function(){var p=this;if(this.show){var x=this._series;var A="position:absolute;";A+=(this.background)?"background:"+this.background+";":"";A+=(this.border)?"border:"+this.border+";":"";A+=(this.fontSize)?"font-size:"+this.fontSize+";":"";A+=(this.fontFamily)?"font-family:"+this.fontFamily+";":"";A+=(this.textColor)?"color:"+this.textColor+";":"";A+=(this.marginTop!=null)?"margin-top:"+this.marginTop+";":"";A+=(this.marginBottom!=null)?"margin-bottom:"+this.marginBottom+";":"";A+=(this.marginLeft!=null)?"margin-left:"+this.marginLeft+";":"";A+=(this.marginRight!=null)?"margin-right:"+this.marginRight+";":"";this._elem=e('<table class="jqplot-table-legend" style="'+A+'"></table>');var E=false,w=false,m,u;var y=x[0];var n=new e.jqplot.ColorGenerator(y.seriesColors);if(y.show){var F=y.data;if(this.numberRows){m=this.numberRows;if(!this.numberColumns){u=Math.ceil(F.length/m)}else{u=this.numberColumns}}else{if(this.numberColumns){u=this.numberColumns;m=Math.ceil(F.length/this.numberColumns)}else{m=F.length;u=1}}var D,C,o,r,q,t,v,B;var z=0;for(D=0;D<m;D++){if(w){o=e('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem)}else{o=e('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem)}for(C=0;C<u;C++){if(z<F.length){t=this.labels[z]||F[z][0].toString();B=n.next();if(!w){if(D>0){E=true}else{E=false}}else{if(D==m-1){E=false}else{E=true}}v=(E)?this.rowSpacing:"0";r=e('<td class="jqplot-table-legend" style="text-align:center;padding-top:'+v+';"><div><div class="jqplot-table-legend-swatch" style="border-color:'+B+';"></div></div></td>');q=e('<td class="jqplot-table-legend" style="padding-top:'+v+';"></td>');if(this.escapeHtml){q.text(t)}else{q.html(t)}if(w){q.prependTo(o);r.prependTo(o)}else{r.appendTo(o);q.appendTo(o)}E=true}z++}}}}return this._elem};function c(q,p,n){n=n||{};n.axesDefaults=n.axesDefaults||{};n.legend=n.legend||{};n.seriesDefaults=n.seriesDefaults||{};var m=false;if(n.seriesDefaults.renderer==e.jqplot.FunnelRenderer){m=true}else{if(n.series){for(var o=0;o<n.series.length;o++){if(n.series[o].renderer==e.jqplot.FunnelRenderer){m=true}}}}if(m){n.axesDefaults.renderer=e.jqplot.FunnelAxisRenderer;n.legend.renderer=e.jqplot.FunnelLegendRenderer;n.legend.preDraw=true;n.sortData=false;n.seriesDefaults.pointLabels={show:false}}}function g(p,o,m){for(var n=0;n<this.series.length;n++){if(this.series[n].renderer.constructor==e.jqplot.FunnelRenderer){if(this.series[n].highlightMouseOver){this.series[n].highlightMouseDown=false}}}}function k(m){for(var n=0;n<this.series.length;n++){this.series[n].seriesColors=this.seriesColors;this.series[n].colorGenerator=e.jqplot.colorGenerator}}function d(q,p,o){var n=q.series[p];var m=q.plugins.funnelRenderer.highlightCanvas;m._ctx.clearRect(0,0,m._ctx.canvas.width,m._ctx.canvas.height);n._highlightedPoint=o;q.plugins.funnelRenderer.highlightedSeriesIndex=p;n.renderer.drawSection.call(n,m._ctx,n._vertices[o],n.highlightColors[o],false)}function i(o){var m=o.plugins.funnelRenderer.highlightCanvas;m._ctx.clearRect(0,0,m._ctx.canvas.width,m._ctx.canvas.height);for(var n=0;n<o.series.length;n++){o.series[n]._highlightedPoint=null}o.plugins.funnelRenderer.highlightedSeriesIndex=null;o.target.trigger("jqplotDataUnhighlight")}function a(q,p,t,s,r){if(s){var o=[s.seriesIndex,s.pointIndex,s.data];var n=jQuery.Event("jqplotDataMouseOver");n.pageX=q.pageX;n.pageY=q.pageY;r.target.trigger(n,o);if(r.series[o[0]].highlightMouseOver&&!(o[0]==r.plugins.funnelRenderer.highlightedSeriesIndex&&o[1]==r.series[o[0]]._highlightedPoint)){var m=jQuery.Event("jqplotDataHighlight");m.which=q.which;m.pageX=q.pageX;m.pageY=q.pageY;r.target.trigger(m,o);d(r,o[0],o[1])}}else{if(s==null){i(r)}}}function b(p,o,s,r,q){if(r){var n=[r.seriesIndex,r.pointIndex,r.data];if(q.series[n[0]].highlightMouseDown&&!(n[0]==q.plugins.funnelRenderer.highlightedSeriesIndex&&n[1]==q.series[n[0]]._highlightedPoint)){var m=jQuery.Event("jqplotDataHighlight");m.which=p.which;m.pageX=p.pageX;m.pageY=p.pageY;q.target.trigger(m,n);d(q,n[0],n[1])}}else{if(r==null){i(q)}}}function j(o,n,r,q,p){var m=p.plugins.funnelRenderer.highlightedSeriesIndex;if(m!=null&&p.series[m].highlightMouseDown){i(p)}}function f(p,o,s,r,q){if(r){var n=[r.seriesIndex,r.pointIndex,r.data];var m=jQuery.Event("jqplotDataClick");m.which=p.which;m.pageX=p.pageX;m.pageY=p.pageY;q.target.trigger(m,n)}}function l(q,p,t,s,r){if(s){var o=[s.seriesIndex,s.pointIndex,s.data];var m=r.plugins.funnelRenderer.highlightedSeriesIndex;if(m!=null&&r.series[m].highlightMouseDown){i(r)}var n=jQuery.Event("jqplotDataRightClick");n.which=q.which;n.pageX=q.pageX;n.pageY=q.pageY;r.target.trigger(n,o)}}function h(){if(this.plugins.funnelRenderer&&this.plugins.funnelRenderer.highlightCanvas){this.plugins.funnelRenderer.highlightCanvas.resetCanvas();this.plugins.funnelRenderer.highlightCanvas=null}this.plugins.funnelRenderer={};this.plugins.funnelRenderer.highlightCanvas=new e.jqplot.GenericCanvas();var n=e(this.targetId+" .jqplot-data-label");if(n.length){e(n[0]).before(this.plugins.funnelRenderer.highlightCanvas.createElement(this._gridPadding,"jqplot-funnelRenderer-highlight-canvas",this._plotDimensions,this))}else{this.eventCanvas._elem.before(this.plugins.funnelRenderer.highlightCanvas.createElement(this._gridPadding,"jqplot-funnelRenderer-highlight-canvas",this._plotDimensions,this))}var m=this.plugins.funnelRenderer.highlightCanvas.setContext();this.eventCanvas._elem.bind("mouseleave",{plot:this},function(o){i(o.data.plot)})}e.jqplot.preInitHooks.push(c);e.jqplot.FunnelTickRenderer=function(){e.jqplot.AxisTickRenderer.call(this)};e.jqplot.FunnelTickRenderer.prototype=new e.jqplot.AxisTickRenderer();e.jqplot.FunnelTickRenderer.prototype.constructor=e.jqplot.FunnelTickRenderer})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(a){a.jqplot.LogAxisRenderer=function(){a.jqplot.LinearAxisRenderer.call(this);this.axisDefaults={base:10,tickDistribution:"power"}};a.jqplot.LogAxisRenderer.prototype=new a.jqplot.LinearAxisRenderer();a.jqplot.LogAxisRenderer.prototype.constructor=a.jqplot.LogAxisRenderer;a.jqplot.LogAxisRenderer.prototype.init=function(b){this.drawBaseline=true;this.minorTicks="auto";this._scalefact=1;a.extend(true,this,b);this._autoFormatString="%d";this._overrideFormatString=false;for(var c in this.renderer.axisDefaults){if(this[c]==null){this[c]=this.renderer.axisDefaults[c]}}this.resetDataBounds()};a.jqplot.LogAxisRenderer.prototype.createTicks=function(d){var G=this._ticks;var w=this.ticks;var s=this.name;var u=this._dataBounds;var b=(this.name.charAt(0)==="x")?this._plotDimensions.width:this._plotDimensions.height;var k;var N,v;var m,l;var M,K;var g=30;this._scalefact=(Math.max(b,g+1)-g)/300;if(w.length){for(K=0;K<w.length;K++){var A=w[K];var H=new this.tickRenderer(this.tickOptions);if(A.constructor==Array){H.value=A[0];H.label=A[1];if(!this.showTicks){H.showLabel=false;H.showMark=false}else{if(!this.showTickMarks){H.showMark=false}}H.setTick(A[0],this.name);this._ticks.push(H)}else{if(a.isPlainObject(A)){a.extend(true,H,A);H.axis=this.name;this._ticks.push(H)}else{H.value=A;if(!this.showTicks){H.showLabel=false;H.showMark=false}else{if(!this.showTickMarks){H.showMark=false}}H.setTick(A,this.name);this._ticks.push(H)}}}this.numberTicks=w.length;this.min=this._ticks[0].value;this.max=this._ticks[this.numberTicks-1].value}else{if(this.min==null&&this.max==null){N=u.min*(2-this.padMin);v=u.max*this.padMax;if(N==v){var c=0.05;N=N*(1-c);v=v*(1+c)}if(this.min!=null&&this.min<=0){throw new Error("Log axis minimum must be greater than 0")}if(this.max!=null&&this.max<=0){throw new Error("Log axis maximum must be greater than 0")}function f(j){var i=Math.pow(10,Math.floor(Math.log(j)/Math.LN10));return Math.ceil(j/i)*i}function x(j){var i=Math.pow(10,Math.floor(Math.log(j)/Math.LN10));return Math.floor(j/i)*i}var F,r;F=Math.pow(this.base,Math.floor(Math.log(N)/Math.log(this.base)));r=Math.pow(this.base,Math.ceil(Math.log(v)/Math.log(this.base)));if(F===0){F=1}var E=Math.round(Math.log(F)/Math.LN10);if(this.tickOptions==null||!this.tickOptions.formatString){this._overrideFormatString=true}this.min=F;this.max=r;var q=this.max-this.min;var C=(this.minorTicks==="auto")?0:this.minorTicks;var h;if(this.numberTicks==null){if(b>140){h=Math.round(Math.log(this.max/this.min)/Math.log(this.base)+1);if(h<2){h=2}if(C===0){var o=b/(h-1);if(o<100){C=0}else{if(o<190){C=1}else{if(o<250){C=3}else{if(o<600){C=4}else{C=9}}}}}}else{h=2;if(C===0){C=1}C=0}}else{h=this.numberTicks}if(E>=0&&C!==3){this._autoFormatString="%d"}else{if(E<=0&&C===3){var o=-(E-1);this._autoFormatString="%."+Math.abs(E-1)+"f"}else{if(E<0){var o=-E;this._autoFormatString="%."+Math.abs(E)+"f"}else{this._autoFormatString="%d"}}}var O,H,z,p,n,k;for(var K=0;K<h;K++){M=Math.pow(this.base,K-h+1)*this.max;H=new this.tickRenderer(this.tickOptions);if(this._overrideFormatString){H.formatString=this._autoFormatString}if(!this.showTicks){H.showLabel=false;H.showMark=false}else{if(!this.showTickMarks){H.showMark=false}}H.setTick(M,this.name);this._ticks.push(H);if(C&&K<h-1){p=Math.pow(this.base,K-h+2)*this.max;n=p-M;k=p/(C+1);for(var J=C-1;J>=0;J--){z=p-k*(J+1);H=new this.tickRenderer(this.tickOptions);if(this._overrideFormatString&&this._autoFormatString!=""){H.formatString=this._autoFormatString}if(!this.showTicks){H.showLabel=false;H.showMark=false}else{if(!this.showTickMarks){H.showMark=false}}H.setTick(z,this.name);this._ticks.push(H)}}}}else{if(this.min!=null&&this.max!=null){var y=a.extend(true,{},this.tickOptions,{name:this.name,value:null});var I,e;if(this.numberTicks==null&&this.tickInterval==null){var D=Math.max(b,g+1);var L=Math.ceil((D-g)/35+1);var B=a.jqplot.LinearTickGenerator.bestConstrainedInterval(this.min,this.max,L);this._autoFormatString=B[3];I=B[2];e=B[4];for(var K=0;K<I;K++){y.value=this.min+K*e;H=new this.tickRenderer(y);if(this._overrideFormatString&&this._autoFormatString!=""){H.formatString=this._autoFormatString}if(!this.showTicks){H.showLabel=false;H.showMark=false}else{if(!this.showTickMarks){H.showMark=false}}this._ticks.push(H)}}else{if(this.numberTicks!=null&&this.tickInterval!=null){I=this.numberTicks;for(var K=0;K<I;K++){y.value=this.min+K*this.tickInterval;H=new this.tickRenderer(y);if(this._overrideFormatString&&this._autoFormatString!=""){H.formatString=this._autoFormatString}if(!this.showTicks){H.showLabel=false;H.showMark=false}else{if(!this.showTickMarks){H.showMark=false}}this._ticks.push(H)}}}}}}};a.jqplot.LogAxisRenderer.prototype.pack=function(f,e){var r=parseInt(this.base,10);var y=this._ticks;var d=function(h){return Math.log(h)/Math.log(r)};var b=function(h){return Math.pow(Math.E,(Math.log(r)*h))};var u=d(this.max);var s=d(this.min);var m=e.max;var k=e.min;var o=(this._label==null)?false:this._label.show;for(var q in f){this._elem.css(q,f[q])}this._offsets=e;var g=m-k;var j=u-s;this.p2u=function(h){return b((h-k)*j/g+s)};this.u2p=function(h){return(d(h)-s)*g/j+k};if(this.name=="xaxis"||this.name=="x2axis"){this.series_u2p=function(h){return(d(h)-s)*g/j};this.series_p2u=function(h){return b(h*j/g+s)}}else{this.series_u2p=function(h){return(d(h)-u)*g/j};this.series_p2u=function(h){return b(h*j/g+u)}}if(this.show){if(this.name=="xaxis"||this.name=="x2axis"){for(var v=0;v<y.length;v++){var n=y[v];if(n.show&&n.showLabel){var c;if(n.constructor==a.jqplot.CanvasAxisTickRenderer&&n.angle){switch(n.labelPosition){case"auto":if(n.angle<0){c=-n.getWidth()+n._textRenderer.height*Math.sin(-n._textRenderer.angle)/2}else{c=-n._textRenderer.height*Math.sin(n._textRenderer.angle)/2}break;case"end":c=-n.getWidth()+n._textRenderer.height*Math.sin(-n._textRenderer.angle)/2;break;case"start":c=-n._textRenderer.height*Math.sin(n._textRenderer.angle)/2;break;case"middle":c=-n.getWidth()/2+n._textRenderer.height*Math.sin(-n._textRenderer.angle)/2;break;default:c=-n.getWidth()/2+n._textRenderer.height*Math.sin(-n._textRenderer.angle)/2;break}}else{c=-n.getWidth()/2}var z=this.u2p(n.value)+c+"px";n._elem.css("left",z);n.pack()}}if(o){var l=this._label._elem.outerWidth(true);this._label._elem.css("left",k+g/2-l/2+"px");if(this.name=="xaxis"){this._label._elem.css("bottom","0px")}else{this._label._elem.css("top","0px")}this._label.pack()}}else{for(var v=0;v<y.length;v++){var n=y[v];if(n.show&&n.showLabel){var c;if(n.constructor==a.jqplot.CanvasAxisTickRenderer&&n.angle){switch(n.labelPosition){case"auto":case"end":if(n.angle<0){c=-n._textRenderer.height*Math.cos(-n._textRenderer.angle)/2}else{c=-n.getHeight()+n._textRenderer.height*Math.cos(n._textRenderer.angle)/2}break;case"start":if(n.angle>0){c=-n._textRenderer.height*Math.cos(-n._textRenderer.angle)/2}else{c=-n.getHeight()+n._textRenderer.height*Math.cos(n._textRenderer.angle)/2}break;case"middle":c=-n.getHeight()/2;break;default:c=-n.getHeight()/2;break}}else{c=-n.getHeight()/2}var z=this.u2p(n.value)+c+"px";n._elem.css("top",z);n.pack()}}if(o){var x=this._label._elem.outerHeight(true);this._label._elem.css("top",m-g/2-x/2+"px");if(this.name=="yaxis"){this._label._elem.css("left","0px")}else{this._label._elem.css("right","0px")}this._label.pack()}}}}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(a){a.jqplot.MekkoAxisRenderer=function(){};a.jqplot.MekkoAxisRenderer.prototype.init=function(c){this.tickMode;this.barLabelRenderer=a.jqplot.AxisLabelRenderer;this.barLabels=this.barLabels||[];this.barLabelOptions={};this.tickOptions=a.extend(true,{showGridline:false},this.tickOptions);this._barLabels=[];a.extend(true,this,c);if(this.name=="yaxis"){this.tickOptions.formatString=this.tickOptions.formatString||"%d%"}var b=this._dataBounds;b.min=0;if(this.name=="yaxis"||this.name=="y2axis"){b.max=100;this.tickMode="even"}else{if(this.name=="xaxis"){this.tickMode=(this.tickMode==null)?"bar":this.tickMode;for(var d=0;d<this._series.length;d++){b.max+=this._series[d]._sumy}}else{if(this.name=="x2axis"){this.tickMode=(this.tickMode==null)?"even":this.tickMode;for(var d=0;d<this._series.length;d++){b.max+=this._series[d]._sumy}}}}};a.jqplot.MekkoAxisRenderer.prototype.draw=function(b,j){if(this.show){this.renderer.createTicks.call(this);var h=0;var c;var g=document.createElement("div");this._elem=a(g);this._elem.addClass("jqplot-axis jqplot-"+this.name);this._elem.css("position","absolute");g=null;if(this.name=="xaxis"||this.name=="x2axis"){this._elem.width(this._plotDimensions.width)}else{this._elem.height(this._plotDimensions.height)}this.labelOptions.axis=this.name;this._label=new this.labelRenderer(this.labelOptions);if(this._label.show){this._elem.append(this._label.draw(b))}var f,e,g;if(this.showTicks){f=this._ticks;for(var d=0;d<f.length;d++){e=f[d];if(e.showLabel&&(!e.isMinorTick||this.showMinorTicks)){this._elem.append(e.draw(b))}}}for(d=0;d<this.barLabels.length;d++){this.barLabelOptions.axis=this.name;this.barLabelOptions.label=this.barLabels[d];this._barLabels.push(new this.barLabelRenderer(this.barLabelOptions));if(this.tickMode!="bar"){this._barLabels[d].show=false}if(this._barLabels[d].show){var g=this._barLabels[d].draw(b,j);g.removeClass("jqplot-"+this.name+"-label");g.addClass("jqplot-"+this.name+"-tick");g.addClass("jqplot-mekko-barLabel");g.appendTo(this._elem);g=null}}}return this._elem};a.jqplot.MekkoAxisRenderer.prototype.reset=function(){this.min=this._min;this.max=this._max;this.tickInterval=this._tickInterval;this.numberTicks=this._numberTicks};a.jqplot.MekkoAxisRenderer.prototype.set=function(){var k=0;var d;var c=0;var j=0;var b=(this._label==null)?false:this._label.show;if(this.show&&this.showTicks){var g=this._ticks;for(var f=0;f<g.length;f++){var e=g[f];if(e.showLabel&&(!e.isMinorTick||this.showMinorTicks)){if(this.name=="xaxis"||this.name=="x2axis"){d=e._elem.outerHeight(true)}else{d=e._elem.outerWidth(true)}if(d>k){k=d}}}if(b){c=this._label._elem.outerWidth(true);j=this._label._elem.outerHeight(true)}if(this.name=="xaxis"){k=k+j;this._elem.css({height:k+"px",left:"0px",bottom:"0px"})}else{if(this.name=="x2axis"){k=k+j;this._elem.css({height:k+"px",left:"0px",top:"0px"})}else{if(this.name=="yaxis"){k=k+c;this._elem.css({width:k+"px",left:"0px",top:"0px"});if(b&&this._label.constructor==a.jqplot.AxisLabelRenderer){this._label._elem.css("width",c+"px")}}else{k=k+c;this._elem.css({width:k+"px",right:"0px",top:"0px"});if(b&&this._label.constructor==a.jqplot.AxisLabelRenderer){this._label._elem.css("width",c+"px")}}}}}};a.jqplot.MekkoAxisRenderer.prototype.createTicks=function(){var z=this._ticks;var w=this.ticks;var B=this.name;var y=this._dataBounds;var p,x;var n,r;var d,c;var h,b,s,q;if(w.length){for(s=0;s<w.length;s++){var e=w[s];var h=new this.tickRenderer(this.tickOptions);if(e.constructor==Array){h.value=e[0];h.label=e[1];if(!this.showTicks){h.showLabel=false;h.showMark=false}else{if(!this.showTickMarks){h.showMark=false}}h.setTick(e[0],this.name);this._ticks.push(h)}else{h.value=e;if(!this.showTicks){h.showLabel=false;h.showMark=false}else{if(!this.showTickMarks){h.showMark=false}}h.setTick(e,this.name);this._ticks.push(h)}}this.numberTicks=w.length;this.min=this._ticks[0].value;this.max=this._ticks[this.numberTicks-1].value;this.tickInterval=(this.max-this.min)/(this.numberTicks-1)}else{if(B=="xaxis"||B=="x2axis"){p=this._plotDimensions.width}else{p=this._plotDimensions.height}if(this.min!=null&&this.max!=null&&this.numberTicks!=null){this.tickInterval=null}n=(this.min!=null)?this.min:y.min;r=(this.max!=null)?this.max:y.max;if(n==r){var g=0.05;if(n>0){g=Math.max(Math.log(n)/Math.LN10,0.05)}n-=g;r+=g}var k=r-n;var m,o;var v,l,u;var f=[3,5,6,11,21];if(this.name=="yaxis"||this.name=="y2axis"){this.min=0;this.max=100;if(!this.numberTicks){if(this.tickInterval){this.numberTicks=3+Math.ceil(k/this.tickInterval)}else{v=2+Math.ceil((p-(this.tickSpacing-1))/this.tickSpacing);for(s=0;s<f.length;s++){u=v/f[s];if(u==1){this.numberTicks=f[s];break}else{if(u>1){l=u;continue}else{if(u<1){if(Math.abs(l-1)<Math.abs(u-1)){this.numberTicks=f[s-1];break}else{this.numberTicks=f[s];break}}else{if(s==f.length-1){this.numberTicks=f[s]}}}}}this.tickInterval=k/(this.numberTicks-1)}}else{this.tickInterval=k/(this.numberTicks-1)}for(var s=0;s<this.numberTicks;s++){b=this.min+s*this.tickInterval;h=new this.tickRenderer(this.tickOptions);if(!this.showTicks){h.showLabel=false;h.showMark=false}else{if(!this.showTickMarks){h.showMark=false}}h.setTick(b,this.name);this._ticks.push(h)}}else{if(this.tickMode=="bar"){this.min=0;this.numberTicks=this._series.length+1;h=new this.tickRenderer(this.tickOptions);if(!this.showTicks){h.showLabel=false;h.showMark=false}else{if(!this.showTickMarks){h.showMark=false}}h.setTick(0,this.name);this._ticks.push(h);v=0;for(s=1;s<this.numberTicks;s++){v+=this._series[s-1]._sumy;h=new this.tickRenderer(this.tickOptions);if(!this.showTicks){h.showLabel=false;h.showMark=false}else{if(!this.showTickMarks){h.showMark=false}}h.setTick(v,this.name);this._ticks.push(h)}this.max=this.max||v;if(this.max>v){h=new this.tickRenderer(this.tickOptions);if(!this.showTicks){h.showLabel=false;h.showMark=false}else{if(!this.showTickMarks){h.showMark=false}}h.setTick(this.max,this.name);this._ticks.push(h)}}else{if(this.tickMode=="even"){this.min=0;this.max=this.max||y.max;var A=2+Math.ceil((p-(this.tickSpacing-1))/this.tickSpacing);k=this.max-this.min;this.numberTicks=A;this.tickInterval=k/(this.numberTicks-1);for(s=0;s<this.numberTicks;s++){b=this.min+s*this.tickInterval;h=new this.tickRenderer(this.tickOptions);if(!this.showTicks){h.showLabel=false;h.showMark=false}else{if(!this.showTickMarks){h.showMark=false}}h.setTick(b,this.name);this._ticks.push(h)}}}}}};a.jqplot.MekkoAxisRenderer.prototype.pack=function(e,d){var C=this._ticks;var x=this.max;var v=this.min;var m=d.max;var j=d.min;var o=(this._label==null)?false:this._label.show;for(var s in e){this._elem.css(s,e[s])}this._offsets=d;var f=m-j;var g=x-v;this.p2u=function(b){return(b-j)*g/f+v};this.u2p=function(b){return(b-v)*f/g+j};if(this.name=="xaxis"||this.name=="x2axis"){this.series_u2p=function(b){return(b-v)*f/g};this.series_p2u=function(b){return b*g/f+v}}else{this.series_u2p=function(b){return(b-x)*f/g};this.series_p2u=function(b){return b*g/f+x}}if(this.show){if(this.name=="xaxis"||this.name=="x2axis"){for(var y=0;y<C.length;y++){var n=C[y];if(n.show&&n.showLabel){var c;if(n.constructor==a.jqplot.CanvasAxisTickRenderer&&n.angle){var A=(this.name=="xaxis")?1:-1;switch(n.labelPosition){case"auto":if(A*n.angle<0){c=-n.getWidth()+n._textRenderer.height*Math.sin(-n._textRenderer.angle)/2}else{c=-n._textRenderer.height*Math.sin(n._textRenderer.angle)/2}break;case"end":c=-n.getWidth()+n._textRenderer.height*Math.sin(-n._textRenderer.angle)/2;break;case"start":c=-n._textRenderer.height*Math.sin(n._textRenderer.angle)/2;break;case"middle":c=-n.getWidth()/2+n._textRenderer.height*Math.sin(-n._textRenderer.angle)/2;break;default:c=-n.getWidth()/2+n._textRenderer.height*Math.sin(-n._textRenderer.angle)/2;break}}else{c=-n.getWidth()/2}var D=this.u2p(n.value)+c+"px";n._elem.css("left",D);n.pack()}}var k;if(o){k=this._label._elem.outerWidth(true);this._label._elem.css("left",j+f/2-k/2+"px");if(this.name=="xaxis"){this._label._elem.css("bottom","0px")}else{this._label._elem.css("top","0px")}this._label.pack()}var B,u,q;for(var y=0;y<this.barLabels.length;y++){B=this._barLabels[y];if(B.show){k=B.getWidth();u=this._ticks[y].getLeft()+this._ticks[y].getWidth();q=this._ticks[y+1].getLeft();B._elem.css("left",(q+u-k)/2+"px");B._elem.css("top",this._ticks[y]._elem.css("top"));B.pack()}}}else{for(var y=0;y<C.length;y++){var n=C[y];if(n.show&&n.showLabel){var c;if(n.constructor==a.jqplot.CanvasAxisTickRenderer&&n.angle){var A=(this.name=="yaxis")?1:-1;switch(n.labelPosition){case"auto":case"end":if(A*n.angle<0){c=-n._textRenderer.height*Math.cos(-n._textRenderer.angle)/2}else{c=-n.getHeight()+n._textRenderer.height*Math.cos(n._textRenderer.angle)/2}break;case"start":if(n.angle>0){c=-n._textRenderer.height*Math.cos(-n._textRenderer.angle)/2}else{c=-n.getHeight()+n._textRenderer.height*Math.cos(n._textRenderer.angle)/2}break;case"middle":c=-n.getHeight()/2;break;default:c=-n.getHeight()/2;break}}else{c=-n.getHeight()/2}var D=this.u2p(n.value)+c+"px";n._elem.css("top",D);n.pack()}}if(o){var z=this._label._elem.outerHeight(true);this._label._elem.css("top",m-f/2-z/2+"px");if(this.name=="yaxis"){this._label._elem.css("left","0px")}else{this._label._elem.css("right","0px")}this._label.pack()}}}}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(b){b.jqplot.MekkoRenderer=function(){this.shapeRenderer=new b.jqplot.ShapeRenderer();this.borderColor=null;this.showBorders=true};b.jqplot.MekkoRenderer.prototype.init=function(c,e){this.fill=false;this.fillRect=true;this.strokeRect=true;this.shadow=false;this._xwidth=0;this._xstart=0;b.extend(true,this.renderer,c);var d={lineJoin:"miter",lineCap:"butt",isarc:false,fillRect:this.fillRect,strokeRect:this.strokeRect};this.renderer.shapeRenderer.init(d);e.axes.x2axis._series.push(this);this._type="mekko"};b.jqplot.MekkoRenderer.prototype.setGridData=function(h){var e=this._xaxis.series_u2p;var c=this._yaxis.series_u2p;var g=this._plotData;this.gridData=[];this._xwidth=e(this._sumy)-e(0);if(this.index>0){this._xstart=h.series[this.index-1]._xstart+h.series[this.index-1]._xwidth}var l=this.canvas.getHeight();var d=0;var k;var j;for(var f=0;f<g.length;f++){if(g[f]!=null){d+=g[f][1];k=l-(d/this._sumy*l);j=g[f][1]/this._sumy*l;this.gridData.push([this._xstart,k,this._xwidth,j])}}};b.jqplot.MekkoRenderer.prototype.makeGridData=function(f,g){var d=this._xaxis.series_u2p;var l=this.canvas.getHeight();var c=0;var j;var h;var k=[];for(var e=0;e<f.length;e++){if(f[e]!=null){c+=f[e][1];j=l-(c/this._sumy*l);h=f[e][1]/this._sumy*l;k.push([this._xstart,j,this._xwidth,h])}}return k};b.jqplot.MekkoRenderer.prototype.draw=function(c,h,d){var e;var g=(d!=undefined)?d:{};var f=(g.showLine!=undefined)?g.showLine:this.showLine;var j=new b.jqplot.ColorGenerator(this.seriesColors);c.save();if(h.length){if(f){for(e=0;e<h.length;e++){g.fillStyle=j.next();if(this.renderer.showBorders){g.strokeStyle=this.renderer.borderColor}else{g.strokeStyle=g.fillStyle}this.renderer.shapeRenderer.draw(c,h[e],g)}}}c.restore()};b.jqplot.MekkoRenderer.prototype.drawShadow=function(c,e,d){};b.jqplot.MekkoLegendRenderer=function(){};b.jqplot.MekkoLegendRenderer.prototype.init=function(c){this.numberRows=null;this.numberColumns=null;this.placement="outside";b.extend(true,this,c)};b.jqplot.MekkoLegendRenderer.prototype.draw=function(){var f=this;if(this.show){var o=this._series;var r="position:absolute;";r+=(this.background)?"background:"+this.background+";":"";r+=(this.border)?"border:"+this.border+";":"";r+=(this.fontSize)?"font-size:"+this.fontSize+";":"";r+=(this.fontFamily)?"font-family:"+this.fontFamily+";":"";r+=(this.textColor)?"color:"+this.textColor+";":"";this._elem=b('<table class="jqplot-table-legend" style="'+r+'"></table>');var w=false,n=true,c,l;var p=o[0];var d=new b.jqplot.ColorGenerator(p.seriesColors);if(p.show){var x=p.data;if(this.numberRows){c=this.numberRows;if(!this.numberColumns){l=Math.ceil(x.length/c)}else{l=this.numberColumns}}else{if(this.numberColumns){l=this.numberColumns;c=Math.ceil(x.length/this.numberColumns)}else{c=x.length;l=1}}var v,u,e,h,g,k,m,t;var q=0;for(v=0;v<c;v++){if(n){e=b('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem)}else{e=b('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem)}for(u=0;u<l;u++){if(q<x.length){k=this.labels[q]||x[q][0].toString();t=d.next();if(!n){if(v>0){w=true}else{w=false}}else{if(v==c-1){w=false}else{w=true}}m=(w)?this.rowSpacing:"0";h=b('<td class="jqplot-table-legend" style="text-align:center;padding-top:'+m+';"><div><div class="jqplot-table-legend-swatch" style="border-color:'+t+';"></div></div></td>');g=b('<td class="jqplot-table-legend" style="padding-top:'+m+';"></td>');if(this.escapeHtml){g.text(k)}else{g.html(k)}if(n){g.prependTo(e);h.prependTo(e)}else{h.appendTo(e);g.appendTo(e)}w=true}q++}}e=null;h=null;g=null}}return this._elem};b.jqplot.MekkoLegendRenderer.prototype.pack=function(f){if(this.show){var e={_top:f.top,_left:f.left,_right:f.right,_bottom:this._plotDimensions.height-f.bottom};if(this.placement=="insideGrid"){switch(this.location){case"nw":var d=e._left+this.xoffset;var c=e._top+this.yoffset;this._elem.css("left",d);this._elem.css("top",c);break;case"n":var d=(f.left+(this._plotDimensions.width-f.right))/2-this.getWidth()/2;var c=e._top+this.yoffset;this._elem.css("left",d);this._elem.css("top",c);break;case"ne":var d=f.right+this.xoffset;var c=e._top+this.yoffset;this._elem.css({right:d,top:c});break;case"e":var d=f.right+this.xoffset;var c=(f.top+(this._plotDimensions.height-f.bottom))/2-this.getHeight()/2;this._elem.css({right:d,top:c});break;case"se":var d=f.right+this.xoffset;var c=f.bottom+this.yoffset;this._elem.css({right:d,bottom:c});break;case"s":var d=(f.left+(this._plotDimensions.width-f.right))/2-this.getWidth()/2;var c=f.bottom+this.yoffset;this._elem.css({left:d,bottom:c});break;case"sw":var d=e._left+this.xoffset;var c=f.bottom+this.yoffset;this._elem.css({left:d,bottom:c});break;case"w":var d=e._left+this.xoffset;var c=(f.top+(this._plotDimensions.height-f.bottom))/2-this.getHeight()/2;this._elem.css({left:d,top:c});break;default:var d=e._right-this.xoffset;var c=e._bottom+this.yoffset;this._elem.css({right:d,bottom:c});break}}else{switch(this.location){case"nw":var d=this._plotDimensions.width-e._left+this.xoffset;var c=e._top+this.yoffset;this._elem.css("right",d);this._elem.css("top",c);break;case"n":var d=(f.left+(this._plotDimensions.width-f.right))/2-this.getWidth()/2;var c=this._plotDimensions.height-e._top+this.yoffset;this._elem.css("left",d);this._elem.css("bottom",c);break;case"ne":var d=this._plotDimensions.width-f.right+this.xoffset;var c=e._top+this.yoffset;this._elem.css({left:d,top:c});break;case"e":var d=this._plotDimensions.width-f.right+this.xoffset;var c=(f.top+(this._plotDimensions.height-f.bottom))/2-this.getHeight()/2;this._elem.css({left:d,top:c});break;case"se":var d=this._plotDimensions.width-f.right+this.xoffset;var c=f.bottom+this.yoffset;this._elem.css({left:d,bottom:c});break;case"s":var d=(f.left+(this._plotDimensions.width-f.right))/2-this.getWidth()/2;var c=this._plotDimensions.height-f.bottom+this.yoffset;this._elem.css({left:d,top:c});break;case"sw":var d=this._plotDimensions.width-e._left+this.xoffset;var c=f.bottom+this.yoffset;this._elem.css({right:d,bottom:c});break;case"w":var d=this._plotDimensions.width-e._left+this.xoffset;var c=(f.top+(this._plotDimensions.height-f.bottom))/2-this.getHeight()/2;this._elem.css({right:d,top:c});break;default:var d=e._right-this.xoffset;var c=e._bottom+this.yoffset;this._elem.css({right:d,bottom:c});break}}}};function a(g,f,d){d=d||{};d.axesDefaults=d.axesDefaults||{};d.legend=d.legend||{};d.seriesDefaults=d.seriesDefaults||{};var c=false;if(d.seriesDefaults.renderer==b.jqplot.MekkoRenderer){c=true}else{if(d.series){for(var e=0;e<d.series.length;e++){if(d.series[e].renderer==b.jqplot.MekkoRenderer){c=true}}}}if(c){d.axesDefaults.renderer=b.jqplot.MekkoAxisRenderer;d.legend.renderer=b.jqplot.MekkoLegendRenderer;d.legend.preDraw=true}}b.jqplot.preInitHooks.push(a)})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(c){c.jqplot.MeterGaugeRenderer=function(){c.jqplot.LineRenderer.call(this)};c.jqplot.MeterGaugeRenderer.prototype=new c.jqplot.LineRenderer();c.jqplot.MeterGaugeRenderer.prototype.constructor=c.jqplot.MeterGaugeRenderer;c.jqplot.MeterGaugeRenderer.prototype.init=function(e){this.diameter=null;this.padding=null;this.shadowOffset=2;this.shadowAlpha=0.07;this.shadowDepth=4;this.background="#efefef";this.ringColor="#BBC6D0";this.needleColor="#C3D3E5";this.tickColor="#989898";this.ringWidth=null;this.min;this.max;this.ticks=[];this.showTicks=true;this.showTickLabels=true;this.label=null;this.labelHeightAdjust=0;this.labelPosition="inside";this.intervals=[];this.intervalColors=["#4bb2c5","#EAA228","#c5b47f","#579575","#839557","#958c12","#953579","#4b5de4","#d8b83f","#ff5800","#0085cc","#c747a3","#cddf54","#FBD178","#26B4E3","#bd70c7"];this.intervalInnerRadius=null;this.intervalOuterRadius=null;this.tickRenderer=c.jqplot.MeterGaugeTickRenderer;this.tickPositions=[1,2,2.5,5,10];this.tickSpacing=30;this.numberMinorTicks=null;this.hubRadius=null;this.tickPadding=null;this.needleThickness=null;this.needlePad=6;this.pegNeedle=true;this._type="meterGauge";c.extend(true,this,e);this.type=null;this.numberTicks=null;this.tickInterval=null;this.span=180;if(this.type=="circular"){this.semiCircular=false}else{if(this.type!="circular"){this.semiCircular=true}else{this.semiCircular=(this.span<=180)?true:false}}this._tickPoints=[];this._labelElem=null;this.startAngle=(90+(360-this.span)/2)*Math.PI/180;this.endAngle=(90-(360-this.span)/2)*Math.PI/180;this.setmin=!!(this.min==null);this.setmax=!!(this.max==null);if(this.intervals.length){if(this.intervals[0].length==null||this.intervals.length==1){for(var f=0;f<this.intervals.length;f++){this.intervals[f]=[this.intervals[f],this.intervals[f],this.intervalColors[f]]}}else{if(this.intervals[0].length==2){for(f=0;f<this.intervals.length;f++){this.intervals[f]=[this.intervals[f][0],this.intervals[f][1],this.intervalColors[f]]}}}}if(this.ticks.length){if(this.ticks[0].length==null||this.ticks[0].length==1){for(var f=0;f<this.ticks.length;f++){this.ticks[f]=[this.ticks[f],this.ticks[f]]}}this.min=(this.min==null)?this.ticks[0][0]:this.min;this.max=(this.max==null)?this.ticks[this.ticks.length-1][0]:this.max;this.setmin=false;this.setmax=false;this.numberTicks=this.ticks.length;this.tickInterval=this.ticks[1][0]-this.ticks[0][0];this.tickFactor=Math.floor(parseFloat((Math.log(this.tickInterval)/Math.log(10)).toFixed(11)));this.numberMinorTicks=b(this.tickPositions,this.tickInterval,this.tickFactor);if(!this.numberMinorTicks){this.numberMinorTicks=b(this.tickPositions,this.tickInterval,this.tickFactor-1)}if(!this.numberMinorTicks){this.numberMinorTicks=1}}else{if(this.intervals.length){this.min=(this.min==null)?0:this.min;this.setmin=false;if(this.max==null){if(this.intervals[this.intervals.length-1][0]>=this.data[0][1]){this.max=this.intervals[this.intervals.length-1][0];this.setmax=false}}else{this.setmax=false}}else{this.min=(this.min==null)?0:this.min;this.setmin=false;if(this.max==null){this.max=this.data[0][1]*1.25;this.setmax=true}else{this.setmax=false}}}};c.jqplot.MeterGaugeRenderer.prototype.setGridData=function(j){var f=[];var k=[];var e=this.startAngle;for(var h=0;h<this.data.length;h++){f.push(this.data[h][1]);k.push([this.data[h][0]]);if(h>0){f[h]+=f[h-1]}}var g=Math.PI*2/f[f.length-1];for(var h=0;h<f.length;h++){k[h][1]=f[h]*g}this.gridData=k};c.jqplot.MeterGaugeRenderer.prototype.makeGridData=function(j,k){var f=[];var l=[];var e=this.startAngle;for(var h=0;h<j.length;h++){f.push(j[h][1]);l.push([j[h][0]]);if(h>0){f[h]+=f[h-1]}}var g=Math.PI*2/f[f.length-1];for(var h=0;h<f.length;h++){l[h][1]=f[h]*g}return l};function b(j,f,g){var e;for(var h=j.length-1;h>=0;h--){e=f/(j[h]*Math.pow(10,g));if(e==4||e==5){return e-1}}return null}c.jqplot.MeterGaugeRenderer.prototype.draw=function(X,aC,ap){var aa;var aM=(ap!=undefined)?ap:{};var ai=0;var ah=0;var at=1;if(ap.legendInfo&&ap.legendInfo.placement=="inside"){var aI=ap.legendInfo;switch(aI.location){case"nw":ai=aI.width+aI.xoffset;break;case"w":ai=aI.width+aI.xoffset;break;case"sw":ai=aI.width+aI.xoffset;break;case"ne":ai=aI.width+aI.xoffset;at=-1;break;case"e":ai=aI.width+aI.xoffset;at=-1;break;case"se":ai=aI.width+aI.xoffset;at=-1;break;case"n":ah=aI.height+aI.yoffset;break;case"s":ah=aI.height+aI.yoffset;at=-1;break;default:break}}if(this.label){this._labelElem=c('<div class="jqplot-meterGauge-label" style="position:absolute;">'+this.label+"</div>");this.canvas._elem.after(this._labelElem)}var m=(aM.shadow!=undefined)?aM.shadow:this.shadow;var N=(aM.showLine!=undefined)?aM.showLine:this.showLine;var I=(aM.fill!=undefined)?aM.fill:this.fill;var K=X.canvas.width;var S=X.canvas.height;if(this.padding==null){this.padding=Math.round(Math.min(K,S)/30)}var Q=K-ai-2*this.padding;var ab=S-ah-2*this.padding;if(this.labelPosition=="bottom"&&this.label){ab-=this._labelElem.outerHeight(true)}var L=Math.min(Q,ab);var ad=L;if(!this.diameter){if(this.semiCircular){if(Q>=2*ab){if(!this.ringWidth){this.ringWidth=2*ab/35}this.needleThickness=this.needleThickness||2+Math.pow(this.ringWidth,0.8);this.innerPad=this.ringWidth/2+this.needleThickness/2+this.needlePad;this.diameter=2*(ab-2*this.innerPad)}else{if(!this.ringWidth){this.ringWidth=Q/35}this.needleThickness=this.needleThickness||2+Math.pow(this.ringWidth,0.8);this.innerPad=this.ringWidth/2+this.needleThickness/2+this.needlePad;this.diameter=Q-2*this.innerPad-this.ringWidth-this.padding}this._center=[(K-at*ai)/2+at*ai,(S+at*ah-this.padding-this.ringWidth-this.innerPad)]}else{if(!this.ringWidth){this.ringWidth=ad/35}this.needleThickness=this.needleThickness||2+Math.pow(this.ringWidth,0.8);this.innerPad=0;this.diameter=ad-this.ringWidth;this._center=[(K-at*ai)/2+at*ai,(S-at*ah)/2+at*ah]}if(this._labelElem&&this.labelPosition=="bottom"){this._center[1]-=this._labelElem.outerHeight(true)}}this._radius=this.diameter/2;this.tickSpacing=6000/this.diameter;if(!this.hubRadius){this.hubRadius=this.diameter/18}this.shadowOffset=0.5+this.ringWidth/9;this.shadowWidth=this.ringWidth*1;this.tickPadding=3+Math.pow(this.diameter/20,0.7);this.tickOuterRadius=this._radius-this.ringWidth/2-this.tickPadding;this.tickLength=(this.showTicks)?this._radius/13:0;if(this.ticks.length==0){var A=this.max,aL=this.min,q=this.setmax,aG=this.setmin,au=(A-aL)*this.tickSpacing/this.span;var aw=Math.floor(parseFloat((Math.log(au)/Math.log(10)).toFixed(11)));var an=(au/Math.pow(10,aw));(an>2&&an<=2.5)?an=2.5:an=Math.ceil(an);var T=this.tickPositions;var aA,ak;for(aa=0;aa<T.length;aa++){if(an==T[aa]||aa&&T[aa-1]<an&&an<T[aa]){au=T[aa]*Math.pow(10,aw);aA=aa}}for(aa=0;aa<T.length;aa++){if(an==T[aa]||aa&&T[aa-1]<an&&an<T[aa]){au=T[aa]*Math.pow(10,aw);ak=Math.ceil((A-aL)/au)}}if(q&&aG){var aP=(aL>0)?aL-aL%au:aL-aL%au-au;if(!this.forceZero){var D=Math.min(aL-aP,0.8*au);var o=Math.floor(D/T[aA]);if(o>1){aP=aP+T[aA]*(o-1);if(parseInt(aP,10)!=aP&&parseInt(aP-T[aA],10)==aP-T[aA]){aP=aP-T[aA]}}}if(aL==aP){aL-=au}else{if(aL-aP>0.23*au){aL=aP}else{aL=aP-au;ak+=1}}ak+=1;var E=aL+(ak-1)*au;if(A>=E){E+=au;ak+=1}if(E-A<0.23*au){E+=au;ak+=1}this.max=A=E;this.min=aL;this.tickInterval=au;this.numberTicks=ak;var O;for(aa=0;aa<ak;aa++){O=parseFloat((aL+aa*au).toFixed(11));this.ticks.push([O,O])}this.max=this.ticks[ak-1][1];this.tickFactor=aw;this.numberMinorTicks=b(this.tickPositions,this.tickInterval,this.tickFactor);if(!this.numberMinorTicks){this.numberMinorTicks=b(this.tickPositions,this.tickInterval,this.tickFactor-1)}}else{if(q){var E=aL+(ak-1)*au;if(A>=E){A=E+au;ak+=1}else{A=E}this.tickInterval=this.tickInterval||au;this.numberTicks=this.numberTicks||ak;var O;for(aa=0;aa<this.numberTicks;aa++){O=parseFloat((aL+aa*this.tickInterval).toFixed(11));this.ticks.push([O,O])}this.max=this.ticks[this.numberTicks-1][1];this.tickFactor=aw;this.numberMinorTicks=b(this.tickPositions,this.tickInterval,this.tickFactor);if(!this.numberMinorTicks){this.numberMinorTicks=b(this.tickPositions,this.tickInterval,this.tickFactor-1)}}}if(!q&&!aG){var P=this.max-this.min;aw=Math.floor(parseFloat((Math.log(P)/Math.log(10)).toFixed(11)))-1;var aN=[5,6,4,7,3,8,9,10,2],V,C,av=0,M;if(P>1){var aJ=String(P);if(aJ.search(/\./)==-1){var aF=aJ.search(/0+$/);av=(aF>0)?aJ.length-aF-1:0}}M=P/Math.pow(10,av);for(aa=0;aa<aN.length;aa++){V=M/(aN[aa]-1);if(V==parseInt(V,10)){this.numberTicks=aN[aa];this.tickInterval=P/(this.numberTicks-1);this.tickFactor=aw+1;break}}var O;for(aa=0;aa<this.numberTicks;aa++){O=parseFloat((this.min+aa*this.tickInterval).toFixed(11));this.ticks.push([O,O])}this.numberMinorTicks=b(this.tickPositions,this.tickInterval,this.tickFactor);if(!this.numberMinorTicks){this.numberMinorTicks=b(this.tickPositions,this.tickInterval,this.tickFactor-1)}if(!this.numberMinorTicks){this.numberMinorTicks=1;var aH=[4,5,3,6,2];for(aa=0;aa<5;aa++){var ao=this.tickInterval/aH[aa];if(ao==parseInt(ao,10)){this.numberMinorTicks=aH[aa]-1;break}}}}}var U=this._radius,aE=this.startAngle,k=this.endAngle,H=Math.PI,e=Math.PI/2;if(this.semiCircular){var z=Math.atan(this.innerPad/U),ac=this.outerStartAngle=aE-z,aB=this.outerEndAngle=k+z,B=this.hubStartAngle=aE-Math.atan(this.innerPad/this.hubRadius*2),af=this.hubEndAngle=k+Math.atan(this.innerPad/this.hubRadius*2);X.save();X.translate(this._center[0],this._center[1]);X.lineJoin="round";X.lineCap="round";X.save();X.beginPath();X.fillStyle=this.background;X.arc(0,0,U,ac,aB,false);X.closePath();X.fill();X.restore();var aj="rgba(0,0,0,"+this.shadowAlpha+")";X.save();for(var aa=0;aa<this.shadowDepth;aa++){X.translate(this.shadowOffset*Math.cos(this.shadowAngle/180*Math.PI),this.shadowOffset*Math.sin(this.shadowAngle/180*Math.PI));X.beginPath();X.strokeStyle=aj;X.lineWidth=this.shadowWidth;X.arc(0,0,U,ac,aB,false);X.closePath();X.stroke()}X.restore();X.save();var az=parseInt((this.shadowDepth+1)/2,10);for(var aa=0;aa<az;aa++){X.translate(this.shadowOffset*Math.cos(this.shadowAngle/180*Math.PI),this.shadowOffset*Math.sin(this.shadowAngle/180*Math.PI));X.beginPath();X.fillStyle=aj;X.arc(0,0,this.hubRadius,B,af,false);X.closePath();X.fill()}X.restore();X.save();X.beginPath();X.strokeStyle=this.ringColor;X.lineWidth=this.ringWidth;X.arc(0,0,U,ac,aB,false);X.closePath();X.stroke();X.restore();X.save();X.beginPath();X.fillStyle=this.ringColor;X.arc(0,0,this.hubRadius,B,af,false);X.closePath();X.fill();X.restore();if(this.showTicks){X.save();var f=this.tickOuterRadius,aq=this.tickLength,v=aq/2,F=this.numberMinorTicks,am=this.span*Math.PI/180/(this.ticks.length-1),p=am/(F+1);for(aa=0;aa<this.ticks.length;aa++){X.beginPath();X.lineWidth=1.5+this.diameter/360;X.strokeStyle=this.ringColor;var ae=am*aa+aE;X.moveTo(-f*Math.cos(am*aa+aE),f*Math.sin(am*aa+aE));X.lineTo(-(f-aq)*Math.cos(am*aa+aE),(f-aq)*Math.sin(am*aa+aE));this._tickPoints.push([(f-aq)*Math.cos(am*aa+aE)+this._center[0]+this.canvas._offsets.left,(f-aq)*Math.sin(am*aa+aE)+this._center[1]+this.canvas._offsets.top,am*aa+aE]);X.stroke();X.lineWidth=1+this.diameter/440;if(aa<this.ticks.length-1){for(var Y=1;Y<=F;Y++){X.beginPath();X.moveTo(-f*Math.cos(am*aa+p*Y+aE),f*Math.sin(am*aa+p*Y+aE));X.lineTo(-(f-v)*Math.cos(am*aa+p*Y+aE),(f-v)*Math.sin(am*aa+p*Y+aE));X.stroke()}}}X.restore()}if(this.showTickLabels){var J,W,T,aO,g,G,n=0;var an=this.tickPadding*(1-1/(this.diameter/80+1));for(aa=0;aa<this.ticks.length;aa++){J=c('<div class="jqplot-meterGauge-tick" style="position:absolute;">'+this.ticks[aa][1]+"</div>");this.canvas._elem.after(J);aO=J.outerWidth(true);g=J.outerHeight(true);W=this._tickPoints[aa][0]-aO*(this._tickPoints[aa][2]-Math.PI)/Math.PI-an*Math.cos(this._tickPoints[aa][2]);T=this._tickPoints[aa][1]-g/2+g/2*Math.pow(Math.abs((Math.sin(this._tickPoints[aa][2]))),0.5)+an/3*Math.pow(Math.abs((Math.sin(this._tickPoints[aa][2]))),0.5);J.css({left:W,top:T,color:this.tickColor});G=aO*Math.cos(this._tickPoints[aa][2])+g*Math.sin(Math.PI/2+this._tickPoints[aa][2]/2);n=(G>n)?G:n}}if(this.label&&this.labelPosition=="inside"){var W=this._center[0]+this.canvas._offsets.left;var an=this.tickPadding*(1-1/(this.diameter/80+1));var T=0.5*(this._center[1]+this.canvas._offsets.top-this.hubRadius)+0.5*(this._center[1]+this.canvas._offsets.top-this.tickOuterRadius+this.tickLength+an)+this.labelHeightAdjust;W-=this._labelElem.outerWidth(true)/2;T-=this._labelElem.outerHeight(true)/2;this._labelElem.css({left:W,top:T})}else{if(this.label&&this.labelPosition=="bottom"){var W=this._center[0]+this.canvas._offsets.left-this._labelElem.outerWidth(true)/2;var T=this._center[1]+this.canvas._offsets.top+this.innerPad+this.ringWidth+this.padding+this.labelHeightAdjust;this._labelElem.css({left:W,top:T})}}X.save();var ax=this.intervalInnerRadius||this.hubRadius*1.5;if(this.intervalOuterRadius==null){if(this.showTickLabels){var ag=(this.tickOuterRadius-this.tickLength-this.tickPadding-this.diameter/8)}else{var ag=(this.tickOuterRadius-this.tickLength-this.diameter/16)}}else{var ag=this.intervalOuterRadius}var P=this.max-this.min;var aD=this.intervals[this.intervals.length-1]-this.min;var y,Z,u=this.span*Math.PI/180;for(aa=0;aa<this.intervals.length;aa++){y=(aa==0)?aE:aE+(this.intervals[aa-1][0]-this.min)*u/P;if(y<0){y=0}Z=aE+(this.intervals[aa][0]-this.min)*u/P;if(Z<0){Z=0}X.beginPath();X.fillStyle=this.intervals[aa][2];X.arc(0,0,ax,y,Z,false);X.lineTo(ag*Math.cos(Z),ag*Math.sin(Z));X.arc(0,0,ag,Z,y,true);X.lineTo(ax*Math.cos(y),ax*Math.sin(y));X.closePath();X.fill()}X.restore();var ay=this.data[0][1];var R=this.max-this.min;if(this.pegNeedle){if(this.data[0][1]>this.max+R*3/this.span){ay=this.max+R*3/this.span}if(this.data[0][1]<this.min-R*3/this.span){ay=this.min-R*3/this.span}}var al=(ay-this.min)/R*this.span*Math.PI/180+this.startAngle;X.save();X.beginPath();X.fillStyle=this.ringColor;X.strokeStyle=this.ringColor;this.needleLength=(this.tickOuterRadius-this.tickLength)*0.85;this.needleThickness=(this.needleThickness<2)?2:this.needleThickness;var aK=this.needleThickness*0.4;var x=this.needleLength/10;var s=(this.needleThickness-aK)/10;var ar;for(var aa=0;aa<10;aa++){ar=this.needleThickness-aa*s;X.moveTo(x*aa*Math.cos(al),x*aa*Math.sin(al));X.lineWidth=ar;X.lineTo(x*(aa+1)*Math.cos(al),x*(aa+1)*Math.sin(al));X.stroke()}X.restore()}else{this._center=[(K-at*ai)/2+at*ai,(S-at*ah)/2+at*ah]}};c.jqplot.MeterGaugeAxisRenderer=function(){c.jqplot.LinearAxisRenderer.call(this)};c.jqplot.MeterGaugeAxisRenderer.prototype=new c.jqplot.LinearAxisRenderer();c.jqplot.MeterGaugeAxisRenderer.prototype.constructor=c.jqplot.MeterGaugeAxisRenderer;c.jqplot.MeterGaugeAxisRenderer.prototype.init=function(e){this.tickRenderer=c.jqplot.MeterGaugeTickRenderer;c.extend(true,this,e);this._dataBounds={min:0,max:100};this.min=0;this.max=100;this.showTicks=false;this.ticks=[];this.showMark=false;this.show=false};c.jqplot.MeterGaugeLegendRenderer=function(){c.jqplot.TableLegendRenderer.call(this)};c.jqplot.MeterGaugeLegendRenderer.prototype=new c.jqplot.TableLegendRenderer();c.jqplot.MeterGaugeLegendRenderer.prototype.constructor=c.jqplot.MeterGaugeLegendRenderer;c.jqplot.MeterGaugeLegendRenderer.prototype.init=function(e){this.numberRows=null;this.numberColumns=null;c.extend(true,this,e)};c.jqplot.MeterGaugeLegendRenderer.prototype.draw=function(){if(this.show){var p=this._series;var x="position:absolute;";x+=(this.background)?"background:"+this.background+";":"";x+=(this.border)?"border:"+this.border+";":"";x+=(this.fontSize)?"font-size:"+this.fontSize+";":"";x+=(this.fontFamily)?"font-family:"+this.fontFamily+";":"";x+=(this.textColor)?"color:"+this.textColor+";":"";x+=(this.marginTop!=null)?"margin-top:"+this.marginTop+";":"";x+=(this.marginBottom!=null)?"margin-bottom:"+this.marginBottom+";":"";x+=(this.marginLeft!=null)?"margin-left:"+this.marginLeft+";":"";x+=(this.marginRight!=null)?"margin-right:"+this.marginRight+";":"";this._elem=c('<table class="jqplot-table-legend" style="'+x+'"></table>');var f=false,q=false,u,o;var w=p[0];if(w.show){var t=w.data;if(this.numberRows){u=this.numberRows;if(!this.numberColumns){o=Math.ceil(t.length/u)}else{o=this.numberColumns}}else{if(this.numberColumns){o=this.numberColumns;u=Math.ceil(t.length/this.numberColumns)}else{u=t.length;o=1}}var n,m,r,g,e,l,k,h;var v=0;for(n=0;n<u;n++){if(q){r=c('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem)}else{r=c('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem)}for(m=0;m<o;m++){if(v<t.length){l=this.labels[v]||t[v][0].toString();h=w.color;if(!q){if(n>0){f=true}else{f=false}}else{if(n==u-1){f=false}else{f=true}}k=(f)?this.rowSpacing:"0";g=c('<td class="jqplot-table-legend" style="text-align:center;padding-top:'+k+';"><div><div class="jqplot-table-legend-swatch" style="border-color:'+h+';"></div></div></td>');e=c('<td class="jqplot-table-legend" style="padding-top:'+k+';"></td>');if(this.escapeHtml){e.text(l)}else{e.html(l)}if(q){e.prependTo(r);g.prependTo(r)}else{g.appendTo(r);e.appendTo(r)}f=true}v++}}}}return this._elem};function a(j,h,f){f=f||{};f.axesDefaults=f.axesDefaults||{};f.legend=f.legend||{};f.seriesDefaults=f.seriesDefaults||{};f.grid=f.grid||{};var e=false;if(f.seriesDefaults.renderer==c.jqplot.MeterGaugeRenderer){e=true}else{if(f.series){for(var g=0;g<f.series.length;g++){if(f.series[g].renderer==c.jqplot.MeterGaugeRenderer){e=true}}}}if(e){f.axesDefaults.renderer=c.jqplot.MeterGaugeAxisRenderer;f.legend.renderer=c.jqplot.MeterGaugeLegendRenderer;f.legend.preDraw=true;f.grid.background=f.grid.background||"white";f.grid.drawGridlines=false;f.grid.borderWidth=(f.grid.borderWidth!=null)?f.grid.borderWidth:0;f.grid.shadow=(f.grid.shadow!=null)?f.grid.shadow:false}}function d(e){}c.jqplot.preInitHooks.push(a);c.jqplot.postParseOptionsHooks.push(d);c.jqplot.MeterGaugeTickRenderer=function(){c.jqplot.AxisTickRenderer.call(this)};c.jqplot.MeterGaugeTickRenderer.prototype=new c.jqplot.AxisTickRenderer();c.jqplot.MeterGaugeTickRenderer.prototype.constructor=c.jqplot.MeterGaugeTickRenderer})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(a){a.jqplot.OHLCRenderer=function(){a.jqplot.LineRenderer.call(this);this.candleStick=false;this.tickLength="auto";this.bodyWidth="auto";this.openColor=null;this.closeColor=null;this.wickColor=null;this.fillUpBody=false;this.fillDownBody=true;this.upBodyColor=null;this.downBodyColor=null;this.hlc=false;this.lineWidth=1.5;this._tickLength;this._bodyWidth};a.jqplot.OHLCRenderer.prototype=new a.jqplot.LineRenderer();a.jqplot.OHLCRenderer.prototype.constructor=a.jqplot.OHLCRenderer;a.jqplot.OHLCRenderer.prototype.init=function(e){e=e||{};this.lineWidth=e.lineWidth||1.5;a.jqplot.LineRenderer.prototype.init.call(this,e);this._type="ohlc";var b=this._yaxis._dataBounds;var f=this._plotData;if(f[0].length<5){this.renderer.hlc=true;for(var c=0;c<f.length;c++){if(f[c][2]<b.min||b.min==null){b.min=f[c][2]}if(f[c][1]>b.max||b.max==null){b.max=f[c][1]}}}else{for(var c=0;c<f.length;c++){if(f[c][3]<b.min||b.min==null){b.min=f[c][3]}if(f[c][2]>b.max||b.max==null){b.max=f[c][2]}}}};a.jqplot.OHLCRenderer.prototype.draw=function(A,N,j){var J=this.data;var v=this._xaxis.min;var z=this._xaxis.max;var l=0;var K=J.length;var p=this._xaxis.series_u2p;var G=this._yaxis.series_u2p;var D,E,f,M,F,n,O,C;var y;var u=this.renderer;var s=(j!=undefined)?j:{};var k=(s.shadow!=undefined)?s.shadow:this.shadow;var B=(s.fill!=undefined)?s.fill:this.fill;var c=(s.fillAndStroke!=undefined)?s.fillAndStroke:this.fillAndStroke;u.bodyWidth=(s.bodyWidth!=undefined)?s.bodyWidth:u.bodyWidth;u.tickLength=(s.tickLength!=undefined)?s.tickLength:u.tickLength;A.save();if(this.show){var m,q,g,Q,t;for(var D=0;D<J.length;D++){if(J[D][0]<v){l=D}else{if(J[D][0]<z){K=D+1}}}var I=this.gridData[K-1][0]-this.gridData[l][0];var L=K-l;try{var P=Math.abs(this._xaxis.series_u2p(parseInt(this._xaxis._intervalStats[0].sortedIntervals[0].interval,10))-this._xaxis.series_u2p(0))}catch(H){var P=I/L}if(u.candleStick){if(typeof(u.bodyWidth)=="number"){u._bodyWidth=u.bodyWidth}else{u._bodyWidth=Math.min(20,P/1.65)}}else{if(typeof(u.tickLength)=="number"){u._tickLength=u.tickLength}else{u._tickLength=Math.min(10,P/3.5)}}for(var D=l;D<K;D++){m=p(J[D][0]);if(u.hlc){q=null;g=G(J[D][1]);Q=G(J[D][2]);t=G(J[D][3])}else{q=G(J[D][1]);g=G(J[D][2]);Q=G(J[D][3]);t=G(J[D][4])}y={};if(u.candleStick&&!u.hlc){n=u._bodyWidth;O=m-n/2;if(t<q){if(u.wickColor){y.color=u.wickColor}else{if(u.downBodyColor){y.color=u.upBodyColor}}f=a.extend(true,{},s,y);u.shapeRenderer.draw(A,[[m,g],[m,t]],f);u.shapeRenderer.draw(A,[[m,q],[m,Q]],f);y={};M=t;F=q-t;if(u.fillUpBody){y.fillRect=true}else{y.strokeRect=true;n=n-this.lineWidth;O=m-n/2}if(u.upBodyColor){y.color=u.upBodyColor;y.fillStyle=u.upBodyColor}C=[O,M,n,F]}else{if(t>q){if(u.wickColor){y.color=u.wickColor}else{if(u.downBodyColor){y.color=u.downBodyColor}}f=a.extend(true,{},s,y);u.shapeRenderer.draw(A,[[m,g],[m,q]],f);u.shapeRenderer.draw(A,[[m,t],[m,Q]],f);y={};M=q;F=t-q;if(u.fillDownBody){y.fillRect=true}else{y.strokeRect=true;n=n-this.lineWidth;O=m-n/2}if(u.downBodyColor){y.color=u.downBodyColor;y.fillStyle=u.downBodyColor}C=[O,M,n,F]}else{if(u.wickColor){y.color=u.wickColor}f=a.extend(true,{},s,y);u.shapeRenderer.draw(A,[[m,g],[m,Q]],f);y={};y.fillRect=false;y.strokeRect=false;O=[m-n/2,q];M=[m+n/2,t];n=null;F=null;C=[O,M]}}f=a.extend(true,{},s,y);u.shapeRenderer.draw(A,C,f)}else{E=s.color;if(u.openColor){s.color=u.openColor}if(!u.hlc){u.shapeRenderer.draw(A,[[m-u._tickLength,q],[m,q]],s)}s.color=E;if(u.wickColor){s.color=u.wickColor}u.shapeRenderer.draw(A,[[m,g],[m,Q]],s);s.color=E;if(u.closeColor){s.color=u.closeColor}u.shapeRenderer.draw(A,[[m,t],[m+u._tickLength,t]],s);s.color=E}}}A.restore()};a.jqplot.OHLCRenderer.prototype.drawShadow=function(b,d,c){};a.jqplot.OHLCRenderer.checkOptions=function(d,c,b){if(!b.highlighter){b.highlighter={showMarker:false,tooltipAxes:"y",yvalues:4,formatString:'<table class="jqplot-highlighter"><tr><td>date:</td><td>%s</td></tr><tr><td>open:</td><td>%s</td></tr><tr><td>hi:</td><td>%s</td></tr><tr><td>low:</td><td>%s</td></tr><tr><td>close:</td><td>%s</td></tr></table>'}}}})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(e){e.jqplot.PieRenderer=function(){e.jqplot.LineRenderer.call(this)};e.jqplot.PieRenderer.prototype=new e.jqplot.LineRenderer();e.jqplot.PieRenderer.prototype.constructor=e.jqplot.PieRenderer;e.jqplot.PieRenderer.prototype.init=function(q,u){this.diameter=null;this.padding=20;this.sliceMargin=0;this.fill=true;this.shadowOffset=2;this.shadowAlpha=0.07;this.shadowDepth=5;this.highlightMouseOver=true;this.highlightMouseDown=false;this.highlightColors=[];this.dataLabels="percent";this.showDataLabels=false;this.dataLabelFormatString=null;this.dataLabelThreshold=3;this.dataLabelPositionFactor=0.52;this.dataLabelNudge=2;this.dataLabelCenterOn=true;this.startAngle=0;this.tickRenderer=e.jqplot.PieTickRenderer;this._drawData=true;this._type="pie";if(q.highlightMouseDown&&q.highlightMouseOver==null){q.highlightMouseOver=false}e.extend(true,this,q);if(this.sliceMargin<0){this.sliceMargin=0}this._diameter=null;this._radius=null;this._sliceAngles=[];this._highlightedPoint=null;if(this.highlightColors.length==0){for(var s=0;s<this.seriesColors.length;s++){var r=e.jqplot.getColorComponents(this.seriesColors[s]);var o=[r[0],r[1],r[2]];var t=o[0]+o[1]+o[2];for(var p=0;p<3;p++){o[p]=(t>570)?o[p]*0.8:o[p]+0.3*(255-o[p]);o[p]=parseInt(o[p],10)}this.highlightColors.push("rgb("+o[0]+","+o[1]+","+o[2]+")")}}this.highlightColorGenerator=new e.jqplot.ColorGenerator(this.highlightColors);u.postParseOptionsHooks.addOnce(m);u.postInitHooks.addOnce(g);u.eventListenerHooks.addOnce("jqplotMouseMove",b);u.eventListenerHooks.addOnce("jqplotMouseDown",a);u.eventListenerHooks.addOnce("jqplotMouseUp",l);u.eventListenerHooks.addOnce("jqplotClick",f);u.eventListenerHooks.addOnce("jqplotRightClick",n);u.postDrawHooks.addOnce(i)};e.jqplot.PieRenderer.prototype.setGridData=function(t){var p=[];var u=[];var o=this.startAngle/180*Math.PI;var s=0;this._drawData=false;for(var r=0;r<this.data.length;r++){if(this.data[r][1]!=0){this._drawData=true}p.push(this.data[r][1]);u.push([this.data[r][0]]);if(r>0){p[r]+=p[r-1]}s+=this.data[r][1]}var q=Math.PI*2/p[p.length-1];for(var r=0;r<p.length;r++){u[r][1]=p[r]*q;u[r][2]=this.data[r][1]/s}this.gridData=u};e.jqplot.PieRenderer.prototype.makeGridData=function(t,u){var p=[];var v=[];var s=0;var o=this.startAngle/180*Math.PI;this._drawData=false;for(var r=0;r<t.length;r++){if(this.data[r][1]!=0){this._drawData=true}p.push(t[r][1]);v.push([t[r][0]]);if(r>0){p[r]+=p[r-1]}s+=t[r][1]}var q=Math.PI*2/p[p.length-1];for(var r=0;r<p.length;r++){v[r][1]=p[r]*q;v[r][2]=t[r][1]/s}return v};function h(o){return Math.sin((o-(o-Math.PI)/8/Math.PI)/2)}function j(u,t,o,v,r){var w=0;var q=t-u;var s=Math.abs(q);var p=o;if(v==false){p+=r}if(p>0&&s>0.01&&s<6.282){w=parseFloat(p)/2/h(q)}return w}e.jqplot.PieRenderer.prototype.drawSlice=function(B,z,y,u,w){if(this._drawData){var p=this._radius;var A=this.fill;var x=this.lineWidth;var s=this.sliceMargin;if(this.fill==false){s+=this.lineWidth}B.save();B.translate(this._center[0],this._center[1]);var D=j(z,y,this.sliceMargin,this.fill,this.lineWidth);var o=D*Math.cos((z+y)/2);var C=D*Math.sin((z+y)/2);if((y-z)<=Math.PI){p-=D}else{p+=D}B.translate(o,C);if(w){for(var v=0,t=this.shadowDepth;v<t;v++){B.save();B.translate(this.shadowOffset*Math.cos(this.shadowAngle/180*Math.PI),this.shadowOffset*Math.sin(this.shadowAngle/180*Math.PI));q(p)}for(var v=0,t=this.shadowDepth;v<t;v++){B.restore()}}else{q(p)}B.restore()}function q(r){if(y>6.282+this.startAngle){y=6.282+this.startAngle;if(z>y){z=6.281+this.startAngle}}if(z>=y){return}B.beginPath();B.fillStyle=u;B.strokeStyle=u;B.lineWidth=x;B.arc(0,0,r,z,y,false);B.lineTo(0,0);B.closePath();if(A){B.fill()}else{B.stroke()}}};e.jqplot.PieRenderer.prototype.draw=function(B,z,E,o){var W;var H=(E!=undefined)?E:{};var t=0;var s=0;var N=1;var L=new e.jqplot.ColorGenerator(this.seriesColors);if(E.legendInfo&&E.legendInfo.placement=="insideGrid"){var J=E.legendInfo;switch(J.location){case"nw":t=J.width+J.xoffset;break;case"w":t=J.width+J.xoffset;break;case"sw":t=J.width+J.xoffset;break;case"ne":t=J.width+J.xoffset;N=-1;break;case"e":t=J.width+J.xoffset;N=-1;break;case"se":t=J.width+J.xoffset;N=-1;break;case"n":s=J.height+J.yoffset;break;case"s":s=J.height+J.yoffset;N=-1;break;default:break}}var K=(H.shadow!=undefined)?H.shadow:this.shadow;var A=(H.fill!=undefined)?H.fill:this.fill;var C=B.canvas.width;var I=B.canvas.height;var Q=C-t-2*this.padding;var X=I-s-2*this.padding;var M=Math.min(Q,X);var Y=M;this._sliceAngles=[];var v=this.sliceMargin;if(this.fill==false){v+=this.lineWidth}var q;var G=0;var R,aa,Z,ab;var D=this.startAngle/180*Math.PI;for(var W=0,V=z.length;W<V;W++){aa=(W==0)?D:z[W-1][1]+D;Z=z[W][1]+D;this._sliceAngles.push([aa,Z]);q=j(aa,Z,this.sliceMargin,this.fill,this.lineWidth);if(Math.abs(Z-aa)>Math.PI){G=Math.max(q,G)}}if(this.diameter!=null&&this.diameter>0){this._diameter=this.diameter-2*G}else{this._diameter=Y-2*G}if(this._diameter<6){e.jqplot.log("Diameter of pie too small, not rendering.");return}var S=this._radius=this._diameter/2;this._center=[(C-N*t)/2+N*t+G*Math.cos(D),(I-N*s)/2+N*s+G*Math.sin(D)];if(this.shadow){for(var W=0,V=z.length;W<V;W++){ab="rgba(0,0,0,"+this.shadowAlpha+")";this.renderer.drawSlice.call(this,B,this._sliceAngles[W][0],this._sliceAngles[W][1],ab,true)}}for(var W=0;W<z.length;W++){this.renderer.drawSlice.call(this,B,this._sliceAngles[W][0],this._sliceAngles[W][1],L.next(),false);if(this.showDataLabels&&z[W][2]*100>=this.dataLabelThreshold){var F,U=(this._sliceAngles[W][0]+this._sliceAngles[W][1])/2,T;if(this.dataLabels=="label"){F=this.dataLabelFormatString||"%s";T=e.jqplot.sprintf(F,z[W][0])}else{if(this.dataLabels=="value"){F=this.dataLabelFormatString||"%d";T=e.jqplot.sprintf(F,this.data[W][1])}else{if(this.dataLabels=="percent"){F=this.dataLabelFormatString||"%d%%";T=e.jqplot.sprintf(F,z[W][2]*100)}else{if(this.dataLabels.constructor==Array){F=this.dataLabelFormatString||"%s";T=e.jqplot.sprintf(F,this.dataLabels[W])}}}}var p=(this._radius)*this.dataLabelPositionFactor+this.sliceMargin+this.dataLabelNudge;var P=this._center[0]+Math.cos(U)*p+this.canvas._offsets.left;var O=this._center[1]+Math.sin(U)*p+this.canvas._offsets.top;var u=e('<div class="jqplot-pie-series jqplot-data-label" style="position:absolute;">'+T+"</div>").insertBefore(o.eventCanvas._elem);if(this.dataLabelCenterOn){P-=u.width()/2;O-=u.height()/2}else{P-=u.width()*Math.sin(U/2);O-=u.height()/2}P=Math.round(P);O=Math.round(O);u.css({left:P,top:O})}}};e.jqplot.PieAxisRenderer=function(){e.jqplot.LinearAxisRenderer.call(this)};e.jqplot.PieAxisRenderer.prototype=new e.jqplot.LinearAxisRenderer();e.jqplot.PieAxisRenderer.prototype.constructor=e.jqplot.PieAxisRenderer;e.jqplot.PieAxisRenderer.prototype.init=function(o){this.tickRenderer=e.jqplot.PieTickRenderer;e.extend(true,this,o);this._dataBounds={min:0,max:100};this.min=0;this.max=100;this.showTicks=false;this.ticks=[];this.showMark=false;this.show=false};e.jqplot.PieLegendRenderer=function(){e.jqplot.TableLegendRenderer.call(this)};e.jqplot.PieLegendRenderer.prototype=new e.jqplot.TableLegendRenderer();e.jqplot.PieLegendRenderer.prototype.constructor=e.jqplot.PieLegendRenderer;e.jqplot.PieLegendRenderer.prototype.init=function(o){this.numberRows=null;this.numberColumns=null;e.extend(true,this,o)};e.jqplot.PieLegendRenderer.prototype.draw=function(){var r=this;if(this.show){var B=this._series;this._elem=e(document.createElement("table"));this._elem.addClass("jqplot-table-legend");var E={position:"absolute"};if(this.background){E.background=this.background}if(this.border){E.border=this.border}if(this.fontSize){E.fontSize=this.fontSize}if(this.fontFamily){E.fontFamily=this.fontFamily}if(this.textColor){E.textColor=this.textColor}if(this.marginTop!=null){E.marginTop=this.marginTop}if(this.marginBottom!=null){E.marginBottom=this.marginBottom}if(this.marginLeft!=null){E.marginLeft=this.marginLeft}if(this.marginRight!=null){E.marginRight=this.marginRight}this._elem.css(E);var I=false,A=false,o,y;var C=B[0];var p=new e.jqplot.ColorGenerator(C.seriesColors);if(C.show){var J=C.data;if(this.numberRows){o=this.numberRows;if(!this.numberColumns){y=Math.ceil(J.length/o)}else{y=this.numberColumns}}else{if(this.numberColumns){y=this.numberColumns;o=Math.ceil(J.length/this.numberColumns)}else{o=J.length;y=1}}var H,G;var q,w,v;var x,z,F;var D=0;var u,t;for(H=0;H<o;H++){q=e(document.createElement("tr"));q.addClass("jqplot-table-legend");if(A){q.prependTo(this._elem)}else{q.appendTo(this._elem)}for(G=0;G<y;G++){if(D<J.length){x=this.labels[D]||J[D][0].toString();F=p.next();if(!A){if(H>0){I=true}else{I=false}}else{if(H==o-1){I=false}else{I=true}}z=(I)?this.rowSpacing:"0";w=e(document.createElement("td"));w.addClass("jqplot-table-legend jqplot-table-legend-swatch");w.css({textAlign:"center",paddingTop:z});u=e(document.createElement("div"));u.addClass("jqplot-table-legend-swatch-outline");t=e(document.createElement("div"));t.addClass("jqplot-table-legend-swatch");t.css({backgroundColor:F,borderColor:F});w.append(u.append(t));v=e(document.createElement("td"));v.addClass("jqplot-table-legend jqplot-table-legend-label");v.css("paddingTop",z);if(this.escapeHtml){v.text(x)}else{v.html(x)}if(A){v.prependTo(q);w.prependTo(q)}else{w.appendTo(q);v.appendTo(q)}I=true}D++}}}}return this._elem};e.jqplot.PieRenderer.prototype.handleMove=function(q,p,t,s,r){if(s){var o=[s.seriesIndex,s.pointIndex,s.data];r.target.trigger("jqplotDataMouseOver",o);if(r.series[o[0]].highlightMouseOver&&!(o[0]==r.plugins.pieRenderer.highlightedSeriesIndex&&o[1]==r.series[o[0]]._highlightedPoint)){r.target.trigger("jqplotDataHighlight",o);d(r,o[0],o[1])}}else{if(s==null){k(r)}}};function c(s,r,p){p=p||{};p.axesDefaults=p.axesDefaults||{};p.legend=p.legend||{};p.seriesDefaults=p.seriesDefaults||{};var o=false;if(p.seriesDefaults.renderer==e.jqplot.PieRenderer){o=true}else{if(p.series){for(var q=0;q<p.series.length;q++){if(p.series[q].renderer==e.jqplot.PieRenderer){o=true}}}}if(o){p.axesDefaults.renderer=e.jqplot.PieAxisRenderer;p.legend.renderer=e.jqplot.PieLegendRenderer;p.legend.preDraw=true;p.seriesDefaults.pointLabels={show:false}}}function g(r,q,o){for(var p=0;p<this.series.length;p++){if(this.series[p].renderer.constructor==e.jqplot.PieRenderer){if(this.series[p].highlightMouseOver){this.series[p].highlightMouseDown=false}}}}function m(o){for(var p=0;p<this.series.length;p++){this.series[p].seriesColors=this.seriesColors;this.series[p].colorGenerator=e.jqplot.colorGenerator}}function d(t,r,q){var p=t.series[r];var o=t.plugins.pieRenderer.highlightCanvas;o._ctx.clearRect(0,0,o._ctx.canvas.width,o._ctx.canvas.height);p._highlightedPoint=q;t.plugins.pieRenderer.highlightedSeriesIndex=r;p.renderer.drawSlice.call(p,o._ctx,p._sliceAngles[q][0],p._sliceAngles[q][1],p.highlightColorGenerator.get(q),false)}function k(q){var o=q.plugins.pieRenderer.highlightCanvas;o._ctx.clearRect(0,0,o._ctx.canvas.width,o._ctx.canvas.height);for(var p=0;p<q.series.length;p++){q.series[p]._highlightedPoint=null}q.plugins.pieRenderer.highlightedSeriesIndex=null;q.target.trigger("jqplotDataUnhighlight")}function b(s,r,v,u,t){if(u){var q=[u.seriesIndex,u.pointIndex,u.data];var p=jQuery.Event("jqplotDataMouseOver");p.pageX=s.pageX;p.pageY=s.pageY;t.target.trigger(p,q);if(t.series[q[0]].highlightMouseOver&&!(q[0]==t.plugins.pieRenderer.highlightedSeriesIndex&&q[1]==t.series[q[0]]._highlightedPoint)){var o=jQuery.Event("jqplotDataHighlight");o.which=s.which;o.pageX=s.pageX;o.pageY=s.pageY;t.target.trigger(o,q);d(t,q[0],q[1])}}else{if(u==null){k(t)}}}function a(r,q,u,t,s){if(t){var p=[t.seriesIndex,t.pointIndex,t.data];if(s.series[p[0]].highlightMouseDown&&!(p[0]==s.plugins.pieRenderer.highlightedSeriesIndex&&p[1]==s.series[p[0]]._highlightedPoint)){var o=jQuery.Event("jqplotDataHighlight");o.which=r.which;o.pageX=r.pageX;o.pageY=r.pageY;s.target.trigger(o,p);d(s,p[0],p[1])}}else{if(t==null){k(s)}}}function l(q,p,t,s,r){var o=r.plugins.pieRenderer.highlightedSeriesIndex;if(o!=null&&r.series[o].highlightMouseDown){k(r)}}function f(r,q,u,t,s){if(t){var p=[t.seriesIndex,t.pointIndex,t.data];var o=jQuery.Event("jqplotDataClick");o.which=r.which;o.pageX=r.pageX;o.pageY=r.pageY;s.target.trigger(o,p)}}function n(s,r,v,u,t){if(u){var q=[u.seriesIndex,u.pointIndex,u.data];var o=t.plugins.pieRenderer.highlightedSeriesIndex;if(o!=null&&t.series[o].highlightMouseDown){k(t)}var p=jQuery.Event("jqplotDataRightClick");p.which=s.which;p.pageX=s.pageX;p.pageY=s.pageY;t.target.trigger(p,q)}}function i(){if(this.plugins.pieRenderer&&this.plugins.pieRenderer.highlightCanvas){this.plugins.pieRenderer.highlightCanvas.resetCanvas();this.plugins.pieRenderer.highlightCanvas=null}this.plugins.pieRenderer={highlightedSeriesIndex:null};this.plugins.pieRenderer.highlightCanvas=new e.jqplot.GenericCanvas();var p=e(this.targetId+" .jqplot-data-label");if(p.length){e(p[0]).before(this.plugins.pieRenderer.highlightCanvas.createElement(this._gridPadding,"jqplot-pieRenderer-highlight-canvas",this._plotDimensions,this))}else{this.eventCanvas._elem.before(this.plugins.pieRenderer.highlightCanvas.createElement(this._gridPadding,"jqplot-pieRenderer-highlight-canvas",this._plotDimensions,this))}var o=this.plugins.pieRenderer.highlightCanvas.setContext();this.eventCanvas._elem.bind("mouseleave",{plot:this},function(q){k(q.data.plot)})}e.jqplot.preInitHooks.push(c);e.jqplot.PieTickRenderer=function(){e.jqplot.AxisTickRenderer.call(this)};e.jqplot.PieTickRenderer.prototype=new e.jqplot.AxisTickRenderer();e.jqplot.PieTickRenderer.prototype.constructor=e.jqplot.PieTickRenderer})(jQuery);
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(e){e.jqplot.PyramidAxisRenderer=function(){e.jqplot.LinearAxisRenderer.call(this)};e.jqplot.PyramidAxisRenderer.prototype=new e.jqplot.LinearAxisRenderer();e.jqplot.PyramidAxisRenderer.prototype.constructor=e.jqplot.PyramidAxisRenderer;e.jqplot.PyramidAxisRenderer.prototype.init=function(f){this.position=null;this.drawBaseline=true;this.baselineWidth=null;this.baselineColor=null;this.tickSpacingFactor=25;this._type="pyramid";this._splitAxis=false;this._splitLength=null;this.category=false;this._autoFormatString="";this._overrideFormatString=false;e.extend(true,this,f);this.renderer.options=f;this.resetDataBounds=this.renderer.resetDataBounds;this.resetDataBounds()};e.jqplot.PyramidAxisRenderer.prototype.resetDataBounds=function(){var h=this._dataBounds;h.min=null;h.max=null;var g;for(var m=0;m<this._series.length;m++){var n=this._series[m];var o=n._plotData;for(var k=0,f=o.length;k<f;k++){if(this.name.charAt(0)==="x"){g=o[k][1];if((g!==null&&g<h.min)||h.min===null){h.min=g}if((g!==null&&g>h.max)||h.max===null){h.max=g}}else{g=o[k][0];if((g!==null&&g<h.min)||h.min===null){h.min=g}if((g!==null&&g>h.max)||h.max===null){h.max=g}}}}};e.jqplot.PyramidAxisRenderer.prototype.draw=function(f,n){if(this.show){this.renderer.createTicks.call(this,n);var m=0;var g;if(this._elem){this._elem.emptyForce();this._elem=null}this._elem=e(document.createElement("div"));this._elem.addClass("jqplot-axis jqplot-"+this.name);this._elem.css("position","absolute");if(this.name=="xaxis"||this.name=="x2axis"){this._elem.width(this._plotDimensions.width)}else{this._elem.height(this._plotDimensions.height)}this.labelOptions.axis=this.name;this._label=new this.labelRenderer(this.labelOptions);if(this._label.show){var l=this._label.draw(f,n);l.appendTo(this._elem);l=null}var k=this._ticks;var j;for(var h=0;h<k.length;h++){j=k[h];if(j.show&&j.showLabel&&(!j.isMinorTick)){this._elem.append(j.draw(f,n))}}j=null;k=null}return this._elem};var b=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];var d={};for(var c=0,a=b.length;c<a;c++){d[b[c]]=b[c]}e.jqplot.PyramidAxisRenderer.prototype.createTicks=function(D){var J=this.ticks;var M=this._dataBounds;var E;var K;var B;var G;var y;var n;var k;var h;var H;var C;var x;var L=this.min;var N=this.max;var q;var v;var m;var g;var j;var O;var A;var F;var r;var P;var z=null;var I;if(J.length){for(H=0,C=J.length;H<C;H++){q=J[H];v=new this.tickRenderer(this.tickOptions);if(e.isArray(q)){v.value=q[0];v.label=q[1];v.setTick(q[0],this.name);this._ticks.push(v)}else{if(e.isPlainObject(q)){e.extend(true,v,q);v.axis=this.name;this._ticks.push(v)}else{if(typeof q==="string"){P=H+D.defaultAxisStart}else{P=q}v.value=P;v.label=q;v.axis=this.name;this._ticks.push(v)}}}this.numberTicks=J.length;this.min=this._ticks[0].value;this.max=this._ticks[this.numberTicks-1].value;this.tickInterval=(this.max-this.min)/(this.numberTicks-1);if(this._options.tickInterval){var o=this._options.tickInterval;for(H=0;H<this.numberTicks;H++){if(H%o!==0){this._ticks[H].isMinorTick=true}}}else{E=(this.name.charAt(0)==="x")?this._plotDimensions.width:this._plotDimensions.height;r=Math.round(2+E/this.tickSpacingFactor);if(this.numberTicks>r){I=this.numberTicks-1;for(H=2;H<I;H++){if(I%H===0&&I/H<r){z=H-1;break}}if(z!==null){var p=1;for(H=1,C=this._ticks.length;H<C;H++){if(p<=z){this._ticks[H].show=false;p+=1}else{p=1}}}}}I=[];if(this.category){this._ticks[0].showGridline=false;this._ticks[0].showMark=false;for(H=this._ticks.length-1;H>0;H--){v=new this.tickRenderer(this.tickOptions);v.value=this._ticks[H-1].value+this.tickInterval/2;v.label="";v.showLabel=false;v.axis=this.name;this._ticks[H].showGridline=false;this._ticks[H].showMark=false;this._ticks.splice(H,0,v)}v=new this.tickRenderer(this.tickOptions);v.value=this._ticks[0].value-this.tickInterval/2;v.label="";v.showLabel=false;v.axis=this.name;this._ticks.unshift(v);v=new this.tickRenderer(this.tickOptions);v.value=this._ticks[this._ticks.length-1].value+this.tickInterval/2;v.label="";v.showLabel=false;v.axis=this.name;this._ticks.push(v);this.tickInterval=this.tickInterval/2;this.numberTicks=this._ticks.length;this.min=this._ticks[0].value;this.max=this._ticks[this._ticks.length-1].value}}else{if(this.name.charAt(0)==="x"){E=this._plotDimensions.width;var w=Math.max(M.max,Math.abs(M.min));var u=Math.min(M.min,-w);B=u;G=w;y=G-B;if(this.tickOptions==null||!this.tickOptions.formatString){this._overrideFormatString=true}m=30;g=Math.max(E,m+1);j=(g-m)/300;O=e.jqplot.LinearTickGenerator(B,G,j);A=B+y*(this.padMin-1);F=G-y*(this.padMax-1);if(B<A||G>F){A=B-y*(this.padMin-1);F=G+y*(this.padMax-1);O=e.jqplot.LinearTickGenerator(A,F,j)}this.min=O[0];this.max=O[1];this.numberTicks=O[2];this._autoFormatString=O[3];this.tickInterval=O[4]}else{E=this._plotDimensions.height;B=M.min;G=M.max;x=this._series[0];this._ticks=[];y=G-B;if(d[y]){y+=1;G+=1}this.max=G;this.min=B;r=Math.round(2+E/this.tickSpacingFactor);if(y+1<=r){this.numberTicks=y+1;this.tickInterval=1}else{for(var H=r;H>1;H--){if(y/(H-1)===Math.round(y/(H-1))){this.numberTicks=H;this.tickInterval=y/(H-1);break}}}}if(this._overrideFormatString&&this._autoFormatString!=""){this.tickOptions=this.tickOptions||{};this.tickOptions.formatString=this._autoFormatString}var f;for(H=0;H<this.numberTicks;H++){this.tickOptions.axis=this.name;f=this.min+this.tickInterval*H;if(this.name.charAt(0)==="x"){f=Math.abs(f)}this.tickOptions.value=this.min+this.tickInterval*H;v=new this.tickRenderer(this.tickOptions);v.label=v.prefix+v.formatter(v.formatString,f);this._ticks.push(v);if(this.name.charAt(0)==="x"&&D.axes.yMidAxis.show&&this.tickOptions.value===0){this._splitAxis=true;this._splitLength=D.axes.yMidAxis.getWidth();v=new this.tickRenderer(this.tickOptions);this._ticks.push(v);v.value=this.max/2000}}v=null}};e.jqplot.PyramidAxisRenderer.prototype.set=function(){var o=0;var j;var g=0;var n=0;var m;var l;var k;var f=(this._label==null)?false:this._label.show;if(this.show){l=this._ticks;a=l.length;for(m=0;m<a;m++){k=l[m];if(!k._breakTick&&k.show&&k.showLabel&&!k.isMinorTick){if(this.name.charAt(0)==="x"){j=k._elem.outerHeight(true)}else{j=k._elem.outerWidth(true)}if(j>o){o=j}}}if(this.name==="yMidAxis"){for(m=0;m<a;m++){k=l[m];if(k._elem){j=(o-k._elem.outerWidth(true))/2;k._elem.css("left",j)}}}k=null;l=null;if(f){g=this._label._elem.outerWidth(true);n=this._label._elem.outerHeight(true)}if(this.name==="xaxis"){o=o+n;this._elem.css({height:o+"px",left:"0px",bottom:"0px"})}else{if(this.name==="x2axis"){o=o+n;this._elem.css({height:o+"px",left:"0px",top:"0px"})}else{if(this.name==="yaxis"){o=o+g;this._elem.css({width:o+"px",left:"0px",top:"0px"});if(f&&this._label.constructor==e.jqplot.AxisLabelRenderer){this._label._elem.css("width",g+"px")}}else{if(this.name==="yMidAxis"){var j=o/2-g/2;this._elem.css({width:o+"px",top:"0px"});if(f&&this._label.constructor==e.jqplot.AxisLabelRenderer){this._label._elem.css({width:g,left:j,top:0})}}else{o=o+g;this._elem.css({width:o+"px",right:"0px",top:"0px"});if(f&&this._label.constructor==e.jqplot.AxisLabelRenderer){this._label._elem.css("width",g+"px")}}}}}}};e.jqplot.PyramidAxisRenderer.prototype.pack=function(j,g){j=j||{};g=g||this._offsets;var B=this._ticks;var v=this.max;var u=this.min;var o=g.max;var m=g.min;var r=(this._label==null)?false:this._label.show;for(var s in j){this._elem.css(s,j[s])}this._offsets=g;var k=o-m;var l=v-u;var z=this._splitLength;if(this._splitAxis){k-=this._splitLength;this.p2u=function(h){return(h-m)*l/k+u};this.u2p=function(h){if(h<=0){return(h-u)*k/l+m}else{return(h-u)*k/l+m+z}};this.series_u2p=function(h){if(h<=0){return(h-u)*k/l}else{return(h-u)*k/l+z}};this.series_p2u=function(h){return h*l/k+u}}else{this.p2u=function(h){return(h-m)*l/k+u};this.u2p=function(h){return(h-u)*k/l+m};if(this.name.charAt(0)==="x"){this.series_u2p=function(h){return(h-u)*k/l};this.series_p2u=function(h){return h*l/k+u}}else{this.series_u2p=function(h){return(h-v)*k/l};this.series_p2u=function(h){return h*l/k+v}}}if(this.show){if(this.name.charAt(0)==="x"){for(var x=0;x<B.length;x++){var q=B[x];if(q.show&&q.showLabel){var f;if(q.constructor==e.jqplot.CanvasAxisTickRenderer&&q.angle){var A=(this.name=="xaxis")?1:-1;switch(q.labelPosition){case"auto":if(A*q.angle<0){f=-q.getWidth()+q._textRenderer.height*Math.sin(-q._textRenderer.angle)/2}else{f=-q._textRenderer.height*Math.sin(q._textRenderer.angle)/2}break;case"end":f=-q.getWidth()+q._textRenderer.height*Math.sin(-q._textRenderer.angle)/2;break;case"start":f=-q._textRenderer.height*Math.sin(q._textRenderer.angle)/2;break;case"middle":f=-q.getWidth()/2+q._textRenderer.height*Math.sin(-q._textRenderer.angle)/2;break;default:f=-q.getWidth()/2+q._textRenderer.height*Math.sin(-q._textRenderer.angle)/2;break}}else{f=-q.getWidth()/2}var C=this.u2p(q.value)+f+"px";q._elem.css("left",C);q.pack()}}if(r){var n=this._label._elem.outerWidth(true);this._label._elem.css("left",m+k/2-n/2+"px");if(this.name=="xaxis"){this._label._elem.css("bottom","0px")}else{this._label._elem.css("top","0px")}this._label.pack()}}else{for(var x=0;x<B.length;x++){var q=B[x];if(q.show&&q.showLabel&&!q.isMinorTick){var f;if(q.constructor==e.jqplot.CanvasAxisTickRenderer&&q.angle){var A=(this.name=="yaxis")?1:-1;switch(q.labelPosition){case"auto":case"end":if(A*q.angle<0){f=-q._textRenderer.height*Math.cos(-q._textRenderer.angle)/2}else{f=-q.getHeight()+q._textRenderer.height*Math.cos(q._textRenderer.angle)/2}break;case"start":if(q.angle>0){f=-q._textRenderer.height*Math.cos(-q._textRenderer.angle)/2}else{f=-q.getHeight()+q._textRenderer.height*Math.cos(q._textRenderer.angle)/2}break;case"middle":f=-q.getHeight()/2;break;default:f=-q.getHeight()/2;break}}else{f=-q.getHeight()/2}var C=this.u2p(q.value)+f+"px";q._elem.css("top",C);q.pack()}}if(r){var y=this._label._elem.outerHeight(true);if(this.name!=="yMidAxis"){this._label._elem.css("top",o-k/2-y/2+"px")}if(this.name=="yaxis"){this._label._elem.css("left","0px")}else{if(this.name!=="yMidAxis"){this._label._elem.css("right","0px")}}this._label.pack()}}}B=null}})(jQuery);
/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function($) {     
    // Class: $.jqplot.CanvasGridRenderer
    // The default jqPlot grid renderer, creating a grid on a canvas element.
    // The renderer has no additional options beyond the <Grid> class.
    $.jqplot.PyramidGridRenderer = function(){
        $.jqplot.CanvasGridRenderer.call(this);
    };

    $.jqplot.PyramidGridRenderer.prototype = new $.jqplot.CanvasGridRenderer();
    $.jqplot.PyramidGridRenderer.prototype.constructor = $.jqplot.PyramidGridRenderer;
    
    // called with context of Grid object
    $.jqplot.CanvasGridRenderer.prototype.init = function(options) {
        this._ctx;
        this.plotBands = {
            show: false,
            color: 'rgb(230, 219, 179)',
            axis: 'y',
            start: null,
            interval: 10
        };
        $.extend(true, this, options);
        // set the shadow renderer options
        var sopts = {lineJoin:'miter', lineCap:'round', fill:false, isarc:false, angle:this.shadowAngle, offset:this.shadowOffset, alpha:this.shadowAlpha, depth:this.shadowDepth, lineWidth:this.shadowWidth, closePath:false, strokeStyle:this.shadowColor};
        this.renderer.shadowRenderer.init(sopts);
    };
    
    $.jqplot.PyramidGridRenderer.prototype.draw = function() {
        this._ctx = this._elem.get(0).getContext("2d");
        var ctx = this._ctx;
        var axes = this._axes;
        var xp = axes.xaxis.u2p;
        var yp = axes.yMidAxis.u2p;
        var xnudge = axes.xaxis.max/1000.0;
        var xp0 = xp(0);
        var xpn = xp(xnudge);
        var ax = ['xaxis', 'yaxis', 'x2axis', 'y2axis','yMidAxis'];
        // Add the grid onto the grid canvas.  This is the bottom most layer.
        ctx.save();
        ctx.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height);
        ctx.fillStyle = this.backgroundColor || this.background;

        ctx.fillRect(this._left, this._top, this._width, this._height);

        if (this.plotBands.show) {
            ctx.save();
            var pb = this.plotBands;
            ctx.fillStyle = pb.color;
            var axis;
            var x, y, w, h;
            // find axis to work with
            if (pb.axis.charAt(0) === 'x') {
                if (axes.xaxis.show) {
                    axis = axes.xaxis;
                }
            }
            else if (pb.axis.charAt(0) === 'y') {
                if (axes.yaxis.show) {
                    axis = axes.yaxis;
                }
                else if (axes.y2axis.show) {
                    axis = axes.y2axis;
                }
                else if (axes.yMidAxis.show) {
                    axis = axes.yMidAxis;
                }
            }

            if (axis !== undefined) {
                // draw some rectangles
                var start = pb.start;
                if (start === null) {
                    start = axis.min;
                }
                for (var i = start; i < axis.max; i += 2 * pb.interval) {
                    if (axis.name.charAt(0) === 'y') {
                        x = this._left;
                        if ((i + pb.interval) < axis.max) {
                            y = axis.series_u2p(i + pb.interval) + this._top;
                        }
                        else {
                            y = axis.series_u2p(axis.max) + this._top;
                        }
                        w = this._right - this._left;
                        h = axis.series_u2p(start) - axis.series_u2p(start + pb.interval);
                        ctx.fillRect(x, y, w, h);
                    }
                    // else {
                    //     y = 0;
                    //     x = axis.series_u2p(i);
                    //     h = this._height;
                    //     w = axis.series_u2p(start + pb.interval) - axis.series_u2p(start);
                    // }

                }
            }
            ctx.restore();
        }
        
        ctx.save();
        ctx.lineJoin = 'miter';
        ctx.lineCap = 'butt';
        ctx.lineWidth = this.gridLineWidth;
        ctx.strokeStyle = this.gridLineColor;
        var b, e, s, m;
        for (var i=5; i>0; i--) {
            var name = ax[i-1];
            var axis = axes[name];
            var ticks = axis._ticks;
            var numticks = ticks.length;
            if (axis.show) {
                if (axis.drawBaseline) {
                    var bopts = {};
                    if (axis.baselineWidth !== null) {
                        bopts.lineWidth = axis.baselineWidth;
                    }
                    if (axis.baselineColor !== null) {
                        bopts.strokeStyle = axis.baselineColor;
                    }
                    switch (name) {
                        case 'xaxis':
                            if (axes.yMidAxis.show) {
                                drawLine (this._left, this._bottom, xp0, this._bottom, bopts);
                                drawLine (xpn, this._bottom, this._right, this._bottom, bopts);
                            }
                            else {
                                drawLine (this._left, this._bottom, this._right, this._bottom, bopts);
                            }
                            break;
                        case 'yaxis':
                            drawLine (this._left, this._bottom, this._left, this._top, bopts);
                            break;
                        case 'yMidAxis':               
                            drawLine(xp0, this._bottom, xp0, this._top, bopts);
                            drawLine(xpn, this._bottom, xpn, this._top, bopts);
                            break;
                        case 'x2axis':
                            if (axes.yMidAxis.show) {
                                drawLine (this._left, this._top, xp0, this._top, bopts);
                                drawLine (xpn, this._top, this._right, this._top, bopts);
                            }
                            else {
                                drawLine (this._left, this._bottom, this._right, this._bottom, bopts);
                            }
                            break;
                        case 'y2axis':
                            drawLine (this._right, this._bottom, this._right, this._top, bopts);
                            break;

                    }
                }
                for (var j=numticks; j>0; j--) {
                    var t = ticks[j-1];
                    if (t.show) {
                        var pos = Math.round(axis.u2p(t.value)) + 0.5;
                        switch (name) {
                            case 'xaxis':
                                // draw the grid line if we should
                                if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks)) {
                                    drawLine(pos, this._top, pos, this._bottom);
                                }
                                
                                // draw the mark
                                if (t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._bottom;
                                            e = this._bottom+s;
                                            break;
                                        case 'inside':
                                            b = this._bottom-s;
                                            e = this._bottom;
                                            break;
                                        case 'cross':
                                            b = this._bottom-s;
                                            e = this._bottom+s;
                                            break;
                                        default:
                                            b = this._bottom;
                                            e = this._bottom+s;
                                            break;
                                    }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[pos,b],[pos,e]], {lineCap:'butt', lineWidth:this.gridLineWidth, offset:this.gridLineWidth*0.75, depth:2, fill:false, closePath:false});
                                    }
                                    // draw the line
                                    drawLine(pos, b, pos, e);
                                }
                                break;
                            case 'yaxis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks)) {
                                    drawLine(this._right, pos, this._left, pos);
                                }

                                // draw the mark
                                if (t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._left-s;
                                            e = this._left;
                                            break;
                                        case 'inside':
                                            b = this._left;
                                            e = this._left+s;
                                            break;
                                        case 'cross':
                                            b = this._left-s;
                                            e = this._left+s;
                                            break;
                                        default:
                                            b = this._left-s;
                                            e = this._left;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                                    }
                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                                }
                                break;
                            case 'yMidAxis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks)) {
                                    drawLine(this._left, pos, xp0, pos);
                                    drawLine(xpn, pos, this._right, pos);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;

                                    b = xp0;
                                    e = xp0 + s;
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                                    }
                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});

                                    b = xpn - s;
                                    e = xpn;
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                                    }
                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                                }
                                break;
                            case 'x2axis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks)) {
                                    drawLine(pos, this._bottom, pos, this._top);
                                }

                                // draw the mark
                                if (t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._top-s;
                                            e = this._top;
                                            break;
                                        case 'inside':
                                            b = this._top;
                                            e = this._top+s;
                                            break;
                                        case 'cross':
                                            b = this._top-s;
                                            e = this._top+s;
                                            break;
                                        default:
                                            b = this._top-s;
                                            e = this._top;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[pos,b],[pos,e]], {lineCap:'butt', lineWidth:this.gridLineWidth, offset:this.gridLineWidth*0.75, depth:2, fill:false, closePath:false});
                                    }
                                    drawLine(pos, b, pos, e);
                                }
                                break;
                            case 'y2axis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks)) {
                                    drawLine(this._left, pos, this._right, pos);
                                }

                                // draw the mark
                                if (t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._right;
                                            e = this._right+s;
                                            break;
                                        case 'inside':
                                            b = this._right-s;
                                            e = this._right;
                                            break;
                                        case 'cross':
                                            b = this._right-s;
                                            e = this._right+s;
                                            break;
                                        default:
                                            b = this._right;
                                            e = this._right+s;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                                    }
                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
                t = null;
            }
            axis = null;
            ticks = null;
        }
        
        ctx.restore();
        
        function drawLine(bx, by, ex, ey, opts) {
            ctx.save();
            opts = opts || {};
            if (opts.lineWidth == null || opts.lineWidth != 0){
                $.extend(true, ctx, opts);
                ctx.beginPath();
                ctx.moveTo(bx, by);
                ctx.lineTo(ex, ey);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        if (this.shadow) {
            if (axes.yMidAxis.show) {
                var points = [[this._left, this._bottom], [xp0, this._bottom]];
                this.renderer.shadowRenderer.draw(ctx, points);
                var points = [[xpn, this._bottom], [this._right, this._bottom], [this._right, this._top]];
                this.renderer.shadowRenderer.draw(ctx, points);
                var points = [[xp0, this._bottom], [xp0, this._top]];
                this.renderer.shadowRenderer.draw(ctx, points);
            }
            else {
                var points = [[this._left, this._bottom], [this._right, this._bottom], [this._right, this._top]];
                this.renderer.shadowRenderer.draw(ctx, points);
            }
        }
        // Now draw border around grid.  Use axis border definitions. start at
        // upper left and go clockwise.
        if (this.borderWidth != 0 && this.drawBorder) {
            if (axes.yMidAxis.show) {
                drawLine (this._left, this._top, xp0, this._top, {lineCap:'round', strokeStyle:axes.x2axis.borderColor, lineWidth:axes.x2axis.borderWidth});
                drawLine (xpn, this._top, this._right, this._top, {lineCap:'round', strokeStyle:axes.x2axis.borderColor, lineWidth:axes.x2axis.borderWidth});
                drawLine (this._right, this._top, this._right, this._bottom, {lineCap:'round', strokeStyle:axes.y2axis.borderColor, lineWidth:axes.y2axis.borderWidth});
                drawLine (this._right, this._bottom, xpn, this._bottom, {lineCap:'round', strokeStyle:axes.xaxis.borderColor, lineWidth:axes.xaxis.borderWidth});
                drawLine (xp0, this._bottom, this._left, this._bottom, {lineCap:'round', strokeStyle:axes.xaxis.borderColor, lineWidth:axes.xaxis.borderWidth});
                drawLine (this._left, this._bottom, this._left, this._top, {lineCap:'round', strokeStyle:axes.yaxis.borderColor, lineWidth:axes.yaxis.borderWidth});
                drawLine (xp0, this._bottom, xp0, this._top, {lineCap:'round', strokeStyle:axes.yaxis.borderColor, lineWidth:axes.yaxis.borderWidth});
                drawLine (xpn, this._bottom, xpn, this._top, {lineCap:'round', strokeStyle:axes.yaxis.borderColor, lineWidth:axes.yaxis.borderWidth});
            }
            else {
                drawLine (this._left, this._top, this._right, this._top, {lineCap:'round', strokeStyle:axes.x2axis.borderColor, lineWidth:axes.x2axis.borderWidth});
                drawLine (this._right, this._top, this._right, this._bottom, {lineCap:'round', strokeStyle:axes.y2axis.borderColor, lineWidth:axes.y2axis.borderWidth});
                drawLine (this._right, this._bottom, this._left, this._bottom, {lineCap:'round', strokeStyle:axes.xaxis.borderColor, lineWidth:axes.xaxis.borderWidth});
                drawLine (this._left, this._bottom, this._left, this._top, {lineCap:'round', strokeStyle:axes.yaxis.borderColor, lineWidth:axes.yaxis.borderWidth});
            }
        }
        // ctx.lineWidth = this.borderWidth;
        // ctx.strokeStyle = this.borderColor;
        // ctx.strokeRect(this._left, this._top, this._width, this._height);
        
        ctx.restore();
        ctx =  null;
        axes = null;
    };
})(jQuery); 
/* jqPlot 1.0.8r1250 | (c) 2009-2013 Chris Leonello | jplot.com
   jsDate | (c) 2010-2013 Chris Leonello
 */(function(c){if(c.jqplot.PyramidAxisRenderer===undefined){c.ajax({url:c.jqplot.pluginLocation+"jqplot.pyramidAxisRenderer.js",dataType:"script",async:false})}if(c.jqplot.PyramidGridRenderer===undefined){c.ajax({url:c.jqplot.pluginLocation+"jqplot.pyramidGridRenderer.js",dataType:"script",async:false})}c.jqplot.PyramidRenderer=function(){c.jqplot.LineRenderer.call(this)};c.jqplot.PyramidRenderer.prototype=new c.jqplot.LineRenderer();c.jqplot.PyramidRenderer.prototype.constructor=c.jqplot.PyramidRenderer;c.jqplot.PyramidRenderer.prototype.init=function(j,o){j=j||{};this._type="pyramid";this.barPadding=10;this.barWidth=null;this.fill=true;this.highlightMouseOver=true;this.highlightMouseDown=false;this.highlightColors=[];this.highlightThreshold=2;this.synchronizeHighlight=false;this.offsetBars=false;if(j.highlightMouseDown&&j.highlightMouseOver==null){j.highlightMouseOver=false}this.side="right";c.extend(true,this,j);if(this.side==="left"){this._highlightThreshold=[[-this.highlightThreshold,0],[-this.highlightThreshold,0],[0,0],[0,0]]}else{this._highlightThreshold=[[0,0],[0,0],[this.highlightThreshold,0],[this.highlightThreshold,0]]}this.renderer.options=j;this._highlightedPoint=null;this._dataColors=[];this._barPoints=[];this.fillAxis="y";this._primaryAxis="_yaxis";this._xnudge=0;var n={lineJoin:"miter",lineCap:"butt",fill:this.fill,fillRect:this.fill,isarc:false,strokeStyle:this.color,fillStyle:this.color,closePath:this.fill,lineWidth:this.lineWidth};this.renderer.shapeRenderer.init(n);var m=j.shadowOffset;if(m==null){if(this.lineWidth>2.5){m=1.25*(1+(Math.atan((this.lineWidth/2.5))/0.785398163-1)*0.6)}else{m=1.25*Math.atan((this.lineWidth/2.5))/0.785398163}}var h={lineJoin:"miter",lineCap:"butt",fill:this.fill,fillRect:this.fill,isarc:false,angle:this.shadowAngle,offset:m,alpha:this.shadowAlpha,depth:this.shadowDepth,closePath:this.fill,lineWidth:this.lineWidth};this.renderer.shadowRenderer.init(h);o.postDrawHooks.addOnce(f);o.eventListenerHooks.addOnce("jqplotMouseMove",e);if(this.side==="left"){for(var k=0,g=this.data.length;k<g;k++){this.data[k][1]=-Math.abs(this.data[k][1])}}};c.jqplot.PyramidRenderer.prototype.setGridData=function(p){var j=this._xaxis.series_u2p;var o=this._yaxis.series_u2p;var k=this._plotData;var n=this._prevPlotData;this.gridData=[];this._prevGridData=[];var g=k.length;var m=false;var h;for(h=0;h<g;h++){if(k[h][1]<0){this.side="left"}}if(this._yaxis.name==="yMidAxis"&&this.side==="right"){this._xnudge=this._xaxis.max/2000;m=true}for(h=0;h<g;h++){if(k[h][0]!=null&&k[h][1]!=null){this.gridData.push([j(k[h][1]),o(k[h][0])])}else{if(k[h][0]==null){this.gridData.push([j(k[h][1]),null])}else{if(k[h][1]==null){this.gridData.push(null,[o(k[h][0])])}}}if(k[h][1]===0&&m){this.gridData[h][0]=j(this._xnudge)}}};c.jqplot.PyramidRenderer.prototype.makeGridData=function(m,p){var k=this._xaxis.series_u2p;var o=this._yaxis.series_u2p;var j=[];var g=m.length;var n=false;var h;for(h=0;h<g;h++){if(m[h][1]<0){this.side="left"}}if(this._yaxis.name==="yMidAxis"&&this.side==="right"){this._xnudge=this._xaxis.max/2000;n=true}for(h=0;h<g;h++){if(m[h][0]!=null&&m[h][1]!=null){j.push([k(m[h][1]),o(m[h][0])])}else{if(m[h][0]==null){j.push([k(m[h][1]),null])}else{if(m[h][1]==null){j.push([null,o(m[h][0])])}}}if(m[h][1]===0&&n){j[h][0]=k(this._xnudge)}}return j};c.jqplot.PyramidRenderer.prototype.setBarWidth=function(){var k;var g=0;var h=0;var m=this[this._primaryAxis];var q,l,o;g=m.max-m.min;var n=m.numberTicks;var j=(n-1)/2;var p=(this.barPadding===0)?1:0;if(m.name=="xaxis"||m.name=="x2axis"){this.barWidth=(m._offsets.max-m._offsets.min)/g-this.barPadding+p}else{if(this.fill){this.barWidth=(m._offsets.min-m._offsets.max)/g-this.barPadding+p}else{this.barWidth=(m._offsets.min-m._offsets.max)/g}}};c.jqplot.PyramidRenderer.prototype.draw=function(B,I,k){var E;var u=c.extend({},k);var p=(u.shadow!=undefined)?u.shadow:this.shadow;var K=(u.showLine!=undefined)?u.showLine:this.showLine;var C=(u.fill!=undefined)?u.fill:this.fill;var t=this._xaxis.series_u2p;var G=this._yaxis.series_u2p;var z,x;this._dataColors=[];this._barPoints=[];if(this.renderer.options.barWidth==null){this.renderer.setBarWidth.call(this)}var D=[],s,F;if(K){var q=new c.jqplot.ColorGenerator(this.negativeSeriesColors);var v=new c.jqplot.ColorGenerator(this.seriesColors);var J=q.get(this.index);if(!this.useNegativeColors){J=u.fillStyle}var o=u.fillStyle;var n;var L=this._xaxis.series_u2p(this._xnudge);var j=this._yaxis.series_u2p(this._yaxis.min);var m=this._yaxis.series_u2p(this._yaxis.max);var H=this.barWidth;var y=H/2;var D=[];var r=this.offsetBars?y:0;for(var E=0,A=I.length;E<A;E++){if(this.data[E][0]==null){continue}n=I[E][1];if(this._plotData[E][1]<0){if(this.varyBarColor&&!this._stack){if(this.useNegativeColors){u.fillStyle=q.next()}else{u.fillStyle=v.next()}}}else{if(this.varyBarColor&&!this._stack){u.fillStyle=v.next()}else{u.fillStyle=o}}if(this.fill){if(this._plotData[E][1]>=0){s=I[E][0]-L;F=this.barWidth;D=[L,n-y-r,s,F]}else{s=L-I[E][0];F=this.barWidth;D=[I[E][0],n-y-r,s,F]}this._barPoints.push([[D[0],D[1]+F],[D[0],D[1]],[D[0]+s,D[1]],[D[0]+s,D[1]+F]]);if(p){this.renderer.shadowRenderer.draw(B,D)}var g=u.fillStyle||this.color;this._dataColors.push(g);this.renderer.shapeRenderer.draw(B,D,u)}else{if(E===0){D=[[L,j],[I[E][0],j],[I[E][0],I[E][1]-y-r]]}else{if(E<A-1){D=D.concat([[I[E-1][0],I[E-1][1]-y-r],[I[E][0],I[E][1]+y-r],[I[E][0],I[E][1]-y-r]])}else{D=D.concat([[I[E-1][0],I[E-1][1]-y-r],[I[E][0],I[E][1]+y-r],[I[E][0],m],[L,m]]);if(p){this.renderer.shadowRenderer.draw(B,D)}var g=u.fillStyle||this.color;this._dataColors.push(g);this.renderer.shapeRenderer.draw(B,D,u)}}}}}if(this.highlightColors.length==0){this.highlightColors=c.jqplot.computeHighlightColors(this._dataColors)}else{if(typeof(this.highlightColors)=="string"){this.highlightColors=[];for(var E=0;E<this._dataColors.length;E++){this.highlightColors.push(this.highlightColors)}}}};function b(l,k,h){h=h||{};h.axesDefaults=h.axesDefaults||{};h.grid=h.grid||{};h.legend=h.legend||{};h.seriesDefaults=h.seriesDefaults||{};var g=false;if(h.seriesDefaults.renderer===c.jqplot.PyramidRenderer){g=true}else{if(h.series){for(var j=0;j<h.series.length;j++){if(h.series[j].renderer===c.jqplot.PyramidRenderer){g=true}}}}if(g){h.axesDefaults.renderer=c.jqplot.PyramidAxisRenderer;h.grid.renderer=c.jqplot.PyramidGridRenderer;h.seriesDefaults.pointLabels={show:false}}}function f(){if(this.plugins.pyramidRenderer&&this.plugins.pyramidRenderer.highlightCanvas){this.plugins.pyramidRenderer.highlightCanvas.resetCanvas();this.plugins.pyramidRenderer.highlightCanvas=null}this.plugins.pyramidRenderer={highlightedSeriesIndex:null};this.plugins.pyramidRenderer.highlightCanvas=new c.jqplot.GenericCanvas();this.eventCanvas._elem.before(this.plugins.pyramidRenderer.highlightCanvas.createElement(this._gridPadding,"jqplot-pyramidRenderer-highlight-canvas",this._plotDimensions,this));this.plugins.pyramidRenderer.highlightCanvas.setContext();this.eventCanvas._elem.bind("mouseleave",{plot:this},function(g){d(g.data.plot)})}function a(m,l,j,i){var h=m.series[l];var g=m.plugins.pyramidRenderer.highlightCanvas;g._ctx.clearRect(0,0,g._ctx.canvas.width,g._ctx.canvas.height);h._highlightedPoint=j;m.plugins.pyramidRenderer.highlightedSeriesIndex=l;var k={fillStyle:h.highlightColors[j],fillRect:false};h.renderer.shapeRenderer.draw(g._ctx,i,k);if(h.synchronizeHighlight!==false&&m.series.length>=h.synchronizeHighlight&&h.synchronizeHighlight!==l){h=m.series[h.synchronizeHighlight];k={fillStyle:h.highlightColors[j],fillRect:false};h.renderer.shapeRenderer.draw(g._ctx,h._barPoints[j],k)}g=null}function d(j){var g=j.plugins.pyramidRenderer.highlightCanvas;g._ctx.clearRect(0,0,g._ctx.canvas.width,g._ctx.canvas.height);for(var h=0;h<j.series.length;h++){j.series[h]._highlightedPoint=null}j.plugins.pyramidRenderer.highlightedSeriesIndex=null;j.target.trigger("jqplotDataUnhighlight");g=null}function e(k,j,n,m,l){if(m){var i=[m.seriesIndex,m.pointIndex,m.data];var h=jQuery.Event("jqplotDataMouseOver");h.pageX=k.pageX;h.pageY=k.pageY;l.target.trigger(h,i);if(l.series[i[0]].highlightMouseOver&&!(i[0]==l.plugins.pyramidRenderer.highlightedSeriesIndex&&i[1]==l.series[i[0]]._highlightedPoint)){var g=jQuery.Event("jqplotDataHighlight");g.which=k.which;g.pageX=k.pageX;g.pageY=k.pageY;l.target.trigger(g,i);a(l,m.seriesIndex,m.pointIndex,m.points)}}else{if(m==null){d(l)}}}c.jqplot.preInitHooks.push(b)})(jQuery);
/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function($) {
    
    /**
     * Class: $.jqplot.Trendline
     * Plugin which will automatically compute and draw trendlines for plotted data.
     */
    $.jqplot.Trendline = function() {
        // Group: Properties
        
        // prop: show
        // Wether or not to show the trend line.
        this.show = $.jqplot.config.enablePlugins;
        // prop: color
        // CSS color spec for the trend line.
        // By default this wil be the same color as the primary line.
        this.color = '#666666';
        // prop: renderer
        // Renderer to use to draw the trend line.
        // The data series that is plotted may not be rendered as a line.
        // Therefore, we use our own line renderer here to draw a trend line.
        this.renderer = new $.jqplot.LineRenderer();
        // prop: rendererOptions
        // Options to pass to the line renderer.
        // By default, markers are not shown on trend lines.
        this.rendererOptions = {marker:{show:false}};
        // prop: label
        // Label for the trend line to use in the legend.
        this.label = '';
        // prop: type
        // Either 'exponential', 'exp', or 'linear'.
        this.type = 'linear';
        // prop: shadow
        // true or false, whether or not to show the shadow.
        this.shadow = true;
        // prop: markerRenderer
        // Renderer to use to draw markers on the line.
        // I think this is wrong.
        this.markerRenderer = {show:false};
        // prop: lineWidth
        // Width of the trend line.
        this.lineWidth = 1.5;
        // prop: shadowAngle
        // Angle of the shadow on the trend line.
        this.shadowAngle = 45;
        // prop: shadowOffset
        // pixel offset for each stroke of the shadow.
        this.shadowOffset = 1.0;
        // prop: shadowAlpha
        // Alpha transparency of the shadow.
        this.shadowAlpha = 0.07;
        // prop: shadowDepth
        // number of strokes to make of the shadow.
        this.shadowDepth = 3;
        this.isTrendline = true;
        
    };
    
    $.jqplot.postSeriesInitHooks.push(parseTrendLineOptions);
    $.jqplot.postDrawSeriesHooks.push(drawTrendline);
    $.jqplot.addLegendRowHooks.push(addTrendlineLegend);
    
    // called witin scope of the legend object
    // current series passed in
    // must return null or an object {label:label, color:color}
    function addTrendlineLegend(series) {
        var ret = null;
        if (series.trendline && series.trendline.show) {
            var lt = series.trendline.label.toString();
            if (lt) {
                ret = {label:lt, color:series.trendline.color};
            }
        }
        return ret;
    }

    // called within scope of a series
    function parseTrendLineOptions (target, data, seriesDefaults, options, plot) {
        if (this._type && (this._type === 'line' || this._type == 'bar')) {
            this.trendline = new $.jqplot.Trendline();
            options = options || {};
            $.extend(true, this.trendline, {color:this.color}, seriesDefaults.trendline, options.trendline);
            this.trendline.renderer.init.call(this.trendline, null);
        }
    }
    
    // called within scope of series object
    function drawTrendline(sctx, options) {
        // if we have options, merge trendline options in with precedence
        options = $.extend(true, {}, this.trendline, options);

        if (this.trendline && options.show) {
            var fit;
            // this.renderer.setGridData.call(this);
            var data = options.data || this.data;
            fit = fitData(data, this.trendline.type);
            var gridData = options.gridData || this.renderer.makeGridData.call(this, fit.data);
            this.trendline.renderer.draw.call(this.trendline, sctx, gridData, {showLine:true, shadow:this.trendline.shadow});
        }
    }
    
    function regression(x, y, typ)  {
        var type = (typ == null) ? 'linear' : typ;
        var N = x.length;
        var slope;
        var intercept;  
        var SX = 0;
        var SY = 0;
        var SXX = 0;
        var SXY = 0;
        var SYY = 0;
        var Y = [];
        var X = [];
    
        if (type == 'linear') {
            X = x;
            Y = y;
        }
        else if (type == 'exp' || type == 'exponential') {
            for ( var i=0; i<y.length; i++) {
                // ignore points <= 0, log undefined.
                if (y[i] <= 0) {
                    N--;
                }
                else {
                    X.push(x[i]);
                    Y.push(Math.log(y[i]));
                }
            }
        }

        for ( var i = 0; i < N; i++) {
            SX = SX + X[i];
            SY = SY + Y[i];
            SXY = SXY + X[i]* Y[i];
            SXX = SXX + X[i]* X[i];
            SYY = SYY + Y[i]* Y[i];
        }

        slope = (N*SXY - SX*SY)/(N*SXX - SX*SX);
        intercept = (SY - slope*SX)/N;

        return [slope, intercept];
    }

    function linearRegression(X,Y) {
        var ret;
        ret = regression(X,Y,'linear');
        return [ret[0],ret[1]];
    }

    function expRegression(X,Y) {
        var ret;
        var x = X;
        var y = Y;
        ret = regression(x, y,'exp');
        var base = Math.exp(ret[0]);
        var coeff = Math.exp(ret[1]);
        return [base, coeff];
    }

    function fitData(data, typ) {
        var type = (typ == null) ?  'linear' : typ;
        var ret;
        var res;
        var x = [];
        var y = [];
        var ypred = [];
        
        for (i=0; i<data.length; i++){
            if (data[i] != null && data[i][0] != null && data[i][1] != null) {
                x.push(data[i][0]);
                y.push(data[i][1]);
            }
        }
        
        if (type == 'linear') {
            ret = linearRegression(x,y);
            for ( var i=0; i<x.length; i++){
                res = ret[0]*x[i] + ret[1];
                ypred.push([x[i], res]);
            }
        }
        else if (type == 'exp' || type == 'exponential') {
            ret = expRegression(x,y);
            for ( var i=0; i<x.length; i++){
                res = ret[1]*Math.pow(ret[0],x[i]);
                ypred.push([x[i], res]);
            }
        }
        return {data: ypred, slope: ret[0], intercept: ret[1]};
    } 

})(jQuery);
(function($) {
    // make sure undefined is undefined
    var undefined;
    var _axisNames = ['yMidAxis', 'xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis'];
    
    /**
     *
     * Hooks: jqPlot Pugin Hooks
     *
     * $.jqplot.postRedrawSeriesHooks - called after series redrawn.                    // customizing  (2012-08-30, Roy Choi)
     * $.jqplot.postRemoveSeriesPointHooks - called after series point removed.         // customizing  (2012-08-30, Roy Choi)
     * $.jqplot.postAppendSeriesPointHooks - called after series point append.          // customizing  (2012-08-30, Roy Choi)
     * $.jqplot.postUpdateSeriesHooks - called after series data update.            // customizing  (2013-02-14, Roy Choi)
     * $.jqplot.postSeriesHighlightHooks - called after series highlight update.            // customizing  (2013-02-28, Roy Choi)
     * $.jqplot.postSeriesUnhighlightHooks - called after series unhighlight update.            // customizing  (2013-02-28, Roy Choi)
     *
     */

    $.jqplot.preRedrawSeriesHooks = [];
    // customizing  (2013-03-14, Roy Choi)
    $.jqplot.postRedrawSeriesHooks = [];
    // customizing  (2012-08-30, Roy Choi)
    $.jqplot.postRemoveSeriesPointHooks = [];
    // customizing  (2012-08-30, Roy Choi)
    $.jqplot.postAppendSeriesPointHooks = [];
    // customizing  (2012-08-30, Roy Choi)
    $.jqplot.postUpdateSeriesHooks = [];
    // customizing  (2013-02-14, Roy Choi)

    $.jqplot.postSeriesHighlightHooks = [];
    // customizing  (2013-02-28, Roy Choi)
    $.jqplot.postSeriesUnhighlightHooks = [];
    // customizing  (2013-02-28, Roy Choi)
    
    $.jqplot.preReinitHooks = [];
    
    function Axis() {};
    
  Axis.prototype.resetDataBounds = function() {
      // Go through all the series attached to this axis and find
      // the min/max bounds for this axis.
      var db = this._dataBounds;
      var nd = [];
        db.min = null;
        db.max = null;
      var l, s, d;
      // check for when to force min 0 on bar series plots.
      var doforce = (this.show) ? true : false;
      for (var i=0; i<this._series.length; i++) {
          s = this._series[i];
          if (s.show || this.scaleToHiddenSeries) {
              d = s._plotData;
              if (s._type === 'line' && s.renderer.bands.show && this.name.charAt(0) !== 'x') {
                  d = [[0, s.renderer.bands._min], [1, s.renderer.bands._max]];
              }

              var minyidx = 1, maxyidx = 1;

              if (s._type != null && s._type == 'ohlc') {
                  minyidx = 3;
                  maxyidx = 2;
              } else if (s.renderer.constructor === $.jqplot.BoxplotRenderer) {
                  minyidx = 1;
                  maxyidx = 5;
              }
              
              if (this.name == 'xaxis' || this.name == 'x2axis') {
                  
                  for (var j=0, l=d.length; j<l; j++) { 
                      if (d[j][0] != null && !isNaN(d[j][0])) {
                          if (d[j][0] < db.min || db.min == null) {
                              db.min = d[j][0];
                          }
                          if (d[j][0] > db.max || db.max == null) {
                              db.max = d[j][0];
                          }
                      } else {
                          nd.push(j);
                      }
                  }
              }              
              else {
                  for (var j=0, l=d.length; j<l; j++) { 
                      if (d[j][minyidx] != null && !isNaN(d[j][minyidx])) {
                          if (d[j][minyidx] < db.min || db.min == null) {
                              db.min = d[j][minyidx];
                          }
                          if (d[j][maxyidx] > db.max || db.max == null) {
                              db.max = d[j][maxyidx];
                          }
                      } else {
                          nd.push(j);
                      }
                  }
              }

              // Hack to not pad out bottom of bar plots unless user has specified a padding.
              // every series will have a chance to set doforce to false.  once it is set to 
              // false, it cannot be reset to true.
              // If any series attached to axis is not a bar, wont force 0.
              if (doforce && s.renderer.constructor !== $.jqplot.BarRenderer) {
                  doforce = false;
              }

              else if (doforce && this._options.hasOwnProperty('forceTickAt0') && this._options.forceTickAt0 == false) {
                  doforce = false;
              }

              else if (doforce && s.renderer.constructor === $.jqplot.BarRenderer) {
                  if (s.barDirection == 'vertical' && this.name != 'xaxis' && this.name != 'x2axis') { 
                      if (this._options.pad != null || this._options.padMin != null) {
                          doforce = false;
                      }
                  }

                  else if (s.barDirection == 'horizontal' && (this.name == 'xaxis' || this.name == 'x2axis')) {
                      if (this._options.pad != null || this._options.padMin != null) {
                          doforce = false;
                      }
                  }

              }
          }
      }

      if (doforce && this.renderer.constructor === $.jqplot.LinearAxisRenderer && db.min >= 0) {
          this.padMin = 1.0;
          this.forceTickAt0 = true;
      }
      
      db = s = l = d = null;
  };
    
    /**
     * Class: Series
     * An individual data series object.  Cannot be instantiated directly, but created
     * by the Plot oject.  Series properties can be set or overriden by the
     * options passed in from the user.
     * - custom options
     *  markerOptions: {
     *      stroke: Boolean
     *  }
     */
    function Series() {
        this.hide = false;
        this.highlight = true;
        this.highlighted = null;
        this.hasNullPoint = false;  // to check series has empty point
        this.breakOnDiff = null;
    }
    
    

    Series.prototype.init = function(index, gridbw, plot) {
        

        // weed out any null values in the data.
        this.index = index;
        this.gridBorderWidth = gridbw;
        var d = this.data;
        var temp = [], i, l;
        
        if (this.renderer !== $.jqplot.BigDataScatterRenderer) {
            for ( i = 0, l = d.length; i < l; i++) {
                if ((d[i] == null || d[i][0] == null || isNaN(d[i][0]) || d[i][1] == null || isNaN(d[i][1])) && !this.hasNullPoint) {
                    this.hasNullPoint = true;
                }
            }
        }
        
        // parse the renderer options and apply default colors if not provided
        // Set color even if not shown, so series don't change colors when other
        // series on plot shown/hidden.
        if (!this.color) {
            this.color = plot.colorGenerator.get(this.index);
        }
        // customizing
        if (this.showMarker && this.markerOptions && !this.markerOptions.strokeStyle) {
            this.markerOptions.strokeStyle = this.getStrokeStyleByColor(this.color);
        }
        if (!this.negativeColor) {
            this.negativeColor = plot.negativeColorGenerator.get(this.index);
        }

        if (!this.fillColor) {
            this.fillColor = this.color;
        }
        if (this.fillAlpha) {
            var comp = $.jqplot.normalize2rgb(this.fillColor);
            var comp = $.jqplot.getColorComponents(comp);
            this.fillColor = 'rgba(' + comp[0] + ',' + comp[1] + ',' + comp[2] + ',' + this.fillAlpha + ')';
        }
        if ($.isFunction(this.renderer)) {
            this.renderer = new this.renderer();
        }
        this.renderer.init.call(this, this.rendererOptions, plot);
        if (this.renderer.constructor !== $.jqplot.BigdataScatterRenderer) {
            this.markerRenderer = new this.markerRenderer();
            
            if (!this.markerOptions.color) {
                this.markerOptions.color = this.color;
            }
            if (this.markerOptions.show == null) {
                this.markerOptions.show = this.showMarker;
            }
            this.showMarker = this.markerOptions.show;
            
            // the markerRenderer is called within its own scope, don't want to overwrite series options!!
            this.markerRenderer.init(this.markerOptions);
        } else {
            if (!this.markerOptions.color) {
                this.markerOptions.color = this.color;
            }
            if (this.markerOptions.show == null) {
                this.markerOptions.show = this.showMarker;
            }
            this.showMarker = this.markerOptions.show;
        }
        
    };

    // customizing (2011-11-02, Roy Choi)
    Series.prototype.getStrokeStyleByColor = function(style) {
        if (style) {
            if (style.indexOf('#') != -1) {
                var r, g, b, h = style;
                h = h.replace('#', '');
                if (h.length == 3) {
                    h = h.charAt(0) + h.charAt(0) + h.charAt(1) + h.charAt(1) + h.charAt(2) + h.charAt(2);
                }
                r = parseInt(h.slice(0, 2), 16) - parseInt('40', 16);
                if (r < 0)
                    r = 0;
                r = r.toString(16);
                g = parseInt(h.slice(2, 4), 16) - parseInt('40', 16);
                if (g < 0)
                    g = 0;
                g = g.toString(16);
                b = parseInt(h.slice(4, 6), 16) - parseInt('40', 16);
                if (b < 0)
                    b = 0;
                b = b.toString(16);
                var hex;
                hex = '#' + (r.length == 1 ? '0' + r : r) + (g.length == 1 ? '0' + g : g) + (b.length == 1 ? '0' + b : b);

                r = g = b = h = null;

                try {
                    return hex;
                } finally {
                    hex = null;
                }
            } else if (style.indexOf('rgb') != -1) {
                // bug fix (2015-05-15, Carrie Bae)
                var r, g, b, pat = /rgba?\( *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *(?:, *[0-9.]*)?\)/;
                var m = style.match(pat);
                var hex = '#';
                for (var i = 1; i < 4; i++) {
                    var temp = ("0" + parseInt(m[i],10).toString(16)).slice(-2);
                    var rgbUnit = parseInt(temp, 16) - parseInt('40', 16);

                    if (rgbUnit < 0)
                        rgbUnit = 0;
                        
                    rgbUnit = rgbUnit.toString(16);
                    hex += (rgbUnit.length == 1 ? '0' + rgbUnit : rgbUnit);
                }
                try {
                    return hex;
                } finally {
                    h = null;
                }
            } else {
                return null;
            }
        } else {
            return null;
        }
    };

    // customizing add new method
    /** removePoint
     *
     */
    Series.prototype.removePoint = function(plot, pointIndex, draw) {
        this.data.splice(pointIndex, 1);

        if (draw) {
            if (plot.options.multiCanvas) {
                this.draw(this.canvas._ctx, {}, plot);
            } else {
                plot.redrawSeries();
            }

            for (var j = 0; j < $.jqplot.postRemoveSeriesPointHooks.length; j++) {
                $.jqplot.postRemoveSeriesPointHooks[j].call(this, pointIndex, plot);
            }
            j = null;
        }
    };

    // customizing add new method
    /** appendPoint
     *
     */
    Series.prototype.appendPoint = function(plot, pointData, draw) {
        this.data.push(pointData);

        if (draw) {
            if (plot.options.multiCanvas) {
                this.draw(this.canvas._ctx, {}, plot);
            } else {
                plot.redrawSeries();
            }
            for (var j = 0; j < $.jqplot.postAppendSeriesPointHooks.length; j++) {
                $.jqplot.postAppendSeriesPointHooks[j].call(this, pointData, plot);
            }
            j = null;
        }
    };

    // customizing add new method
    /** updateData
     *
     */
    Series.prototype.updateData = function(plot, data, draw) {
        this.data = data;

        if (draw) {
            if (plot.options.multiCanvas) {
                this.draw(this.canvas._ctx, {}, plot);
            } else {
                plot.redrawSeries();
            }
            for (var j = 0; j < $.jqplot.postUpdateSeriesHooks.length; j++) {
                $.jqplot.postUpdateSeriesHooks[j].call(this, data, plot);
            }
            j = null;
            //plot.replot({resetAxes:true});
        }
    };

    // toggles series display on plot, e.g. show/hide series
    Series.prototype.toggleDisplay = function(ev, callback) {
        var plot = ev.data.plot;
        var s, speed;

        if (plot.options.multiCanvas) {
            if (ev.data.series) {
                s = ev.data.series;
            } else {
                s = this;
            }

            if (ev.data.speed) {
                speed = ev.data.speed;
            }
            if (speed) {
                // this can be tricky because series may not have a canvas element if replotting.
                if (s.canvas._elem.is(':hidden') || !s.show) {

                    s.canvas._elem.removeClass('jqplot-series-hidden');
                    if (s.shadowCanvas._elem) {
                        s.shadowCanvas._elem.fadeIn(speed);
                    }
                    s.canvas._elem.fadeIn(speed, callback);
                    s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-' + s.index).fadeIn(speed);
                } else {

                    s.canvas._elem.addClass('jqplot-series-hidden');
                    if (s.shadowCanvas._elem) {
                        s.shadowCanvas._elem.fadeOut(speed);
                    }
                    s.canvas._elem.fadeOut(speed, callback);
                    s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-' + s.index).fadeOut(speed);
                }
            } else {
                // this can be tricky because series may not have a canvas element if replotting.
                if (s.canvas._elem.is(':hidden') || !s.show) {

                    s.canvas._elem.removeClass('jqplot-series-hidden');
                    if (s.shadowCanvas._elem) {
                        s.shadowCanvas._elem.show();
                    }
                    s.canvas._elem.show(0, callback);
                    s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-' + s.index).show();
                } else {

                    s.canvas._elem.addClass('jqplot-series-hidden');
                    if (s.shadowCanvas._elem) {
                        s.shadowCanvas._elem.hide();
                    }
                    s.canvas._elem.hide(0, callback);
                    s.canvas._elem.nextAll('.jqplot-point-label.jqplot-series-' + s.index).hide();
                }
            }
        } else {
            if (ev.data.series) {
                s = ev.data.series;
            } else {
                s = this;
            }

            if (ev.data.series && !$.isArray(s) &&  $.inArray(s.index, plot.highlightSeriesIndexes) > -1 && s.hide) {
                plot.moveSeriesToBack(s.index);
            }

            var ctx = this.canvas._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            var series = plot.series;
            var j;
            for (var i = 0, len = series.length; i < len; i++) {
                j = plot.seriesStack[i];
                if (!series[j].hide) {
                    series[j].draw(ctx, {}, plot);
                }
            }

            i = j = len = ctx = series = null;

        }

        plot.target.trigger('jqPlot.seriesVisibleChange', [plot, s]);

        s = null;
    };

  // data - optional data point array to draw using this series renderer
  // gridData - optional grid data point array to draw using this series renderer
  // stackData - array of cumulative data for stacked plots.
  Series.prototype.draw = function(sctx, opts, plot) {
    
      var options = (opts == undefined) ? {} : opts;
      sctx = (sctx == undefined) ? this.canvas._ctx : sctx;
      
      var j, data, gridData;
      
      // hooks get called even if series not shown
      // we don't clear canvas here, it would wipe out all other series as well.
      for (j=0; j<$.jqplot.preDrawSeriesHooks.length; j++) {
          $.jqplot.preDrawSeriesHooks[j].call(this, sctx, options);
      }
      if (this.show) {
            if (this._type === 'line' && !this.renderer.smooth) {
                this.renderer.setNormalGridData.call(this, plot);
            } else {
                this.renderer.setGridData.call(this, plot);
            }
          if (!options.preventJqPlotSeriesDrawTrigger) {
              $(sctx.canvas).trigger('jqplotSeriesDraw', [this.data, this.gridData]);
          }
          data = [];
          if (options.data) {
              data = options.data;
          }
          else if (!this._stack) {
              data = this.data;
          }
          else {
              data = this._plotData;
          }
          
          
          if (this._type === 'line' && !this.renderer.smooth) {
              if (!options.data && !this._stack) {
                gridData = options.gridData || this.gridData;
              } else {
                gridData = options.gridData || this.renderer.makeNormalGridData.call(this, data, plot);
              }
          } else {
              gridData = options.gridData || this.renderer.makeGridData.call(this, data, plot);
              
              if (this._type === 'line' && this.renderer.smooth && this.renderer._smoothedData.length) {
                    gridData = this.renderer._smoothedData;
              }
          }
          
          if (!options.data && !this._stack && this.breakOnDiff !== null && data.length > 0) {
              var startIndex = 0;
              var diffColumnIndex = this.breakOnDiff;
              var currentDiff = data[0][diffColumnIndex];
              
              for (var i = 0, l = data.length; i < l; i++) {
                  if (data[i][diffColumnIndex] !== currentDiff) {
                      currentDiff = data[i][diffColumnIndex];
                      
                      this.renderer.draw.call(this, sctx, gridData.slice(startIndex, i), options, plot);
                      
                      startIndex = i;
                  }
              }
              this.renderer.draw.call(this, sctx, gridData.slice(startIndex), options, plot);
              
          } else {
              this.renderer.draw.call(this, sctx, gridData, options, plot);
          }
      }
      
      for (j=0; j<$.jqplot.postDrawSeriesHooks.length; j++) {
          $.jqplot.postDrawSeriesHooks[j].call(this, sctx, options, plot);
      }
      
      sctx = opts = plot = j = data = gridData = null;

  };

    /**
     * Class: jqPlot
     * Plot object returned by call to $.jqplot.  Handles parsing user options,
     * creating sub objects (Axes, legend, title, series) and rendering the plot.
     */
    function jqPlot() {
        this.seriesCanvas = null;
        this.seriesHighlightCanvas = null;
        this.highlightSeriesIndexes = [];
        
        this.multiCanvasLimit = 50;

        // Group: methods
        //
        // method: init
        // sets the plot target, checks data and applies user
        // options to plot.
        this.init = function(target, data, options) {
            options = options || {};
            for (var i = 0; i < $.jqplot.preInitHooks.length; i++) {
                $.jqplot.preInitHooks[i].call(this, target, data, options);
            }

            for (var i = 0; i < this.preInitHooks.hooks.length; i++) {
                this.preInitHooks.hooks[i].call(this, target, data, options);
            }

            this.targetId = '#' + target;
            this.target = $('#' + target);
            
            this.target.trigger('jqplotPreInit', [this]);

            //////
            // Add a reference to plot
            //////
            if (this._addDomReference) {
                this.target.data('jqplot', this);
            }
            // remove any error class that may be stuck on target.
            this.target.removeClass('jqplot-error');
            if (!this.target.get(0)) {
                throw new Error("No plot target specified");
            }

            // make sure the target is positioned by some means and set css
            if (this.target.css('position') == 'static') {
                this.target.css('position', 'relative');
            }
            if (!this.target.hasClass('jqplot-target')) {
                this.target.addClass('jqplot-target');
            }

            // if no height or width specified, use a default.
            if (!this.target.height()) {
                var h;
                if (options && options.height) {
                    h = parseInt(options.height, 10);
                } else if (this.target.attr('data-height')) {
                    h = parseInt(this.target.attr('data-height'), 10);
                } else if (this.target.css('height')) {
                    ;
                } else {
                    h = parseInt($.jqplot.config.defaultHeight, 10);
                }
                this._height = h;
                this.target.css('height', h + 'px');
            } else {
                this._height = h = this.target.height();
            }
            if (!this.target.width()) {
                var w;
                if (options && options.width) {
                    w = parseInt(options.width, 10);
                } else if (this.target.attr('data-width')) {
                    w = parseInt(this.target.attr('data-width'), 10);
                } else if (this.target.css('width')) {
                    ;
                } else {
                    w = parseInt($.jqplot.config.defaultWidth, 10);
                }
                this._width = w;
                this.target.css('width', w + 'px');
            } else {
                this._width = w = this.target.width();
            }

            for (var i = 0, l = _axisNames.length; i < l; i++) {
                this.axes[_axisNames[i]] = new Axis(_axisNames[i]);
            }

            this._plotDimensions.height = this._height;
            this._plotDimensions.width = this._width;
            this.grid._plotDimensions = this._plotDimensions;
            this.title._plotDimensions = this._plotDimensions;
            this.baseCanvas._plotDimensions = this._plotDimensions;
            this.eventCanvas._plotDimensions = this._plotDimensions;
            this.legend._plotDimensions = this._plotDimensions;
            if (this._height <= 0 || this._width <= 0 || !this._height || !this._width) {
                throw new Error("Canvas dimension not set");
            }

            if (options.dataRenderer && $.isFunction(options.dataRenderer)) {
                if (options.dataRendererOptions) {
                    this.dataRendererOptions = options.dataRendererOptions;
                }
                this.dataRenderer = options.dataRenderer;
                data = this.dataRenderer(data, this, this.dataRendererOptions);
            }

            if (options.noDataIndicator && $.isPlainObject(options.noDataIndicator)) {
                $.extend(true, this.noDataIndicator, options.noDataIndicator);
            }

            if (data == null || $.isArray(data) == false || data.length == 0 || $.isArray(data[0]) == false || data[0].length == 0) {

                if (this.noDataIndicator.show == false) {
                    throw new Error("No data specified");
                } else {
                    // have to be descructive here in order for plot to not try and render series.
                    // This means that $.jqplot() will have to be called again when there is data.
                    //delete options.series;

                    for (var ax in this.noDataIndicator.axes) {
                        for (var prop in this.noDataIndicator.axes[ax]) {
                            this.axes[ax][prop] = this.noDataIndicator.axes[ax][prop];
                        }
                    }

                    this.postDrawHooks.add(function() {
                        var eh = this.eventCanvas.getHeight();
                        var ew = this.eventCanvas.getWidth();
                        var temp = $('<div class="jqplot-noData-container" style="position:absolute;"></div>');
                        this.target.append(temp);
                        temp.height(eh);
                        temp.width(ew);
                        temp.css('top', this.eventCanvas._offsets.top);
                        temp.css('left', this.eventCanvas._offsets.left);

                        var temp2 = $('<div class="jqplot-noData-contents" style="text-align:center; position:relative; margin-left:auto; margin-right:auto;"></div>');
                        temp.append(temp2);
                        temp2.html(this.noDataIndicator.indicator);
                        var th = temp2.height();
                        var tw = temp2.width();
                        temp2.height(th);
                        temp2.width(tw);
                        temp2.css('top', (eh - th) / 2 + 'px');
                    });

                }
            }

            // customizing
            if (options.copyData) {
                // make a copy of the data
                this.data = $.extend(true, [], data);
            } else {
                // use orginal data
                this.data = data;
            }
            
            if (options.defaultGridPadding) {
                $.extend(this._defaultGridPadding, options.defaultGridPadding);
            }

            this.parseOptions(options);

            if (this.textColor) {
                this.target.css('color', this.textColor);
            }
            if (this.fontFamily) {
                this.target.css('font-family', this.fontFamily);
            }
            if (this.fontSize) {
                this.target.css('font-size', this.fontSize);
            }

            this.title.init();
            this.legend.init();
            this._sumy = 0;
            this._sumx = 0;
            this.computePlotData();
            for (var i = 0; i < this.series.length; i++) {
                // set default stacking order for series canvases
                this.seriesStack.push(i);
                this.previousSeriesStack.push(i);
                if(this.options.multiCanvas && this.series[i].shadowCanvas) {
                    this.series[i].shadowCanvas._plotDimensions = this._plotDimensions;
                }
                this.series[i].canvas._plotDimensions = this._plotDimensions;
                for (var j = 0; j < $.jqplot.preSeriesInitHooks.length; j++) {
                    $.jqplot.preSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                for (var j = 0; j < this.preSeriesInitHooks.hooks.length; j++) {
                    this.preSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                // this.computePlotData(this.series[i], i);
                this.series[i]._plotDimensions = this._plotDimensions;
                this.series[i].init(i, this.grid.borderWidth, this);
                for (var j = 0; j < $.jqplot.postSeriesInitHooks.length; j++) {
                    $.jqplot.postSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                for (var j = 0; j < this.postSeriesInitHooks.hooks.length; j++) {
                    this.postSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                this._sumy += this.series[i]._sumy;
                this._sumx += this.series[i]._sumx;
            }

            var name, axis;
            for (var i = 0, l = _axisNames.length; i < l; i++) {
                name = _axisNames[i];
                axis = this.axes[name];
                axis._plotDimensions = this._plotDimensions;
                axis.init();
                if (this.axes[name].borderColor == null) {
                    if (name.charAt(0) !== 'x' && axis.useSeriesColor === true && axis.show) {
                        axis.borderColor = axis._series[0].color;
                    } else {
                        axis.borderColor = this.grid.borderColor;
                    }
                }
            }

            if (this.sortData) {
                sortData(this.series);
            }
            this.grid.init();
            this.grid._axes = this.axes;

            this.legend._series = this.series;

            for (var i = 0; i < $.jqplot.postInitHooks.length; i++) {
                $.jqplot.postInitHooks[i].call(this, target, this.data, options);
            }

            for (var i = 0; i < this.postInitHooks.hooks.length; i++) {
                this.postInitHooks.hooks[i].call(this, target, this.data, options);
            }
        };

    // method: reInitialize
    // reinitialize plot for replotting.
    // not called directly.
    this.reInitialize = function (data, opts) {
        // Plot should be visible and have a height and width.
        // If plot doesn't have height and width for some
        // reason, set it by other means.  Plot must not have
        // a display:none attribute, however.

        for (var i=0; i<$.jqplot.preReinitHooks.length; i++) {
            $.jqplot.preReinitHooks[i].call(this, this.targetId.substr(1), data, opts);
        }

        var options = $.extend(true, {}, this.options, opts);

        var target = this.targetId.substr(1);
        var tdata = (data == null) ? this.data : data;

        for (var i=0; i<$.jqplot.preInitHooks.length; i++) {
            $.jqplot.preInitHooks[i].call(this, target, tdata, options);
        }

        for (var i=0; i<this.preInitHooks.hooks.length; i++) {
            this.preInitHooks.hooks[i].call(this, target, tdata, options);
        }
        
        this._height = this.target.height();
        this._width = this.target.width();
        
        if (this._height <=0 || this._width <=0 || !this._height || !this._width) {
            throw new Error("Target dimension not set");
        }
        
        this._plotDimensions.height = this._height;
        this._plotDimensions.width = this._width;
        this.grid._plotDimensions = this._plotDimensions;
        this.title._plotDimensions = this._plotDimensions;
        this.baseCanvas._plotDimensions = this._plotDimensions;
        this.eventCanvas._plotDimensions = this._plotDimensions;
        this.legend._plotDimensions = this._plotDimensions;

        var name,
            t, 
            j, 
            axis;

        for (var i=0, l=_axisNames.length; i<l; i++) {
            name = _axisNames[i];
            axis = this.axes[name];

            // Memory Leaks patch : clear ticks elements
            t = axis._ticks;
            for (var j = 0, tlen = t.length; j < tlen; j++) {
              var el = t[j]._elem;
              if (el) {
                // if canvas renderer
                if ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) {
                  window.G_vmlCanvasManager.uninitElement(el.get(0));
                }
                el.emptyForce();
                el = null;
                t._elem = null;
              }
            }
            t = null;

            delete axis.ticks;
            delete axis._ticks;
            this.axes[name] = new Axis(name);
            this.axes[name]._plotWidth = this._width;
            this.axes[name]._plotHeight = this._height;
        }
        
        if (data) {
            if (options.dataRenderer && $.isFunction(options.dataRenderer)) {
                if (options.dataRendererOptions) {
                    this.dataRendererOptions = options.dataRendererOptions;
                }
                this.dataRenderer = options.dataRenderer;
                data = this.dataRenderer(data, this, this.dataRendererOptions);
            }
            
            // make a copy of the data
            this.data = $.extend(true, [], data);
        }

        if (opts) {
            this.parseOptions(options);
        }
        
        this.title._plotWidth = this._width;
        
        if (this.textColor) {
            this.target.css('color', this.textColor);
        }
        if (this.fontFamily) {
            this.target.css('font-family', this.fontFamily);
        }
        if (this.fontSize) {
            this.target.css('font-size', this.fontSize);
        }

        this.title.init();
        this.legend.init();
        this._sumy = 0;
        this._sumx = 0;

        this.seriesStack = [];
        this.previousSeriesStack = [];

        this.computePlotData();
        for (var i=0, l=this.series.length; i<l; i++) {
            // set default stacking order for series canvases
            this.seriesStack.push(i);
            this.previousSeriesStack.push(i);
            this.series[i].shadowCanvas._plotDimensions = this._plotDimensions;
            this.series[i].canvas._plotDimensions = this._plotDimensions;
            for (var j=0; j<$.jqplot.preSeriesInitHooks.length; j++) {
                $.jqplot.preSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
            }
            for (var j=0; j<this.preSeriesInitHooks.hooks.length; j++) {
                this.preSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
            }
            // this.populatePlotData(this.series[i], i);
            this.series[i]._plotDimensions = this._plotDimensions;
            this.series[i].init(i, this.grid.borderWidth, this);
            for (var j=0; j<$.jqplot.postSeriesInitHooks.length; j++) {
                $.jqplot.postSeriesInitHooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
            }
            for (var j=0; j<this.postSeriesInitHooks.hooks.length; j++) {
                this.postSeriesInitHooks.hooks[j].call(this.series[i], target, this.data, this.options.seriesDefaults, this.options.series[i], this);
            }
            this._sumy += this.series[i]._sumy;
            this._sumx += this.series[i]._sumx;
        }

        for (var i=0, l=_axisNames.length; i<l; i++) {
            name = _axisNames[i];
            axis = this.axes[name];

            axis._plotDimensions = this._plotDimensions;
            axis.init();
            if (axis.borderColor == null) {
                if (name.charAt(0) !== 'x' && axis.useSeriesColor === true && axis.show) {
                    axis.borderColor = axis._series[0].color;
                }
                else {
                    axis.borderColor = this.grid.borderColor;
                }
            }
        }
        
        if (this.sortData) {
            sortData(this.series);
        }
        this.grid.init();
        this.grid._axes = this.axes;
        
        this.legend._series = this.series;

        for (var i=0, l=$.jqplot.postInitHooks.length; i<l; i++) {
            $.jqplot.postInitHooks[i].call(this, target, this.data, options);
        }

        for (var i=0, l=this.postInitHooks.hooks.length; i<l; i++) {
            this.postInitHooks.hooks[i].call(this, target, this.data, options);
        }
    };

    // method: replot
    // Does a reinitialization of the plot followed by
    // a redraw.  Method could be used to interactively
    // change plot characteristics and then replot.
    //
    // Parameters:
    // options - Options used for replotting.
    //
    // Properties:
    // clear - false to not clear (empty) the plot container before replotting (default: true).
    // resetAxes - true to reset all axes min, max, numberTicks and tickInterval setting so axes will rescale themselves.
    //             optionally pass in list of axes to reset (e.g. ['xaxis', 'y2axis']) (default: false).
    this.replot = function(options) {
        var opts =  options || {};
        var data = opts.data || null;
        var clear = (opts.clear === false) ? false : true;
        var resetAxes = opts.resetAxes || false;
        delete opts.data;
        delete opts.clear;
        delete opts.resetAxes;

        this.target.trigger('jqplotPreReplot');
        
        if (clear) {
            this.destroy();
        }
        // if have data or other options, full reinit.
        // otherwise, quickinit.
        if (data || !$.isEmptyObject(opts)) {
            this.reInitialize(data, opts);
        }
        else {
            this.quickInit();
        }

        if (resetAxes) {
            this.resetAxesScale(resetAxes, typeof resetAxes === 'object' ? resetAxes : {});
        }
        this.draw();
        this.target.trigger('jqplotPostReplot');
    };

    // sort the series data in increasing order.
    function sortData(series) {
        var d, sd, pd, ppd, ret;
        for (var i=0; i<series.length; i++) {
            var check;
            var bat = [series[i].data, series[i]._stackData, series[i]._plotData, series[i]._prevPlotData];
            for (var n=0; n<4; n++) {
                check = true;
                d = bat[n];
                if (series[i]._stackAxis == 'x') {
                    for (var j = 0; j < d.length; j++) {
                        if (typeof(d[j][1]) != "number") {
                            check = false;
                            break;
                        }
                    }
                    if (check) {
                        d.sort(function(a,b) { return a[1] - b[1]; });
                    }
                }
                else {
                    for (var j = 0; j < d.length; j++) {
                        if (typeof(d[j][0]) != "number") {
                            check = false;
                            break;
                        }
                    }
                    if (check) {
                        d.sort(function(a,b) { return a[0] - b[0]; });
                    }
                }
            }
           
        }
    }
    
    // populate the _stackData and _plotData arrays for the plot and the series.
    this.populatePlotData = function(series, index) {
        // if a stacked chart, compute the stacked data
        this._plotData = [];
        this._stackData = [];
        series._stackData = [];
        series._plotData = [];
        series._sumy = 0;
        series._sumx = 0;
        //var plotValues = {x:[], y:[]};
        if (this.stackSeries && !series.disableStack) {
            series._stack = true;
            var sidx = series._stackAxis == 'x' ? 0 : 1;
            var idx = sidx ? 0 : 1;
            // push the current data into stackData
            //this._stackData.push(this.series[i].data);
            var temp = $.extend(true, [], series.data);
            // create the data that will be plotted for this series
            var plotdata = $.extend(true, [], series.data);
            // for first series, nothing to add to stackData.
            for (var j=0; j<index; j++) {
                var cd = this.series[j].data;
                for (var k=0; k<cd.length; k++) {
                    temp[k][0] += cd[k][0];
                    temp[k][1] += cd[k][1];
                    // only need to sum up the stack axis column of data
                    plotdata[k][sidx] += cd[k][sidx];
                }
            }
            /*for (var i=0; i<plotdata.length; i++) {
                plotValues.x.push(plotdata[i][0]);
                plotValues.y.push(plotdata[i][1]);
            }*/
            this._plotData.push(plotdata);
            this._stackData.push(temp);
            series._stackData = temp;
            series._plotData = plotdata;
            //series._plotValues = plotValues;
            
            cd = j = sidx = idx = temp = plotdata = null;
        }
        else {
           /* for (var i=0; i<series.data.length; i++) {
                plotValues.x.push(series.data[i][0]);
                plotValues.y.push(series.data[i][1]);
                
                series._sumy += series.data[i][1];
                series._sumx += series.data[i][0];
            }*/
            if (series.renderer.constructor == $.jqplot.MekkoRenderer) {
                series._sumy += series.data[i][1];
            series._sumx += series.data[i][0];
            }
            this._stackData.push(series.data);
            this.series[index]._stackData = series.data;
            this._plotData.push(series.data);
            series._plotData = series.data;
            //series._plotValues = plotValues;
        }
        if (index>0) {
            series._prevPlotData = this.series[index-1]._plotData;
        }
        /*series._sumy = 0;
        series._sumx = 0;
        for (i=series.data.length-1; i>-1; i--) {
            series._sumy += series.data[i][1];
            series._sumx += series.data[i][0];
        }*/
        i = null;
        plotValues = null;
    };
    
      this.computePlotData = function() {
          this._plotData = [];
          this._stackData = [];
          var series,
              index,
              l;
    
    
          for (index=0, l=this.series.length; index<l; index++) {
              series = this.series[index];
              this._plotData.push([]);
              this._stackData.push([]);
              var cd = series.data;
              var plotValues = {x:[], y:[]};
    
              if (this.stackSeries && !series.disableStack) {
                      this._plotData[index] = $.extend(true, [], cd);
                      this._stackData[index] = $.extend(true, [], cd);
                      series._plotData = this._plotData[index];
                      series._stackData = this._stackData[index];
                      
                  series._stack = true;
                  ///////////////////////////
                  // have to check for nulls
                  ///////////////////////////
                  var sidx = (series._stackAxis === 'x') ? 0 : 1;
    
                  for (var k=0, cdl=cd.length; k<cdl; k++) {
                      var temp = cd[k][sidx];
                      if (temp == null) {
                          temp = 0;
                      }
                      this._plotData[index][k][sidx] = temp;
                      this._stackData[index][k][sidx] = temp;
    
                      if (index > 0) {
                          for (var j=index; j--;) {
                              var prevval = this._plotData[j][k][sidx];
                              // only need to sum up the stack axis column of data
                              // and only sum if it is of same sign.
                              // if previous series isn't same sign, keep looking
                              // at earlier series untill we find one of same sign.
                              if (temp * prevval >= 0) {
                                  this._plotData[index][k][sidx] += prevval;
                                  this._stackData[index][k][sidx] += prevval;
                                  break;
                              } 
                          }
                      }
                  }
    
              }
              else {
                      this._plotData[index] = cd;
                      this._stackData[index] = cd;
                      series._plotData = this._plotData[index];
                      series._stackData = this._stackData[index];
                      
                  /*for (var i=0; i<series.data.length; i++) {
                      plotValues.x.push(series.data[i][0]);
                      plotValues.y.push(series.data[i][1]);
                  }*/
                  this._stackData.push(series.data);
                  this.series[index]._stackData = series.data;
                  this._plotData.push(series.data);
                  series._plotData = series.data;
                  //series._plotValues = plotValues;
              }
              if (index>0) {
                  series._prevPlotData = this.series[index-1]._plotData;
              }
              series._sumy = 0;
              series._sumx = 0;
              /*for (i=series.data.length-1; i>-1; i--) {
                  series._sumy += series.data[i][1];
                  series._sumx += series.data[i][0];
              }*/
          }
      };
      
        var normalizeData = function(data, dir, start) {
            // return data as an array of point arrays,
            // in form [[x1,y1...], [x2,y2...], ...]
            var temp = [];
            var i, l;
            dir = dir || 'vertical';
            if (!$.isArray(data[0])) {
                // we have a series of scalars.  One line with just y values.
                // turn the scalar list of data into a data array of form:
                // [[1, data[0]], [2, data[1]], ...]
                for ( i = 0, l = data.length; i < l; i++) {
                    if (dir == 'vertical') {
                        temp.push([start + i, data[i]]);
                    } else {
                        temp.push([data[i], start + i]);
                    }
                }
            } else {
                // we have a properly formatted data series, copy it.
                $.extend(true, temp, data);
            }
            return temp;
        };

        this.parseOptions = function(options) {
            for (var i = 0; i < this.preParseOptionsHooks.hooks.length; i++) {
                this.preParseOptionsHooks.hooks[i].call(this, options);
            }
            for (var i = 0; i < $.jqplot.preParseOptionsHooks.length; i++) {
                $.jqplot.preParseOptionsHooks[i].call(this, options);
            }
            this.options = $.extend(true, {}, this.defaults, options);
            
            // customizing
            if (!this.options.multiCanvas || this.data.length > this.multiCanvasLimit) {
                this.seriesCanvas = new $.jqplot.GenericCanvas();
                this.seriesHighlightCanvas = new $.jqplot.GenericCanvas();
                
                this.options.multiCanvas = false;
            }
            
            var opts = this.options;
            this.animate = opts.animate;
            this.animateReplot = opts.animateReplot;
            this.stackSeries = opts.stackSeries;
            if ($.isPlainObject(opts.fillBetween)) {

                var temp = ['series1', 'series2', 'color', 'baseSeries', 'fill'], tempi;

                for (var i = 0, l = temp.length; i < l; i++) {
                    tempi = temp[i];
                    if (opts.fillBetween[tempi] != null) {
                        this.fillBetween[tempi] = opts.fillBetween[tempi];
                    }
                }
            }

            if (opts.seriesColors) {
                this.seriesColors = opts.seriesColors;
            }
            if (opts.negativeSeriesColors) {
                this.negativeSeriesColors = opts.negativeSeriesColors;
            }
            if (opts.captureRightClick) {
                this.captureRightClick = opts.captureRightClick;
            }
            this.defaultAxisStart = (options && options.defaultAxisStart != null) ? options.defaultAxisStart : this.defaultAxisStart;
            this.colorGenerator.setColors(this.seriesColors);
            this.negativeColorGenerator.setColors(this.negativeSeriesColors);
            // var cg = new this.colorGenerator(this.seriesColors);
            // var ncg = new this.colorGenerator(this.negativeSeriesColors);
            // this._gridPadding = this.options.gridPadding;
            $.extend(true, this._gridPadding, opts.gridPadding);
            this.sortData = (opts.sortData != null) ? opts.sortData : this.sortData;
            for (var i = 0; i < 12; i++) {
                var n = _axisNames[i];
                var axis = this.axes[n];
                axis._options = $.extend(true, {}, opts.axesDefaults, opts.axes[n]);
                $.extend(true, axis, opts.axesDefaults, opts.axes[n]);
                axis._plotWidth = this._width;
                axis._plotHeight = this._height;
            }
            // if (this.data.length == 0) {
            //     this.data = [];
            //     for (var i=0; i<this.options.series.length; i++) {
            //         this.data.push(this.options.series.data);
            //     }
            // }
            
            var colorIndex = 0;
            this.series = [];
            for (var i = 0; i < this.data.length; i++) {
                var sopts = $.extend(true, {
                    index : i
                }, {
                    seriesColors : this.seriesColors,
                    negativeSeriesColors : this.negativeSeriesColors
                }, this.options.seriesDefaults, this.options.series[i], {
                    rendererOptions : {
                        animation : {
                            show : this.animate
                        }
                    }
                });
                // customizing (2013-02-12, Roy Choi)
                var tempGenericCanvas;
                if (!this.options.multiCanvas) {
                    tempGenericCanvas = $.jqplot.GenericCanvas;
                    $.jqplot.GenericCanvas = function() {
                        return null;
                    };
                }
                // pass in options in case something needs set prior to initialization.
                var temp = new Series(sopts);
                // customizing (2013-02-12, Roy Choi)
                if (!this.options.multiCanvas) {
                    $.jqplot.GenericCanvas = tempGenericCanvas;
                    temp.canvas = this.seriesCanvas;
                }
                for (var j = 0; j < $.jqplot.preParseSeriesOptionsHooks.length; j++) {
                    $.jqplot.preParseSeriesOptionsHooks[j].call(temp, this.options.seriesDefaults, this.options.series[i]);
                }
                for (var j = 0; j < this.preParseSeriesOptionsHooks.hooks.length; j++) {
                    this.preParseSeriesOptionsHooks.hooks[j].call(temp, this.options.seriesDefaults, this.options.series[i]);
                }
                // Now go back and apply the options to the series.  Really should just do this during initializaiton, but don't want to
                // mess up preParseSeriesOptionsHooks at this point.
                $.extend(true, temp, sopts);
                var dir = 'vertical';
                if (temp.renderer === $.jqplot.BarRenderer && temp.rendererOptions && temp.rendererOptions.barDirection == 'horizontal') {
                    dir = 'horizontal';
                    temp._stackAxis = 'x';
                    temp._primaryAxis = '_yaxis';
                }
                // enhancement (2011-10-24, Roy Choi)
                temp.data = ($.isArray(this.data[i][0])) ? this.data[i] : normalizeData(this.data[i], dir, this.defaultAxisStart);
                //temp.data = normalizeData(this.data[i], dir, this.defaultAxisStart);
                switch (temp.xaxis) {
                    case 'xaxis':
                        temp._xaxis = this.axes.xaxis;
                        break;
                    case 'x2axis':
                        temp._xaxis = this.axes.x2axis;
                        break;
                    default:
                        break;
                }
                temp._yaxis = this.axes[temp.yaxis];
                temp._xaxis._series.push(temp);
                temp._yaxis._series.push(temp);
                if (temp.show) {
                    temp._xaxis.show = true;
                    temp._yaxis.show = true;
                } else {
                    if (temp._xaxis.scaleToHiddenSeries) {
                        temp._xaxis.show = true;
                    }
                    if (temp._yaxis.scaleToHiddenSeries) {
                        temp._yaxis.show = true;
                    }
                }

                // // parse the renderer options and apply default colors if not provided
                // if (!temp.color && temp.show != false) {
                //     temp.color = cg.next();
                //     colorIndex = cg.getIndex() - 1;;
                // }
                // if (!temp.negativeColor && temp.show != false) {
                //     temp.negativeColor = ncg.get(colorIndex);
                //     ncg.setIndex(colorIndex);
                // }
                if (!temp.label) {
                    temp.label = 'Series ' + (i + 1).toString();
                }
                // temp.rendererOptions.show = temp.show;
                // $.extend(true, temp.renderer, {color:this.seriesColors[i]}, this.rendererOptions);
                this.series.push(temp);
                for (var j = 0; j < $.jqplot.postParseSeriesOptionsHooks.length; j++) {
                    $.jqplot.postParseSeriesOptionsHooks[j].call(this.series[i], this.options.seriesDefaults, this.options.series[i]);
                }
                for (var j = 0; j < this.postParseSeriesOptionsHooks.hooks.length; j++) {
                    this.postParseSeriesOptionsHooks.hooks[j].call(this.series[i], this.options.seriesDefaults, this.options.series[i]);
                }
            }

            // copy the grid and title options into this object.
            $.extend(true, this.grid, this.options.grid);
            // if axis border properties aren't set, set default.
            for (var i = 0, l = _axisNames.length; i < l; i++) {
                var n = _axisNames[i];
                var axis = this.axes[n];
                if (axis.borderWidth == null) {
                    axis.borderWidth = this.grid.borderWidth;
                }
            }

            if ( typeof this.options.title == 'string') {
                this.title.text = this.options.title;
            } else if ( typeof this.options.title == 'object') {
                $.extend(true, this.title, this.options.title);
            }
            this.title._plotWidth = this._width;
            this.legend.setOptions(this.options.legend);

            for (var i = 0; i < $.jqplot.postParseOptionsHooks.length; i++) {
                $.jqplot.postParseOptionsHooks[i].call(this, options);
            }
            for (var i = 0; i < this.postParseOptionsHooks.hooks.length; i++) {
                this.postParseOptionsHooks.hooks[i].call(this, options);
            }
            
            
        };

        // method: draw
        // Draws all elements of the plot into the container.
        // Does not clear the container before drawing.
        this.draw = function() {
            if (this.drawIfHidden || this.target.is(':visible')) {
                this.target.trigger('jqplotPreDraw');
                var i, j, l, tempseries;
                for ( i = 0, l = $.jqplot.preDrawHooks.length; i < l; i++) {
                    $.jqplot.preDrawHooks[i].call(this);
                }
                for ( i = 0, l = this.preDrawHooks.hooks.length; i < l; i++) {
                    this.preDrawHooks.hooks[i].apply(this, this.preDrawSeriesHooks.args[i]);
                }
                // create an underlying canvas to be used for special features.
                this.target.append(this.baseCanvas.createElement({
                    left : 0,
                    right : 0,
                    top : 0,
                    bottom : 0
                }, 'jqplot-base-canvas', null, this));
                this.baseCanvas.setContext();
                this.target.append(this.title.draw());
                this.title.pack({
                    top : 0,
                    left : 0
                });

                // make room  for the legend between the grid and the edge.
                // pass a dummy offsets object and a reference to the plot.
                var legendElem = this.legend.draw({}, this);
                var legendResizeHandle;

                var gridPadding = {
                    top : 0,
                    left : 0,
                    bottom : 0,
                    right : 0
                };

                if ((this.legend.placement == "outside" || this.legend.placement == "outsideGrid") && this.legend.show) {
                    // temporarily append the legend to get dimensions
                    this.target.append(legendElem);
                    switch (this.legend.location) {
                        case 'n':
                            gridPadding.top += this.legend.getHeight() + this._defaultGridPadding.top;
                            legendResizeHandle = 's';
                            break;
                        case 's':
                            gridPadding.bottom += this.legend.getHeight();
                            legendResizeHandle = 'n';
                            break;
                        case 'ne':
                        case 'e':
                        case 'se':
                            gridPadding.right += this.legend.getWidth();
                            legendResizeHandle = 'w';
                            break;
                        case 'nw':
                        case 'w':
                        case 'sw':
                            gridPadding.left += this.legend.getWidth();
                            legendResizeHandle = 'e';
                            break;
                        default:
                            // same as 'ne'
                            gridPadding.right += this.legend.getWidth();
                            legendResizeHandle = 'w';
                            break;
                    }
                    legendElem = legendElem.detach();
                }

                var ax = this.axes;
                var name;
                // draw the yMidAxis first, so xaxis of pyramid chart can adjust itself if needed.
                for ( i = 0; i < 12; i++) {
                    name = _axisNames[i];
                    this.target.append(ax[name].draw(this.baseCanvas._ctx, this));
                    ax[name].set();
                }
                if (ax.yaxis.show) {
                    gridPadding.left += ax.yaxis.getWidth();
                }
                var ra = ['y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis'];
                var rapad = [0, 0, 0, 0, 0, 0, 0, 0];
                var gpr = 0;
                var n;
                for ( n = 0; n < 8; n++) {
                    if (ax[ra[n]].show) {
                        gpr += ax[ra[n]].getWidth();
                        rapad[n] = gpr;
                    }
                }
                gridPadding.right += gpr;
                if (ax.x2axis.show) {
                    gridPadding.top += ax.x2axis.getHeight();
                }
                if (this.title.show) {
                    gridPadding.top += this.title.getHeight();
                }
                if (ax.xaxis.show) {
                    gridPadding.bottom += ax.xaxis.getHeight();
                }
                
                // custom
                if (this.options.customAxes && $.isPlainObject(this.options.customAxes)) {
                    var customAxesPaddingTop = 0;
                    var customAxesPaddingBottom = 0;
                    $.each(this.options.customAxes, function(key, ca) {
                        if (ca.location === 'top' && customAxesPaddingTop < $.isNumeric(ca.padding) ? ca.padding : 0) {
                            customAxesPaddingTop = ca.padding;
                        } else if (ca.location === 'bottom' && customAxesPaddingBottom < $.isNumeric(ca.padding) ? ca.padding : 0) {
                            customAxesPaddingBottom = ca.padding;
                        }
                    });
                    
                    if (customAxesPaddingTop) {
                        gridPadding.top += customAxesPaddingTop;
                    }
                    if (customAxesPaddingBottom) {
                        gridPadding.bottom += customAxesPaddingBottom;
                    }
                }

                // end of gridPadding adjustments.

                // if user passed in gridDimensions option, check against calculated gridPadding
                if (this.options.gridDimensions && $.isPlainObject(this.options.gridDimensions)) {
                    var gdw = parseInt(this.options.gridDimensions.width, 10) || 0;
                    var gdh = parseInt(this.options.gridDimensions.height, 10) || 0;
                    var widthAdj = (this._width - gridPadding.left - gridPadding.right - gdw) / 2;
                    var heightAdj = (this._height - gridPadding.top - gridPadding.bottom - gdh) / 2;

                    if (heightAdj >= 0 && widthAdj >= 0) {
                        gridPadding.top += heightAdj;
                        gridPadding.bottom += heightAdj;
                        gridPadding.left += widthAdj;
                        gridPadding.right += widthAdj;
                    }
                }
                var arr = ['top', 'bottom', 'left', 'right'];
                for (var n in arr) {
                    //if (/*this._gridPadding[arr[n]] == null &&*/ gridPadding[arr[n]] > 0) {
                        this._gridPadding[arr[n]] = gridPadding[arr[n]];
                    if (this._gridPadding[arr[n]] == null || this._gridPadding[arr[n]] === 0) {
                        this._gridPadding[arr[n]] = this._defaultGridPadding[arr[n]];
                    }
                }

                var legendPadding = this._gridPadding;

                if (this.legend.placement === 'outside' || this.legend.placement === 'outsideGrid') {
                    legendPadding = {
                        top : this.title.getHeight(),
                        left : 0,
                        right : 0,
                        bottom : 0
                    };
                    if (this.legend.location === 's') {
                        legendPadding.left = this._gridPadding.left;
                        legendPadding.right = this._gridPadding.right;
                    }
                }

                ax.xaxis.pack({
                    position : 'absolute',
                    bottom : this._gridPadding.bottom - ax.xaxis.getHeight(),
                    left : 0,
                    width : this._width
                }, {
                    min : this._gridPadding.left,
                    max : this._width - this._gridPadding.right
                });
                ax.yaxis.pack({
                    position : 'absolute',
                    top : 0,
                    left : this._gridPadding.left - ax.yaxis.getWidth(),
                    height : this._height
                }, {
                    min : this._height - this._gridPadding.bottom,
                    max : this._gridPadding.top
                });
                ax.x2axis.pack({
                    position : 'absolute',
                    top : this._gridPadding.top - ax.x2axis.getHeight(),
                    left : 0,
                    width : this._width
                }, {
                    min : this._gridPadding.left,
                    max : this._width - this._gridPadding.right
                });
                for ( i = 8; i > 0; i--) {
                    ax[ra[i - 1]].pack({
                        position : 'absolute',
                        top : 0,
                        right : this._gridPadding.right - rapad[i - 1]
                    }, {
                        min : this._height - this._gridPadding.bottom,
                        max : this._gridPadding.top
                    });
                }
                var ltemp = (this._width - this._gridPadding.left - this._gridPadding.right) / 2.0 + this._gridPadding.left - ax.yMidAxis.getWidth() / 2.0;
                ax.yMidAxis.pack({
                    position : 'absolute',
                    top : 0,
                    left : ltemp,
                    zIndex : 9,
                    textAlign : 'center'
                }, {
                    min : this._height - this._gridPadding.bottom,
                    max : this._gridPadding.top
                });
                
                // customizing 2016-01-11, Roy Choi
                if (this.grid.borderAntiAliasing === false) {
                    this._gridPadding.left += .5;
                    this._gridPadding.right += .5;
                    this._gridPadding.top += .5;
                    this._gridPadding.bottom += .5;
                }
                this.target.append(this.grid.createElement(this._gridPadding, this));
                this.grid.draw();

                var series = this.series;
                var seriesLength = series.length;
                if (this.options.multiCanvas) {
                    // put the shadow canvases behind the series canvases so shadows don't overlap on stacked bars.
                    for ( i = 0, l = seriesLength; i < l; i++) {
                        // draw series in order of stacking.  This affects only
                        // order in which canvases are added to dom.
                        j = this.seriesStack[i];
                        this.target.append(series[j].shadowCanvas.createElement(this._gridPadding, 'jqplot-series-shadowCanvas', this._plotDimensions, this));
                        series[j].shadowCanvas.setContext();
                        series[j].shadowCanvas._elem.data('seriesIndex', j);
                    }

                    for ( i = 0, l = seriesLength; i < l; i++) {
                        // draw series in order of stacking.  This affects only
                        // order in which canvases are added to dom.
                        j = this.seriesStack[i];
                        this.target.append(series[j].canvas.createElement(this._gridPadding, 'jqplot-series-canvas', this._plotDimensions, this));
                        series[j].canvas.setContext();
                        series[j].canvas._elem.data('seriesIndex', j);
                    }
                } else {
                    this.target.append(this.seriesCanvas.createElement(this._gridPadding, 'jqplot-series-canvas', this._plotDimensions, this));
                    this.seriesCanvas.setContext();
                    this.target.append(this.seriesHighlightCanvas.createElement(this._gridPadding, 'jqplot-series-canvas', this._plotDimensions, this));
                    this.seriesHighlightCanvas.setContext();
                }

                // Need to use filled canvas to capture events in IE.
                // Also, canvas seems to block selection of other elements in document on FF.
                this.target.append(this.eventCanvas.createElement(this._gridPadding, 'jqplot-event-canvas', null, this));
                this.eventCanvas.setContext();
                this.eventCanvas._ctx.fillStyle = 'rgba(0,0,0,0)';
                this.eventCanvas._ctx.fillRect(0, 0, this.eventCanvas._ctx.canvas.width, this.eventCanvas._ctx.canvas.height);

                // bind custom event handlers to regular events.
                this.bindCustomEvents();

                // draw legend before series if the series needs to know the legend dimensions.
                if (this.legend.preDraw) {
                    if(this.legend.show) {
                        this.eventCanvas._elem.before(legendElem);
                    }
                    this.legend.pack(legendPadding);
                    if (this.legend._elem) {
                        this.drawSeries({
                            legendInfo : {
                                location : this.legend.location,
                                placement : this.legend.placement,
                                width : this.legend.getWidth(),
                                height : this.legend.getHeight(),
                                xoffset : this.legend.xoffset,
                                yoffset : this.legend.yoffset
                            }
                        });
                    } else {
                        this.drawSeries();
                    }
                } else {// draw series before legend
                    this.drawSeries();
                    if (seriesLength && this.legend.show) {
                        $(series[seriesLength - 1].canvas._elem).after(legendElem);
                    }
                    this.legend.pack(legendPadding);
                }
                
                if (this.legend.show) {
                    var self = this;
                    var location = this.legend.location.charAt(this.legend.location.length - 1);
                    var maxOptions;
                    switch (location) {
                        case 's':
                        case 'n':
                            maxOptions = {
                                maxWidth: null,
                                minWidth: null,
                                maxHeight: this.target.height() * .8,
                                minHeight: 50
                            };
                            break;
                        case 'e':
                        case 'w':
                        default:
                            maxOptions = {
                                maxWidth: this.target.width() * .8,
                                minWidth: 100,
                                maxHeight: null,
                                minHeight: null
                            };
                            break;
                    }
                    legendElem.resizable($.extend(true, {}, {
                        containment: 'parent',
                        handles: legendResizeHandle,
                        stop: function(ev) {
                            var width, height;
                            switch(self.legend.location.charAt(self.legend.location.length - 1)) {
                                case 's':
                                case 'n':
                                    width = 0;
                                    height = $(this).height();
                                    self.options.legend._width = width;
                                    self.options.legend._height = height;
                                    self.legend._width = width;
                                    self.legend._height = height;
                                    break;
                                case 'e':
                                case 'w':
                                default:
                                    width = $(this).width();
                                    height = 0;
                                    self.options.legend._height = height;
                                    self.options.legend._width = width;
                                    self.legend._height = height;
                                    self.legend._width = width;
                                    break;
                            }
                            var newAxes = {};
                            
                            if (self.plugins.cursor && self.plugins.cursor._zoom && self.plugins.cursor._zoom.isZoomed) {
                              $.each(self.axes, function(axisName, axis) {
                                if (axis != null && axis._options && axis._options.show !== false && axis.renderer.constructor === $.jqplot.LinearAxisRenderer) {
                                  if (axis.tickInset) {
                                    axis.min = axis.min + axis.tickInset * axis.tickInterval;
                                    axis.max = axis.max - axis.tickInset * axis.tickInterval;
                                  }
                                  axis.ticks = [];
                                  axis._ticks = [];
                                  axis.tickInterval = null;
                                  axis.numberTicks = null;
                                }
                              });
                              self.replot();
                            } else {
                              $.each(self.options.axes, function(axisName, ax) {
                                if (ax == null) return;
                                if (ax.show !== false) {
                                  newAxes[axisName] = {
                                      min: ax.min,
                                      max: ax.max
                                  };
                                } else if (ax.autoscale) {
                                  newAxes[axisName] = true;
                                } else {
                                  newAxes[axisName] = {
                                    min: ax.min,
                                    max: ax.max
                                  };
                                }
                              });
                              
                              self.replot({resetAxes: newAxes});
                            }
                            
                            self.target.trigger('jqplotLegendResize', [width, height]);
                            self = null;
                        }
                    }, maxOptions));
                }

                // register event listeners on the overlay canvas
                for (var i = 0, l = $.jqplot.eventListenerHooks.length; i < l; i++) {
                    // in the handler, this will refer to the eventCanvas dom element.
                    // make sure there are references back into plot objects.
                    this.eventCanvas._elem.bind($.jqplot.eventListenerHooks[i][0], {
                        plot : this
                    }, $.jqplot.eventListenerHooks[i][1]);
                }

                // register event listeners on the overlay canvas
                for (var i = 0, l = this.eventListenerHooks.hooks.length; i < l; i++) {
                    // in the handler, this will refer to the eventCanvas dom element.
                    // make sure there are references back into plot objects.
                    this.eventCanvas._elem.bind(this.eventListenerHooks.hooks[i][0], {
                        plot : this
                    }, this.eventListenerHooks.hooks[i][1]);
                }

                var fb = this.fillBetween;
                if (fb.fill && fb.series1 !== fb.series2 && fb.series1 < seriesLength && fb.series2 < seriesLength && series[fb.series1]._type === 'line' && series[fb.series2]._type === 'line') {
                    this.doFillBetweenLines();
                }

                for (var i = 0, l = $.jqplot.postDrawHooks.length; i < l; i++) {
                    $.jqplot.postDrawHooks[i].call(this);
                }

                for (var i = 0, l = this.postDrawHooks.hooks.length; i < l; i++) {
                    this.postDrawHooks.hooks[i].apply(this, this.postDrawHooks.args[i]);
                }

                if (this.target.is(':visible')) {
                    this._drawCount += 1;
                }

                var temps, tempr, sel, _els, multiCanvas = this.options.multiCanvas;
                // customizing
                // ughh.  ideally would hide all series then show them.
                for ( i = 0, l = seriesLength; i < l; i++) {
                    temps = series[i];
                    tempr = temps.renderer;
                    sel = '.jqplot-point-label.jqplot-series-' + i;
                    // customizing
                    if (multiCanvas && tempr.animation && tempr.animation._supported && tempr.animation.show && (this._drawCount < 2 || this.animateReplot)) {
                        _els = this.target.find(sel);
                        _els.stop(true, true).hide();
                        temps.canvas._elem.stop(true, true).hide();
                        //temps.shadowCanvas._elem.stop(true, true).hide();
                        temps.canvas._elem.jqplotEffect('blind', {
                            mode : 'show',
                            direction : tempr.animation.direction
                        }, tempr.animation.speed);
                        //temps.shadowCanvas._elem.jqplotEffect('blind', {mode: 'show', direction: tempr.animation.direction}, tempr.animation.speed);
                        _els.fadeIn(tempr.animation.speed * 0.8);
                    }
                }
                _els = null;

                this.target.trigger('jqplotPostDraw', [this]);
            }
            
        };

        // method: redrawSeries
        // customizing (2012-08-21, Roy Choi)
        // only useable on single canvase mode
        this.redrawSeries = function(axes) {
            for ( i = 0; i < $.jqplot.preRedrawSeriesHooks.length; i++) {
                $.jqplot.preRedrawSeriesHooks[i].call(this);
            }

            this._redrawInset = true;

            axes = axes || {};

            this.resetAxesScale(true);

            var i, j;

            for (var ax in axes) {
                $.extend(true, this.axes[ax], axes[ax]);
                this.axes[ax]._ticks = [];
            }

            if ( typeof axes !== 'object' || Object.keys(axes).length === 0) {
                for (var ax in this.axes) {
                    this.axes[ax]._ticks = [];
                }
            }

            ax = null;

            this._sumy = 0;
            this._sumx = 0;
            for ( i = 0; i < this.series.length; i++) {
                this._sumy += this.series[i]._sumy;
                this._sumx += this.series[i]._sumx;
            }

            if (this.drawIfHidden || this.target.is(':visible')) {
                this.target.children('.jqplot-axis').each(function() {
                    $(this).remove();
                });

                var gridPadding = {
                    top : 0,
                    left : 0,
                    bottom : 0,
                    right : 0
                };

                if ((this.legend.placement == "outside" || this.legend.placement == "outsideGrid") && this.legend.show) {// customizing (2012-05-03, Roy Choi)
                    // temporarily append the legend to get dimensions
                    //this.target.append(legendElem);       // customizing (2012-05-03, Roy Choi)
                    switch (this.legend.location) {
                        case 'n':
                            gridPadding.top += this.legend.getHeight() + 10;
                            // customizing (2012-05-03, Roy Choi)
                            break;
                        case 's':
                            gridPadding.bottom += this.legend.getHeight() + 10;
                            break;
                        case 'ne':
                        case 'e':
                        case 'se':
                            gridPadding.right += this.legend.getWidth() + 10;
                            break;
                        case 'nw':
                        case 'w':
                        case 'sw':
                            gridPadding.left += this.legend.getWidth() + 10;
                            break;
                        default:
                            // same as 'ne'
                            gridPadding.right += this.legend.getWidth() + 10;
                            break;
                    }
                    //legendElem = legendElem.detach();     // customizing (2012-05-03, Roy Choi)
                }

                var ax = this.axes;
                var name;

                // draw the yMidAxis first, so xaxis of pyramid chart can adjust itself if needed.
                for ( i = 0; i < 12; i++) {
                    name = _axisNames[i];
                    this.target.append(ax[name].draw(this.baseCanvas._ctx, this));
                    ax[name].set();
                }
                if (ax.yaxis.show) {
                    gridPadding.left += ax.yaxis.getWidth();
                }
                var ra = ['y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis'];
                var rapad = [0, 0, 0, 0, 0, 0, 0, 0];
                var gpr = 0;
                var n;

                for ( n = 0; n < 8; n++) {
                    if (ax[ra[n]].show) {
                        gpr += ax[ra[n]].getWidth();
                        rapad[n] = gpr;
                    }
                }
                gridPadding.right += gpr;
                if (ax.x2axis.show) {
                    gridPadding.top += ax.x2axis.getHeight();
                }
                if (this.title.show) {
                    gridPadding.top += this.title.getHeight();
                }
                if (ax.xaxis.show) {
                    gridPadding.bottom += ax.xaxis.getHeight();
                }

                // end of gridPadding adjustments.

                // if user passed in gridDimensions option, check against calculated gridPadding
                if (this.options.gridDimensions && $.isPlainObject(this.options.gridDimensions)) {
                    var gdw = parseInt(this.options.gridDimensions.width, 10) || 0;
                    var gdh = parseInt(this.options.gridDimensions.height, 10) || 0;
                    var widthAdj = (this._width - gridPadding.left - gridPadding.right - gdw) / 2;
                    var heightAdj = (this._height - gridPadding.top - gridPadding.bottom - gdh) / 2;

                    if (heightAdj >= 0 && widthAdj >= 0) {
                        gridPadding.top += heightAdj;
                        gridPadding.bottom += heightAdj;
                        gridPadding.left += widthAdj;
                        gridPadding.right += widthAdj;
                    }
                    gdw = gdh = widthAdj = heightAdj = null;
                }
                var arr = ['top', 'bottom', 'left', 'right'];
                for (var n in arr) {
                    // customizing (2012-05-03, Roy Choi) - legend resize
                    this._gridPadding[arr[n]] = gridPadding[arr[n]];
                    if (this._defaultGridPadding[arr[n]] && this._gridPadding[arr[n]] <= 0) {
                        this._gridPadding[arr[n]] = this._defaultGridPadding[arr[n]];
                    }
                }
                n = null;

                ax.xaxis.pack({
                    position : 'absolute',
                    bottom : this._gridPadding.bottom - ax.xaxis.getHeight(),
                    left : 0,
                    width : this._width
                }, {
                    min : this._gridPadding.left,
                    max : this._width - this._gridPadding.right
                });
                ax.yaxis.pack({
                    position : 'absolute',
                    top : 0,
                    left : this._gridPadding.left - ax.yaxis.getWidth(),
                    height : this._height
                }, {
                    min : this._height - this._gridPadding.bottom,
                    max : this._gridPadding.top
                });
                ax.x2axis.pack({
                    position : 'absolute',
                    top : this._gridPadding.top - ax.x2axis.getHeight(),
                    left : 0,
                    width : this._width
                }, {
                    min : this._gridPadding.left,
                    max : this._width - this._gridPadding.right
                });
                for ( i = 8; i > 0; i--) {
                    ax[ra[i - 1]].pack({
                        position : 'absolute',
                        top : 0,
                        right : this._gridPadding.right - rapad[i - 1]
                    }, {
                        min : this._height - this._gridPadding.bottom,
                        max : this._gridPadding.top
                    });
                }
                var ltemp = (this._width - this._gridPadding.left - this._gridPadding.right) / 2.0 + this._gridPadding.left - ax.yMidAxis.getWidth() / 2.0;
                ax.yMidAxis.pack({
                    position : 'absolute',
                    top : 0,
                    left : ltemp,
                    zIndex : 9,
                    textAlign : 'center'
                }, {
                    min : this._height - this._gridPadding.bottom,
                    max : this._gridPadding.top
                });

                this.grid.draw();

                for ( i = 0; i < this.series.length; i++) {
                    // draw series in order of stacking.  This affects only
                    // order in which canvases are added to dom.
                    j = this.seriesStack[i];
                    if (this.series[j].shadowCanvas) {
                        this.target.append(this.series[j].shadowCanvas.createElement(this._gridPadding, 'jqplot-series-shadowCanvas', null, this));
                        this.series[j].shadowCanvas.setContext();
                        this.series[j].shadowCanvas._elem.data('seriesIndex', j);
                    }
                }

                if (this.options.multiCanvas) {
                    /*this.seriesCanvas.setContext();
                     this.seriesHighlightCanvas.setContext();*/
                    for ( i = 0; i < this.series.length; i++) {
                        // draw series in order of stacking.  This affects only
                        // order in which canvases are added to dom.
                        j = this.seriesStack[i];
                        this.target.append(this.series[j].canvas.createElement(this._gridPadding, 'jqplot-series-canvas', null, this));
                        this.series[j].canvas.setContext();
                        this.series[j].canvas._elem.data('seriesIndex', j);
                    }
                } else {
                    this.seriesCanvas.setContext();
                    //this.seriesHighlightCanvas.setContext();
                    for ( i = 0; i < this.series.length; i++) {
                        // draw series in order of stacking.  This affects only
                        // order in which canvases are added to dom.
                        j = this.seriesStack[i];
                        this.series[j].canvas = this.seriesCanvas;
                    }

                    // draw legend before series if the series needs to know the legend dimensions.
                    var ctx = this.seriesCanvas._ctx;
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    ctx = null;
                }

                this.drawSeries();
                if (this.highlightSeriesIndexes.length > 0) {
                    this.moveSeriesToFront(this.highlightSeriesIndexes);
                }

                if (this.target.is(':visible')) {
                    this._drawCount += 1;
                }

                i = j = gridPadding = ax = name = ra = rapad = gpr = n = arr = ltemp = null;
            }

            for ( i = 0; i < $.jqplot.postRedrawSeriesHooks.length; i++) {
                $.jqplot.postRedrawSeriesHooks[i].call(this);
            }

            i = j = null;

            this._redrawInset = false;
        };

        this.bindCustomEvents = function() {
            this.eventCanvas._elem.bind('click', {
                plot : this
            }, this.onClick);
            this.eventCanvas._elem.bind('dblclick', {
                plot : this
            }, this.onDblClick);
            this.eventCanvas._elem.bind('mousedown', {
                plot : this
            }, this.onMouseDown);
            this.eventCanvas._elem.bind('mousemove', {
                plot : this
            }, this.onMouseMove);
            this.eventCanvas._elem.bind('mouseenter', {
                plot : this
            }, this.onMouseEnter);
            this.eventCanvas._elem.bind('mouseleave', {
                plot : this
            }, this.onMouseLeave);
            this.eventCanvas._elem.bind('mouseup', {
                plot : this
            }, this.onMouseUp);
            this.eventCanvas._elem.bind('keydown', {
                plot : this
            }, this.onKeyDown);
            if (this.captureRightClick)
                this.eventCanvas._elem.unbind('contextmenu', this.onRightClick);
                this.eventCanvas._elem.bind('contextmenu', {
                    plot : this
                }, this.onRightClick);
        };

        // customizing for key down (2013-02-20, Roy Choi)
        this.onKeyDown = function(ev) {
            var evt = jQuery.Event('jqplotKeyDown');
            $(this).trigger(evt, [ev.data.plot]);

            evt = null;
        };

        function searchCandidate(array, index, xValue, yValue, thresholdX, thresholdY) {
            var ret = [], down = true, up = true,
                downIndex = index, upIndex = index+1,
                xMin = xValue - thresholdX, xMax = xValue + thresholdX,
                yMin = yValue - thresholdY, yMax = yValue + thresholdY,
                len = array.length, point;
            
            while (down || up) {
                if (down && downIndex >= 0) {
                    point = array[downIndex];
                    if (point[0] !== null && !isNaN(point[0]) && point[0] >= xMin && point[0] <= xMax) {
                        if (point[1] !== null && !isNaN(point[1]) && point[1] >= yMin && point[1] <= yMax) {
                            ret.push(downIndex);
                        }
                        downIndex--;
                    } else {
                        down = false;
                    }
                } else {
                   down = false;
                }
                if (up && upIndex < len) {
                    point = array[upIndex];
                    if (point[0] !== null && !isNaN(point[0]) && point[0] >= xMin && point[0] <= xMax) {
                        if (point[1] !== null && !isNaN(point[1]) && point[1] >= yMin && point[1] <= yMax) {
                            ret.push(upIndex);
                        }
                        upIndex++;
                    } else {
                        up = false;
                    }
                } else {
                   up = false;
                }
            }
            
            return ret;
        }
        
        function binaryIndexOf(array, xValue, yValue, thresholdX, thresholdY) {
            if (array.length === 0) {
                return;
            }
            
            var minIndex = 0,
                maxIndex = array.length - 1,
                currentIndex,
                currentElement,
                nextElement,
                candidates = [];
                
            while (minIndex <= maxIndex) {
                currentIndex = (minIndex + maxIndex) / 2 | 0;
                currentElement = array[currentIndex];
                nextElement = currentIndex === array.length - 1 ? array[currentIndex] : array[currentIndex + 1];
                
                if (currentElement[0] <= xValue && xValue <= nextElement[0]) {
                    return searchCandidate(array, currentIndex, xValue, yValue, thresholdX, thresholdY);
                }
                else if (currentElement[0] < xValue && xValue > nextElement[0]) {
                    minIndex = currentIndex + 1;
                } else {
                    maxIndex = currentIndex - 1;
                }
            }
            
            return candidates;
        }


    this.checkIntersection = function (ev, gridpos, plot) {
        if (plot.plugins.cursor && plot.plugins.cursor._zoom && plot.plugins.cursor._zoom.zooming) {
            return null;
        }
        
        var series = plot.series;
        var i, j, k, l, s, r, x, y, theta, sm, sa, minang, maxang;
        var d0, d, p, pp, points, bw, hp;
        var threshold, t;
        var candidates, sData, thresholdX, thresholdY;
        
        l = plot.seriesStack.length;
        for (k=l-1; k>=0; k--) {
            i = plot.seriesStack[k];
            s = series[i];
            
            if (s.hide || !s.show) {
              continue;
            }
            
            hp = s._highlightThreshold;
            switch (s.renderer.constructor) {
                case $.jqplot.BarRenderer:
                    x = gridpos.x;
                    y = gridpos.y;
                    for (j=0; j<s._barPoints.length; j++) {
                        points = s._barPoints[j];
                        p = s.gridData[j];
                        if (x>points[0][0] && x<points[2][0] && y>points[2][1] && y<points[0][1]) {
                            return {seriesIndex:s.index, pointIndex:j, gridData:p, data:s.data[j], points:s._barPoints[j]};
                        }
                    }
                    break;
                case $.jqplot.PyramidRenderer:
                    x = gridpos.x;
                    y = gridpos.y;
                    for (j=0; j<s._barPoints.length; j++) {
                        points = s._barPoints[j];
                        p = s.gridData[j];
                        if (x > points[0][0] + hp[0][0] && x < points[2][0] + hp[2][0] && y > points[2][1] && y < points[0][1]) {
                            return {seriesIndex:s.index, pointIndex:j, gridData:p, data:s.data[j], points:s._barPoints[j]};
                        }
                    }
                    break;
                
                case $.jqplot.DonutRenderer:
                    sa = s.startAngle/180*Math.PI;
                    x = gridpos.x - s._center[0];
                    y = gridpos.y - s._center[1];
                    r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                    if (x > 0 && -y >= 0) {
                        theta = 2*Math.PI - Math.atan(-y/x);
                    }
                    else if (x > 0 && -y < 0) {
                        theta = -Math.atan(-y/x);
                    }
                    else if (x < 0) {
                        theta = Math.PI - Math.atan(-y/x);
                    }
                    else if (x == 0 && -y > 0) {
                        theta = 3*Math.PI/2;
                    }
                    else if (x == 0 && -y < 0) {
                        theta = Math.PI/2;
                    }
                    else if (x == 0 && y == 0) {
                        theta = 0;
                    }
                    if (sa) {
                        theta -= sa;
                        if (theta < 0) {
                            theta += 2*Math.PI;
                        }
                        else if (theta > 2*Math.PI) {
                            theta -= 2*Math.PI;
                        }
                    }
        
                    sm = s.sliceMargin/180*Math.PI;
                    if (r < s._radius && r > s._innerRadius) {
                        for (j=0; j<s.gridData.length; j++) {
                            minang = (j>0) ? s.gridData[j-1][1]+sm : sm;
                            maxang = s.gridData[j][1];
                            if (theta > minang && theta < maxang) {
                                return {seriesIndex:s.index, pointIndex:j, gridData:[gridpos.x,gridpos.y], data:s.data[j]};
                            }
                        }
                    }
                    break;
                    
                case $.jqplot.PieRenderer:
                    sa = s.startAngle/180*Math.PI;
                    x = gridpos.x - s._center[0];
                    y = gridpos.y - s._center[1];
                    r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                    if (x > 0 && -y >= 0) {
                        theta = 2*Math.PI - Math.atan(-y/x);
                    }
                    else if (x > 0 && -y < 0) {
                        theta = -Math.atan(-y/x);
                    }
                    else if (x < 0) {
                        theta = Math.PI - Math.atan(-y/x);
                    }
                    else if (x == 0 && -y > 0) {
                        theta = 3*Math.PI/2;
                    }
                    else if (x == 0 && -y < 0) {
                        theta = Math.PI/2;
                    }
                    else if (x == 0 && y == 0) {
                        theta = 0;
                    }
                    if (sa) {
                        theta -= sa;
                        if (theta < 0) {
                            theta += 2*Math.PI;
                        }
                        else if (theta > 2*Math.PI) {
                            theta -= 2*Math.PI;
                        }
                    }
        
                    sm = s.sliceMargin/180*Math.PI;
                    if (r < s._radius) {
                        for (j=0; j<s.gridData.length; j++) {
                            minang = (j>0) ? s.gridData[j-1][1]+sm : sm;
                            maxang = s.gridData[j][1];
                            if (theta > minang && theta < maxang) {
                                return {seriesIndex:s.index, pointIndex:j, gridData:[gridpos.x,gridpos.y], data:s.data[j]};
                            }
                        }
                    }
                    break;
                    
                case $.jqplot.BubbleRenderer:
                    x = gridpos.x;
                    y = gridpos.y;
                    var ret = null;
                    
                    if (s.show) {
                        for (var j=0; j<s.gridData.length; j++) {
                            p = s.gridData[j];
                            d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );
                            if (d <= p[2] && (d <= d0 || d0 == null)) {
                               d0 = d;
                               ret = {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                            }
                        }
                        if (ret != null) {
                            return ret;
                        }
                    }
                    break;
                    
                case $.jqplot.FunnelRenderer:
                    x = gridpos.x;
                    y = gridpos.y;
                    var v = s._vertices,
                        vfirst = v[0],
                        vlast = v[v.length-1],
                        lex,
                        rex,
                        cv;

                    // equations of right and left sides, returns x, y values given height of section (y value and 2 points)

                    function findedge (l, p1 , p2) {
                        var m = (p1[1] - p2[1])/(p1[0] - p2[0]);
                        var b = p1[1] - m*p1[0];
                        var y = l + p1[1];
    
                        return [(y - b)/m, y];
                    }

                    // check each section
                    lex = findedge(y, vfirst[0], vlast[3]);
                    rex = findedge(y, vfirst[1], vlast[2]);
                    for (j=0; j<v.length; j++) {
                        cv = v[j];
                        if (y >= cv[0][1] && y <= cv[3][1] && x >= lex[0] && x <= rex[0]) {
                            return {seriesIndex:s.index, pointIndex:j, gridData:null, data:s.data[j]};
                        }
                    }         
                    break;           
                
                case $.jqplot.LineRenderer:
                    x = gridpos.x;
                    y = gridpos.y;
                    r = s.renderer;
                    if (s.show) {
                        if ((s.fill || (s.renderer.bands.show && s.renderer.bands.fill)) && (!plot.plugins.highlighter || !plot.plugins.highlighter.show)) {
                            // first check if it is in bounding box
                            var inside = false;
                            if (x>s._boundingBox[0][0] && x<s._boundingBox[1][0] && y>s._boundingBox[1][1] && y<s._boundingBox[0][1]) { 
                                // now check the crossing number   
                                
                                var numPoints = s._areaPoints.length;
                                var ii;
                                var j = numPoints-1;

                                for(var ii=0; ii < numPoints; ii++) { 
                                    var vertex1 = [s._areaPoints[ii][0], s._areaPoints[ii][1]];
                                    var vertex2 = [s._areaPoints[j][0], s._areaPoints[j][1]];

                                    if (vertex1[1] < y && vertex2[1] >= y || vertex2[1] < y && vertex1[1] >= y)     {
                                        if (vertex1[0] + (y - vertex1[1]) / (vertex2[1] - vertex1[1]) * (vertex2[0] - vertex1[0]) < x) {
                                            inside = !inside;
                                        }
                                    }

                                    j = ii;
                                }        
                            }
                            if (inside) {
                                return {seriesIndex:i, pointIndex:null, gridData:s.gridData, data:s.data, points:s._areaPoints};
                            }
                            break;
                            
                        }

                        else {
                            t = s.markerRenderer.size/2+s.neighborThreshold;
                            threshold = (t > 0) ? t : 0;
                            for (var j=0; j<s.gridData.length; j++) {
                                p = s.gridData[j];
                                // neighbor looks different to OHLC chart.
                                if (r.constructor == $.jqplot.OHLCRenderer) {
                                    if (r.candleStick) {
                                        var yp = s._yaxis.series_u2p;
                                        if (x >= p[0]-r._bodyWidth/2 && x <= p[0]+r._bodyWidth/2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                        }
                                    }
                                    // if an open hi low close chart
                                    else if (!r.hlc){
                                        var yp = s._yaxis.series_u2p;
                                        if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                        }
                                    }
                                    // a hi low close chart
                                    else {
                                        var yp = s._yaxis.series_u2p;
                                        if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {
                                            return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                        }
                                    }
                        
                                }
                                else if (p[0] != null && p[1] != null){
                                    d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );
                                    if (d <= threshold && (d <= d0 || d0 == null)) {
                                       d0 = d;
                                       return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                    }
                                }
                            } 
                        }
                    }
                    break;
                case $.jqplot.BigDataScatterRenderer:
                    if (ev.type !== 'click') {
                        break;
                    }
                    
                    x = s._xaxis.series_p2u(gridpos.x);
                    y = s._yaxis.series_p2u(gridpos.y);
                    r = s.renderer;
                    candidates = [];
                    
                    if (s.show && s.data.length) {
                        sData = s.data;
                        
                        t = s.markerOptions.size/2+s.neighborThreshold;
                        threshold = (t > 0) ? t : 0;
                        thresholdX = x - s._xaxis.series_p2u(gridpos.x - t);
                        thresholdY = Math.abs(y - s._yaxis.series_p2u(gridpos.y - t));
                        
                        if (s._xaxis._dataBounds.min >= x) {
                            candidates = searchCandidate(sData, 0, x, y, thresholdX, thresholdY);
                        } else if (s._xaxis._dataBounds.max <= x) {
                            candidates = searchCandidate(sData, s.data.length - 1, x, y, thresholdX, thresholdY);
                        } else {
                            candidates = binaryIndexOf(sData, x, y, thresholdX, thresholdY);
                        }
                        
                        var nearest = candidates.map(function(index) {
                             var x = gridpos.x - s._xaxis.series_u2p(sData[index][0]),
                                y = gridpos.y - s._yaxis.series_u2p(sData[index][1]);
                            return [
                                index,
                                x*x + y*y
                            ];
                        }).sort(function(a, b) {
                            return a[1] - b[1];
                        }).shift();
                        
                        if (!!nearest) {
                            return {seriesIndex: i, pointIndex:nearest[0], gridData:[s._xaxis.series_u2p(sData[nearest[0]][0]), s._yaxis.series_u2p(sData[nearest[0]][1])], data:sData[nearest[0]]};
                        }
                    }
                    break;
                default:
                    x = gridpos.x;
                    y = gridpos.y;
                    r = s.renderer;
                    if (s.show) {
                        t = s.markerRenderer.size/2+s.neighborThreshold;
                        threshold = (t > 0) ? t : 0;
                        for (var j=0; j<s.gridData.length; j++) {
                            p = s.gridData[j];
                            // neighbor looks different to OHLC chart.
                            if (r.constructor == $.jqplot.OHLCRenderer) {
                                if (r.candleStick) {
                                    var yp = s._yaxis.series_u2p;
                                    if (x >= p[0]-r._bodyWidth/2 && x <= p[0]+r._bodyWidth/2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                                        return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                    }
                                }
                                // if an open hi low close chart
                                else if (!r.hlc){
                                    var yp = s._yaxis.series_u2p;
                                    if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                                        return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                    }
                                }
                                // a hi low close chart
                                else {
                                    var yp = s._yaxis.series_u2p;
                                    if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {
                                        return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                    }
                                }
                        
                            }
                            else {
                                d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );
                                if (d <= threshold && (d <= d0 || d0 == null)) {
                                   d0 = d;
                                   return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                                }
                            }
                        } 
                    }
                    break;
            }
        }
        
        sData = null;
        
        return null;
    };

    // author: Daniel Vassalio
    // http://stackoverflow.com/questions/2752349/fast-rectangle-to-rectangle-intersection
    function intersectRect(r1Left, r1Top, r1Right, r1Bottom,
                            r2Left, r2Top, r2Right, r2Bottom) {
        return !(r2Left > r1Right || 
            r2Right < r1Left || 
            r2Top > r1Bottom ||
            r2Bottom < r1Top);
    } 
    
    this.getIntersectionDataByRectangle = function (s, start, stop) {
        if (s.hide || !s.show || s.data.length === 0) {
            return pointIndexes;
        }

        var j, x, y;
        var u, p, points;
        var sData;

        var pointIndexes = [];
        var rectangle = {
            left: start.x > stop.x ? stop.x : start.x,
            top: start.y > stop.y ? stop.y : start.y,
            right: 0,
            bottom: 0
        };
        var rectanglePoints = [];

        if (start.x > stop.x) {
            rectangle.left = stop.x;
            rectangle.right = start.x;
        } else {
            rectangle.left = start.x;
            rectangle.right = stop.x;
        }

        if (start.y > stop.y) {
            rectangle.top = stop.y;
            rectangle.bottom = start.y;
        } else {
            rectangle.top = start.y;
            rectangle.bottom = stop.y;
        }

        rectanglePoints = [
            [rectangle.left, rectangle.top],
            [rectangle.right, rectangle.top],
            [rectangle.right, rectangle.bottom],
            [rectangle.left, rectangle.bottom]
        ];

        switch (s.renderer.constructor) {
            case $.jqplot.BarRenderer:
                // for (j=0; j<s._barPoints.length; j++) {
                //     points = s._barPoints[j];
                     
                //     if (intersectRect(rectangle.left, rectangle.top, rectangle.right, rectangle.bottom,
                //         points[0][0], points[0][1], points[2][0], points[2][1])) {
                //         pointIndexes.push(j);
                //     }
                // }
                // break;
            case $.jqplot.PyramidRenderer:
                for (j=0; j<s._barPoints.length; j++) {
                    points = s._barPoints[j];
                    if (jsIntersect.intersect(rectanglePoints, points)) {
                        pointIndexes.push(j);
                    }
                }
                break;
            
            case $.jqplot.DonutRenderer:
                //TODO implement
                // sa = s.startAngle/180*Math.PI;
                // x = gridpos.x - s._center[0];
                // y = gridpos.y - s._center[1];
                // r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                // if (x > 0 && -y >= 0) {
                //     theta = 2*Math.PI - Math.atan(-y/x);
                // }
                // else if (x > 0 && -y < 0) {
                //     theta = -Math.atan(-y/x);
                // }
                // else if (x < 0) {
                //     theta = Math.PI - Math.atan(-y/x);
                // }
                // else if (x == 0 && -y > 0) {
                //     theta = 3*Math.PI/2;
                // }
                // else if (x == 0 && -y < 0) {
                //     theta = Math.PI/2;
                // }
                // else if (x == 0 && y == 0) {
                //     theta = 0;
                // }
                // if (sa) {
                //     theta -= sa;
                //     if (theta < 0) {
                //         theta += 2*Math.PI;
                //     }
                //     else if (theta > 2*Math.PI) {
                //         theta -= 2*Math.PI;
                //     }
                // }
    
                // sm = s.sliceMargin/180*Math.PI;
                // if (r < s._radius && r > s._innerRadius) {
                //     for (j=0; j<s.gridData.length; j++) {
                //         minang = (j>0) ? s.gridData[j-1][1]+sm : sm;
                //         maxang = s.gridData[j][1];
                //         if (theta > minang && theta < maxang) {
                //             return {seriesIndex:s.index, pointIndex:j, gridData:[gridpos.x,gridpos.y], data:s.data[j]};
                //         }
                //     }
                // }
                break;
                
            case $.jqplot.PieRenderer:
                //TODO implement
                // sa = s.startAngle/180*Math.PI;
                // x = gridpos.x - s._center[0];
                // y = gridpos.y - s._center[1];
                // r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                // if (x > 0 && -y >= 0) {
                //     theta = 2*Math.PI - Math.atan(-y/x);
                // }
                // else if (x > 0 && -y < 0) {
                //     theta = -Math.atan(-y/x);
                // }
                // else if (x < 0) {
                //     theta = Math.PI - Math.atan(-y/x);
                // }
                // else if (x == 0 && -y > 0) {
                //     theta = 3*Math.PI/2;
                // }
                // else if (x == 0 && -y < 0) {
                //     theta = Math.PI/2;
                // }
                // else if (x == 0 && y == 0) {
                //     theta = 0;
                // }
                // if (sa) {
                //     theta -= sa;
                //     if (theta < 0) {
                //         theta += 2*Math.PI;
                //     }
                //     else if (theta > 2*Math.PI) {
                //         theta -= 2*Math.PI;
                //     }
                // }
    
                // sm = s.sliceMargin/180*Math.PI;
                // if (r < s._radius) {
                //     for (j=0; j<s.gridData.length; j++) {
                //         minang = (j>0) ? s.gridData[j-1][1]+sm : sm;
                //         maxang = s.gridData[j][1];
                //         if (theta > minang && theta < maxang) {
                //             return {seriesIndex:s.index, pointIndex:j, gridData:[gridpos.x,gridpos.y], data:s.data[j]};
                //         }
                //     }
                // }
                break;
                
            case $.jqplot.BubbleRenderer:
                //TODO implement
                return pointIndexes;
                // x = gridpos.x;
                // y = gridpos.y;
                // var ret = null;
                
                // if (s.show) {
                //     for (var j=0; j<s.gridData.length; j++) {
                //         p = s.gridData[j];
                //         d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );
                //         if (d <= p[2] && (d <= d0 || d0 == null)) {
                //             d0 = d;
                //             ret = {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                //         }
                //     }
                //     if (ret != null) {
                //         return ret;
                //     }
                // }
                // break;
                
            case $.jqplot.FunnelRenderer:
                //TODO implement
                // x = gridpos.x;
                // y = gridpos.y;
                // var v = s._vertices,
                //     vfirst = v[0],
                //     vlast = v[v.length-1],
                //     lex,
                //     rex,
                //     cv;

                // // equations of right and left sides, returns x, y values given height of section (y value and 2 points)

                // function findedge (l, p1 , p2) {
                //     var m = (p1[1] - p2[1])/(p1[0] - p2[0]);
                //     var b = p1[1] - m*p1[0];
                //     var y = l + p1[1];

                //     return [(y - b)/m, y];
                // }

                // // check each section
                // lex = findedge(y, vfirst[0], vlast[3]);
                // rex = findedge(y, vfirst[1], vlast[2]);
                // for (j=0; j<v.length; j++) {
                //     cv = v[j];
                //     if (y >= cv[0][1] && y <= cv[3][1] && x >= lex[0] && x <= rex[0]) {
                //         return {seriesIndex:s.index, pointIndex:j, gridData:null, data:s.data[j]};
                //     }
                // }         
                break;           
            
            case $.jqplot.LineRenderer:
                for (var j=0; j<s.gridData.length; j++) {
                    p = s.gridData[j];
                    if (p[0] != null && p[1] != null){
                        if (p[0] >= rectangle.left && p[0] <= rectangle.right && p[1] >= rectangle.top && p[1] <= rectangle.bottom) {
                            pointIndexes.push(j);
                        }
                    }
                } 
                break;
            case $.jqplot.BigDataScatterRenderer:
                var rectangleData = {
                    left: s._xaxis.series_p2u(rectangle.left),
                    top: s._yaxis.series_p2u(rectangle.top),
                    right: s._xaxis.series_p2u(rectangle.right),
                    bottom:  s._yaxis.series_p2u(rectangle.bottom),
                };
                
                sData = s.data;

                for (var j=0; j<sData.length; j++) {
                    p = sData[j];
                    if (p[0] >= rectangleData.left && p[0] <= rectangleData.right &&
                        ((rectangleData.top >= rectangleData.bottom && p[1] <= rectangleData.top && p[1] >= rectangleData.bottom) ||
                        (rectangleData.top < rectangleData.bottom && p[1] >= rectangleData.top && p[1] <= rectangleData.bottom))){
                        pointIndexes.push(j);
                    }
                } 
                break;
            default:
                //TODO implement
                // x = gridpos.x;
                // y = gridpos.y;
                // r = s.renderer;
                // if (s.show) {
                //     t = s.markerRenderer.size/2+s.neighborThreshold;
                //     threshold = (t > 0) ? t : 0;
                //     for (var j=0; j<s.gridData.length; j++) {
                //         p = s.gridData[j];
                //         // neighbor looks different to OHLC chart.
                //         if (r.constructor == $.jqplot.OHLCRenderer) {
                //             if (r.candleStick) {
                //                 var yp = s._yaxis.series_u2p;
                //                 if (x >= p[0]-r._bodyWidth/2 && x <= p[0]+r._bodyWidth/2 && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                //                     return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                //                 }
                //             }
                //             // if an open hi low close chart
                //             else if (!r.hlc){
                //                 var yp = s._yaxis.series_u2p;
                //                 if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][2]) && y <= yp(s.data[j][3])) {
                //                     return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                //                 }
                //             }
                //             // a hi low close chart
                //             else {
                //                 var yp = s._yaxis.series_u2p;
                //                 if (x >= p[0]-r._tickLength && x <= p[0]+r._tickLength && y >= yp(s.data[j][1]) && y <= yp(s.data[j][2])) {
                //                     return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                //                 }
                //             }
                    
                //         }
                //         else {
                //             d = Math.sqrt( (x-p[0]) * (x-p[0]) + (y-p[1]) * (y-p[1]) );
                //             if (d <= threshold && (d <= d0 || d0 == null)) {
                //                 d0 = d;
                //                 return {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]};
                //             }
                //         }
                //     } 
                // }
                break;
        }
        
        sData = null;
        
        return pointIndexes;
    };
    

    this.getEventPosition = function (ev) {
      var plot = ev.data.plot;
      var go = plot.eventCanvas._elem.offset();
      var gridPos = {x:ev.pageX - go.left, y:ev.pageY - go.top};
      var dataPos = {xaxis:null, yaxis:null, x2axis:null, y2axis:null, y3axis:null, y4axis:null, y5axis:null, y6axis:null, y7axis:null, y8axis:null, y9axis:null, yMidAxis:null};
      var an = ['xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
      var ax = plot.axes;
      var n, axis;
      for (n=11; n>0; n--) {
          axis = an[n-1];
          if (ax[axis].show) {
              dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);
          }
      }

      return {offsets:go, gridPos:gridPos, dataPos:dataPos};
    };
    
    this.onClick = function(ev) {
        // Event passed in is normalized and will have data attribute.
        // Event passed out is unnormalized.
        var positions = ev.data.plot.getEventPosition(ev);
        var p = ev.data.plot;
        var neighbor = p.checkIntersection(ev, positions.gridPos, p);
        var evt = $.Event('jqplotClick');
        evt.originalEvent = ev;
        evt.pageX = ev.pageX;
        evt.pageY = ev.pageY;
        $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
    };
    
    this.onDblClick = function(ev) {
        // Event passed in is normalized and will have data attribute.
        // Event passed out is unnormalized.
        var positions = ev.data.plot.getEventPosition(ev);
        var p = ev.data.plot;
        var neighbor = p.checkIntersection(ev, positions.gridPos, p);
        var evt = $.Event('jqplotDblClick');
        evt.originalEvent = ev;
        evt.pageX = ev.pageX;
        evt.pageY = ev.pageY;
        $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
    };
    
    this.onMouseDown = function(ev) {
        var positions = ev.data.plot.getEventPosition(ev);
        var p = ev.data.plot;
        var neighbor = p.checkIntersection(ev, positions.gridPos, p);
        var evt = $.Event('jqplotMouseDown');
        evt.originalEvent = ev;
        evt.pageX = ev.pageX;
        evt.pageY = ev.pageY;
        $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
    };
    
    this.onMouseUp = function(ev) {
        var positions = ev.data.plot.getEventPosition(ev);
        var p = ev.data.plot;
        var evt = $.Event('jqplotMouseUp');
        evt.originalEvent = ev;
        evt.pageX = ev.pageX;
        evt.pageY = ev.pageY;
        $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);
    };
    
    this.onRightClick = function(ev) {
        var positions = ev.data.plot.getEventPosition(ev);
        var p = ev.data.plot;
        var neighbor = p.checkIntersection(ev, positions.gridPos, p);
        if (p.captureRightClick) {
            if (ev.which == 3) {
                var evt = $.Event('jqplotRightClick');
                evt.originalEvent = ev;
                evt.pageX = ev.pageX;
                evt.pageY = ev.pageY;
                $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
            }
            else {
                var evt = $.Event('jqplotMouseUp');
                evt.originalEvent = ev;
                evt.pageX = ev.pageX;
                evt.pageY = ev.pageY;
                $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
            }
        }
    };
    
    this.onMouseMove = function(ev) {
        var positions = ev.data.plot.getEventPosition(ev);
        var p = ev.data.plot;
        var neighbor = p.checkIntersection(ev, positions.gridPos, p);
        var evt = $.Event('jqplotMouseMove');
        evt.originalEvent = ev;
        evt.pageX = ev.pageX;
        evt.pageY = ev.pageY;
        $(this).trigger(evt, [positions.gridPos, positions.dataPos, neighbor, p]);
    };
    
    this.onMouseEnter = function(ev) {
        var positions = ev.data.plot.getEventPosition(ev);
        var p = ev.data.plot;
        var evt = $.Event('jqplotMouseEnter');
        evt.pageX = ev.pageX;
        evt.pageY = ev.pageY;
        evt.relatedTarget = ev.relatedTarget;
        $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);
    };
    
    this.onMouseLeave = function(ev) {
        var positions = ev.data.plot.getEventPosition(ev);
        var p = ev.data.plot;
        var evt = $.Event('jqplotMouseLeave');
        evt.originalEvent = ev;
        evt.pageX = ev.pageX;
        evt.pageY = ev.pageY;
        evt.relatedTarget = ev.relatedTarget;
        $(this).trigger(evt, [positions.gridPos, positions.dataPos, null, p]);
    };

        // customizing new method (2012-05-30, Roy Choi)
        // method: addSeries
        // Add Series one series on the plot.
        // data is array
        // options is extended to the SeriesDefault option
        this.addSeries = function(options, draw) {
            if (!$.isArray(options)) {
                options = [options];
            }
            //var colorIndex = 0;
            var slen = this.series.length;
            var first = slen === 0;
            var k = 0;

            var self = this;

            for (var i = slen, d_len = options.length; i < slen + d_len; i++) {
                var data = options[k].data;
                this.data.push(data);
                //$.merge(this._plotData,data[k]);

                this.options.series.push(options[k]);
                
                
                
                var sopts = $.extend(true, {index: i}, {seriesColors:this.seriesColors, negativeSeriesColors:this.negativeSeriesColors}, this.options.seriesDefaults, this.options.series[i], {rendererOptions:{animation:{show: this.animate}}});
                // pass in options in case something needs set prior to initialization.
                var temp = new Series(sopts);
                // customizing (2013-02-12, Roy Choi)
                if (this.options.multiCanvas) {
                    temp.canvas = new $.jqplot.GenericCanvas();
                    if ( typeof this.options.seriesDefaults == 'object' && this.options.seriesDefaults.shadow) {
                        temp.shadowCanvas = new $.jqplot.GenericCanvas();
                    }
                } else {
                    temp.canvas = this.seriesCanvas;
                }
                
                
                for (var j=0; j<$.jqplot.preParseSeriesOptionsHooks.length; j++) {
                    $.jqplot.preParseSeriesOptionsHooks[j].call(temp, this.options.seriesDefaults, this.options.series[i]);
                }
                for (var j=0; j<this.preParseSeriesOptionsHooks.hooks.length; j++) {
                    this.preParseSeriesOptionsHooks.hooks[j].call(temp, this.options.seriesDefaults, this.options.series[i]);
                }
                // Now go back and apply the options to the series.  Really should just do this during initializaiton, but don't want to
                // mess up preParseSeriesOptionsHooks at this point.
                $.extend(true, temp, sopts);
                var dir = 'vertical';
                if (temp.renderer === $.jqplot.BarRenderer && temp.rendererOptions && temp.rendererOptions.barDirection == 'horizontal') {
                    dir = 'horizontal';
                    temp._stackAxis = 'x';
                    temp._primaryAxis = '_yaxis';
                }
                temp.data = ($.isArray(data[0])) ? data : normalizeData(data, dir, this.defaultAxisStart);
                switch (temp.xaxis) {
                    case 'xaxis':
                        temp._xaxis = this.axes.xaxis;
                        break;
                    case 'x2axis':
                        temp._xaxis = this.axes.x2axis;
                        break;
                    default:
                        break;
                }
                temp._yaxis = this.axes[temp.yaxis];
                temp._xaxis._series.push(temp);
                temp._yaxis._series.push(temp);
                if (temp.show) {
                    temp._xaxis.show = true;
                    temp._yaxis.show = true;
                }
                else {
                    if (temp._xaxis.scaleToHiddenSeries) {
                        temp._xaxis.show = true;
                    }
                    if (temp._yaxis.scaleToHiddenSeries) {
                        temp._yaxis.show = true;
                    }
                }
        
                // // parse the renderer options and apply default colors if not provided
                // if (!temp.color && temp.show != false) {
                //     temp.color = cg.next();
                //     colorIndex = cg.getIndex() - 1;;
                // }
                // if (!temp.negativeColor && temp.show != false) {
                //     temp.negativeColor = ncg.get(colorIndex);
                //     ncg.setIndex(colorIndex);
                // }
                if (!temp.label) {
                    temp.label = 'Series '+ (i+1).toString();
                }
                // temp.rendererOptions.show = temp.show;
                // $.extend(true, temp.renderer, {color:this.seriesColors[i]}, this.rendererOptions);
                this.series.push(temp);  
                for (var j=0; j<$.jqplot.postParseSeriesOptionsHooks.length; j++) {
                    $.jqplot.postParseSeriesOptionsHooks[j].call(this.series[i], this.options.seriesDefaults, this.options.series[i]);
                }
                for (var j=0; j<this.postParseSeriesOptionsHooks.hooks.length; j++) {
                    this.postParseSeriesOptionsHooks.hooks[j].call(this.series[i], this.options.seriesDefaults, this.options.series[i]);
                }
                
                temp = null;
                
                this.computePlotData();
                
                this.seriesStack.push(i);
                this.previousSeriesStack.push(i);
                
                if(this.options.multiCanvas && this.series[i].shadowCanvas) {
                    this.series[i].shadowCanvas._plotDimensions = this._plotDimensions;
                }
                this.series[i].canvas._plotDimensions = this._plotDimensions;
                for (var j = 0; j < $.jqplot.preSeriesInitHooks.length; j++) {
                    $.jqplot.preSeriesInitHooks[j].call(this.series[i], this.target.attr('id'), this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                for (var j = 0; j < this.preSeriesInitHooks.hooks.length; j++) {
                    this.preSeriesInitHooks.hooks[j].call(this.series[i], this.target.attr('id'), this.data, this.options.seriesDefaults, this.options.series[i], this);
                }

                //this.populatePlotData(this.series[i], i);
                
                // this.computePlotData(this.series[i], i);
                this.series[i]._plotDimensions = this._plotDimensions;
                this.series[i].init(i, this.grid.borderWidth, this);
                for (var j = 0; j < $.jqplot.postSeriesInitHooks.length; j++) {
                    $.jqplot.postSeriesInitHooks[j].call(this.series[i], this.target.attr('id'), this.data, this.options.seriesDefaults, this.options.series[i], this);
                }
                for (var j = 0; j < this.postSeriesInitHooks.hooks.length; j++) {
                    this.postSeriesInitHooks.hooks[j].call(this.series[i], this.target.attr('id'), this.data, this.options.seriesDefaults, this.options.series[i], this);
                }

                // set default stacking order for series canvases

                this._sumy += this.series[i]._sumy;
                this._sumx += this.series[i]._sumx;

                // customizing (2013-02-12, Roy Choi)
                if (this.options.multiCanvas) {
                    this.target.find('.jqplot-series-canvas:last').after(this.series[i].canvas.createElement(this._gridPadding, 'jqplot-series-canvas', null, this));
                    this.series[i].canvas.setContext();
                    this.series[i].canvas._elem.data('seriesIndex', i);
                }

                if (first) {
                    this.replot();
                } else if (draw && !this.series[i].hide && this.series[i].show) {
                    var sr = this.series[i];
                    sr.draw(sr.canvas._ctx, {}, self);
                    if (options.showLabel) this.legend.renderer.addSeries.call(this.legend, this, [sr]);
                    sr = null;
                    
                    if (this.series[i].renderer.constructor === $.jqplot.LineRenderer) {
                        if (!this.plugins.lineRenderer || !this.plugins.lineRenderer.highlightCanvas) {
                            this.plugins.lineRenderer.highlightedSeriesIndex = null;
                            this.plugins.lineRenderer.highlightCanvas = new $.jqplot.GenericCanvas();
                            
                            this.eventCanvas._elem.before(this.plugins.lineRenderer.highlightCanvas.createElement(this._gridPadding, 'jqplot-lineRenderer-highlight-canvas', this._plotDimensions, this));
                            this.plugins.lineRenderer.highlightCanvas.setContext();
                        }
                    }
                    
                    /*setTimeout(function(){
                     sr.draw(sr.canvas._ctx, {},self);
                     self.legend.renderer.addSeries.call(self.legend,self,[sr]);
                     self = sr = null;
                     },0);*/
                } else {
                    if (options.showLabel) this.legend.renderer.addSeries.call(this.legend, this, [this.series[i]]);
                }

                k++;
            }
        };

        // customizing new method (2013-02-15, Roy Choi)
        // method: removeSeries
        // remove a series on the plot.
        // seriesIndex is number
        // draw is boolean whether redraw series
        this.removeSeries = function(seriesIndex, draw) {
            draw = draw === false ? false : true;
            this.options.series[seriesIndex] = null;
            this.options.series.splice(seriesIndex, 1);
            this.series[seriesIndex].data = null;
            this.series.splice(seriesIndex, 1);
            this.data.splice(seriesIndex, 1);

            var stackIndex = $.inArray(seriesIndex, this.seriesStack);
            if (stackIndex > -1) {
                this.seriesStack.splice(stackIndex, 1);
            }

            if (draw) {
                this.redrawSeries();
            }
        };

        // method: drawSeries
        // Redraws all or just one series on the plot.  No axis scaling
        // is performed and no other elements on the plot are redrawn.
        // options is an options object to pass on to the series renderers.
        // It can be an empty object {}.  idx is the series index
        // to redraw if only one series is to be redrawn.
        this.drawSeries = function(options, idx) {
            if (!this.options.multiCanvas) {
                this.seriesHighlightCanvas._plotDimensions = this._plotDimensions;
                this.clearHighlightSeries();
            }

            var i, series, ctx;
            // if only one argument passed in and it is a number, use it ad idx.
            idx = ( typeof (options) === "number" && idx == null) ? options : idx;
            options = ( typeof (options) === "object") ? options : {};
            // draw specified series
            if (idx != undefined) {
                series = this.series[idx];
                
                if (this.options.multiCanvas) {
                    if (series.shadowCanvas) {
                        ctx = series.shadowCanvas._ctx;
                        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                        series.drawShadow(ctx, options, this);
                    }
                    ctx = series.canvas._ctx;
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    series.draw(ctx, options, this);
                } else {
                    ctx = series.canvas._ctx;
                    if (series.hide)
                        series.draw(ctx, options, this);
                    // customizing (2012-08-30, Roy Choi)
                }

                if (series.renderer.constructor == $.jqplot.BezierCurveRenderer) {
                    if (idx < this.series.length - 1) {
                        this.drawSeries(idx + 1);
                    }
                }
            }  else if (this.series.length && this.series[0].renderer.constructor === $.jqplot.BigDataScatterRenderer) {
                this.options.multiCanvas = false;
                ctx = this.series[0].canvas._ctx;
                this.series[0].renderer.draw.call(this, ctx, null, options, this);
            } else {
                // if call series drawShadow method first, in case all series shadows
                // should be drawn before any series.  This will ensure, like for
                // stacked bar plots, that shadows don't overlap series.
                for ( i = 0; i < this.series.length; i++) {
                    // first clear the canvas
                    series = this.series[i];
                    
                    if (series.hide)
                        continue;
                    // customizing (2012-08-30, Roy Choi)
                    if (this.options.multiCanvas) {
                        if (series.shadow) {
                            ctx = series.shadowCanvas._ctx;
                            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                            series.drawShadow(ctx, options, this);
                        }
                        ctx = series.canvas._ctx;
                        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                        series.draw(ctx, options, this);
                    } else {
                        ctx = series.canvas._ctx;
                        series.draw(ctx, options, this);
                    }
                }
            }
            options = idx = i = series = ctx = null;
            
            
        };

        // method: clearHighlightSeries
        // Created by Roy 2016.10.21
        this.clearHighlightSeries = function() {
            var ctx = this.seriesHighlightCanvas._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx = null;
        };

        this.clearHighlighted = function(highlightedSeries) {
            var series = highlightedSeries || this.series;
            if (!$.isArray(series)) {
                series = [series];
            }
            series.forEach(function(s) {
                s.highlighted = false;
            });
        };

        this.checkMacOS = function() {
            return navigator.platform.indexOf('Mac') > -1;
        }

        this.checkCtrlKey = function(ev) {
            if (this.checkMacOS()) {
                return ev.metaKey;
            } else {
                return ev.ctrlKey;
            }
        };

        // method: moveSeriesToFront
        // This method requires jQuery 1.4+
        // Moves the specified series canvas in front of all other series canvases.
        // This effectively "draws" the specified series on top of all other series,
        // although it is performed through DOM manipulation, no redrawing is performed.
        //
        // Parameters:
        // idx - 0 based index of the series to move.  This will be the index of the series
        // as it was first passed into the jqplot function.
        this.moveSeriesToFront = function(idx, continuous) {
            var stackIndex = $.inArray(idx, this.seriesStack);
            
            if (stackIndex < 0) {
                return;
            }

            if (this.options.multiCanvas) {
                if (stackIndex === this.seriesStack.length - 1) {// customizing (2012-04-25, Roy Choi)
                    this.previousSeriesStack = this.seriesStack.slice(0);
                    //return;
                } else {
                    var opidx = this.seriesStack[this.seriesStack.length - 1];
                    var serelem = this.series[idx].canvas._elem.detach();
                    if (this.series[idx].shadowCanvas) {
                        var shadelem = this.series[idx].shadowCanvas._elem.detach();
                        this.series[opidx].shadowCanvas._elem.after(shadelem);
                    }
                    this.series[opidx].canvas._elem.after(serelem);
                    this.previousSeriesStack = this.seriesStack.slice(0);
                    this.seriesStack.splice(stackIndex, 1);
                    this.seriesStack.push(idx);
                }
                
                this.series.forEach(function(series, index) {
                    if (index !== idx) {
                        series.canvas._elem.fadeTo('fast', .4);
                    }
                });
                this.series[idx].canvas._elem.fadeTo('fast', 1.0);
                this.series[idx].highlighted = true;
            } else {
                // if (stackIndex === this.seriesStack.length - 1) {// customizing (2012-04-25, Roy Choi)
                //     this.previousSeriesStack = this.seriesStack.slice(0);
                //     //return;
                // }

                // customizing Start (2012-04-20, Roy Choi)
                if (!continuous) {
                    this.clearHighlightSeries();
                    this.clearHighlighted();
                    this.highlightSeriesIndexes = [];
                }
                this.seriesCanvas._elem.fadeTo(0, .4);
                var ctx = this.seriesHighlightCanvas._ctx;
                this.series[idx].draw(ctx, {}, this);
                this.series[idx].highlighted = true;
                ctx = null;
            }
            this.highlightSeriesIndexes.push(idx);
            this.seriesStack.push(this.seriesStack.splice(stackIndex, 1).shift());
            this.target.trigger('jqPlot.SeriesToFront', [idx, this]);

            for (var i = 0; i < $.jqplot.postSeriesHighlightHooks.length; i++) {
                $.jqplot.postSeriesHighlightHooks[i].call(this, idx);
            }
        };

        // method: moveSeriesToBack
        // This method requires jQuery 1.4+
        // Moves the specified series canvas behind all other series canvases.
        //
        // Parameters:
        // idx - 0 based index of the series to move.  This will be the index of the series
        // as it was first passed into the jqplot function
        this.moveSeriesToBack = function(idx) {
            idx = parseInt(idx, 10);
            var stackIndex = $.inArray(idx, this.seriesStack);
            // if already in back, return
            if (stackIndex == -1) {
                return;
            }

            if (this.options.multiCanvas) {
                if (this.highlightSeriesIndexes.length === 1 && this.highlightSeriesIndexes[0] === idx) {
                    var opidx = this.seriesStack[0];
                    $.each(this.series, function(ind, series) {
                        series.highlighted = false;
                        if (!series.hide) {
                            $(series.canvas._elem).fadeTo(0, 1.0);
                        }
                    });
                }
                if (this.highlightSeriesIndexes.length >= 1) {
                    var serelem = this.series[idx].canvas._elem.detach();
                    if (this.series[idx].shadowCanvas) {
                        var shadelem = this.series[idx].shadowCanvas._elem.detach();
                        this.series[opidx].shadowCanvas._elem.before(shadelem);
                    }
                    this.series[opidx].canvas._elem.before(serelem);
                    this.previousSeriesStack = this.seriesStack.slice(0);
                    this.seriesStack.splice(stackIndex, 1);
                    this.seriesStack.unshift(idx);

                    this.highlightSeriesIndexes.splice(this.highlightSeriesIndexes.indexOf(idx),1);
                    this.series[idx].highlighted = false;
                }
                if (this.highlightedSeriesIndex.length > 0) {
                    this.series[idx].canvas._elem.fadeTo(0, .4);
                }
            } else {
                if (this.highlightSeriesIndexes.length === 1 && this.highlightSeriesIndexes[0] === idx) {
                    var opidx = this.seriesStack[0];
                    $.each(this.series, function(ind, series) {
                        series.highlighted = false;
                    });

                    this.seriesCanvas._elem.fadeTo(0, 1.0);

                    this.highlightSeriesIndexes = [];
                    this.clearHighlightSeries();
                    this.clearHighlighted();
                } else if (this.highlightSeriesIndexes.length > 1) {
                    this.highlightSeriesIndexes.splice(this.highlightSeriesIndexes.indexOf(idx),1);
                    this.series[idx].highlighted = false;

                    this.clearHighlightSeries();
                    var ctx = this.seriesHighlightCanvas._ctx;
                    this.highlightSeriesIndexes.forEach(function(seriesIndex) {
                        this.series[seriesIndex].draw(ctx, {}, this);
                    }, this);
                    ctx = null;
                }
            }
            
            this.target.trigger('jqPlot.SeriesToBack', [idx, this]);

            for (var i = 0; i < $.jqplot.postSeriesUnhighlightHooks.length; i++) {
                $.jqplot.postSeriesUnhighlightHooks[i].call(this);
            }
        };

        // method: restorePreviousSeriesOrder
        // This method requires jQuery 1.4+
        // Restore the series canvas order to its previous state.
        // Useful to put a series back where it belongs after moving
        // it to the front.
        this.restorePreviousSeriesOrder = function() {
            var i, j, serelem, shadelem, temp, move, keep;
            // if no change, return.
            if (this.seriesStack == this.previousSeriesStack) {
                return;
            }

            if (this.options.multiCanvas) {
                // customizing Start (2012-04-20, Roy Choi)
                $.each(this.series, function(ind, series) {
                    series.highlighted = false;
                    if (!series.hide) {
                        $(series.canvas._elem).fadeTo(0, 1.0);
                    }
                });
                // customizing End (2012-04-20, Roy Choi)
                for ( i = 1; i < this.previousSeriesStack.length; i++) {
                    move = this.previousSeriesStack[i];
                    keep = this.previousSeriesStack[i - 1];
                    serelem = this.series[move].canvas._elem.detach();
                    if (this.series[move].shadowCanvas) {
                        shadelem = this.series[move].shadowCanvas._elem.detach();
                        this.series[keep].shadowCanvas._elem.after(shadelem);
                    }
                    this.series[keep].canvas._elem.after(serelem);
                }
                temp = this.seriesStack.slice(0);
                this.seriesStack = this.previousSeriesStack.slice(0);
                this.previousSeriesStack = temp;
            } else {
                // customizing Start (2012-04-20, Roy Choi)
                $.each(this.series, function(ind, series) {
                    series.highlighted = false;
                });
                temp = this.seriesStack.slice(0);
                this.seriesStack = this.previousSeriesStack.slice(0);
                this.previousSeriesStack = temp;
                temp = null;
                this.seriesCanvas._elem.fadeTo(0, 1.0);
                this.clearHighlightSeries();
                //this.redraw();
            }
            this.highlightSeriesIndexes = [];
            this.target.trigger('jqPlot.PreviousSeriesOrder', [this]);

            for (var i = 0; i < $.jqplot.postSeriesUnhighlightHooks.length; i++) {
                $.jqplot.postSeriesUnhighlightHooks[i].call(this);
            }
        };

        // method: restoreOriginalSeriesOrder
        // This method requires jQuery 1.4+
        // Restore the series canvas order to its original order
        // when the plot was created.
        this.restoreOriginalSeriesOrder = function() {
            var i, j, arr = [], serelem, shadelem;
            //var i, arr=[];

            if (this.options.multiCanvas) {
                var i, j, arr = [], serelem, shadelem;
                for ( i = 0; i < this.series.length; i++) {
                    arr.push(i);
                }
                if (this.seriesStack == arr) {
                    return;
                }
                // customizing Start (2012-04-20, Roy Choi)
                $.each(this.series, function(ind, series) {
                    series.highlighted = false;
                    if (!series.hide) {
                        $(series.canvas._elem).fadeTo(0, 1.0);
                    }
                });
                // customizing End (2012-04-20, Roy Choi)
                this.previousSeriesStack = this.seriesStack.slice(0);
                this.seriesStack = arr;
                for ( i = 1; i < this.seriesStack.length; i++) {
                    serelem = this.series[i].canvas._elem.detach();
                    if ( shadelem = this.series[i].shadowCanvas) {
                        shadelem = this.series[i].shadowCanvas._elem.detach();
                        this.series[i - 1].shadowCanvas._elem.after(shadelem);
                    }
                    this.series[i - 1].canvas._elem.after(serelem);
                }
            } else {
                for ( i = 0; i < this.series.length; i++) {
                    arr.push(i);
                }
                if (this.seriesStack == arr) {
                    return;
                }
                // customizing Start (2012-04-20, Roy Choi)
                $.each(this.series, function(ind, series) {
                    series.highlighted = false;
                });
                // customizing End (2012-04-20, Roy Choi)
                this.previousSeriesStack = this.seriesStack.slice(0);
                this.seriesStack = arr;
                arr = null;
                //for (i=1; i<this.seriesStack.length; i++) {
                //serelem = this.series[i].canvas._elem.detach();
                //shadelem = this.series[i].shadowCanvas._elem.detach();
                //this.series[i-1].shadowCanvas._elem.after(shadelem);
                //this.series[i-1].canvas._elem.after(serelem);
                //}
                this.seriesCanvas._elem.fadeTo(0, 1.0);
                this.clearHighlightSeries();
                //this.redraw();
            }

            this.highlightSeriesIndexes = [];
            this.target.trigger('jqPlot.OriginalSeriesOrder', [this]);

            for (var i = 0; i < $.jqplot.postSeriesUnhighlightHooks.length; i++) {
                $.jqplot.postSeriesUnhighlightHooks[i].call(this);
            }
        };
    }

    // setGridData
    // converts the user data values to grid coordinates and stores them
    // in the gridData array.
    // Called with scope of a series.
    $.jqplot.LineRenderer.prototype.setNormalGridData = function(plot) {
        // recalculate the grid data
        var xp = this._xaxis.series_u2p;
        var yp = this._yaxis.series_u2p;
        var data = this._plotData;
        var pdata = this._prevPlotData;
        this.gridData = [];
        this._prevGridData = [];
        this.renderer._smoothedData = [];
        this.renderer._smoothedPlotData = [];
        this.renderer._hiBandGridData = [];
        this.renderer._lowBandGridData = [];
        this.renderer._hiBandSmoothedData = [];
        this.renderer._lowBandSmoothedData = [];
        var bands = this.renderer.bands;
        var hasNull = this.hasNullPoint;
        var pointData, prevPointData;
        
        var gd = this.gridData;
        var pd = this._prevGridData;

        if (!xp) {
            return;
        }
        
        if (!hasNull) {
            for (var i = 0, l = data.length; i < l; i++) {
                // if not a line series or if no nulls in data, push the converted point onto the array.
                pointData = data[i];
          gd.push([xp.call(this._xaxis, pointData[0]), yp.call(this._yaxis, pointData[1])]);
          
          prevPointData = pdata[i];
          if (prevPointData != null) {
            pd.push([xp.call(this._xaxis, prevPointData[0]), yp.call(this._yaxis, prevPointData[1])]);
          }
            }
        } else {
            for (var i = 0, l = data.length; i < l; i++) {
                pointData = data[i];

                // if not a line series or if no nulls in data, push the converted point onto the array.
        if (pointData[0] != null && !isNaN(pointData[0]) && pointData[1] != null && !isNaN(pointData[1])) {
            gd.push([xp.call(this._xaxis, pointData[0]), yp.call(this._yaxis, pointData[1])]);
        }
        // else if there is a null, preserve it.
        else if (pointData[0] == null || isNaN(pointData[0])) {
                    gd.push([null, yp.call(this._yaxis, pointData[1])]);
                } else if (pointData[1] == null || isNaN(pointData[1])) {
                    gd.push([xp.call(this._xaxis, pointData[0]), null]);
                }
                
                prevPointData = pdata[i];
                if (prevPointData != null) {
                    // if not a line series or if no nulls in data, push the converted point onto the array.
                    if (prevPointData[0] != null && !isNaN(prevPointData[0]) && prevPointData[1] != null && !isNaN(prevPointData[1])) {
                        pd.push([xp.call(this._xaxis, prevPointData[0]), yp.call(this._yaxis, prevPointData[1])]);
                    }
                    // else if there is a null, preserve it.
                    else if (prevPointData[0] == null || isNaN(prevPointData[0])) {
                        pd.push([null, yp.call(this._yaxis, prevPointData[1])]);
                    } else if (prevPointData[1] == null || isNaN(prevPointData[1])) {
                        pd.push([xp.call(this._xaxis, prevPointData[0]), null]);
                    }
                }
            }
        }
        
        gd = pd = null;

        // don't do smoothing or bands on broken lines.
        if (hasNull) {
            this.renderer.smooth = false;
            if (this._type === 'line') {
                bands.show = false;
            }
        }

        if (this._type === 'line' && bands.show) {
            var hiData, lowData;
            for (var i = 0, l = bands.hiData.length; i < l; i++) {
                hiData = bands.hiData[i];
                this.renderer._hiBandGridData.push([xp.call(this._xaxis, hiData[0]), yp.call(this._yaxis, hiData[1])]);
            }
            for (var i = 0, l = bands.lowData.length; i < l; i++) {
                lowData = bands.lowData[i];
                this.renderer._lowBandGridData.push([xp.call(this._xaxis, lowData[0]), yp.call(this._yaxis, lowData[1])]);
            }
        }
    };
    
    // makeNormalGridData   - customizing (2014-05-21, Roy)
    // converts any arbitrary data values to grid coordinates and
    // returns them.  This method exists so that plugins can use a series'
    // linerenderer to generate grid data points without overwriting the
    // grid data associated with that series.
    // Called with scope of a series.
    $.jqplot.LineRenderer.prototype.makeNormalGridData = function(data, plot) {
        
        // recalculate the grid data
        var xp = this._xaxis.series_u2p;
        var yp = this._yaxis.series_u2p;
        var gd = [];
        var pgd = [];
        this.renderer._smoothedData = [];
        this.renderer._smoothedPlotData = [];
        this.renderer._hiBandGridData = [];
        this.renderer._lowBandGridData = [];
        this.renderer._hiBandSmoothedData = [];
        this.renderer._lowBandSmoothedData = [];
        var bands = this.renderer.bands;
        var i, l, pointData;

        if (!this.hasNullPoint) {
            for (i=0, l=data.length; i<l; i++) {
                pointData = data[i];
                gd.push([xp.call(this._xaxis, pointData[0]), yp.call(this._yaxis, pointData[1])]);
            }
        } else {
            for (i=0, l=data.length; i<l; i++) {
                pointData = data[i];
                // if not a line series or if no nulls in data, push the converted point onto the array.
            if (pointData[0] != null && !isNaN(pointData[0]) && pointData[1] != null && !isNaN(pointData[1])) {
                gd.push([xp.call(this._xaxis, pointData[0]), yp.call(this._yaxis, pointData[1])]);
            }
            // else if there is a null, preserve it.
            else if (pointData[0] == null || isNaN(pointData[0])) {
                  gd.push([null, yp.call(this._yaxis, pointData[1])]);
              }
              else if (pointData[1] == null || isNaN(pointData[1])) {
                  gd.push([xp.call(this._xaxis, pointData[0]), null]);
              }
            }
        }

        // don't do smoothing or bands on broken lines.
        if (this.hasNullPoint) {
            this.renderer.smooth = false;
            if (this._type === 'line') {
                bands.show = false;
            }
        }

        if (this._type === 'line' && bands.show) {
            for (var i=0, l=bands.hiData.length; i<l; i++) {
                this.renderer._hiBandGridData.push([xp.call(this._xaxis, bands.hiData[i][0]), yp.call(this._yaxis, bands.hiData[i][1])]);
            }
            for (var i=0, l=bands.lowData.length; i<l; i++) {
                this.renderer._lowBandGridData.push([xp.call(this._xaxis, bands.lowData[i][0]), yp.call(this._yaxis, bands.lowData[i][1])]);
            }
        }


        return gd;
    };

    // called within scope of series.
    $.jqplot.LineRenderer.prototype.draw = function(ctx, gd, options, plot) {
        
        var i;
        // get a copy of the options, so we don't modify the original object.
        var opts = $.extend(true, {}, options);
        var shadow = (opts.shadow != undefined) ? opts.shadow : this.shadow;
        var showLine = (opts.showLine != undefined) ? opts.showLine : this.showLine;
        var fill = (opts.fill != undefined) ? opts.fill : this.fill;
        var fillAndStroke = (opts.fillAndStroke != undefined) ? opts.fillAndStroke : this.fillAndStroke;
        var xmin, ymin, xmax, ymax;
        
        if (plot && plot.plugins.cursor) {
            var cursor = plot.plugins.cursor;
            var isZoomed = cursor && (cursor._zoom.isZoomed || cursor._zoom.zooming) && !cursor._zoom.resetzooming;
            cursor = null;
        }
        
        //ctx.save();
        if (gd.length) {
            if (showLine) {
                opts.breakOnNull = opts.breakOnNull || this.breakOnNull;
                opts.hasNullPoint = opts.hasNullPoint || this.hasNullPoint;
                
                // if we fill, we'll have to add points to close the curve.
                if (fill) {
                    if (this.fillToZero) { 
                        // have to break line up into shapes at axis crossings
                        var negativeColor = this.negativeColor;
                        if (! this.useNegativeColors) {
                            negativeColor = opts.fillStyle;
                        }
                        var isnegative = false;
                        var posfs = opts.fillStyle;
                    
                        // if stoking line as well as filling, get a copy of line data.
                        if (fillAndStroke) {
                            var fasgd = gd.slice(0);
                        }
                        // if not stacked, fill down to axis
                        if (this.index == 0 || !this._stack) {
                        
                            var tempgd = [];
                            var pd = (this.renderer.smooth) ? this.renderer._smoothedPlotData : this._plotData;
                            this._areaPoints = [];
                            var pyzero = this._yaxis.series_u2p(this.fillToValue);
                            var pxzero = this._xaxis.series_u2p(this.fillToValue);

                            opts.closePath = true;
                            
                            if (this.fillAxis == 'y') {
                                tempgd.push([gd[0][0], pyzero]);
                                this._areaPoints.push([gd[0][0], pyzero]);
                                
                                for (var i=0; i<gd.length-1; i++) {
                                    tempgd.push(gd[i]);
                                    this._areaPoints.push(gd[i]);
                                    // do we have an axis crossing?
                                    if (pd[i][1] * pd[i+1][1] <= 0) {
                                        if (pd[i][1] < 0) {
                                            isnegative = true;
                                            opts.fillStyle = negativeColor;
                                        }
                                        else {
                                            isnegative = false;
                                            opts.fillStyle = posfs;
                                        }
                                        
                                        var xintercept = gd[i][0] + (gd[i+1][0] - gd[i][0]) * (pyzero-gd[i][1])/(gd[i+1][1] - gd[i][1]);
                                        tempgd.push([xintercept, pyzero]);
                                        this._areaPoints.push([xintercept, pyzero]);
                                        // now draw this shape and shadow.
                                        if (shadow) {
                                            this.renderer.shadowRenderer.draw(ctx, tempgd, opts);
                                        }
                                        this.renderer.shapeRenderer.draw(ctx, tempgd, opts);
                                        // now empty temp array and continue
                                        tempgd = [[xintercept, pyzero]];
                                        // this._areaPoints = [[xintercept, pyzero]];
                                    }   
                                }
                                if (pd[gd.length-1][1] < 0) {
                                    isnegative = true;
                                    opts.fillStyle = negativeColor;
                                }
                                else {
                                    isnegative = false;
                                    opts.fillStyle = posfs;
                                }
                                tempgd.push(gd[gd.length-1]);
                                this._areaPoints.push(gd[gd.length-1]);
                                tempgd.push([gd[gd.length-1][0], pyzero]); 
                                this._areaPoints.push([gd[gd.length-1][0], pyzero]); 
                            }
                            // now draw the last area.
                            if (shadow) {
                                this.renderer.shadowRenderer.draw(ctx, tempgd, opts);
                            }
                            this.renderer.shapeRenderer.draw(ctx, tempgd, opts);
                            
                            
                            // var gridymin = this._yaxis.series_u2p(0);
                            // // IE doesn't return new length on unshift
                            // gd.unshift([gd[0][0], gridymin]);
                            // len = gd.length;
                            // gd.push([gd[len - 1][0], gridymin]);                   
                        }
                        // if stacked, fill to line below 
                        else {
                            var prev = this._prevGridData;
                            for (var i=prev.length; i>0; i--) {
                                gd.push(prev[i-1]);
                                // this._areaPoints.push(prev[i-1]);
                            }
                            if (shadow) {
                                this.renderer.shadowRenderer.draw(ctx, gd, opts);
                            }
                            this._areaPoints = gd;
                            this.renderer.shapeRenderer.draw(ctx, gd, opts);
                        }
                    }
                    /////////////////////////
                    // Not filled to zero
                    ////////////////////////
                    else {                    
                        // if stoking line as well as filling, get a copy of line data.
                        if (fillAndStroke) {
                            var fasgd = gd.slice(0);
                        }
                        // if not stacked, fill down to axis
                        if (this.index == 0 || !this._stack) {
                            // var gridymin = this._yaxis.series_u2p(this._yaxis.min) - this.gridBorderWidth / 2;
                            var gridymin = ctx.canvas.height;
                            // IE doesn't return new length on unshift
                            gd.unshift([gd[0][0], gridymin]);
                            var len = gd.length;
                            gd.push([gd[len - 1][0], gridymin]);                   
                        }
                        // if stacked, fill to line below 
                        else {
                            var prev = this._prevGridData;
                            for (var i=prev.length; i>0; i--) {
                                gd.push(prev[i-1]);
                            }
                        }
                        this._areaPoints = gd;
                        
                        if (shadow) {
                            this.renderer.shadowRenderer.draw(ctx, gd, opts);
                        }

                        this.renderer.shapeRenderer.draw(ctx, gd, opts, isZoomed);
                    }
                    if (fillAndStroke) {
                        var fasopts = $.extend(true, {}, opts, {fill:false, closePath:false});
                        this.renderer.shapeRenderer.draw(ctx, fasgd, fasopts);
                        //////////
                        // TODO: figure out some way to do shadows nicely
                        // if (shadow) {
                        //     this.renderer.shadowRenderer.draw(ctx, fasgd, fasopts);
                        // }
                        // now draw the markers
                        if (this.markerRenderer.show) {
                            if (this.renderer.smooth) {
                                fasgd = this.gridData;
                            }
                            for (i=0; i<fasgd.length; i++) {
                                this.markerRenderer.draw(fasgd[i][0], fasgd[i][1], ctx, opts.markerOptions);
                            }
                            //this.markerRenderer.drawAll(fasgd, ctx, opts.markerOptions);
                        }
                    }
                }
                else {

                    if (this.renderer.bands.show) {
                        var bdat;
                        var bopts = $.extend(true, {}, opts);
                        if (this.renderer.bands.showLines) {
                            bdat = (this.renderer.smooth) ? this.renderer._hiBandSmoothedData : this.renderer._hiBandGridData;
                            this.renderer.shapeRenderer.draw(ctx, bdat, opts);
                            bdat = (this.renderer.smooth) ? this.renderer._lowBandSmoothedData : this.renderer._lowBandGridData;
                            this.renderer.shapeRenderer.draw(ctx, bdat, bopts);
                        }

                        if (this.renderer.bands.fill) {
                            if (this.renderer.smooth) {
                                bdat = this.renderer._hiBandSmoothedData.concat(this.renderer._lowBandSmoothedData.reverse());
                            }
                            else {
                                bdat = this.renderer._hiBandGridData.concat(this.renderer._lowBandGridData.reverse());
                            }
                            this._areaPoints = bdat;
                            bopts.closePath = true;
                            bopts.fill = true;
                            bopts.fillStyle = this.renderer.bands.fillColor;
                            this.renderer.shapeRenderer.draw(ctx, bdat, bopts);
                        }
                    }

                    if (shadow) {
                        this.renderer.shadowRenderer.draw(ctx, gd, opts);
                    }
    
                    this.renderer.shapeRenderer.draw(ctx, gd, opts, isZoomed);
                }
            }
            // calculate the bounding box
            var xmin = xmax = ymin = ymax = null;
            for (i=0; i<this._areaPoints.length; i++) {
                var p = this._areaPoints[i];
                if (xmin > p[0] || xmin == null) {
                    xmin = p[0];
                }
                if (ymax < p[1] || ymax == null) {
                    ymax = p[1];
                }
                if (xmax < p[0] || xmax == null) {
                    xmax = p[0];
                }
                if (ymin > p[1] || ymin == null) {
                    ymin = p[1];
                }
            }

            if (this.type === 'line' && this.renderer.bands.show) {
                ymax = this._yaxis.series_u2p(this.renderer.bands._min);
                ymin = this._yaxis.series_u2p(this.renderer.bands._max);
            }

            this._boundingBox = [[xmin, ymax], [xmax, ymin]];
        
            // now draw the markers
            if (this.markerRenderer.show && !fill) {
                
                var isFill = false;
                var isStroke = false;
                
                if (this.markerRenderer.style.indexOf('fill') > -1) {
                    isFill = true;
                }
                if (this.markerRenderer.style.indexOf('fill') < 0 || this.markerRenderer.stroke) {
                    isStroke = true;
                }

                if (this.renderer.smooth) {
                    gd = this.gridData;
                }

                // customizing (2015-05-14, Carrie Bae) : add option strokeStyleFilter 
                if (isFill && $.isFunction(this.markerRenderer.fillStyleFilter) && isStroke && $.isFunction(this.markerRenderer.strokeStyleFilter)) {   // customizing (2014-04-24 Roy Choi)
                    var sd = this.data;
                    if (!$.isPlainObject(opts.markerOptions)) {
                        opts.markerOptions = {};
                    }
                    if (this.hasNullPoint) {
                        for (i=0; i<gd.length; i++) {
                            if (gd[i][0] != null && !isNaN(gd[i][0]) && gd[i][1] != null && !isNaN(gd[i][1])) {
                                opts.markerOptions.strokeStyle = this.markerRenderer.strokeStyleFilter.call(this, sd[i], i);
                                opts.markerOptions.fillStyle = this.markerRenderer.fillStyleFilter.call(this, sd[i], i);
                                this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                            }
                        }
                    } else {
                        for (i=0; i<gd.length; i++) {
                            opts.markerOptions.strokeStyle = this.markerRenderer.strokeStyleFilter.call(this, sd[i], i);
                            opts.markerOptions.fillStyle = this.markerRenderer.fillStyleFilter.call(this, sd[i], i);
                            this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                        }
                    }

                } else if (isStroke && $.isFunction(this.markerRenderer.strokeStyleFilter)) {
                    var sd = this.data;
                    if (!$.isPlainObject(opts.markerOptions)) {
                        opts.markerOptions = {};
                    }
                    if (this.hasNullPoint) {
                        for (i=0; i<gd.length; i++) {
                            if (gd[i][0] != null && !isNaN(gd[i][0]) && gd[i][1] != null && !isNaN(gd[i][1])) {
                                opts.markerOptions.strokeStyle = this.markerRenderer.strokeStyleFilter.call(this, sd[i], i);
                                this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                            }
                        }
                    } else {
                        for (i=0; i<gd.length; i++) {
                            opts.markerOptions.strokeStyle = this.markerRenderer.strokeStyleFilter.call(this, sd[i], i);
                            this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                        }
                    }
                
                } else if (isFill && $.isFunction(this.markerRenderer.fillStyleFilter)) {
                    var sd = this.data;
                    if (!$.isPlainObject(opts.markerOptions)) {
                        opts.markerOptions = {};
                    }
                    if (this.hasNullPoint) {
                        for (i=0; i<gd.length; i++) {
                            if (gd[i][0] != null && !isNaN(gd[i][0]) && gd[i][1] != null && !isNaN(gd[i][1])) {
                                opts.markerOptions.fillStyle = this.markerRenderer.fillStyleFilter.call(this, sd[i], i);
                                opts.markerOptions.strokeStyle = this.getStrokeStyleByColor(opts.markerOptions.fillStyle);
                                this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                            }
                        }
                    } else {
                        for (i=0; i<gd.length; i++) {
                            opts.markerOptions.fillStyle = this.markerRenderer.fillStyleFilter.call(this, sd[i], i);
                            opts.markerOptions.strokeStyle = this.getStrokeStyleByColor(opts.markerOptions.fillStyle);
                            this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                        }
                    }

                } else {
                    if (this.hasNullPoint) {
                        for (i=0; i<gd.length; i++) {
                        if (gd[i][0] != null && !isNaN(gd[i][0]) && gd[i][1] != null && !isNaN(gd[i][1])) {
                            this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                        }
                    }
                    } else {
                        for (i=0; i<gd.length; i++) {
                        this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
                    }
                        /*var cursor = plot.plugins.cursor;
                        this.markerRenderer.drawAll(gd, ctx, opts.markerOptions, cursor && cursor._zoom.isZoomed);
                        cursor = null;*/
                    }
                }
            }
        }
        
        //ctx.restore();
        

    }; 

    // called within context of plot
    // create a canvas which we can draw on.
    // insert it before the eventCanvas, so eventCanvas will still capture events.

    $.jqplot.postDrawHooks.push(function() {
        // customizing (2012-05-23, Roy Choi) bug fixed
        this.target.find('.jqplot-lineRenderer-highlight-canvas').remove();
    });

    // class: $.jqplot.MarkerRenderer
    // The default jqPlot marker renderer, rendering the points on the line.
    var orgMarkerRenderer = $.jqplot.MarkerRenderer;
    $.jqplot.MarkerRenderer = function(options) {
        orgMarkerRenderer.call(this, options);
        
        // customizing (2011-10-27, Roy Choi)
        // prop: stroke
        // stroke or not. when marker style is filled...
        this.stroke = false;
        // prop: strokeStyle
        // stroke style of marker.
        this.strokeStyle = null;
        
        // customizing (2014-04-14, Roy Choi)
        this.fillRect = false;
        this.strokeRect = false;
    };
    $.jqplot.MarkerRenderer.prototype = new orgMarkerRenderer();

    $.jqplot.MarkerRenderer.prototype.init = function(options) {
        $.extend(true, this, options);
        var sdopt = {
            angle : this.shadowAngle,
            offset : this.shadowOffset,
            alpha : this.shadowAlpha,
            lineWidth : this.lineWidth,
            depth : this.shadowDepth,
            closePath : true
        };
        if (this.style.indexOf('filled') != -1) {
            sdopt.fill = true;
        }
        if (this.style.indexOf('ircle') != -1) {
            sdopt.isarc = true;
            sdopt.closePath = false;
        }
        this.shadowRenderer.init(sdopt);

        var shopt = {
            fill : false,
            isarc : false,
            stroke : false,
            strokeStyle : this.strokeStyle,
            fillStyle : this.color,
            lineWidth : this.lineWidth,
            closePath : true,
            // customizing (2014-04-14, Roy Choi)
            fillRect : this.fillRect,
            strokeRect : this.strokeRect,
            size : this.size
        };
        if (this.style.indexOf('filled') != -1) {
            shopt.fill = true;
        }
        if (this.style.indexOf('ircle') != -1) {
            shopt.isarc = true;
            shopt.closePath = false;
        }
        // customizing (2011-10-27, Roy Choi)
        if (this.stroke) {
            shopt.stroke = true;
            shopt.strokeStyle = this.strokeStyle;
        }
        this.shapeRenderer.init(shopt);
    };

  $.jqplot.MarkerRenderer.prototype.drawAll = function(gd, ctx, options, isZoomed) {
        options = options || {};
        // hack here b/c shape renderer uses canvas based color style options
        // and marker uses css style names.
        if (options.show == null || options.show != false) {
            if (options.color && !options.fillStyle) {
                options.fillStyle = options.color;
            }
            if (options.color && !options.strokeStyle) {
                options.strokeStyle = options.color;
            }

                this.shapeRenderer.drawShapes(ctx, gd, options, this.style, isZoomed);
        }
    };

    // class: $.jqplot.shapeRenderer
    // The default jqPlot shape renderer.  Given a set of points will
    // plot them and either stroke a line (fill = false) or fill them (fill = true).
    // If a filled shape is desired, closePath = true must also be set to close
    // the shape.
    var orgShapeRenderer = $.jqplot.ShapeRenderer;
    $.jqplot.ShapeRenderer = function(options) {
        orgShapeRenderer.call(this, options);
        
        // customizing
        // prop: stroke
        // true to draw shape as a stroked.
        this.stroke = false;
        // prop: strokeStyle
        // css color spec for the stoke style
        this.strokeStyle = null;
        
        // customizing (2014-04-14, Roy Choi)
        this.size = 5;
    };
    $.jqplot.ShapeRenderer.prototype = new orgShapeRenderer();
    
  $.jqplot.ShapeRenderer.prototype.getDiamondPoints = function(x, y) {
      var stretch = 1.2;
      var dx = this.size/2/stretch;
      var dy = this.size/2*stretch;
      var points = [[x-dx, y], [x, y+dy], [x+dx, y], [x, y-dy]];
      return points;
      //this.shapeRenderer.draw(ctx, points, options);
  };
  
  $.jqplot.ShapeRenderer.prototype.getPlusPoints = function(x, y) {
      var stretch = 1.0;
      var dx = this.size/2*stretch;
      var dy = this.size/2*stretch;
      var points1 = [[x, y-dy], [x, y+dy]];
      var points2 = [[x+dx, y], [x-dx, y]];
      return [points1, points2];
      //var opts = $.extend(true, {}, this.options, {closePath:false});
      //this.shapeRenderer.draw(ctx, points1, opts);
      //this.shapeRenderer.draw(ctx, points2, opts);
  };
  
  $.jqplot.ShapeRenderer.prototype.getXPoints = function(x, y) {
      var stretch = 1.0;
      var dx = this.size/2*stretch;
      var dy = this.size/2*stretch;
      //var opts = $.extend(true, {}, this.options, {closePath:false});
      var points1 = [[x-dx, y-dy], [x+dx, y+dy]];
      var points2 = [[x-dx, y+dy], [x+dx, y-dy]];
      return [points1, points2];
      //this.shapeRenderer.draw(ctx, points1, opts);
      //this.shapeRenderer.draw(ctx, points2, opts);
  };
  
  $.jqplot.ShapeRenderer.prototype.getDashPoints = function(x, y) {
      var stretch = 1.0;
      var dx = this.size/2*stretch;
      var dy = this.size/2*stretch;
      var points = [[x-dx, y], [x+dx, y]];
      return points;
      //this.shapeRenderer.draw(ctx, points, options);
  };
  
  $.jqplot.ShapeRenderer.prototype.getLinePoints = function(p1, p2) {
      var points = [p1, p2];
      return points;
      //this.shapeRenderer.draw(ctx, points, options);
  };
  
  $.jqplot.ShapeRenderer.prototype.getSquarePoints = function(x, y) {
      var stretch = 1.0;
      var dx = this.size/2/stretch;
      var dy = this.size/2*stretch;
      var points = [[x-dx, y-dy], [x-dx, y+dy], [x+dx, y+dy], [x+dx, y-dy]];
      return points;
      //this.shapeRenderer.draw(ctx, points, options);
  };
  
  $.jqplot.ShapeRenderer.prototype.getCirclePoints = function(x, y) {
      var radius = this.size/2;
      var end = 2*Math.PI;
      var points = [x, y, radius, 0, end, true];
      return points;
      //this.shapeRenderer.draw(ctx, points, options);
  };
    
    // function: draw
    // draws the shape.
    //
    // ctx - canvas drawing context
    // points - array of points for shapes or
    // [x, y, width, height] for rectangles or
    // [x, y, radius, start angle (rad), end angle (rad)] for circles and arcs.
    $.jqplot.ShapeRenderer.prototype.draw = function(ctx, points, options, isZoomed) {
        ctx.save();
        var opts = (options != null) ? options : {};
        var fill = (opts.fill != null) ? opts.fill : this.fill;
        var stroke = (opts.stroke != null) ? opts.stroke : this.stroke;
        // customizing
        var closePath = (opts.closePath != null) ? opts.closePath : this.closePath;
        var fillRect = (opts.fillRect != null) ? opts.fillRect : this.fillRect;
        var strokeRect = (opts.strokeRect != null) ? opts.strokeRect : this.strokeRect;
        var clearRect = (opts.clearRect != null) ? opts.clearRect : this.clearRect;
        var isarc = (opts.isarc != null) ? opts.isarc : this.isarc;
        var linePattern = (opts.linePattern != null) ? opts.linePattern : this.linePattern;
        var ctxPattern = $.jqplot.LinePattern(ctx, linePattern, closePath);
        
        var breakOnNull = opts.breakOnNull;
        var hasNullPoint = opts.hasNullPoint;
        
        var width = ctx.canvas.width;
        var height = ctx.canvas.height;
        
        ctx.lineWidth = opts.lineWidth || this.lineWidth;
        ctx.lineJoin = opts.lineJoin || this.lineJoin;
        ctx.lineCap = opts.lineCap || this.lineCap;
        ctx.strokeStyle = (opts.strokeStyle || opts.color) || this.strokeStyle || this.color;
        ctx.fillStyle = opts.fillStyle || this.fillStyle;

        ctx.beginPath();
        if (isarc) {
            ctx.arc(points[0], points[1], points[2], points[3], points[4], true);
            if (closePath) {
                ctx.closePath();
            }
            if (fill) {
                ctx.fill();
                // customizing
                if (stroke) {
                    ctx.stroke();
                }
            } else {
                ctx.stroke();
            }
        } else if (clearRect) {
            ctx.clearRect(points[0], points[1], points[2], points[3]);
        } else if (fillRect || strokeRect) {
            if ($.isArray(points[0])) { // customizing (2014-04-14, Roy Choi)
                if (fillRect) {
                    ctx.fillRect(points[0][0], points[0][1], this.size, this.size);
                }
                if (strokeRect) {
                    ctx.strokeRect(points[0][0], points[0][1], this.size, this.size);
                }
            } else {
                if (fillRect) {
                    ctx.fillRect(points[0], points[1], points[2], points[3]);
                }
                if (strokeRect) {
                    ctx.strokeRect(points[0], points[1], points[2], points[3]);
                }
            }
        } else if (points && points.length) {
            var move = true;
            var px = py = null;
            if (isZoomed) {
                if (hasNullPoint) {
                    for (var i = 0, points_len = points.length; i < points_len; i++) {
                        // skip to the first non-null point and move to it.
                        if (points[i][0] != null && !isNaN(points[i][0]) && points[i][1] != null && !isNaN(points[i][1])) {
                            if (move && (breakOnNull || px === null || py === null || (px < 0 && points[i][0] < 0) || (px > width && points[i][0] > width)
                                || (py < 0 && points[i][1] < 0) || (py > height && points[i][1] > height))) {
                                ctxPattern.moveTo(points[i][0], points[i][1]);
                            } else {
                                ctxPattern.lineTo(points[i][0], points[i][1]);
                            }
                            px = points[i][0];
                            py = points[i][1];
                            move = false;
                        } else {
                            move = true;
                            px = py = null;
                        }
                    }
                } else {
                    ctxPattern.moveTo(points[0][0], points[0][1]);
                    for (var i = 1, points_len = points.length; i < points_len; i++) {
                        if ( (px < 0 && points[i][0] < 0) || (px > width && points[i][0] > width)
                            || (py < 0 && points[i][1] < 0) || (py > height && points[i][1] > height)) {
                            ctxPattern.moveTo(points[i][0], points[i][1]);
                        } else {
                            ctxPattern.lineTo(points[i][0], points[i][1]);
                        }
                        px = points[i][0];
                        py = points[i][1];
                    }
                }
            } else {
                if (hasNullPoint) {
                    for (var i = 0, points_len = points.length; i < points_len; i++) {
                        // skip to the first non-null point and move to it.
                        if (points[i][0] != null && !isNaN(points[i][0]) && points[i][1] != null && !isNaN(points[i][1])) {
                            if (move && breakOnNull) {
                                ctxPattern.moveTo(points[i][0], points[i][1]);
                            } else {
                                ctxPattern.lineTo(points[i][0], points[i][1]);
                            }
                            move = false;
                        } else {
                            move = true;
                        }
                    }
                } else {
                    ctxPattern.moveTo(points[0][0], points[0][1]);
                    for (var i = 1, points_len = points.length; i < points_len; i++) {
                        ctxPattern.lineTo(points[i][0], points[i][1]);
                    }
                }
            }
            
            if (closePath) {
                ctxPattern.closePath();
            }
            if (fill) {
                ctx.fill();
                // customizing
                if (stroke) {
                    ctx.stroke();
                }
            } else {
                ctx.stroke();
            }
        }
        ctx.restore();
    };
    
    // function: drawShapes
    // draw all shapes.
    //
    // ctx - canvas drawing context
    // points - array of points for shapes or
    // [x, y, width, height] for rectangles or
    // [x, y, radius, start angle (rad), end angle (rad)] for circles and arcs.
    $.jqplot.ShapeRenderer.prototype.drawShapes = function(ctx, gd, options, style, isZoomed) {
        ctx.save();
        var opts = (options != null) ? options : {};
        var getPoints, closeAngle = false;
        
        switch (style) {
      case 'diamond':
      case 'filledDiamond':
          getPoints = this.getDiamondPoints;
          closeAngle = true;
          break;
      case 'circle':
      case 'filledCircle':
          getPoints = this.getCirclePoints;
          break;
      case 'x':
          getPoints = this.getXPoints;
          opts = $.extend(true, {}, opts, {closePath:false});
          break;
      case 'plus':
          getPoints = this.getPlusPoints;
          opts = $.extend(true, {}, opts, {closePath:false});
          break;
      case 'dash':
          getPoints = this.getDashPoints;
          break;
      /*case 'line':
          this.getLine(x, y, ctx, false, options);
          break;*/
      case 'square':
      case 'filledSquare':
      default:
          getPoints = this.getSquarePoints;
          closeAngle = true;
          break;
    }
        
        var fill = (opts.fill != null) ? opts.fill : this.fill;
        var stroke = (opts.stroke != null) ? opts.stroke : this.stroke;
        // customizing
        var closePath = (opts.closePath != null) ? opts.closePath : this.closePath;
        var fillRect = (opts.fillRect != null) ? opts.fillRect : this.fillRect;
        var strokeRect = (opts.strokeRect != null) ? opts.strokeRect : this.strokeRect;
        var clearRect = (opts.clearRect != null) ? opts.clearRect : this.clearRect;
        var isarc = (opts.isarc != null) ? opts.isarc : this.isarc;
        var linePattern = (opts.linePattern != null) ? opts.linePattern : this.linePattern;
        var ctxPattern = $.jqplot.LinePattern(ctx, linePattern, closePath);
        var points;
        var batchMaxCount = 1000;
        
        var width = ctx.canvas.width;
        var height = ctx.canvas.height;
        
        ctx.lineWidth = opts.lineWidth || this.lineWidth;
        ctx.lineJoin = opts.lineJoin || this.lineJoin;
        ctx.lineCap = opts.lineCap || this.lineCap;
        ctx.strokeStyle = opts.strokeStyle || opts.color || this.strokeStyle || this.color;
        ctx.fillStyle = opts.fillStyle || this.fillStyle;

        ctx.beginPath();
        
        var ctxOptions = {
            lineWidth: ctx.lineWidth,
            lineJoin: ctx.lineJoin,
            lineCap: ctx.lineCap,
            strokeStyle: ctx.strokeStyle,
            fillStyle: ctx.fillStyle
        };
        
        if (isarc) {
            var done = false;
            
            if (isZoomed) {
                for (var i=0, l=gd.length; i<l; i++) {
                    points = getPoints.call(this, gd[i][0], gd[i][1]);
                    
                    if (points[0]+points[2] < 0 || points[0]-points[2] > width || points[1]+points[2] < 0 || points[1]-points[2] > height) {
                        continue;
                    }
                    
                    ctx.moveTo(points[0], points[1]);
                    ctx.arc(points[0], points[1], points[2], points[3], points[4], true);
                    
                    if (i > 0 && i % batchMaxCount === 0) {
                        if (fill) {
                            ctx.fill();
                            if (stroke) {
                                ctx.stroke();
                            }
                        } else {
                            ctx.stroke();
                        }
                        ctx.restore();
                        
                        ctx.lineWidth = ctxOptions.lineWidth;
                        ctx.lineJoin = ctxOptions.lineJoin;
                        ctx.lineCap = ctxOptions.lineCap;
                        ctx.strokeStyle = ctxOptions.strokeStyle;
                        ctx.fillStyle = ctxOptions.fillStyle;
                        
                        ctx.beginPath();
                        
                        done = true;
                    } else {
                        done = false;
                    }
                }
            } else {
                for (var i=0, l=gd.length; i<l; i++) {
                    points = getPoints.call(this, gd[i][0], gd[i][1]);

                    ctx.moveTo(points[0], points[1]);
                    ctx.arc(points[0], points[1], points[2], points[3], points[4], true);
                    
                    if (i > 0 && i % batchMaxCount === 0) {
                        if (fill) {
                            ctx.fill();
                            if (stroke) {
                                ctx.stroke();
                            }
                        } else {
                            ctx.stroke();
                        }
                        ctx.restore();
                        
                        ctx.lineWidth = ctxOptions.lineWidth;
                        ctx.lineJoin = ctxOptions.lineJoin;
                        ctx.lineCap = ctxOptions.lineCap;
                        ctx.strokeStyle = ctxOptions.strokeStyle;
                        ctx.fillStyle = ctxOptions.fillStyle;
                        
                        ctx.beginPath();
                        
                        done = true;
                    } else {
                        done = false;
                    }
                }
            }
            
            
            
            if (!done) {
                if (fill) {
                    ctx.fill();
                    if (stroke) {
                        ctx.stroke();
                    }
                } else {
                    ctx.stroke();
                }
            }

        } else if (clearRect) {
            for (var i=0, l=gd.length; i<l; i++) {
                points = getPoints.call(this, gd[i][0], gd[i][1]);
                ctx.clearRect(points[0], points[1], points[2], points[3]);
            }
        } else if (fillRect && strokeRect) {
            for (var i=0, l=gd.length; i<l; i++) {
                points = getPoints.call(this, gd[i][0], gd[i][1]);
                
                ctx.fillRect(points[0][0], points[0][1], this.size, this.size);
                ctxPattern.moveTo(points[0][0], points[0][1]);
                for (var j = 1, points_len = points.length; j < points_len; j++) {
                    ctxPattern.lineTo(points[j][0], points[j][1]);
                }
                ctxPattern.lineTo(points[0][0], points[0][1]);
            }
            ctx.stroke();
        } else if (fillRect) {
            for (var i=0, l=gd.length; i<l; i++) {
                points = getPoints.call(this, gd[i][0], gd[i][1]);
                
                ctx.fillRect(points[0][0], points[0][1], this.size, this.size);
            }
        } else if (strokeRect) {
            for (var i=0, l=gd.length; i<l; i++) {
                points = getPoints.call(this, gd[i][0], gd[i][1]);

                ctxPattern.moveTo(points[0][0], points[0][1]);
                for (var j = 1, points_len = points.length; j < points_len; j++) {
                    ctxPattern.lineTo(points[j][0], points[j][1]);
                }
                ctxPattern.lineTo(points[0][0], points[0][1]);
            }
            ctx.stroke();
        } else {
            var done = false;
            if (closePath) {
                if (isZoomed) {
                    for (var i=0, l=gd.length; i<l; i++) {
                        points = getPoints.call(this, gd[i][0], gd[i][1]);
                        
                        if (points.filter(function(point) {
                            return point[0] >= 0 && point[0] <= width && point[1] >= 0 && point[1] <= height;
                        }).length === 0) {
                            continue;
                        }
        
                        ctxPattern.moveTo(points[0][0], points[0][1]);
                        for (var j = 1, points_len = points.length; j < points_len; j++) {
                            ctxPattern.lineTo(points[j][0], points[j][1]);
                        }
                        ctxPattern.lineTo(points[0][0], points[0][1]);
        
                        if (i > 0 && i % batchMaxCount === 0) {
        
                            if (fill) {
                                ctx.fill();
                                if (stroke) {
                                    ctx.stroke();
                                }
                            } else {
                                ctx.stroke();
                            }
                            
                            ctx.restore();
                            
                            ctx.lineWidth = ctxOptions.lineWidth;
                            ctx.lineJoin = ctxOptions.lineJoin;
                            ctx.lineCap = ctxOptions.lineCap;
                            ctx.strokeStyle = ctxOptions.strokeStyle;
                            ctx.fillStyle = ctxOptions.fillStyle;
    
                            ctx.beginPath();
                            
                            done = true;
                        } else {
                            done = false;
                        }
                    }
                } else {
                    for (var i=0, l=gd.length; i<l; i++) {
                        points = getPoints.call(this, gd[i][0], gd[i][1]);
        
                        ctxPattern.moveTo(points[0][0], points[0][1]);
                        for (var j = 1, points_len = points.length; j < points_len; j++) {
                            ctxPattern.lineTo(points[j][0], points[j][1]);
                        }
                        ctxPattern.lineTo(points[0][0], points[0][1]);
        
                        if ((i > 0 && i % batchMaxCount === 0) || (fill && stroke)) {
                            if (fill) {
                                ctx.fill();
                                if (stroke) {
                                    ctx.stroke();
                                }
                            } else {
                                ctx.stroke();
                            }
                            
                            ctx.restore();
                            
                            ctx.lineWidth = ctxOptions.lineWidth;
                            ctx.lineJoin = ctxOptions.lineJoin;
                            ctx.lineCap = ctxOptions.lineCap;
                            ctx.strokeStyle = ctxOptions.strokeStyle;
                            ctx.fillStyle = ctxOptions.fillStyle;
    
                            ctx.beginPath();
                            
                            done = true;
                        } else {
                            done = false;
                        }
                    }
                }
                
            } else {
                for (var i=0, l=gd.length; i<l; i++) {
                    points = getPoints.call(this, gd[i][0], gd[i][1]);

                    for (var j = 0, points_len = points.length; j < points_len; j++) {
                        ctxPattern.moveTo(points[j][0][0], points[j][0][1]);
                        for (var k=1; k<points[j].length; k++) {
                            ctxPattern.lineTo(points[j][k][0], points[j][k][1]);
                        }
                    }

                    if (i > 0 && i % batchMaxCount === 0) {
    
                        if (fill) {
                            ctx.fill();
                            if (stroke) {
                                ctx.stroke();
                            }
                        } else {
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                        
                        $.extend(true, ctx, ctxOptions);
                        
                        ctx.beginPath();
                        
                        done = true;
                    } else {
                        done = false;
                    }
                }
            }

            if (!done) {
                if (fill) {
                    ctx.fill();
                    if (stroke) {
                        ctx.stroke();
                    }
                } else {
                    ctx.stroke();
                }
            }
        }
        ctx.restore();
    };
    
    // called with scope of axis
    $.jqplot.LinearAxisRenderer.prototype.pack = function(pos, offsets) {
        // Add defaults for repacking from resetTickValues function.
        pos = pos || {};
        offsets = offsets || this._offsets;
        
        var ticks = this._ticks;
        var max = this.max;
        var min = this.min;
        var offmax = offsets.max;
        var offmin = offsets.min;
        var lshow = (this._label == null) ? false : this._label.show;
        
        for (var p in pos) {
            this._elem.css(p, pos[p]);
        }
        
        this._offsets = offsets;
        // pixellength will be + for x axes and - for y axes becasue pixels always measured from top left.
        var pixellength = offmax - offmin;
        var unitlength = max - min;
        this.tempCalcMin = min;
        this.tempCalcMax = max;
        var tempCalcResult_p2u = unitlength / pixellength;
        var tempCalcResult_u2p = pixellength / unitlength;
        this.tempCalcResult_p2u = tempCalcResult_p2u;
        this.tempCalcResult_u2p = tempCalcResult_u2p;
        
        // point to unit and unit to point conversions references to Plot DOM element top left corner.
        if (this.breakPoints) {
            unitlength = unitlength - this.breakPoints[1] + this.breakPoints[0];
            
            this.p2u = function(p){
                return (p - offmin) * unitlength / pixellength + min;
            };
        
            this.u2p = function(u){
                if (u > this.breakPoints[0] && u < this.breakPoints[1]){
                    u = this.breakPoints[0];
                }
                if (u <= this.breakPoints[0]) {
                    return (u - min) * pixellength / unitlength + offmin;
                }
                else {
                    return (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength + offmin;
                }
            };
                
            if (this.name.charAt(0) == 'x'){
                this.series_u2p = function(u){
                    if (u > this.breakPoints[0] && u < this.breakPoints[1]){
                        u = this.breakPoints[0];
                    }
                    if (u <= this.breakPoints[0]) {
                        return (u - min) * pixellength / unitlength;
                    }
                    else {
                        return (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength;
                    }
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + min;
                };
            }
        
            else {
                this.series_u2p = function(u){
                    if (u > this.breakPoints[0] && u < this.breakPoints[1]){
                        u = this.breakPoints[0];
                    }
                    if (u >= this.breakPoints[1]) {
                        return (u - max) * pixellength / unitlength;
                    }
                    else {
                        return (u + this.breakPoints[1] - this.breakPoints[0] - max) * pixellength / unitlength;
                    }
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + max;
                };
            }
        }
        else {
            this.p2u = function(p){
                return (p - offmin) * unitlength / pixellength + min;
            };
        
            this.u2p = function(u){
                return (u - min) * pixellength / unitlength + offmin;
            };
                
            if (this.name == 'xaxis' || this.name == 'x2axis'){
                this.series_u2p = function(u){
                    return (u - min) * pixellength / unitlength;
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + min;
                };
            }
        
            else {
                this.series_u2p = function(u){
                    return (u - max) * pixellength / unitlength;
                };
                this.series_p2u = function(p){
                    return p * unitlength / pixellength + max;
                };
            }
        }
        
        if (this.show) {
            if (this.name == 'xaxis' || this.name == 'x2axis') {
                for (var i=0; i<ticks.length; i++) {
                    var t = ticks[i];
                    if (t.show && t.showLabel) {
                        var shim;
                        
                        if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) {
                            // will need to adjust auto positioning based on which axis this is.
                            var temp = (this.name == 'xaxis') ? 1 : -1;
                            switch (t.labelPosition) {
                                case 'auto':
                                    // position at end
                                    if (temp * t.angle < 0) {
                                        shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    }
                                    // position at start
                                    else {
                                        shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'end':
                                    shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                                case 'start':
                                    shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    break;
                                case 'middle':
                                    shim = -t.getWidth()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                                default:
                                    shim = -t.getWidth()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    break;
                            }
                        }
                        else {
                            shim = -t.getWidth()/2;
                        }
                        var val = this.u2p(t.value) + shim + 'px';
                        t._elem.css('left', val);
                        t.pack();
                    }
                }
                if (lshow) {
                    var w = this._label._elem.outerWidth(true);
                    this._label._elem.css('left', offmin + pixellength/2 - w/2 + 'px');
                    if (this.name == 'xaxis') {
                        this._label._elem.css('bottom', '0px');
                    }
                    else {
                        this._label._elem.css('top', '0px');
                    }
                    this._label.pack();
                }
            }
            else {
                for (var i=0; i<ticks.length; i++) {
                    var t = ticks[i];
                    if (t.show && t.showLabel) {                        
                        var shim;
                        if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) {
                            // will need to adjust auto positioning based on which axis this is.
                            var temp = (this.name == 'yaxis') ? 1 : -1;
                            switch (t.labelPosition) {
                                case 'auto':
                                    // position at end
                                case 'end':
                                    if (temp * t.angle < 0) {
                                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                                    }
                                    else {
                                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'start':
                                    if (t.angle > 0) {
                                        shim = -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2;
                                    }
                                    else {
                                        shim = -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                                    }
                                    break;
                                case 'middle':
                                    // if (t.angle > 0) {
                                    //     shim = -t.getHeight()/2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                                    // }
                                    // else {
                                    //     shim = -t.getHeight()/2 - t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                                    // }
                                    shim = -t.getHeight()/2;
                                    break;
                                default:
                                    shim = -t.getHeight()/2;
                                    break;
                            }
                        }
                        else {
                            shim = -t.getHeight()/2;
                        }
                        
                        var val = this.u2p(t.value) + shim + 'px';
                        t._elem.css('top', val);
                        t.pack();
                    }
                }
                if (lshow) {
                    var h = this._label._elem.outerHeight(true);
                    this._label._elem.css('top', offmax - pixellength/2 - h/2 + 'px');
                    if (this.name == 'yaxis') {
                        this._label._elem.css('left', '0px');
                    }
                    else {
                        this._label._elem.css('right', '0px');
                    }   
                    this._label.pack();
                }
            }
        }

        ticks = null;
    };

  // called with scope of axis
  $.jqplot.LinearAxisRenderer.prototype.createTicks = function(plot) {
      // we're are operating on an axis here
      var ticks = this._ticks;
      var userTicks = this.ticks;
      var name = this.name;
      // databounds were set on axis initialization.
      var db = this._dataBounds;
      var dim = (this.name.charAt(0) === 'x') ? this._plotDimensions.width : this._plotDimensions.height;
      var interval;
      var min, max;
      var pos1, pos2;
      var tt, i;
      // get a copy of user's settings for min/max.
      var userMin = this.min;
      var userMax = this.max;
      var userNT = this.numberTicks;
      var userTI = this.tickInterval;

      var threshold = 30;
      this._scalefact =  (Math.max(dim, threshold+1) - threshold)/300.0;
      
      // if we already have ticks, use them.
      // ticks must be in order of increasing value.
      
      if (userTicks.length) {
          // ticks could be 1D or 2D array of [val, val, ,,,] or [[val, label], [val, label], ...] or mixed
          for (i=0; i<userTicks.length; i++){
              var ut = userTicks[i];
              var t = new this.tickRenderer(this.tickOptions);
              if ($.isArray(ut)) {
                  t.value = ut[0];
                  if (this.breakPoints) {
                      if (ut[0] == this.breakPoints[0]) {
                          t.label = this.breakTickLabel;
                          t._breakTick = true;
                          t.showGridline = false;
                          t.showMark = false;
                      }
                      else if (ut[0] > this.breakPoints[0] && ut[0] <= this.breakPoints[1]) {
                          t.show = false;
                          t.showGridline = false;
                          t.label = ut[1];
                      }
                      else {
                          t.label = ut[1];
                      }
                  }
                  else {
                      t.label = ut[1];
                  }
                  t.setTick(ut[0], this.name);
                  this._ticks.push(t);
              }

              else if ($.isPlainObject(ut)) {
                  $.extend(true, t, ut);
                  t.axis = this.name;
                  this._ticks.push(t);
              }
              
              else {
                  t.value = ut;
                  if (this.breakPoints) {
                      if (ut == this.breakPoints[0]) {
                          t.label = this.breakTickLabel;
                          t._breakTick = true;
                          t.showGridline = false;
                          t.showMark = false;
                      }
                      else if (ut > this.breakPoints[0] && ut <= this.breakPoints[1]) {
                          t.show = false;
                          t.showGridline = false;
                      }
                  }
                  t.setTick(ut, this.name);

                  if (this.rendererOptions.dataType === 'index' && Math.abs(ut % 1) > 0) {
                      t.show = false;
                      t.showGridline = false;
                  }

                  this._ticks.push(t);
              }
          }
          this.numberTicks = userTicks.length;
          this.min = this._ticks[0].value;
          this.max = this._ticks[this.numberTicks-1].value;
          this.tickInterval = (this.max - this.min) / (this.numberTicks - 1);
      }
      
      // we don't have any ticks yet, let's make some!
      else {
          if (name == 'xaxis' || name == 'x2axis') {
              dim = this._plotDimensions.width;
          }
          else {
              dim = this._plotDimensions.height;
          }

          var _numberTicks = this.numberTicks;

          // if aligning this axis, use number of ticks from previous axis.
          // Do I need to reset somehow if alignTicks is changed and then graph is replotted??
          if (this.alignTicks) {
              if (this.name === 'x2axis' && plot.axes.xaxis.show) {
                  _numberTicks = plot.axes.xaxis.numberTicks;
              }
              else if (this.name.charAt(0) === 'y' && this.name !== 'yaxis' && this.name !== 'yMidAxis' && plot.axes.yaxis.show) {
                  _numberTicks = plot.axes.yaxis.numberTicks;
              }
          }
      
          min = ((this.min != null) ? this.min : db.min);
          max = ((this.max != null) ? this.max : db.max);

          var range;
          if (max === min && max != null) {
              range = 1;
              max += 0.5;
              min -= 0.5;
          } else {
              range = max - min;
          }
          var rmin, rmax;
          var temp;

          if (this.tickOptions == null || !this.tickOptions.formatString) {
              this._overrideFormatString = true;
          }

          // Doing complete autoscaling
          if ((this.min == null || this.max == null) && this.tickInterval == null && this.autoscale) {
              // Check if user must have tick at 0 or 100 and ensure they are in range.
              // The autoscaling algorithm will always place ticks at 0 and 100 if they are in range.
              if (this.forceTickAt0) {
                  if (min > 0) {
                      min = 0;
                  }
                  if (max < 0) {
                      max = 0;
                  }
              }

              if (this.forceTickAt100) {
                  if (min > 100) {
                      min = 100;
                  }
                  if (max < 100) {
                      max = 100;
                  }
              }

              var keepMin = false,
                  keepMax = false;

              if (this.min != null) {
                  keepMin = true;
              }

              else if (this.max != null) {
                  keepMax = true;
              }

              // var threshold = 30;
              // var tdim = Math.max(dim, threshold+1);
              // this._scalefact =  (tdim-threshold)/300.0;
              var ret = $.jqplot.LinearTickGenerator(min, max, this._scalefact, _numberTicks, keepMin, keepMax); 
              // calculate a padded max and min, points should be less than these
              // so that they aren't too close to the edges of the plot.
              // User can adjust how much padding is allowed with pad, padMin and PadMax options. 
              // If min or max is set, don't pad that end of axis.
              var tumin = (this.min != null) ? min : min + range*(this.padMin - 1);
              var tumax = (this.max != null) ? max : max - range*(this.padMax - 1);

              // if they're equal, we shouldn't have to do anything, right?
              // if (min <=tumin || max >= tumax) {
              if (min <tumin || max > tumax) {
                  tumin = (this.min != null) ? min : min - range*(this.padMin - 1);
                  tumax = (this.max != null) ? max : max + range*(this.padMax - 1);
                  ret = $.jqplot.LinearTickGenerator(tumin, tumax, this._scalefact, _numberTicks, keepMin, keepMax);
              }

              this.min = ret[0];
              this.max = ret[1];
              // if numberTicks specified, it should return the same.
              this.numberTicks = ret[2];
              this._autoFormatString = ret[3];
              this.tickInterval = ret[4];
          } 

          // User has specified some axis scale related option, can use auto algorithm
          else {
              
              // if min and max are same, space them out a bit
              if (min == max) {
                  var adj = 0.05;
                  if (min > 0) {
                      adj = Math.max(Math.log(min)/Math.LN10, 0.05);
                  }
                  min -= adj;
                  max += adj;
              }
              
              // autoscale.  Can't autoscale if min or max is supplied.
              // Will use numberTicks and tickInterval if supplied.  Ticks
              // across multiple axes may not line up depending on how
              // bars are to be plotted.
              if (!this.autoscale && (this.min == null || this.max == null || ((this._options.min == null || this._options.max == null) && plot.plugins.cursor && plot.plugins.cursor._zoom.isZoomed)) && this._options.tickSpacing) {
                  var rrange, ti, margin;
                  var forceMinZero = false;
                  var forceZeroLine = false;
                  var intervals = {min:null, max:null, average:null, stddev:null};
                  // if any series are bars, or if any are fill to zero, and if this
                  // is the axis to fill toward, check to see if we can start axis at zero.
                  for (var i=0; i<this._series.length; i++) {
                      var s = this._series[i];
                      
                      if (s.renderer.constructor == $.jqplot.BigDataScatterRenderer) {
                        continue;
                      }
                      
                      var faname = (s.fillAxis == 'x') ? s._xaxis.name : s._yaxis.name;
                      // check to see if this is the fill axis
                      if (this.name == faname) {
                          var vals = s._plotValues[s.fillAxis];
                          var vmin = vals[0];
                          var vmax = vals[0];
                          for (var j=1; j<vals.length; j++) {
                              if (vals[j] < vmin) {
                                  vmin = vals[j];
                              }
                              else if (vals[j] > vmax) {
                                  vmax = vals[j];
                              }
                          }
                          var dp = (vmax - vmin) / vmax;
                          // is this sries a bar?
                          if (s.renderer.constructor == $.jqplot.BarRenderer) {
                              // if no negative values and could also check range.
                              if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {
                                  forceMinZero = true;
                              }
                              else {
                                  forceMinZero = false;
                                  if (s.fill && s.fillToZero && vmin < 0 && vmax > 0) {
                                      forceZeroLine = true;
                                  }
                                  else {
                                      forceZeroLine = false;
                                  }
                              }
                          }
                          
                          // if not a bar and filling, use appropriate method.
                          else if (s.fill) {
                              if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {
                                  forceMinZero = true;
                              }
                              else if (vmin < 0 && vmax > 0 && s.fillToZero) {
                                  forceMinZero = false;
                                  forceZeroLine = true;
                              }
                              else {
                                  forceMinZero = false;
                                  forceZeroLine = false;
                              }
                          }
                          
                          // if not a bar and not filling, only change existing state
                          // if it doesn't make sense
                          else if (vmin < 0) {
                              forceMinZero = false;
                          }
                      }
                  }
                  
                  // check if we need make axis min at 0.
                  if (forceMinZero) {
                      // compute number of ticks
                      this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                      this.min = 0;
                      userMin = 0;
                      // what order is this range?
                      // what tick interval does that give us?
                      ti = max/(this.numberTicks-1);
                      temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                      if (ti/temp == parseInt(ti/temp, 10)) {
                          ti += temp;
                      }
                      this.tickInterval = Math.ceil(ti/temp) * temp;
                      this.max = this.tickInterval * (this.numberTicks - 1);
                  }
                  
                  // check if we need to make sure there is a tick at 0.
                  else if (forceZeroLine) {
                      // compute number of ticks
                      this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                      var ntmin = Math.ceil(Math.abs(min)/range*(this.numberTicks-1));
                      var ntmax = this.numberTicks - 1  - ntmin;
                      ti = Math.max(Math.abs(min/ntmin), Math.abs(max/ntmax));
                      temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                      this.tickInterval = Math.ceil(ti/temp) * temp;
                      this.max = this.tickInterval * ntmax;
                      this.min = -this.tickInterval * ntmin;
                  }
                  
                  // if nothing else, do autoscaling which will try to line up ticks across axes.
                  else {  
                      if (this.numberTicks == null){
                          if (this.tickInterval) {
                              this.numberTicks = 3 + Math.ceil(range / this.tickInterval);
                          }
                          else {
                              this.numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                          }
                      }
              
                      if (this.tickInterval == null) {
                          // get a tick interval
                          ti = range/(this.numberTicks - 1);

                          if (ti < 1) {
                              temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                          }
                          else {
                              temp = 1;
                          }
                          this.tickInterval = Math.ceil(ti*temp*this.pad)/temp;
                      }
                      else {
                          temp = 1 / this.tickInterval;
                      }
                      
                      // try to compute a nicer, more even tick interval
                      // temp = Math.pow(10, Math.floor(Math.log(ti)/Math.LN10));
                      // this.tickInterval = Math.ceil(ti/temp) * temp;
                      rrange = this.tickInterval * (this.numberTicks - 1);
                      margin = (rrange - range)/2;
         
                      if (this.min == null) {
                          this.min = Math.floor(temp*(min-margin))/temp;
                      }
                      if (this.max == null) {
                          this.max = this.min + rrange;
                      }
                  }

                  // Compute a somewhat decent format string if it is needed.
                  // get precision of interval and determine a format string.
                  var sf = $.jqplot.getSignificantFigures(this.tickInterval);

                  var fstr;

                  // if we have only a whole number, use integer formatting
                  if (sf.digitsLeft >= sf.significantDigits) {
                      fstr = '%d';
                  }

                  else {
                      var temp = Math.max(0, 5 - sf.digitsLeft);
                      temp = Math.min(temp, sf.digitsRight);
                      fstr = '%.'+ temp + 'f';
                  }

                  this._autoFormatString = fstr;
              }
              
              // Use the default algorithm which pads each axis to make the chart
              // centered nicely on the grid.
              else {

                  rmin = (this.min != null) ? this.min : min - range*(this.padMin - 1);
                  rmax = (this.max != null) ? this.max : max + range*(this.padMax - 1);
                  range = rmax - rmin;
      
                  if (this.numberTicks == null){
                      // if tickInterval is specified by user, we will ignore computed maximum.
                      // max will be equal or greater to fit even # of ticks.
                      if (this.tickInterval != null) {
                          this.numberTicks = Math.ceil((rmax - rmin)/this.tickInterval)+1;
                      }
                      else if (dim > 100) {
                          this.numberTicks = parseInt(3+(dim-100)/75, 10);
                      }
                      else {
                          this.numberTicks = 2;
                      }
                  }
              
                  if (this.tickInterval == null) {
                      this.tickInterval = range / (this.numberTicks-1);
                  }
                  
                  if (this.max == null) {
                      rmax = rmin + this.tickInterval*(this.numberTicks - 1);
                  }        
                  if (this.min == null) {
                      rmin = rmax - this.tickInterval*(this.numberTicks - 1);
                  }

                  // get precision of interval and determine a format string.
                  var sf = $.jqplot.getSignificantFigures(this.tickInterval);

                  var fstr;

                  // if we have only a whole number, use integer formatting
                  if (sf.digitsLeft >= sf.significantDigits) {
                      fstr = '%d';
                  }

                  else {
                      var temp = Math.max(0, 5 - sf.digitsLeft);
                      temp = Math.min(temp, sf.digitsRight);
                      fstr = '%.'+ temp + 'f';
                  }


                  this._autoFormatString = fstr;

                  this.min = rmin;
                  this.max = rmax;
              }
              
              if (this.renderer.constructor == $.jqplot.LinearAxisRenderer && this._autoFormatString == '') {
                  // fix for misleading tick display with small range and low precision.
                  range = this.max - this.min;
                  // figure out precision
                  var temptick = new this.tickRenderer(this.tickOptions);
                  // use the tick formatString or, the default.
                  var fs = temptick.formatString || $.jqplot.config.defaultTickFormatString; 
                  var fs = fs.match($.jqplot.sprintf.regex)[0];
                  var precision = 0;
                  if (fs) {
                      if (fs.search(/[fFeEgGpP]/) > -1) {
                          var m = fs.match(/\%\.(\d{0,})?[eEfFgGpP]/);
                          if (m) {
                              precision = parseInt(m[1], 10);
                          }
                          else {
                              precision = 6;
                          }
                      }
                      else if (fs.search(/[di]/) > -1) {
                          precision = 0;
                      }
                      // fact will be <= 1;
                      var fact = Math.pow(10, -precision);
                      if (this.tickInterval < fact) {
                          // need to correct underrange
                          if (userNT == null && userTI == null) {
                              this.tickInterval = fact;
                              if (userMax == null && userMin == null) {
                                  // this.min = Math.floor((this._dataBounds.min - this.tickInterval)/fact) * fact;
                                  this.min = Math.floor(this._dataBounds.min/fact) * fact;
                                  if (this.min == this._dataBounds.min) {
                                      this.min = this._dataBounds.min - this.tickInterval;
                                  }
                                  // this.max = Math.ceil((this._dataBounds.max + this.tickInterval)/fact) * fact;
                                  this.max = Math.ceil(this._dataBounds.max/fact) * fact;
                                  if (this.max == this._dataBounds.max) {
                                      this.max = this._dataBounds.max + this.tickInterval;
                                  }
                                  var n = (this.max - this.min)/this.tickInterval;
                                  n = n.toFixed(11);
                                  n = Math.ceil(n);
                                  this.numberTicks = n + 1;
                              }
                              else if (userMax == null) {
                                  // add one tick for top of range.
                                  var n = (this._dataBounds.max - this.min) / this.tickInterval;
                                  n = n.toFixed(11);
                                  this.numberTicks = Math.ceil(n) + 2;
                                  this.max = this.min + this.tickInterval * (this.numberTicks-1);
                              }
                              else if (userMin == null) {
                                  // add one tick for bottom of range.
                                  var n = (this.max - this._dataBounds.min) / this.tickInterval;
                                  n = n.toFixed(11);
                                  this.numberTicks = Math.ceil(n) + 2;
                                  this.min = this.max - this.tickInterval * (this.numberTicks-1);
                              }
                              else {
                                  // calculate a number of ticks so max is within axis scale
                                  this.numberTicks = Math.ceil((userMax - userMin)/this.tickInterval) + 1;
                                  // if user's min and max don't fit evenly in ticks, adjust.
                                  // This takes care of cases such as user min set to 0, max set to 3.5 but tick
                                  // format string set to %d (integer ticks)
                                  this.min =  Math.floor(userMin*Math.pow(10, precision))/Math.pow(10, precision);
                                  this.max =  Math.ceil(userMax*Math.pow(10, precision))/Math.pow(10, precision);
                                  // this.max = this.min + this.tickInterval*(this.numberTicks-1);
                                  this.numberTicks = Math.ceil((this.max - this.min)/this.tickInterval) + 1;
                              }
                          }
                      }
                  }
              }
              
          }
          
          if (this._overrideFormatString && this._autoFormatString != '') {
              this.tickOptions = this.tickOptions || {};
              this.tickOptions.formatString = this._autoFormatString;
          }

          var t, to;
          for (var i=0; i<this.numberTicks; i++){
              tt = this.min + i * this.tickInterval;
              t = new this.tickRenderer(this.tickOptions);
              // var t = new $.jqplot.AxisTickRenderer(this.tickOptions);

              t.setTick(tt, this.name);
              this._ticks.push(t);

              if (i < this.numberTicks - 1) {
                  for (var j=0; j<this.minorTicks; j++) {
                      tt += this.tickInterval/(this.minorTicks+1);
                      to = $.extend(true, {}, this.tickOptions, {name:this.name, value:tt, label:'', isMinorTick:true});
                      t = new this.tickRenderer(to);
                      this._ticks.push(t);
                  }
              }
              t = null;
          }
      }

      if (this.tickInset) {
          this.min = this.min - this.tickInset * this.tickInterval;
          this.max = this.max + this.tickInset * this.tickInterval;
      }

      ticks = null;
  };
  
  // called with scope of axis
  $.jqplot.LinearAxisRenderer.prototype.calculateTicks = function(plot) {
      // we're are operating on an axis here
      var ticks = this._ticks;
      var userTicks = this.ticks;
      var name = this.name;
      // databounds were set on axis initialization.
      var db = this._dataBounds;
      var legendSize = 0;
      if (plot.legend.show && plot.legend._elem) {
          if (this.name.charAt(0) === 'x' && (plot.legend.location === 'e' || plot.legend.location === 'w')) {
              legendSize = plot.legend._elem.width();
          } else if (this.name.charAt(0) === 'y' && (plot.legend.location === 's' || plot.legend.location === 'n')) {
              legendSize = plot.legend._elem.height();
          }
      }
      
      var dim = ((this.name.charAt(0) === 'x') ? this._plotDimensions.width : this._plotDimensions.height) - legendSize;
      var interval;
      var min, max;
      var pos1, pos2;
      var tt, i;
      // get a copy of user's settings for min/max.
      var userMin = this.min;
      var userMax = this.max;
      var userNT = this.numberTicks;
      var userTI = this.tickInterval;
      
      var numberTicks = this.numberTicks;
      var tickInterval = this.tickInterval;
      
      var _autoFormatString;
      
      var result = {
        min: this.min,
        max: this.max
      };

      var threshold = 30;
      _scalefact =  (Math.max(dim, threshold+1) - threshold)/300.0;

      var _numberTicks = this.numberTicks = this.numberTicks != null || this.dataType != 'date' ? this.numberTicks : 
            this.tickSpacing < dim ? Math.floor(dim / this.tickSpacing) + 1 : 2;

      // if aligning this axis, use number of ticks from previous axis.
      // Do I need to reset somehow if alignTicks is changed and then graph is replotted??
      if (this.alignTicks) {
          if (this.name === 'x2axis' && plot.axes.xaxis.show) {
              _numberTicks = plot.axes.xaxis.numberTicks;
          }
          else if (this.name.charAt(0) === 'y' && this.name !== 'yaxis' && this.name !== 'yMidAxis' && plot.axes.yaxis.show) {
              _numberTicks = plot.axes.yaxis.numberTicks;
          }
      }
  
      min = ((this.min != null) ? this.min : db.min);
      max = ((this.max != null) ? this.max : db.max);

      var range;
      if (max === min && max != null) {
          range = 1;
          max += 0.5;
          min -= 0.5;
      } else {
          range = max - min;
      }
      var rmin, rmax;
      var temp;

      if (this.tickOptions == null || !this.tickOptions.formatString) {
          this._overrideFormatString = true;
      }

      // Doing complete autoscaling
      if ((this.min == null || this.max == null) && this.tickInterval == null && this.autoscale) {
          // Check if user must have tick at 0 or 100 and ensure they are in range.
          // The autoscaling algorithm will always place ticks at 0 and 100 if they are in range.
          if (this.forceTickAt0) {
              if (min > 0) {
                  min = 0;
              }
              if (max < 0) {
                  max = 0;
              }
          }

          if (this.forceTickAt100) {
              if (min > 100) {
                  min = 100;
              }
              if (max < 100) {
                  max = 100;
              }
          }

          var keepMin = false,
              keepMax = false;

          if (this.min != null) {
              keepMin = true;
          }

          else if (this.max != null) {
              keepMax = true;
          }

          // var threshold = 30;
          // var tdim = Math.max(dim, threshold+1);
          // _scalefact =  (tdim-threshold)/300.0;
          var ret = $.jqplot.LinearTickGenerator(min, max, _scalefact, _numberTicks, keepMin, keepMax); 
          // calculate a padded max and min, points should be less than these
          // so that they aren't too close to the edges of the plot.
          // User can adjust how much padding is allowed with pad, padMin and PadMax options. 
          // If min or max is set, don't pad that end of axis.
          var tumin = (this.min != null) ? min : min + range*(this.padMin - 1);
          var tumax = (this.max != null) ? max : max - range*(this.padMax - 1);

          // if they're equal, we shouldn't have to do anything, right?
          // if (min <=tumin || max >= tumax) {
          if (min <tumin || max > tumax) {
              tumin = (this.min != null) ? min : min - range*(this.padMin - 1);
              tumax = (this.max != null) ? max : max + range*(this.padMax - 1);
              ret = $.jqplot.LinearTickGenerator(tumin, tumax, _scalefact, _numberTicks, keepMin, keepMax);
          }

          result.min = ret[0];
          result.max = ret[1];
          numberTicks = ret[2];
          tickInterval = ret[4];
      } 

      // User has specified some axis scale related option, can use auto algorithm
      else {
          
          // if min and max are same, space them out a bit
          if (min == max) {
              var adj = 0.05;
              if (min > 0) {
                  adj = Math.max(Math.log(min)/Math.LN10, 0.05);
              }
              min -= adj;
              max += adj;
          }
          
          // autoscale.  Can't autoscale if min or max is supplied.
          // Will use numberTicks and tickInterval if supplied.  Ticks
          // across multiple axes may not line up depending on how
          // bars are to be plotted.
          if (!this.autoscale && (this.min == null || this.max == null || ((this._options.min == null || this._options.max == null) && plot.plugins.cursor && plot.plugins.cursor._zoom.isZoomed)) && this._options.tickSpacing) {
              var rrange, ti, margin;
              var forceMinZero = false;
              var forceZeroLine = false;
              var intervals = {min:null, max:null, average:null, stddev:null};
              // if any series are bars, or if any are fill to zero, and if this
              // is the axis to fill toward, check to see if we can start axis at zero.
              for (var i=0; i<this._series.length; i++) {
                  var s = this._series[i];
                  
                  if (s.renderer.constructor == $.jqplot.BigDataScatterRenderer) {
                    continue;
                  }
                  
                  var faname = (s.fillAxis == 'x') ? s._xaxis.name : s._yaxis.name;
                  // check to see if this is the fill axis
                  if (this.name == faname) {
                      var vals = s._plotValues[s.fillAxis];
                      var vmin = vals[0];
                      var vmax = vals[0];
                      for (var j=1; j<vals.length; j++) {
                          if (vals[j] < vmin) {
                              vmin = vals[j];
                          }
                          else if (vals[j] > vmax) {
                              vmax = vals[j];
                          }
                      }
                      var dp = (vmax - vmin) / vmax;
                      // is this sries a bar?
                      if (s.renderer.constructor == $.jqplot.BarRenderer) {
                          // if no negative values and could also check range.
                          if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {
                              forceMinZero = true;
                          }
                          else {
                              forceMinZero = false;
                              if (s.fill && s.fillToZero && vmin < 0 && vmax > 0) {
                                  forceZeroLine = true;
                              }
                              else {
                                  forceZeroLine = false;
                              }
                          }
                      }
                      
                      // if not a bar and filling, use appropriate method.
                      else if (s.fill) {
                          if (vmin >= 0 && (s.fillToZero || dp > 0.1)) {
                              forceMinZero = true;
                          }
                          else if (vmin < 0 && vmax > 0 && s.fillToZero) {
                              forceMinZero = false;
                              forceZeroLine = true;
                          }
                          else {
                              forceMinZero = false;
                              forceZeroLine = false;
                          }
                      }
                      
                      // if not a bar and not filling, only change existing state
                      // if it doesn't make sense
                      else if (vmin < 0) {
                          forceMinZero = false;
                      }
                  }
              }
              
              // check if we need make axis min at 0.
              if (forceMinZero) {
                  // compute number of ticks
                  numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                  result.min = 0;
                  userMin = 0;
                  // what order is this range?
                  // what tick interval does that give us?
                  ti = max/(numberTicks-1);
                  temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                  if (ti/temp == parseInt(ti/temp, 10)) {
                      ti += temp;
                  }
                  result.max = (Math.ceil(ti/temp) * temp) * (numberTicks - 1);
              }
              
              // check if we need to make sure there is a tick at 0.
              else if (forceZeroLine) {
                  // compute number of ticks
                  numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                  var ntmin = Math.ceil(Math.abs(min)/range*(numberTicks-1));
                  var ntmax = numberTicks - 1  - ntmin;
                  ti = Math.max(Math.abs(min/ntmin), Math.abs(max/ntmax));
                  temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                  tickInterval = Math.ceil(ti/temp) * temp;
                  result.max = tickInterval * ntmax;
                  result.min = -tickInterval * ntmin;
              }
              
              // if nothing else, do autoscaling which will try to line up ticks across axes.
              else {
                  if (numberTicks == null){
                      if (tickInterval) {
                          numberTicks = 3 + Math.ceil(range / this.tickInterval);
                      }
                      else {
                          numberTicks = 2 + Math.ceil((dim-(this.tickSpacing-1))/this.tickSpacing);
                      }
                  }
                  
                  if (tickInterval == null) {
                      // get a tick interval
                      ti = range/(numberTicks - 1);

                      if (ti < 1) {
                          temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti)/Math.LN10)));
                      }
                      else {
                          temp = 1;
                      }
                      tickInterval = Math.ceil(ti*temp*this.pad)/temp;
                  }
                  else {
                      temp = 1 / tickInterval;
                  }
                  
                  // try to compute a nicer, more even tick interval
                  // temp = Math.pow(10, Math.floor(Math.log(ti)/Math.LN10));
                  // this.tickInterval = Math.ceil(ti/temp) * temp;
                  rrange = tickInterval * (this.numberTicks - 1);
                  margin = (rrange - range)/2;
     
                  if (result.min == null) {
                      result.min = Math.floor(temp*(min-margin))/temp;
                  }
                  if (result.max == null) {
                      result.max = result.min + rrange;
                  }
              }

              // Compute a somewhat decent format string if it is needed.
              // get precision of interval and determine a format string.
              var sf = $.jqplot.getSignificantFigures(tickInterval);

              var fstr;

              // if we have only a whole number, use integer formatting
              if (sf.digitsLeft >= sf.significantDigits) {
                  fstr = '%d';
              }

              else {
                  var temp = Math.max(0, 5 - sf.digitsLeft);
                  temp = Math.min(temp, sf.digitsRight);
                  fstr = '%.'+ temp + 'f';
              }

              _autoFormatString = fstr;
          }
          
          // Use the default algorithm which pads each axis to make the chart
          // centered nicely on the grid.
          else {

              rmin = (result.min != null) ? result.min : min - range*(this.padMin - 1);
              rmax = (result.max != null) ? result.max : max + range*(this.padMax - 1);
              range = rmax - rmin;
  
              if (numberTicks == null){
                  // if tickInterval is specified by user, we will ignore computed maximum.
                  // max will be equal or greater to fit even # of ticks.
                  if (tickInterval != null) {
                      numberTicks = Math.ceil((rmax - rmin)/tickInterval)+1;
                  }
                  else if (dim > 100) {
                      numberTicks = parseInt(3+(dim-100)/75, 10);
                  }
                  else {
                      numberTicks = 2;
                  }
              }
          
              if (tickInterval == null) {
                  tickInterval = range / (numberTicks-1);
              }
              
              if (result.max == null) {
                  rmax = rmin + tickInterval*(numberTicks - 1);
              }        
              if (result.min == null) {
                  rmin = rmax - tickInterval*(numberTicks - 1);
              }

              // get precision of interval and determine a format string.
              var sf = $.jqplot.getSignificantFigures(tickInterval);

              var fstr;

              // if we have only a whole number, use integer formatting
              if (sf.digitsLeft >= sf.significantDigits) {
                  fstr = '%d';
              }

              else {
                  var temp = Math.max(0, 5 - sf.digitsLeft);
                  temp = Math.min(temp, sf.digitsRight);
                  fstr = '%.'+ temp + 'f';
              }


              _autoFormatString = fstr;

              result.min = rmin;
              result.max = rmax;
          }
          
          if (this.renderer.constructor == $.jqplot.LinearAxisRenderer && this._autoFormatString == '') {
              // fix for misleading tick display with small range and low precision.
              range = result.max - result.min;
              // figure out precision
              var temptick = new this.tickRenderer(this.tickOptions);
              // use the tick formatString or, the default.
              var fs = temptick.formatString || $.jqplot.config.defaultTickFormatString; 
              var fs = fs.match($.jqplot.sprintf.regex)[0];
              var precision = 0;
              if (fs) {
                  if (fs.search(/[fFeEgGpP]/) > -1) {
                      var m = fs.match(/\%\.(\d{0,})?[eEfFgGpP]/);
                      if (m) {
                          precision = parseInt(m[1], 10);
                      }
                      else {
                          precision = 6;
                      }
                  }
                  else if (fs.search(/[di]/) > -1) {
                      precision = 0;
                  }
                  // fact will be <= 1;
                  var fact = Math.pow(10, -precision);
                  if (tickInterval < fact) {
                      // need to correct underrange
                      if (userNT == null && userTI == null) {
                          tickInterval = fact;
                          if (userMax == null && userMin == null) {
                              // this.min = Math.floor((this._dataBounds.min - this.tickInterval)/fact) * fact;
                              result.min = Math.floor(this._dataBounds.min/fact) * fact;
                              if (result.min == this._dataBounds.min) {
                                  result.min = this._dataBounds.min - tickInterval;
                              }
                              // this.max = Math.ceil((this._dataBounds.max + this.tickInterval)/fact) * fact;
                              result.max = Math.ceil(this._dataBounds.max/fact) * fact;
                              if (result.max == this._dataBounds.max) {
                                  result.max = this._dataBounds.max + tickInterval;
                              }
                              var n = (result.max - result.min)/tickInterval;
                              n = n.toFixed(11);
                              n = Math.ceil(n);
                              numberTicks = n + 1;
                          }
                          else if (userMax == null) {
                              // add one tick for top of range.
                              var n = (this._dataBounds.max - result.min) / tickInterval;
                              n = n.toFixed(11);
                              numberTicks = Math.ceil(n) + 2;
                              result.max = result.min + tickInterval * (numberTicks-1);
                          }
                          else if (userMin == null) {
                              // add one tick for bottom of range.
                              var n = (result.max - this._dataBounds.min) / tickInterval;
                              n = n.toFixed(11);
                              numberTicks = Math.ceil(n) + 2;
                              result.min = result.max - tickInterval * (numberTicks-1);
                          }
                          else {
                              // calculate a number of ticks so max is within axis scale
                              numberTicks = Math.ceil((userMax - userMin)/tickInterval) + 1;
                              // if user's min and max don't fit evenly in ticks, adjust.
                              // This takes care of cases such as user min set to 0, max set to 3.5 but tick
                              // format string set to %d (integer ticks)
                              result.min =  Math.floor(userMin*Math.pow(10, precision))/Math.pow(10, precision);
                              result.max =  Math.ceil(userMax*Math.pow(10, precision))/Math.pow(10, precision);
                              // this.max = this.min + this.tickInterval*(this.numberTicks-1);
                              numberTicks = Math.ceil((result.max - result.min)/tickInterval) + 1;
                          }
                      }
                  }
              }
          }
          
      }
      
      ticks = null;
      
      result.tickInterval = tickInterval;
      
      return result;
  };
  
    $.jqplot.LinearAxisRenderer.prototype.draw = function(ctx, plot) {
        var min, max, calc;
        if (this.show) {
            if (typeof this.rendererOptions.dataType === 'string' && this.rendererOptions.dataType.toLowerCase() === 'date') {
                setDateTicks.call(this, plot);
            } else if (typeof this.rendererOptions.dataType === 'string' && this.rendererOptions.dataType.toLowerCase() === 'index') {
                setIndexTicks.call(this, plot);
            }
            
            // populate the axis label and value properties.
            // createTicks is a method on the renderer, but
            // call it within the scope of the axis.
            this.renderer.createTicks.call(this, plot);
            // fill a div with axes labels in the right direction.
            // Need to pregenerate each axis to get its bounds and
            // position it and the labels correctly on the plot.
            var dim=0;
            var temp;
            // Added for theming.
            if (this._elem) {
                // Memory Leaks patch
                //this._elem.empty();
                this._elem.emptyForce();
                this._elem = null;
            }
            
            this._elem = $(document.createElement('div'));
            this._elem.addClass('jqplot-axis jqplot-'+this.name);
            this._elem.css('position', 'absolute');

            
            if (this.name == 'xaxis' || this.name == 'x2axis') {
                this._elem.width(this._plotDimensions.width);
            }
            else {
                this._elem.height(this._plotDimensions.height);
            }
            
            // create a _label object.
            this.labelOptions.axis = this.name;
            this._label = new this.labelRenderer(this.labelOptions);
            if (this._label.show) {
                var elem = this._label.draw(ctx, plot);
                elem.appendTo(this._elem);
                elem = null;
            }
    
            var t = this._ticks;
            var tick;
            for (var i=0; i<t.length; i++) {
                tick = t[i];
                if (tick.show && tick.showLabel && (!tick.isMinorTick || this.showMinorTicks)) {
                    this._elem.append(tick.draw(ctx, plot, this));
                }
            }
            tick = null;
            t = null;
        }
        return this._elem;
    };
    
    function setIndexTicks(plot) {
        var min, max, calc, range,
            tempFormatter = this.tickOptions.formatter,
            start , end, ticks = [],
            numberTicks,
            interval,
            targetWidth,
            orgMin = this.min, orgMax = this.max;
        
        
        this.autoscale = false;
        plot.options.axes[this.name].autoscale = false;
        plot.axes[this.name].tickOptions.formatString = '';
        plot.axes[this.name]._autoFormatString = '';

        this.__min = this.min;
        this.__max = this.max;
        
        calc = this.renderer.calculateTicks.call(this, plot);

        if (this.min == null) {
            this.__min = calc.min;
        } 

        if (this.max == null) {
            this.__max = calc.max;
        } 
        
        this.tickOptions.formatter = function(pattern, val, plot) {
            if ($.isFunction(tempFormatter)) {
                val = tempFormatter(pattern, val, plot);
            }
            return val % 1 > 0 || val < 0 ? ' ' : val;
        };
        
        if (this.tickInset && !(plot.plugins.cursor && plot.plugins.cursor.show && plot.plugins.cursor._zoom && (plot.plugins.cursor._zoom.isZoomed || plot.plugins.cursor._zoom.zooming))) {
            min = calc.min - this.tickInset * calc.tickInterval;
            max = calc.max + this.tickInset * calc.tickInterval;
        } else if (this.tickInset && plot.plugins.cursor && plot.plugins.cursor.show && plot.plugins.cursor._zoom && !plot.plugins.cursor._zoom.zooming && plot.plugins.cursor._zoom.isZoomed) {
            min = orgMin;
            max = orgMax;
        } else {
            min = calc.min;
            max = calc.max;
        }
        
        range = Math.floor(max) - Math.floor(min);
        
        if (range === 0 && Math.floor(min) < min && Math.floor(max) < max) {
            this.ticks = [min, max];
        } else if (range === 1 && Math.floor(min) < min && Math.floor(max) < max) {
            this.ticks = [min, Math.floor(max), max];
        } else {
            if (min < 0) {
                min = 0;
            }
            
            start = Math.ceil(min), end = Math.floor(max), ticks = [];
            numberTicks = this._numberTicks || 10;
            targetWidth = this.name.charAt(0) === 'x' ? plot.target.width() : plot.target.height();
            
            if (plot.legend.show) {
                switch(plot.legend.location.charAt(0)) {
                    case 's':
                    case 'n':
                        targetWidth -= this.name.charAt(0) === 'x' ? 0 : plot.legend._elem.height();
                        break;
                    case 'e':
                    case 'w':
                        targetWidth -= this.name.charAt(0) === 'x' ? plot.legend._elem.width() : 0;
                        break;
                }
            }
            
            numberTicks = Math.min(end - start + 1, targetWidth / 50, numberTicks);
            interval = Math.floor(range / (numberTicks - 1));
            numberTicks = Math.floor(range / interval) + 1;
            
            for (var i = 0; i < numberTicks - 1; i++) {
                ticks.push(start + i*interval);
            }
            
            ticks.push(end);
            if (max > end) {
                ticks.push(max);
            }

            this.ticks = ticks;
        }
    }
    
    function setDateTicks(plot) {
        var min, max, calc;
        
        if (this.tickSpacing == null || this.tickSpacing < 150) {
            this.tickSpacing = 150;
            this._options.tickSpacing = 150;
        }
        
        calc = this.renderer.calculateTicks.call(this, plot);
        
        if (this.tickInset) {
            min = calc.min - this.tickInset * calc.tickInterval;
            max = calc.max + this.tickInset * calc.tickInterval;
        } else {
            min = calc.min;
            max = calc.max;
        }
        
        if (moment(max).format('L') !== moment(min).format('L') && this._options.tickSpacing == null) {
            this.tickSpacing = 150;
            this._options.tickSpacing = 150;
        }
        
        this.autoscale = false;
        plot.options.axes[this.name].autoscale = false;
    }
    
    function dateTypeAxisTickFormatter(value, plot) {
        formatValue = this.formatter(this.formatString, value, plot);
        if (value == formatValue) {
            value = moment(plot.axes[this.axis].max).format('L') !== moment(plot.axes[this.axis].min).format('L') ? moment(value).format('MM-DD HH:mm:ss') : moment(value).format('HH:mm:ss');
        } else {
            value = formatValue;
        }
        
        return value;
    }
  
    $.jqplot.AxisTickRenderer.prototype.draw = function(ctx, plot, axis) {
        if (this.label === null) {
            this.label = this.prefix + (axis.rendererOptions.dataType === 'date' ? dateTypeAxisTickFormatter.call(this, this.value, plot) : this.formatter(this.formatString, this.value, plot)) + this.suffix;
        }
        var style = {position: 'absolute'};
        if (Number(this.label)) {
            style['whitSpace'] = 'nowrap';
        }
        
        // Memory Leaks patch
        if (this._elem) {
            this._elem.emptyForce();
            this._elem = null;
        }

        this._elem = $(document.createElement('div'));
        this._elem.addClass("jqplot-"+this.axis+"-tick");
        
        if (!this.escapeHTML) {
            this._elem.html(this.label);
        }
        else {
            this._elem.text(this.label);
        }
        
        this._elem.css(style);

        for (var s in this._styles) {
            this._elem.css(s, this._styles[s]);
        }
        if (this.fontFamily) {
            this._elem.css('font-family', this.fontFamily);
        }
        if (this.fontSize) {
            this._elem.css('font-size', this.fontSize);
        }
        if (this.textColor) {
            this._elem.css('color', this.textColor);
        }
        if (this._breakTick) {
          this._elem.addClass('jqplot-breakTick');
        }
        
        return this._elem;
    };

    // Override jqPlot's inner functions
    $.each($.jqplot.applyEnhance({'Axis': Axis, 'Series': Series, 'jqPlot': jqPlot}), function(name, func) {
        eval(name + '=func');
    });
    
    $.fn.jqplotToImageStr = function(options) {
      var defer = new $.Deferred();
      try {
      var imgCanvas = html2canvas(this, {
        onrendered: function(canvas) {
            defer.resolve(canvas.toDataURL("image/png"));
            canvas = null;
        },
        letterRendering: true
      });
      } catch(e) {
        defer.reject('');
      }

      return defer.promise();
  };
  
  // return a DOM <img> element and return it.
  // Should work on canvas supporting browsers.
  $.fn.jqplotToImageElem = function(options) {
    var defer = new $.Deferred();
    var elem = document.createElement("img");
    $(this).jqplotToImageStr(options).then(function(str) {
      
      elem.src = str;
      
      defer.resolve(elem);
    }, function() {
      defer.reject();
    });
    return defer.promise();
  };

  // return a string for an <img> element and return it.
  // Should work on canvas supporting browsers.
  $.fn.jqplotToImageElemStr = function(options) {
    var defer = new $.Deferred();
    
    $(this).jqplotToImageStr(options).then(function(str) {
      
      str = '<img src='+str+' />';
      
      defer.resolve(str);
    }, function() {
      defer.reject();
    });
    
    return defer.promise();
  };

  // Not guaranteed to work, even on canvas supporting browsers due to 
  // limitations with location.href and browser support.
  $.fn.jqplotSaveImage = function() {
    var defer = new $.Deferred();
    
    $(this).jqplotToImageStr({}).then(function(str) {
      
      if (str) {
          window.location.href = str.replace("image/png", "image/octet-stream");
      }
      
      defer.resolve();
    }, function() {
      defer.reject();
    });
    
    return defer.promise();
  };

  // Not guaranteed to work, even on canvas supporting browsers due to
  // limitations with window.open and arbitrary data.
  $.fn.jqplotViewImage = function() {
    var defer = new $.Deferred();
    
    $(this).jqplotToImageElemStr({}).then(function(imgStr) {

      if (imgStr) {
          var w = window.open('');
          w.document.open("image/png");
          w.document.write(imgStr);
          w.document.close();
          w = null;
      }
      
      defer.resolve();
    }, function() {
      defer.reject();
    });
    
    return defer.promise();
  };
    
    /**
     * Namespace: $.fn
     * jQuery namespace to attach functions to jQuery elements.
     * modified by Roy because of infinite loop in writeWrappedText function
     * ref: https://bitbucket.org/cleonello/jqplot/issue/833/font-scaling-in-firefox-22-causes-infinite
     */

    $.fn.jqplotToImageCanvas = function(options) {

        options = options || {};
        var x_offset = (options.x_offset == null) ? 0 : options.x_offset;
        var y_offset = (options.y_offset == null) ? 0 : options.y_offset;
        var backgroundColor = (options.backgroundColor == null) ? 'rgb(255,255,255)' : options.backgroundColor;

        if ($(this).width() == 0 || $(this).height() == 0) {
            return null;
        }

        // excanvas and hence IE < 9 do not support toDataURL and cannot export images.
        if ($.jqplot.use_excanvas) {
            return null;
        }
        
        var newCanvas = document.createElement("canvas");
        var h = $(this).outerHeight(true);
        var w = $(this).outerWidth(true);
        var offs = $(this).offset();
        var plotleft = offs.left;
        var plottop = offs.top;
        var transx = 0, transy = 0;

        // have to check if any elements are hanging outside of plot area before rendering,
        // since changing width of canvas will erase canvas.

        var clses = ['jqplot-table-legend', 'jqplot-xaxis-tick', 'jqplot-x2axis-tick', 'jqplot-yaxis-tick', 'jqplot-y2axis-tick', 'jqplot-y3axis-tick', 
        'jqplot-y4axis-tick', 'jqplot-y5axis-tick', 'jqplot-y6axis-tick', 'jqplot-y7axis-tick', 'jqplot-y8axis-tick', 'jqplot-y9axis-tick',
        'jqplot-xaxis-label', 'jqplot-x2axis-label', 'jqplot-yaxis-label', 'jqplot-y2axis-label', 'jqplot-y3axis-label', 'jqplot-y4axis-label', 
        'jqplot-y5axis-label', 'jqplot-y6axis-label', 'jqplot-y7axis-label', 'jqplot-y8axis-label', 'jqplot-y9axis-label', 'jqplot-highlighter-tooltip-wrapper', 'jqplot-highlighter-tooltip' ];

        var temptop, templeft, tempbottom, tempright;

        for (var i = 0; i < clses.length; i++) {
            $(this).find('.'+clses[i]).each(function() {
                temptop = $(this).offset().top - plottop;
                templeft = $(this).offset().left - plotleft;
                tempright = templeft + $(this).outerWidth(true) + transx;
                tempbottom = temptop + $(this).outerHeight(true) + transy;
                if (templeft < -transx) {
                    w = w - transx - templeft;
                    transx = -templeft;
                }
                if (temptop < -transy) {
                    h = h - transy - temptop;
                    transy = - temptop;
                }
                if (tempright > w) {
                    w = tempright;
                }
                if (tempbottom > h) {
                    h =  tempbottom;
                }
            });
        }

        newCanvas.width = w + Number(x_offset);
        newCanvas.height = h + Number(y_offset);

        var newContext = newCanvas.getContext("2d"); 

        newContext.save();
        newContext.fillStyle = backgroundColor;
        newContext.fillRect(0,0, newCanvas.width, newCanvas.height);
        newContext.restore();

        newContext.translate(transx, transy);
        newContext.textAlign = 'left';
        newContext.textBaseline = 'top';

        function getLineheight(el) {
            var lineheight = parseInt($(el).css('line-height'), 10);

            if (isNaN(lineheight)) {
                lineheight = parseInt($(el).css('font-size'), 10) * 1.2;
            }
            return lineheight;
        }

        function writeWrappedText (el, context, text, left, top, canvasWidth) {
            var lineheight = getLineheight(el);
            var tagwidth = $(el).innerWidth();
            var tagheight = $(el).innerHeight();
            var words = text.split(/\s+/);
            var wl = words.length;
            var w = '';
            var breaks = [];
            var temptop = top;
            var templeft = left;

            for (var i=0; i<wl; i++) {
                w += words[i];
                //only add breaks if there is more than one word
                if (context.measureText(w).width > tagwidth && i > 0) { // cusomized ref. : https://bitbucket.org/cleonello/jqplot/issue/833/font-scaling-in-firefox-22-causes-infinite
                    breaks.push(i);
                    w = '';
                    i--;
                }   
            }
            if (breaks.length === 0) {
                // center text if necessary
                if ($(el).css('textAlign') === 'center') {
                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;
                }
                context.fillText(text, templeft, top);
            }
            else {
                w = words.slice(0, breaks[0]).join(' ');
                // center text if necessary
                if ($(el).css('textAlign') === 'center') {
                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;
                }
                context.fillText(w, templeft, temptop);
                temptop += lineheight;
                for (var i=1, l=breaks.length; i<l; i++) {
                    w = words.slice(breaks[i-1], breaks[i]).join(' ');
                    // center text if necessary
                    if ($(el).css('textAlign') === 'center') {
                        templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;
                    }
                    context.fillText(w, templeft, temptop);
                    temptop += lineheight;
                }
                w = words.slice(breaks[i-1], words.length).join(' ');
                // center text if necessary
                if ($(el).css('textAlign') === 'center') {
                    templeft = left + (canvasWidth - context.measureText(w).width)/2  - transx;
                }
                context.fillText(w, templeft, temptop);
            }

        }

        function _jqpToImage(el, x_offset, y_offset) {
            var tagname = el.tagName.toLowerCase();
            var p = $(el).position();
            var css = window.getComputedStyle ?  window.getComputedStyle(el, "") : el.currentStyle; // for IE < 9
            var left = x_offset + p.left + parseInt(css.marginLeft, 10) + parseInt(css.borderLeftWidth, 10) + parseInt(css.paddingLeft, 10);
            var top = y_offset + p.top + parseInt(css.marginTop, 10) + parseInt(css.borderTopWidth, 10)+ parseInt(css.paddingTop, 10);
            var w = newCanvas.width;
            // var left = x_offset + p.left + $(el).css('marginLeft') + $(el).css('borderLeftWidth') 

            // somehow in here, for divs within divs, the width of the inner div should be used instead of the canvas.

            if ((tagname == 'div' || tagname == 'span' || tagname == 'ul' || tagname == 'li') /*&& !$(el).hasClass('jqplot-highlighter-tooltip')*/) {
                $(el).children().each(function() {
                    _jqpToImage(this, left, top);
                });
                var text = $(el).jqplotChildText();

                if (text) {
                    newContext.font = $(el).jqplotGetComputedFontStyle();
                    newContext.fillStyle = $(el).css('color');

                    writeWrappedText(el, newContext, text, left, top, w);
                }
            }

            // handle the standard table legend

            else if (tagname === 'table' && $(el).hasClass('jqplot-table-legend')) {
                newContext.strokeStyle = $(el).css('border-top-color');
                newContext.fillStyle = $(el).css('background-color');
                newContext.fillRect(left, top, $(el).innerWidth(), $(el).innerHeight());
                if (parseInt($(el).css('border-top-width'), 10) > 0) {
                    newContext.strokeRect(left, top, $(el).innerWidth(), $(el).innerHeight());
                }

                // find all the swatches
                $(el).find('div.jqplot-table-legend-swatch-outline').each(function() {
                    // get the first div and stroke it
                    var elem = $(this);
                    newContext.strokeStyle = elem.css('border-top-color');
                    var l = left + elem.position().left;
                    var t = top + elem.position().top;
                    newContext.strokeRect(l, t, elem.innerWidth(), elem.innerHeight());

                    // now fill the swatch
                    
                    l += parseInt(elem.css('padding-left'), 10);
                    t += parseInt(elem.css('padding-top'), 10);
                    var h = elem.innerHeight() - 2 * parseInt(elem.css('padding-top'), 10);
                    var w = elem.innerWidth() - 2 * parseInt(elem.css('padding-left'), 10);

                    var swatch = elem.children('div.jqplot-table-legend-swatch');
                    newContext.fillStyle = swatch.css('background-color');
                    newContext.fillRect(l, t, w, h);
                });

                // now add text

                $(el).find('td.jqplot-table-legend-label').each(function(){
                    var elem = $(this);
                    var l = left + elem.position().left;
                    var t = top + elem.position().top + parseInt(elem.css('padding-top'), 10);
                    newContext.font = elem.jqplotGetComputedFontStyle();
                    newContext.fillStyle = elem.css('color');
                    writeWrappedText(elem, newContext, elem.text(), l, t, w);
                });

                var elem = null;
            }

            else if (tagname == 'canvas') {
                newContext.drawImage(el, left, top);
            }
        }
        $(this).children().each(function() {
            _jqpToImage(this, x_offset, y_offset);
        });
        return newCanvas;
    };
    
    // externel Series
    $.jqplot.Series = Series;
    
    var dotlen = 0.1;
    var canvasMax = 8000;
    
    function getGraphFunction(x0, y0, x1, y1) {
        if (x0 === x1 || y0 === y1) {
            return {
                y: function(x) { return y0; },
                x: function(y) { return x0; }
            };
        } else if (x0 === x1) {
            return {
                y: function(x) { return [y0, y1]; },
                x: function(y) { return x0; }
            };
        } else if (y0 === y1) {
            return {
                y: function(x) { return y0; },
                x: function(y) { return [x0, x1]; }
            };
        } else {
            var equation, additional;
        
            equation = (y1 - y0) / (x1 - x0);
            additional = y1 - x1 * equation;
            
            return {
                y: function(x) {
                  return equation * x + additional;
                },
                x: function(y) {
                    return (y - additional) / equation;
                }
            };
        }
    }

    $.jqplot.LinePattern = function (ctx, pattern, closePath) {
        if (closePath) {
            return ctx;
        }
        
        var defaultLinePatterns = {
            dotted: [ dotlen, $.jqplot.config.dotGapLength ],
            dashed: [ $.jqplot.config.dashLength, $.jqplot.config.gapLength ],
            solid: null
        };
        
        var abs = Math.abs;
        
        var checkGraph = function(px, py, x, y) {
            if (px === 0 && py === 0 && x === 0 && y === 0) {
                return {
                    x: x,
                    y: y
                };
            }
            var graphFunc;
            var mx = px, my = py;
            if (px < 0 || px > width || py < 0 || py > height
                || x < 0 || x > width || y < 0 || y > height) {
                    
                graphFunc = getGraphFunction(px, py, x, y);
            
                if (abs(px) > abs(py) && px < 0) {
                    mx = 0;
                    my = graphFunc.y(mx);
                } else if (abs(px) > abs(py) && px > width) {
                    mx = width;
                    my = graphFunc.y(mx);
                }
                if (abs(mx) < abs(my) && my < 0) {
                    my = 0;
                    mx = graphFunc.x(my);
                } else if (abs(mx) < abs(my) && my > height) {
                    my = height;
                    mx = graphFunc.x(my);
                }
                
                if (abs(x) > abs(y) && x < 0) {
                    x = 0;
                    y = graphFunc.y(x);
                } else if (abs(x) > abs(y) && x > width) {
                    x = width;
                    y = graphFunc.y(x);
                }
                if (abs(x) < abs(y) && y < 0) {
                    y = 0;
                    x = graphFunc.x(y);
                } else if (abs(x) < abs(y) && y > height) {
                    y = height;
                    x = graphFunc.x(y);
                }
                
                if (mx > -canvasMax && mx < canvasMax && my > -canvasMax && my < canvasMax) {
                    ctx.moveTo(mx, my);
                }
            }
            
            return {
                x: x,
                y: y
            };
        };

        if (typeof pattern === 'string') {
            if (pattern[0] === '.' || pattern[0] === '-') {
                var s = pattern;
                pattern = [];
                for (var i=0, imax=s.length; i<imax; i++) {
                    if (s[i] === '.') {
                        pattern.push( dotlen );
                    }
                    else if (s[i] === '-') {
                        pattern.push( $.jqplot.config.dashLength );
                    }
                    else {
                        continue;
                    }
                    pattern.push( $.jqplot.config.gapLength );
                }
            }
            else {
                pattern = defaultLinePatterns[pattern];
            }
        }
        
        var px = 0,
            py = 0,
            pathx0 = 0,
            pathy0 = 0,
            width = ctx.canvas.width,
            height = ctx.canvas.height,
            graphFunc,
            ox = 0, oy = 0;

        var moveTo = function(x, y) {
            if (x > -canvasMax && x < canvasMax && y > -canvasMax && y < canvasMax) {
                ctx.moveTo(x, y);
            }
            px = x;
            py = y;
            pathx0 = x;
            pathy0 = y;
        };
        
        var beginPath = function () {
            ctx.beginPath();
        };
        if (!(pattern && pattern.length)) {
            var closePath = function () {
                ctx.closePath();
            };
            
            var lineTo = function(x, y) {
                if ((px === x && py === y) || (px < 0 && x < 0) || (px > width && x > width)
                    || (py < 0 && y < 0) || (py > height && y > height)) {
                    px = x;
                    py = y;
                    return;
                }
                
                var ox = x, oy = y;
                
                if (px === x) {
                    if (py < 0) {
                        py = 0;
                        ctx.moveTo(px, py);
                    } else if (py > height) {
                        py = height;
                        ctx.moveTo(px, py);
                    }
                    if (y < 0) {
                        y = 0;
                    } else if (y > height) {
                        y = height;
                    }
                    
                    ctx.moveTo(px, py);
                    ctx.lineTo(x, y);
                } else if (py === y) {
                    if (px < 0) {
                        px = 0;
                        ctx.moveTo(px, py);
                    } else if (px > width) {
                        px = width;
                        ctx.moveTo(px, py);
                    }
                    if (x < 0) {
                        x = 0;
                    } else if (x > width) {
                        x = width;
                    }
                    
                    ctx.lineTo(x, y);
                } else {
                    var check = checkGraph(px, py, x, y);
                    if (check === null) {
                        px = ox;
                        py = oy;
                        return;
                    }
                    
                    ctx.lineTo(check.x, check.y);
                }
                
                px = ox;
                py = oy;
            };
        } else {
            var patternIndex = 0;
            var patternDistance = pattern[0];
            
            var closePath = function () {
                lineTo( pathx0, pathy0 );
            };
    
            var lineTo = function (x, y) {
                if ((px === x && py === y) || (px < 0 && x < 0) || (px > width && x > width)
                    || (py < 0 && y < 0) || (py > height && y > height)) {
                    moveTo(x, y);
                    return;
                } else if (((px < 0) ^ (x < 0)) || ((px > width) ^ (x > width))
                    || ((py < 0) ^ (y < 0)) || ((py > height) ^ (y > height))) {
                    ox = x;
                    oy = y;
                    
                    if (px === x) {
                        if (py < 0) {
                            py = 0;
                        } else if (py > height) {
                            py = height;
                        }
                        if (y < 0) {
                            y = 0;
                        } else if (y > height) {
                            y = height;
                        }
                        
                        ctx.moveTo(px, py);
                    } else if (py === y) {
                        if (px < 0) {
                            px = 0;
                        } else if (px > width) {
                            px = width;
                        }
                        if (x < 0) {
                            x = 0;
                        } else if (x > width) {
                            x = width;
                        }
                        
                        ctx.moveTo(px, py);
                    } else if (!(px === 0 && py === 0 && x === 0 && y === 0)) {
                        var graphFunc;
                        var mx = px, my = py;
                        if (px < 0 || px > width || py < 0 || py > height
                            || x < 0 || x > width || y < 0 || y > height) {
                                
                            graphFunc = getGraphFunction(px, py, x, y);
                        
                            if (abs(px) > abs(py) && px < 0) {
                                px = 0;
                                py = graphFunc.y(px);
                            } else if (abs(px) > abs(py) && px > width) {
                                px = width;
                                py = graphFunc.y(px);
                            }
                            if (abs(px) < abs(py) && py < 0) {
                                py = 0;
                                px = graphFunc.x(py);
                            } else if (abs(px) < abs(py) && py > height) {
                                py = height;
                                px = graphFunc.x(py);
                            }
                            
                            if (abs(x) > abs(y) && x < 0) {
                                x = 0;
                                y = graphFunc.y(x);
                            } else if (abs(x) > abs(y) && x > width) {
                                x = width;
                                y = graphFunc.y(x);
                            }
                            if (abs(x) < abs(y) && y < 0) {
                                y = 0;
                                x = graphFunc.x(y);
                            } else if (abs(x) < abs(y) && y > height) {
                                y = height;
                                x = graphFunc.x(y);
                            }
                            
                            if (mx > -canvasMax && mx < canvasMax && my > -canvasMax && my < canvasMax) {
                                ctx.moveTo(mx, my);
                            }
                        }
                    }
                } else {
                    ox = x;
                    oy = y;
                    ctx.moveTo(px, py);
                }
                
                var scale = ctx.lineWidth;
                var dx = x - px;
                var dy = y - py;
                var dist = Math.sqrt(dx*dx+dy*dy);
                if ((dist > 0) && (scale > 0)) {
                    dx /= dist;
                    dy /= dist;
                    while (true) {
                        var dp = scale * patternDistance;
                        if (dp < dist) {
                            px += dp * dx;
                            py += dp * dy;
                            if ((patternIndex & 1) == 0) {
                                ctx.lineTo( px, py );
                            }
                            else {
                                ctx.moveTo( px, py );
                            }
                            dist -= dp;
                            patternIndex++;
                            if (patternIndex >= pattern.length) {
                                patternIndex = 0;
                            }
                            patternDistance = pattern[patternIndex];
                        }
                        else {
                            px = x;
                            py = y;
                            if ((patternIndex & 1) == 0) {
                                ctx.lineTo( px, py );
                            }
                            
                            px = ox;
                            py = oy;
                            patternDistance -= dist / scale;
                            break;
                        }
                    }
                }
            };
        }
        
        return {
            moveTo: moveTo,
            lineTo: lineTo,
            beginPath: beginPath,
            closePath: closePath
        };
    };

    // customizing (Roy Choi, 2016-09-05)
    // To fix x2axis base line bug
    $.jqplot.CanvasGridRenderer.prototype.draw = function() {
        this._ctx = this._elem.get(0).getContext("2d");
        var ctx = this._ctx;
        var axes = this._axes;
        // Add the grid onto the grid canvas.  This is the bottom most layer.
        ctx.save();
        ctx.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height);
        ctx.fillStyle = this.backgroundColor || this.background;
        ctx.fillRect(this._left, this._top, this._width, this._height);
        
        ctx.save();
        ctx.lineJoin = 'miter';
        ctx.lineCap = 'butt';
        ctx.lineWidth = this.gridLineWidth;
        ctx.strokeStyle = this.gridLineColor;
        var b, e, s, m;
        var ax = ['xaxis', 'yaxis', 'x2axis', 'y2axis'];
        for (var i=4; i>0; i--) {
            var name = ax[i-1];
            var axis = axes[name];
            var ticks = axis._ticks;
            var numticks = ticks.length;
            if (axis.show) {
                if (axis.drawBaseline) {
                    var bopts = {};
                    if (axis.baselineWidth !== null) {
                        bopts.lineWidth = axis.baselineWidth;
                    }
                    if (axis.baselineColor !== null) {
                        bopts.strokeStyle = axis.baselineColor;
                    }
                    switch (name) {
                        case 'xaxis':
                            drawLine (this._left+.5, this._bottom+.5, this._right+.5, this._bottom+.5, bopts);
                            break;
                        case 'yaxis':
                            drawLine (this._left+.5, this._bottom+.5, this._left+.5, this._top+.5, bopts);
                            break;
                        case 'x2axis':
                            drawLine (this._left+.5, this._top+.5, this._right+.5, this._top+.5, bopts);
                            break;
                        case 'y2axis':
                            drawLine (this._right+.5, this._bottom+.5, this._right+.5, this._top+.5, bopts);
                            break;
                    }
                }
                for (var j=numticks; j>0; j--) {
                    var t = ticks[j-1];
                    if (t.show) {
                        var pos = Math.round(axis.u2p(t.value)) + 0.5;
                        switch (name) {
                            case 'xaxis':
                                // draw the grid line if we should
                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {
                                    drawLine(pos, this._top, pos, this._bottom);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._bottom;
                                            e = this._bottom+s;
                                            break;
                                        case 'inside':
                                            b = this._bottom-s;
                                            e = this._bottom;
                                            break;
                                        case 'cross':
                                            b = this._bottom-s;
                                            e = this._bottom+s;
                                            break;
                                        default:
                                            b = this._bottom;
                                            e = this._bottom+s;
                                            break;
                                    }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[pos,b],[pos,e]], {lineCap:'butt', lineWidth:this.gridLineWidth, offset:this.gridLineWidth*0.75, depth:2, fill:false, closePath:false});
                                    }
                                    // draw the line
                                    drawLine(pos, b, pos, e);
                                }
                                break;
                            case 'yaxis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {
                                    drawLine(this._right, pos, this._left, pos);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._left-s;
                                            e = this._left;
                                            break;
                                        case 'inside':
                                            b = this._left;
                                            e = this._left+s;
                                            break;
                                        case 'cross':
                                            b = this._left-s;
                                            e = this._left+s;
                                            break;
                                        default:
                                            b = this._left-s;
                                            e = this._left;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                                    }
                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                                }
                                break;
                            case 'x2axis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {
                                    drawLine(pos, this._bottom, pos, this._top);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._top-s;
                                            e = this._top;
                                            break;
                                        case 'inside':
                                            b = this._top;
                                            e = this._top+s;
                                            break;
                                        case 'cross':
                                            b = this._top-s;
                                            e = this._top+s;
                                            break;
                                        default:
                                            b = this._top-s;
                                            e = this._top;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[pos,b],[pos,e]], {lineCap:'butt', lineWidth:this.gridLineWidth, offset:this.gridLineWidth*0.75, depth:2, fill:false, closePath:false});
                                    }
                                    drawLine(pos, b, pos, e);
                                }
                                break;
                            case 'y2axis':
                                // draw the grid line
                                if (t.showGridline && this.drawGridlines && ((!t.isMinorTick && axis.drawMajorGridlines) || (t.isMinorTick && axis.drawMinorGridlines)) ) {
                                    drawLine(this._left, pos, this._right, pos);
                                }
                                // draw the mark
                                if (t.showMark && t.mark && ((!t.isMinorTick && axis.drawMajorTickMarks) || (t.isMinorTick && axis.drawMinorTickMarks)) ) {
                                    s = t.markSize;
                                    m = t.mark;
                                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                                    switch (m) {
                                        case 'outside':
                                            b = this._right;
                                            e = this._right+s;
                                            break;
                                        case 'inside':
                                            b = this._right-s;
                                            e = this._right;
                                            break;
                                        case 'cross':
                                            b = this._right-s;
                                            e = this._right+s;
                                            break;
                                        default:
                                            b = this._right;
                                            e = this._right+s;
                                            break;
                                            }
                                    // draw the shadow
                                    if (this.shadow) {
                                        this.renderer.shadowRenderer.draw(ctx, [[b, pos], [e, pos]], {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                                    }
                                    drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
                t = null;
            }
            axis = null;
            ticks = null;
        }
        // Now draw grid lines for additional y axes
        //////
        // TO DO: handle yMidAxis
        //////
        ax = ['y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
        for (var i=7; i>0; i--) {
            var axis = axes[ax[i-1]];
            var ticks = axis._ticks;
            if (axis.show) {
                var tn = ticks[axis.numberTicks-1];
                var t0 = ticks[0];
                var left = axis.getLeft();
                var points = [[left, tn.getTop() + tn.getHeight()/2], [left, t0.getTop() + t0.getHeight()/2 + 1.0]];
                // draw the shadow
                if (this.shadow) {
                    this.renderer.shadowRenderer.draw(ctx, points, {lineCap:'butt', fill:false, closePath:false});
                }
                // draw the line
                drawLine(points[0][0], points[0][1], points[1][0], points[1][1], {lineCap:'butt', strokeStyle:axis.borderColor, lineWidth:axis.borderWidth});
                // draw the tick marks
                for (var j=ticks.length; j>0; j--) {
                    var t = ticks[j-1];
                    s = t.markSize;
                    m = t.mark;
                    var pos = Math.round(axis.u2p(t.value)) + 0.5;
                    if (t.showMark && t.mark) {
                        switch (m) {
                            case 'outside':
                                b = left;
                                e = left+s;
                                break;
                            case 'inside':
                                b = left-s;
                                e = left;
                                break;
                            case 'cross':
                                b = left-s;
                                e = left+s;
                                break;
                            default:
                                b = left;
                                e = left+s;
                                break;
                        }
                        points = [[b,pos], [e,pos]];
                        // draw the shadow
                        if (this.shadow) {
                            this.renderer.shadowRenderer.draw(ctx, points, {lineCap:'butt', lineWidth:this.gridLineWidth*1.5, offset:this.gridLineWidth*0.75, fill:false, closePath:false});
                        }
                        // draw the line
                        drawLine(b, pos, e, pos, {strokeStyle:axis.borderColor});
                    }
                    t = null;
                }
                t0 = null;
            }
            axis = null;
            ticks =  null;
        }
        
        ctx.restore();
        
        function drawLine(bx, by, ex, ey, opts) {
            ctx.save();
            opts = opts || {};
            if (opts.lineWidth == null || opts.lineWidth != 0){
                $.extend(true, ctx, opts);
                ctx.beginPath();
                ctx.moveTo(bx, by);
                ctx.lineTo(ex, ey);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        if (this.shadow) {
            var points = [[this._left, this._bottom], [this._right, this._bottom], [this._right, this._top]];
            this.renderer.shadowRenderer.draw(ctx, points);
        }
        // Now draw border around grid.  Use axis border definitions. start at
        // upper left and go clockwise.
        if (this.borderWidth != 0 && this.drawBorder) {
            drawLine (this._left, this._top, this._right, this._top, {lineCap:'round', strokeStyle:axes.x2axis.borderColor, lineWidth:axes.x2axis.borderWidth});
            drawLine (this._right, this._top, this._right, this._bottom, {lineCap:'round', strokeStyle:axes.y2axis.borderColor, lineWidth:axes.y2axis.borderWidth});
            drawLine (this._right, this._bottom, this._left, this._bottom, {lineCap:'round', strokeStyle:axes.xaxis.borderColor, lineWidth:axes.xaxis.borderWidth});
            drawLine (this._left, this._bottom, this._left, this._top, {lineCap:'round', strokeStyle:axes.yaxis.borderColor, lineWidth:axes.yaxis.borderWidth});
        }
        // ctx.lineWidth = this.borderWidth;
        // ctx.strokeStyle = this.borderColor;
        // ctx.strokeRect(this._left, this._top, this._width, this._height);
        
        ctx.restore();
        ctx =  null;
        axes = null;
    };

    /**
     * jsIntersect
     */
    var jsIntersect = (function() {
        function intersect(poly1, poly2) {
            var cross = false,
                i, j, l, t, line1Start, line1End, line2Start, line2End;
            for (i=0, l = poly1.length; i < l; i++) {
                line1Start = poly1[i];
                line1End = i === l-1 ? poly1[0] : poly1[i+1];

                for (j=0, t=poly2.length; j < t; j++) {
                    line2Start = poly2[j];
                    line2End = j === t-1 ? poly2[0] : poly2[j+1];

                    cross = checkLineIntersection(line1Start[0], line1Start[1], line1End[0], line1End[1],
                        line2Start[0], line2Start[1], line2End[0], line2End[1]);
                    if (cross.onLine1 && cross.onLine2) return true;
                }
            }

            return checkInnerPolygon(poly1, poly2);
        }

        function checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
            // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
            var denominator, a, b, numerator1, numerator2, result = {
                x: null,
                y: null,
                onLine1: false,
                onLine2: false
            };
            denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
            if (denominator == 0) {
                return result;
            }
            a = line1StartY - line2StartY;
            b = line1StartX - line2StartX;
            numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
            numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
            a = numerator1 / denominator;
            b = numerator2 / denominator;

            // if we cast these lines infinitely in both directions, they intersect here:
            result.x = line1StartX + (a * (line1EndX - line1StartX));
            result.y = line1StartY + (a * (line1EndY - line1StartY));
        /*
                // it is worth noting that this should be the same as:
                x = line2StartX + (b * (line2EndX - line2StartX));
                y = line2StartX + (b * (line2EndY - line2StartY));
                */
            // if line1 is a segment and line2 is infinite, they intersect if:
            if (a > 0 && a < 1) {
                result.onLine1 = true;
            }
            // if line2 is a segment and line1 is infinite, they intersect if:
            if (b > 0 && b < 1) {
                result.onLine2 = true;
            }
            // if line1 and line2 are segments, they intersect if both of the above are true
            return result;
        };

        // check a polygon is in the other polygon
        function checkInnerPolygon(poly1, poly2) {
            return inside(poly1[0], poly2) || inside(poly2[0], poly1);
        }

        function inside(point, vs) {
            // ref. http://stackoverflow.com/questions/22521982/js-check-if-point-inside-a-polygon
            // ray-casting algorithm based on
            // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

            var x = point[0], y = point[1];

            var inside = false;
            for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                var xi = vs[i][0], yi = vs[i][1];
                var xj = vs[j][0], yj = vs[j][1];

                var intersect = ((yi > y) != (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }

            return inside;
        };

        return {
            intersect: intersect
        };
    })();
})(jQuery);

/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can
 * choose the license that best suits your project and use it accordingly.
 *
 * Although not required, the author would appreciate an email letting him
 * know of any substantial use of jqPlot.  You can reach the author at:
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 *
 */
(function($) {
	if ($.jqplot.Cursor) {
		$.jqplot.preInitHooks.forEach(function(callback, ind) {
			if (callback === $.jqplot.Cursor.init) {
				$.jqplot.preInitHooks.splice(ind, 1);
				return;
			}
		});
		$.jqplot.postDrawHooks.forEach(function(callback, ind) {
			if (callback === $.jqplot.Cursor.postDraw) {
				$.jqplot.postDrawHooks.splice(ind, 1);
				return;
			}
		});
	}

	/**
	 * Class: $.jqplot.Cursor
	 * Plugin class representing the cursor as displayed on the plot.
	 */
	$.jqplot.Cursor = function(options) {
		// Group: Properties
		//
		// prop: style
		// CSS spec for cursor style
		this.style = 'crosshair';
		this.previousCursor = 'auto';
		// prop: show
		// wether to show the cursor or not.
		this.show = $.jqplot.config.enablePlugins;
		// prop: showTooltip
		// show a cursor position tooltip.  Location of the tooltip
		// will be controlled by followMouse and tooltipLocation.
		this.showTooltip = true;
		// prop: followMouse
		// Tooltip follows the mouse, it is not at a fixed location.
		// Tooltip will show on the grid at the location given by
		// tooltipLocation, offset from the grid edge by tooltipOffset.
		this.followMouse = false;
		// prop: tooltipLocation
		// Where to position tooltip.  If followMouse is true, this is
		// relative to the cursor, otherwise, it is relative to the grid.
		// One of 'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'
		this.tooltipLocation = 'se';
		// prop: tooltipOffset
		// Pixel offset of tooltip from the grid boudaries or cursor center.
		this.tooltipOffset = 6;
		// prop: showTooltipGridPosition
		// show the grid pixel coordinates of the mouse.
		this.showTooltipGridPosition = false;
		// prop: showTooltipUnitPosition
		// show the unit (data) coordinates of the mouse.
		this.showTooltipUnitPosition = true;
		// prop: showTooltipDataPosition
		// Used with showVerticalLine to show intersecting data points in the tooltip.
		this.showTooltipDataPosition = false;
		// prop: tooltipFormatString
		// sprintf format string for the tooltip.
		// Uses Ash Searle's javascript sprintf implementation
		// found here: http://hexmen.com/blog/2007/03/printf-sprintf/
		// See http://perldoc.perl.org/functions/sprintf.html for reference
		// Note, if showTooltipDataPosition is true, the default tooltipFormatString
		// will be set to the cursorLegendFormatString, not the default given here.
		this.tooltipFormatString = '%.4P, %.4P';
		// prop: useAxesFormatters
		// Use the x and y axes formatters to format the text in the tooltip.
		this.useAxesFormatters = true;
		// prop: tooltipAxisGroups
		// Show position for the specified axes.
		// This is an array like [['xaxis', 'yaxis'], ['xaxis', 'y2axis']]
		// Default is to compute automatically for all visible axes.
		this.tooltipAxisGroups = [];
		// prop: zoom
		// Enable plot zooming.
		this.zoom = false;
		// zoomProxy and zoomTarget properties are not directly set by user.
		// They Will be set through call to zoomProxy method.
		this.zoomProxy = false;
		this.zoomTarget = false;
		// prop: looseZoom
		// Will expand zoom range to provide more rounded tick values.
		// Works only with linear axes and date axes.
		this.looseZoom = false;
		// prop: clickReset
		// Will reset plot zoom if single click on plot without drag.
		this.clickReset = false;
		// prop: dblClickReset
		// Will reset plot zoom if double click on plot without drag.
		this.dblClickReset = true;
		// prop: showVerticalLine
		// draw a vertical line across the plot which follows the cursor.
		// When the line is near a data point, a special legend and/or tooltip can
		// be updated with the data values.
		this.showVerticalLine = false;
		// prop: showHorizontalLine
		// draw a horizontal line across the plot which follows the cursor.
		this.showHorizontalLine = false;
		// customizing (2016-06-20, Carrie bae) : add shapeDrawOption 
		this.gridLineOptions = {
            color: null,
            pattern: null,
            width: null
		};
		this.shapeDrawOption = {}
		// prop: constrainZoomTo
		// 'none', 'x' or 'y'
		this.constrainZoomTo = 'none';
		// // prop: autoscaleConstraint
		// // when a constrained axis is specified, true will
		// // auatoscale the adjacent axis.
		// this.autoscaleConstraint = true;
		this.shapeRenderer = new $.jqplot.ShapeRenderer();
		this._zoom = {
			start : [],
			end : [],
			started : false,
			zooming : false,
			isZoomed : false,
			axes : {
				start : {},
				end : {}
			},
			gridpos : {},
			datapos : {}
		};
		this._tooltipElem;
		this.zoomCanvas;
		this.cursorCanvas;
		// prop: intersectionThreshold
		// pixel distance from data point or marker to consider cursor lines intersecting with point.
		// If data point markers are not shown, this should be >= 1 or will often miss point intersections.
		this.intersectionThreshold = 2;
		// prop: showCursorLegend
		// Replace the plot legend with an enhanced legend displaying intersection information.
		this.showCursorLegend = false;
		// prop: cursorLegendFormatString
		// Format string used in the cursor legend.  If showTooltipDataPosition is true,
		// this will also be the default format string used by tooltipFormatString.
		this.cursorLegendFormatString = $.jqplot.Cursor.cursorLegendFormatString;
		// whether the cursor is over the grid or not.
		this._oldHandlers = {
			onselectstart : null,
			ondrag : null,
			onmousedown : null
		};
		// prop: constrainOutsideZoom
		// True to limit actual zoom area to edges of grid, even when zooming
		// outside of plot area.  That is, can't zoom out by mousing outside plot.
		this.constrainOutsideZoom = true;
		// prop: showTooltipOutsideZoom
		// True will keep updating the tooltip when zooming of the grid.
		this.showTooltipOutsideZoom = false;
		// true if mouse is over grid, false if not.
		this.onGrid = false;

		// customizing - snapshot (2012-04-09, Roy Choi)
		this.snapshotOn = false;
		this.snapshotWin = null;
		var jqplot_cursor_localpath;
		$('script').each(function(ind, val) {
			if (val.src.search(/jqplot\.cursor/) > -1) {
				jqplot_cursor_localpath = val.src.replace(/^(.*)plugins\/jqplot\.cursor.*$/i, "$1");
			}
		});
		this.localpath = jqplot_cursor_localpath;
		this.zoomHistory = [];
		this.right2leftUndo = true;
		this.right2leftUndoWidth = 6;
		this.right2leftResetWidth = 40;
		this.right2leftUndoDirection = 20;
		this.startGridPoint = [];
		this.endGridPoint = [];
		//this._prevzoom = {axes:{start:{}, end:{}}, gridpos:{}, datapos:{}};

		// customizing - drag (2012-04-23, Roy Choi)
		this.draggable = false;
		this._drag = {
			start : [],
			end : [],
			started : false,
			dragging : false,
			isDragged : false,
			axes : {
				start : {},
				end : {}
			},
			gridpos : {},
			datapos : {}
		};
		this.constrainDragTo = 'none';
		this.dragStartAxes = {};

		// series shift customizing (2012-05-11, Roy Choi)
		this.seriesShift = false;
		this.seriesShiftIndex = null;
		this.seriesShiftStyle = 'horizontal';
		this.seriesShiftOrgData = null;
		this.shiftedSeries = [];
		this.shiftedSeriesBase = null;
		this._shift = {
			start : [],
			end : [],
			started : false,
			shifting : false,
			isShifted : false,
			data : []
		};

		// move zoombox customizing (2013-02-21, Roy Choi)
		this.zoomboxThreshold = 5;
		this.endDataPos = {};
		this.drawOnZoomBoxMove = false;
		//this.overZoomBoxLineType = null;		// Type Case : sv, sh, svh, ev, eh, evh
		this.prevZoomInfo = {
			start : [],
			end : [],
			started : false,
			zooming : false,
			isZoomed : false,
			axes : {
				start : {},
				end : {}
			},
			gridpos : {},
			datapos : {}
		};
		this.prevCursorStyle = null;
		this.zoomboxMoving = false;
		this.zoomboxDraging = false;
		//this.zoomboxMoveStart = false;

		// ---------------------- CUSTOMIZING END --------------------------------- //

		$.extend(true, this, options);
	};

	$.jqplot.Cursor.cursorLegendFormatString = '%s x:%s, y:%s';

	// called with scope of plot
	$.jqplot.Cursor.init = function(target, data, opts) {
	  // If highlighter.selectable is on then zoom is not available 
	  if (opts.highlighter && opts.highlighter.selectable && opts.highlighter.selectable.show) {
      //customizing (2015-09-11, Eric Leem)
      if(!opts.highlighter.selectable.zoom){
        opts.cursor.zoom = false;
      }
    }
	  
		// add a cursor attribute to the plot
		var options = opts || {};
		this.plugins.cursor = new $.jqplot.Cursor(options.cursor);
		var c = this.plugins.cursor;

		if (c.show) {
			$.jqplot.eventListenerHooks.push(['jqplotMouseEnter', handleMouseEnter]);
			$.jqplot.eventListenerHooks.push(['jqplotMouseLeave', handleMouseLeave]);
			$.jqplot.eventListenerHooks.push(['jqplotMouseMove', handleMouseMove]);

			if (c.showCursorLegend) {
				opts.legend = opts.legend || {};
				opts.legend.renderer = $.jqplot.CursorLegendRenderer;
				opts.legend.formatString = this.plugins.cursor.cursorLegendFormatString;
				opts.legend.show = true;
			}

			if (c.zoom) {
				$.jqplot.eventListenerHooks.push(['jqplotMouseDown', handleMouseDown]);

				if (c.draggable) {
					$.jqplot.eventListenerHooks.push(['jqplotRightDown', handleRightDown]);
				}

				if (c.clickReset) {
					$.jqplot.eventListenerHooks.push(['jqplotClick', handleClick]);
				}

				if (c.dblClickReset) {
					$.jqplot.eventListenerHooks.push(['jqplotDblClick', handleDblClick]);
				}
			}

			this.resetZoom = function() {
				if (this.plugins.groupplot && this.plugins.groupplot.ischild && this.plugins.groupplot.parent.plugins.groupplot.groupZoom) {// customizing (2012-05-10, Roy Choi)
					var gplots = this.plugins.groupplot.parent.plugins.groupplot.plots;
					$.each(gplots, function(gid, gplot) {
						var axes = gplot.axes;
						var gc = gplot.plugins.cursor;
						gc.resetzooming = true;
						for (var ax in axes) {
							axes[ax].reset();
							axes[ax]._ticks = [];
							// fake out tick creation algorithm to make sure original auto
							// computed format string is used if _overrideFormatString is true
							if (gc._zoom.axes[ax] !== undefined) {
								axes[ax]._autoFormatString = gc._zoom.axes[ax].tickFormatString;
							}
						}

						gplot.redraw();
						//if(gplot.plugins.highlighter) gplot.plugins.highlighter.moveToFrontMultiTooltip(gplot);		// customizing (2012-04-23, Roy Choi)

						gc.resetzooming = false;
						gc = axes = null;
						gplot.plugins.cursor.zoomHistory = [];
						gplot.plugins.cursor._zoom.isZoomed = false;
						gplot.target.trigger('jqplotResetZoom', [gplot, gplot.plugins.cursor]);
					});
					gplots = null;
					return;
				} else if (!c.zoomProxy) {
					if (this.plugins.cursor._zoom.isZoomed) {
						var axes = this.axes;
						c.resetzooming = true;
						for (var ax in axes) {
							axes[ax].reset();
							axes[ax]._ticks = [];
							// fake out tick creation algorithm to make sure original auto
							// computed format string is used if _overrideFormatString is true
							if (c._zoom.axes[ax] !== undefined) {
								axes[ax]._autoFormatString = c._zoom.axes[ax].tickFormatString;
							}
						}

						this.replot();
						//if(this.plugins.highlighter) this.plugins.highlighter.moveToFrontMultiTooltip(this);		// customizing (2012-04-23, Roy Choi)
						axes = null;
					} else {
						var ctx = this.plugins.cursor.zoomCanvas._ctx;
						ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
						ctx = null;
					}
				} else {
					c.resetzooming = true;
					var ctx = this.plugins.cursor.zoomCanvas._ctx;
					ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
					ctx = null;
				}
				c.resetzooming = false;
				this.plugins.cursor.zoomHistory = [];
				this.plugins.cursor._zoom.isZoomed = false;
				this.target.trigger('jqplotResetZoom', [this, this.plugins.cursor]);
			};

			this.undoZoom = function() {
				if (this.plugins.cursor.zoomHistory.length === 0) {
					var ctx = this.plugins.cursor.zoomCanvas._ctx;
					ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
					ctx = null;
					return;
				} else if (this.plugins.cursor.zoomHistory.length === 1) {
					this.resetZoom();
				} else if (this.plugins.groupplot && this.plugins.groupplot.ischild && this.plugins.groupplot.parent.plugins.groupplot.groupZoom) {// customizing (2012-05-10, Roy Choi)
					var gplots = this.plugins.groupplot.parent.plugins.groupplot.plots;
					$.each(gplots, function(gid, gplot) {
						var _zoomH = gplot.plugins.cursor.zoomHistory.pop();
						if (!gplot.plugins.cursor.zoomProxy) {
							var axes = gplot.axes;
							var caxes = gplot.plugins.cursor._zoom.axes;
							var zoomaxes = _zoomH.zoomaxes;
							$.each(_zoomH.axes, function(ax, val) {
								axes[ax].min = val.min;
								axes[ax].max = val.max;
								axes[ax].tickInterval = val.tickInterval;
								axes[ax].daTickInterval = val.daTickInterval;
								axes[ax].ticks = val.ticks;
							});
						}

						gplot.redraw();
						gplot.target.trigger('jqplotUndoZoom', [this, this.plugins.cursor]);
					});
					gplots = null;
					return;
				} else {
					var _zoomH = this.plugins.cursor.zoomHistory.pop();
					if (_zoomH && !this.plugins.cursor.zoomProxy) {
						var axes = this.axes;
						var caxes = this.plugins.cursor._zoom.axes;
						var zoomaxes = _zoomH.zoomaxes;
						$.each(_zoomH.axes, function(ax, val) {
							axes[ax].min = val.min;
							axes[ax].max = val.max;
							axes[ax].tickInterval = val.tickInterval;
							axes[ax].daTickInterval = val.daTickInterval;
							axes[ax].ticks = val.ticks;
						});
						this.redraw();
					}
				}
				this.target.trigger('jqplotUndoZoom', [this, this.plugins.cursor]);
				//if(this.plugins.highlighter) this.plugins.highlighter.moveToFrontMultiTooltip(this); // customizing (2012-04-23, Roy Choi)
			};

			if (c.showTooltipDataPosition) {
				c.showTooltipUnitPosition = false;
				c.showTooltipGridPosition = false;
				if (options.cursor.tooltipFormatString == undefined) {
					c.tooltipFormatString = $.jqplot.Cursor.cursorLegendFormatString;
				}
			}
		}
	};

	// called with context of plot
	$.jqplot.Cursor.postDraw = function() {
		var c = this.plugins.cursor;
		
		if (!c.show) {
		  return;
		}

		// Memory Leaks patch
		if (c.zoomCanvas) {
			c.zoomCanvas.resetCanvas();
			c.zoomCanvas = null;
		}

		if (c.cursorCanvas) {
			c.cursorCanvas.resetCanvas();
			c.cursorCanvas = null;
		}

		if (c._tooltipElem) {
			c._tooltipElem.emptyForce();
			c._tooltipElem = null;
		}

		if (c.zoom) {
			c.zoomCanvas = new $.jqplot.GenericCanvas();
			this.eventCanvas._elem.before(c.zoomCanvas.createElement(this._gridPadding, 'jqplot-zoom-canvas', this._plotDimensions, this));
			c.zoomCanvas.setContext();
		}

		var elem = document.createElement('div');
		c._tooltipElem = $(elem);
		elem = null;
		c._tooltipElem.addClass('jqplot-cursor-tooltip');
		c._tooltipElem.css({
			position : 'absolute',
			display : 'none'
		});

		if (c.zoomCanvas) {
			c.zoomCanvas._elem.before(c._tooltipElem);
		} else {
			this.eventCanvas._elem.before(c._tooltipElem);
		}

		if (c.showVerticalLine || c.showHorizontalLine) {
			c.cursorCanvas = new $.jqplot.GenericCanvas();
			this.eventCanvas._elem.before(c.cursorCanvas.createElement(this._gridPadding, 'jqplot-cursor-canvas', this._plotDimensions, this));
			c.cursorCanvas.setContext();
			// customizing (2016-06-20, Carrie bae) : add shapeDrawOption 
			c.shapeDrawOption = {
				lineWidth: c.gridLineOptions.width,
				color: c.gridLineOptions.color,
				linePattern: c.gridLineOptions.pattern
			};
		}

		// if we are showing the positions in unit coordinates, and no axes groups
		// were specified, create a default set.
		if (c.showTooltipUnitPosition) {
			if (c.tooltipAxisGroups.length === 0) {
				var series = this.series;
				var s;
				var temp = [];
				for (var i = 0; i < series.length; i++) {
					s = series[i];
					var ax = s.xaxis + ',' + s.yaxis;
					if ($.inArray(ax, temp) == -1) {
						temp.push(ax);
					}
				}
				for (var i = 0; i < temp.length; i++) {
					c.tooltipAxisGroups.push(temp[i].split(','));
				}
			}
		}

		if (c._zoom.isZoomed && c.zoomProxy) {
			c.resetZoom(this, c);
		}
	};

	// Group: methods
	//
	// method: $.jqplot.Cursor.zoomProxy
	// links targetPlot to controllerPlot so that plot zooming of
	// targetPlot will be controlled by zooming on the controllerPlot.
	// controllerPlot will not actually zoom, but acts as an
	// overview plot.  Note, the zoom options must be set to true for
	// zoomProxy to work.
	$.jqplot.Cursor.zoomProxy = function(targetPlot, controllerPlot, drawOnZoomBoxMove) {
		var tc = targetPlot.plugins.cursor;
		var cc = controllerPlot.plugins.cursor;
		tc.zoomTarget = true;
		tc.zoom = true;
		tc.style = 'auto';
		tc.dblClickReset = false;
		cc.zoom = true;
		cc.zoomProxy = true;

		if (controllerPlot.legend.show) {
			controllerPlot.legend._elem.css({
				visibility : 'hidden'
			});
		}
		tc = cc = null;

		var targetPlotId = targetPlot.target.attr('id');
		var controlPlotId = controllerPlot.target.attr('id');

		controllerPlot.target.bind('jqplotZoom', plotZoom);
		controllerPlot.target.bind('jqplotResetZoom', plotReset);
		controllerPlot.target.bind('jqplotUndoZoom', plotUndoZoom);
		// customizing (2012-04-13, Roy Choi)

		function plotZoom(ev, gridpos, datapos, plot, cursor) {
			var targetPlot = $.jqplot.plotList[targetPlotId];
			// customizing (2013-02-19, Roy Choi)
			var tc = targetPlot.plugins.cursor;
			tc.zoomTarget = true;
			tc.zoom = true;
			tc.style = 'auto';

			targetPlot.plugins.cursor.doZoom(gridpos, datapos, targetPlot, cursor);
			// customizing (2013-02-19, Roy Choi)

			targetPlot = tc = null;
		}

		function plotReset(ev, plot, cursor) {
			var targetPlot = $.jqplot.plotList[targetPlotId];
			// customizing (2013-02-19, Roy Choi)
			var controlPlot = $.jqplot.plotList[controlPlotId];
			var tc = targetPlot.plugins.cursor;
			tc.zoomTarget = true;
			tc.zoom = true;
			tc.style = 'auto';
			tc._zoom.isZoomed = true;
			var axes = targetPlot.axes;
			for (var ax in axes) {
				axes[ax].max = controlPlot.axes[ax].max;
				axes[ax].min = controlPlot.axes[ax].min;
				axes[ax].ticks = [];
				axes[ax]._ticks = [];
			}
			//targetPlot.resetZoom();
			//console.log(controlPlot, [new Date(controlPlot.axes.xaxis.min), new Date(controlPlot.axes.xaxis.max)]);
			targetPlot.plugins.cursor.resetZoom(targetPlot, targetPlot.plugins.cursor, controlPlot.axes);

			targetPlot = controlPlot = tc = axes = caxes = null;
		}

		function plotUndoZoom(ev, plot, cursor) {// customizing (2012-04-13, Roy Choi)
			var targetPlot = $.jqplot.plotList[targetPlotId];
			// customizing (2013-02-19, Roy Choi)
			var tc = targetPlot.plugins.cursor;
			tc.zoomTarget = true;
			tc.zoom = true;
			tc.style = 'auto';
			tc._zoom.isZoomed = true;
			tc.undoZoom();

			targetPlot = tc = null;
		}

		targetPlot = controllerPlot = null;
	};

	$.jqplot.Cursor.prototype.resetZoom = function(plot, cursor, controllerAxes) {
		var axes = plot.axes;

		var cax = cursor._zoom.axes;
		if (!plot.plugins.cursor.zoomProxy && cursor._zoom.isZoomed) {
			for (var ax in axes) {
				// axes[ax]._ticks = [];
				// axes[ax].min = cax[ax].min;
				// axes[ax].max = cax[ax].max;
				// axes[ax].numberTicks = cax[ax].numberTicks;
				// axes[ax].tickInterval = cax[ax].tickInterval;
				// // for date axes
				// axes[ax].daTickInterval = cax[ax].daTickInterval;

				axes[ax].reset();
				// customizing (2013-03-11, Roy Choi)
				if (plot.plugins.cursor.zoomTarget) {
					if (controllerAxes[ax].tickInset) {
						axes[ax].min = controllerAxes[ax].noInsetMin;
						axes[ax].max = controllerAxes[ax].noInsetMax;
					} else {
						axes[ax].min = controllerAxes[ax].min;
						axes[ax].max = controllerAxes[ax].max;
					}
				}
				axes[ax]._ticks = [];
				// fake out tick creation algorithm to make sure original auto
				// computed format string is used if _overrideFormatString is true
				if (cax[ax] !== undefined) {
					axes[ax]._autoFormatString = cax[ax].tickFormatString;
				}
			}
			// customizing (2012-04-23, Roy Choi)
			plot.replot();
			//cursor._zoom.isZoomed = false;
		} else {
			var ctx = cursor.zoomCanvas._ctx;
			cursor.prevZoomInfo = {
				start : [],
				end : [],
				started : false,
				zooming : false,
				isZoomed : false,
				axes : {
					start : {},
					end : {}
				},
				gridpos : {},
				datapos : {}
			};
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			ctx = null;
		}
		cursor._zoom.isZoomed = false;
		plot.plugins.cursor.zoomHistory = [];
		plot.target.trigger('jqplotResetZoom', [plot, cursor]);
	};
	// cusomizing for zoom proxy (2013-03-04, Roy Choi) start
	$.jqplot.Cursor.prototype.resetZoomProxy = function(plot, cursor) {
		var ctx = cursor.zoomCanvas._ctx;
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		ctx = null;
		cursor._zoom.isZoomed = false;
		plot.plugins.cursor.zoomHistory = [];
	};
	// cusomizing for zoom proxy (2013-03-04, Roy Choi) end
	$.jqplot.Cursor.resetZoom = function(plot) {
		plot.resetZoom();
	};

	// customizing Start (2012-04-12, Roy Choi)
	$.jqplot.Cursor.prototype.undoZoom = function(plot, cursor) {
		plot.undoZoom();
	};
	$.jqplot.Cursor.undoZoom = function(plot) {
		plot.undoZoom();
	};
	// customizing End (2012-04-12, Roy Choi)

	$.jqplot.Cursor.prototype.setSnapshot = function(plot) {
		var c = plot.plugins.cursor;
		c.style = 'crosshair';
		c.zoom = true;
		c.constrainZoomTo = 'none';
		c.showVerticalLine = true;
		c.showHorizontalLine = true;
		c.snapshotOn = true;
		//$.jqplot.eventListenerHooks.push(['jqplotMouseMove', handleMouseMove]);
		plot.redraw();
		//plot.eventCanvas._elem.bind('jqplotMouseMove', {plot:plot}, handleMouseMove);
		c = null;
	};

	$.jqplot.Cursor.prototype.unsetSnapshot = function(plot) {
		var c = plot.plugins.cursor;
		c.showVerticalLine = false;
		c.showHorizontalLine = false;
		c.snapshotOn = false;
		c.style = 'auto';
		//plot.redraw();
		//var idx = $.inArray(['jqplotMouseMove', handleMouseMove],$.jqplot.eventListenerHooks);
		//if(idx >= 0) delete $.jqplot.eventListenerHooks[idx];
		//plot.eventCanvas._elem.unbind('jqplotMouseMove', handleMouseMove);
		plot.redraw();
		c = null;
	};

	// customizing Start (2012-04-12, Roy Choi)
	$.jqplot.Cursor.prototype.doZoom = function(gridpos, datapos, plot, cursor) {
		var c = cursor.snapshotOn ? $.extend(false, {}, cursor) : cursor;
		var axes = cursor.snapshotOn ? $.extend(false, {}, plot.axes) : plot.axes;
		// customizing (2012-04-09, Roy Choi)
		var zaxes = c._zoom.axes;
		var start = zaxes.start;
		var end = zaxes.end;
		var min, max, dp, span;
		var ctx = plot.plugins.cursor.zoomCanvas._ctx;
		var min_x, min_y, max_x, max_y, snapAxes = {};
		// customizing (2012-04-10, Roy Choi)
		var axisLimit = 5000000000;
		// don't zoom if zoom area is too small (in pixels)

		if (c.zoomProxy || (c.constrainZoomTo == 'none' && Math.abs(gridpos.x - c._zoom.start[0]) > 6 && Math.abs(gridpos.y - c._zoom.start[1]) > 6) || (c.constrainZoomTo == 'x' && Math.abs(gridpos.x - c._zoom.start[0]) > 6) || (c.constrainZoomTo == 'y' && Math.abs(gridpos.y - c._zoom.start[1]) > 6)) {
			if (!plot.plugins.cursor.zoomProxy) {
				if (!plot.plugins.cursor.zoomTarget) {
					var historyaxes = {};
					var zoomaxes = {};
					$.each(axes, function(ax, val) {
						if (historyaxes[ax] == undefined)
							historyaxes[ax] = {};
						historyaxes[ax].min = val.min;
						historyaxes[ax].max = val.max;
						historyaxes[ax].tickInterval = null;
						historyaxes[ax].daTickInterval = null;
						historyaxes[ax].ticks = val.ticks;
					});
					c.zoomHistory.push({
						axes : $.extend(true, {}, historyaxes),
						zoomaxes : $.extend(true, {}, zoomaxes)
					});
					zoomaxes = null;
				}
				for (var ax in datapos) {
					if (!cursor.snapshotOn) {
						// make a copy of the original axes to revert back.
						if (c._zoom.axes[ax] == undefined) {
							c._zoom.axes[ax] = {};
							c._zoom.axes[ax].numberTicks = axes[ax].numberTicks;
							c._zoom.axes[ax].tickInterval = axes[ax].tickInterval;
							// for date axes...
							c._zoom.axes[ax].daTickInterval = axes[ax].daTickInterval;
							c._zoom.axes[ax].min = axes[ax].min;
							c._zoom.axes[ax].max = axes[ax].max;
							c._zoom.axes[ax].tickFormatString = (axes[ax].tickOptions != null) ? axes[ax].tickOptions.formatString : '';
						}

						if ((c.constrainZoomTo == 'none') || (c.constrainZoomTo == 'x' && ax.charAt(0) == 'x') || (c.constrainZoomTo == 'y' && ax.charAt(0) == 'y')) {
							dp = datapos[ax];
							if (dp != null) {
								var newmin, newmax;
								if (dp > start[ax]) {
									newmin = start[ax];
									newmax = dp;
								} else {
									span = start[ax] - dp;
									newmin = dp;
									newmax = start[ax];
								}

								var curax = axes[ax];

								var _numberTicks = null;

								// if aligning this axis, use number of ticks from previous axis.
								// Do I need to reset somehow if alignTicks is changed and then graph is replotted??
								if (curax.alignTicks) {
									if (curax.name === 'x2axis' && plot.axes.xaxis.show) {
										_numberTicks = plot.axes.xaxis.numberTicks;
									} else if (curax.name.charAt(0) === 'y' && curax.name !== 'yaxis' && curax.name !== 'yMidAxis' && plot.axes.yaxis.show) {
										_numberTicks = plot.axes.yaxis.numberTicks;
									}
								}

								if (this.looseZoom && (axes[ax].renderer.constructor === $.jqplot.LinearAxisRenderer || axes[ax].renderer.constructor === $.jqplot.DateAxisRenderer)) {
									var ret = $.jqplot.LinearTickGenerator(newmin, newmax, curax._scalefact, _numberTicks);

									// if new minimum is less than "true" minimum of axis display, adjust it
									if (axes[ax].tickInset && ret[0] < axes[ax].min + axes[ax].tickInset * axes[ax].tickInterval) {
										ret[0] += ret[4];
										ret[2] -= 1;
									}

									// if new maximum is greater than "true" max of axis display, adjust it
									if (axes[ax].tickInset && ret[1] > axes[ax].max - axes[ax].tickInset * axes[ax].tickInterval) {
										ret[1] -= ret[4];
										ret[2] -= 1;
									}
									axes[ax].min = ret[0];
									axes[ax].max = ret[1];
									axes[ax]._autoFormatString = ret[3];
									axes[ax].numberTicks = ret[2];
									axes[ax].tickInterval = ret[4];
									// for date axes...
									axes[ax].daTickInterval = [ret[4] / 1000, 'seconds'];
								} else {
									axes[ax].min = newmin;
									axes[ax].max = newmax;
									axes[ax].tickInterval = null;
									// for date axes...
									axes[ax].daTickInterval = null;
								}

								axes[ax]._ticks = [];

								// customizing for zoomproxy on the CategoryAxisRenderer (2013-02-19, Roy Choi)
								if (plot.plugins.cursor.zoomTarget === true && axes[ax].renderer.constructor === $.jqplot.CategoryAxisRenderer) {
									axes[ax].ticks = [];
									axes[ax].numberTicks = null;
								}

								if ((Math.abs(axes[ax].series_u2p(axes[ax]._min)) > axisLimit || Math.abs(axes[ax].series_u2p(axes[ax].max)) > axisLimit)) {
									if (c.zoomHistory.length) {
										var historyAxes = c.zoomHistory.pop().axes;
										$.each(historyAxes, function(ax, axis) {
											axes[ax].min = axis.min;
											axes[ax].max = axis.max;
											axes[ax].tickInterval = axis.tickInterval;
											axes[ax].daTickInterval = axis.daTickInterval;
											axes[ax].ticks = axis.ticks;
										});
									}
									ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
									return;
								}
							}
						}

					} else {
						if (snapAxes[ax] == undefined)
							snapAxes[ax] = $.extend(true, {}, axes[ax]);
						if ((c.constrainZoomTo == 'none') || (c.constrainZoomTo == 'x' && ax.charAt(0) == 'x') || (c.constrainZoomTo == 'y' && ax.charAt(0) == 'y')) {
							dp = datapos[ax];
							if (dp != null) {
								var newmin, newmax;
								if (dp > start[ax]) {
									newmin = start[ax];
									newmax = dp;
								} else {
									span = start[ax] - dp;
									newmin = dp;
									newmax = start[ax];
								}

								var curax = snapAxes[ax];

								var _numberTicks = null;

								// if aligning this axis, use number of ticks from previous axis.
								// Do I need to reset somehow if alignTicks is changed and then graph is replotted??
								if (curax.alignTicks) {
									if (curax.name === 'x2axis' && plot.axes.xaxis.show) {
										_numberTicks = plot.axes.xaxis.numberTicks;
									} else if (curax.name.charAt(0) === 'y' && curax.name !== 'yaxis' && curax.name !== 'yMidAxis' && plot.axes.yaxis.show) {
										_numberTicks = plot.axes.yaxis.numberTicks;
									}
								}

								if (this.looseZoom && (snapAxes[ax].renderer.constructor === $.jqplot.LinearAxisRenderer || snapAxes[ax].renderer.constructor === $.jqplot.DateAxisRenderer)) {
									var ret = $.jqplot.LinearTickGenerator(newmin, newmax, curax._scalefact, _numberTicks);

									// if new minimum is less than "true" minimum of axis display, adjust it
									if (snapAxes[ax].tickInset && ret[0] < snapAxes[ax].min + snapAxes[ax].tickInset * snapAxes[ax].tickInterval) {
										ret[0] += ret[4];
										ret[2] -= 1;
									}

									// if new maximum is greater than "true" max of axis display, adjust it
									if (snapAxes[ax].tickInset && ret[1] > snapAxes[ax].max - snapAxes[ax].tickInset * snapAxes[ax].tickInterval) {
										ret[1] -= ret[4];
										ret[2] -= 1;
									}
									if (curax.name.charAt(0) === 'x') {// customizing (2012-04-10, Roy Choi)
										min_x = ret[0];
										max_x = ret[1];
									} else {
										min_y = ret[0];
										max_y = ret[1];
									}
								} else {
									if (curax.name.charAt(0) === 'x') {// customizing (2012-04-10, Roy Choi)
										min_x = newmin;
										max_x = newmax;
									} else {
										min_y = newmin;
										max_y = newmax;
									}
								}
							}

							snapAxes[ax]._ticks = [];
						}
					}

					// if ((c.constrainZoomTo == 'x' && ax.charAt(0) == 'y' && c.autoscaleConstraint) || (c.constrainZoomTo == 'y' && ax.charAt(0) == 'x' && c.autoscaleConstraint)) {
					//     dp = datapos[ax];
					//     if (dp != null) {
					//         axes[ax].max == null;
					//         axes[ax].min = null;
					//     }
					// }
				}

				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				if (c.snapshotOn) {
					var snapshotData = {
						data : [],
						series : []
					};
					var series = plot.series;
					var pushed_count = 0;

					for (var i = 0, len = series.length; i < len; i++) {
						var snapdata = [];
						for (var j = 0, slen = series[i].data.length; j < slen; j++) {
							if (series[i].data[j][0] >= min_x && series[i].data[j][0] <= max_x && series[i].data[j][1] >= min_y && series[i].data[j][1] <= max_y) {
								snapdata.push(series[i].data[j]);
								pushed_count++;
							}
						}
						if (snapdata.length > 0) {
							snapshotData.data.push(snapdata);
							snapshotData.series.push({
								color : series[i].color,
								label : series[i].label
							});
						}
					}

					if (pushed_count > 0) {
						if (cursor.snapshotWin && cursor.snapshotWin.closed === false) {
							cursor.snapshotWin.focus();
							cursor.snapshotWin.addSnapShot.call(this, plot, snapshotData);
						} else {
							//if(cursor.snapshotWin) cursor.snapshotWin.unload();
							$(plot.targetId).unbind('getsnapshotdata');
							$(plot.targetId).unbind('closesnapshotwin');
							plot.target.bind('getsnapshotdata', {
								plot : plot,
								snapshotData : snapshotData
							}, function(ev) {
								cursor.snapshotWin.addSnapShotFirst.call(this, ev.data.plot, ev.data.snapshotData);
							});
							//cursor.snapshotWin.location.href = '';
							plot.target.bind('closesnapshotwin', {
								cursor : cursor
							}, function(ev) {
								ev.data.cursor.snapshotWin.snapshot_list = null;
								delete ev.data.cursor.snapshotWin;
							});
							cursor.snapshotWin = window.open(c.localpath + 'snapshot.html?targetId=' + escape(plot.targetId) + '&' + ((new Date()).getTime() / 1000), 'JqplotSnapShotWin', 'top=10,left=10,width=800,height=' + (window.screen.height - 150) + ',location=no,menubar=no,status=no,resizable=yes,scrollbars=no');
						}
					}

					snapshotData = null;
					pushed_count = null;
					snapAxes = null;
					//c._zoom.isZoomed = false;

				} else {
					if (plot.plugins.groupplot && plot.plugins.groupplot.ischild && plot.plugins.groupplot.parent.plugins.groupplot.groupZoom) {
						var gplots = plot.plugins.groupplot.parent.plugins.groupplot.plots;
						var zHistory = c._zoom.isZoomed ? c.zoomHistory[c.zoomHistory.length - 1] : null;
						var groupid = plot.plugins.groupplot.groupid;
						$.each(gplots, function(gid, gplot) {
							var gc = gplot.plugins.cursor;
							if (zHistory && gplot !== plot) {
								gc.zoomHistory.push(zHistory);
							}
							for (var ax in datapos) {
								gplot.axes[ax].min = axes[ax].min;
								gplot.axes[ax].max = axes[ax].max;
								gplot.axes[ax].tickInterval = null;
								gplot.axes[ax].daTickInterval = null;
								//gplot.axes[ax].ticks = axes[ax].ticks;
							}
							gplot.redraw();
							gc._zoom.isZoomed = true;
							if (!gc.snapshotOn && gid != groupid)
								gplot.target.trigger('jqplotZoom');
							//if(gplot.plugins.highlighter) gplot.plugins.highlighter.moveToFrontMultiTooltip(gplot);
						});
						gplots = zHistory = null;
					} else {
						plot.redraw();
						c._zoom.isZoomed = true;
						//if(plot.plugins.highlighter) plot.plugins.highlighter.moveToFrontMultiTooltip(plot);		// customizing (2012-04-23, Roy Choi)
					}

					if (!c.zoomboxMoving && !c.zoomboxDraging) {
						c.prevZoomInfo = $.extend(true, {}, c._zoom);
					}
				}
			}
			if (!c.snapshotOn)
				plot.target.trigger('jqplotZoom', [gridpos, datapos, plot, cursor]);
		} else {
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		}

		c = axes = zaxes = start = end = min = max = dp = span = ctx = null;
		min_x = min_y = max_x = max_y = snapAxes = null;
	};
	// customizing End (2012-04-12, Roy Choi)

	// customizing Start (2012-04-24, Roy Choi)
	$.jqplot.Cursor.prototype.doDrag = function(x_move_pos, y_move_pos, datapos, plot, cursor) {
		var c = cursor;
		var axes = plot.axes;
		// customizing (2012-04-09, Roy Choi)
		var daxes = c._drag.axes;
		var start = daxes.start;
		var min, max, dp, span;
		var startAxes = c.dragStartAxes;

		for (var ax in datapos) {
			dp = datapos[ax];
			if (dp != null) {
				var newmin, newmax;
				var oldmin, oldmax;

				var curax = startAxes[ax];

				oldmin = curax.min;
				oldmax = curax.max;

				if (curax.name.charAt(0) == 'x') {
					newmin = curax.p2u(curax.u2p(oldmin) - x_move_pos);
					newmax = curax.p2u(curax.u2p(oldmax) - x_move_pos);
				} else if (curax.name.charAt(0) == 'y') {
					newmin = curax.p2u(curax.u2p(oldmin) - y_move_pos);
					newmax = curax.p2u(curax.u2p(oldmax) - y_move_pos);
				}

				var _numberTicks = null;

				if (curax.alignTicks) {
					if (curax.name === 'x2axis' && plot.axes.xaxis.show) {
						_numberTicks = plot.axes.xaxis.numberTicks;
					} else if (curax.name.charAt(0) === 'y' && curax.name !== 'yaxis' && curax.name !== 'yMidAxis' && plot.axes.yaxis.show) {
						_numberTicks = plot.axes.yaxis.numberTicks;
					}
				}

				if (this.looseZoom && (axes[ax].renderer.constructor === $.jqplot.LinearAxisRenderer || axes[ax].renderer.constructor === $.jqplot.DateAxisRenderer)) {
					var ret = $.jqplot.LinearTickGenerator(newmin, newmax, curax._scalefact, _numberTicks);

					// if new minimum is less than "true" minimum of axis display, adjust it
					/*if (axes[ax].tickInset && ret[0] < axes[ax].min + axes[ax].tickInset * axes[ax].tickInterval) {
					 ret[0] += ret[4];
					 ret[2] -= 1;
					 }

					 // if new maximum is greater than "true" max of axis display, adjust it
					 if (axes[ax].tickInset && ret[1] > axes[ax].max - axes[ax].tickInset * axes[ax].tickInterval) {
					 ret[1] -= ret[4];
					 ret[2] -= 1;
					 }*/
					axes[ax].min = ret[0];
					axes[ax].max = ret[1];
					axes[ax]._autoFormatString = ret[3];
					axes[ax].numberTicks = ret[2];
					axes[ax].tickInterval = ret[4];
					// for date axes...
					axes[ax].daTickInterval = [ret[4] / 1000, 'seconds'];
				} else {
					axes[ax].min = newmin;
					axes[ax].max = newmax;
					axes[ax].tickInterval = null;
					// for date axes...
					axes[ax].daTickInterval = null;
				}

				axes[ax]._ticks = [];
			}
		}

		plot.redraw();
	};
	// customizing End (2012-04-24, Roy Choi)

	// customizing Start (2012-05-13, Roy Choi) - Series Shift
	$.jqplot.Cursor.prototype.doShift = function(x_move_pos, y_move_pos, datapos, plot, cursor) {
		var c = cursor;
		var ctx = plot.seriesHighlightCanvas._ctx;
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		if (c.seriesShift && c.seriesShiftIndex != null && c._shift.started) {
			plot.seriesCanvas._elem.fadeTo(0, 0.2);
			var s = plot.series[c.seriesShiftIndex];
			var orgData = c._shift.data;
			for (var i = 0, sdlen = s.data.length; i < sdlen; i++) {
				var tmp = orgData[i];
				s.data[i][0] = tmp[0] + x_move_pos;
				s.data[i][1] = tmp[1] + y_move_pos;
				tmp = null;
				//console.log(s.data[i][1], y_move_pos);
			}

			s.draw(ctx, {}, plot);
			orgData = null;
		}
		ctx = null;
	};

	$.jqplot.Cursor.prototype.seriesSameStartPoint = function(plot) {
		var c = plot.plugins.cursor;
		var series = plot.series;
		var startPoint = series[0].data[0];
		var ctx = plot.seriesCanvas._ctx;
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		for (var i = 1, slen = series.length; i < slen; i++) {
			c.shiftedSeries.push(i);
			var sd = series[i].data;
			var x_move = startPoint[0] - sd[0][0];
			var y_move = startPoint[1] - sd[0][1];
			$.each(sd, function(ind, point) {
				point[0] += x_move;
				point[1] += y_move;
			});
			series[i].draw();
		}
		c.seriesShift = false;
		ctx = null;

	};

	$.jqplot.Cursor.prototype.setSeriesShift = function(shiftStyle, plot) {
		var c = plot.plugins.cursor;
		c.seriesShiftStyle = shiftStyle;
		if (c.seriesShiftOrgData == null)
			c.seriesShiftOrgData = $.extend(true, [], plot.data);

		if (shiftStyle == 'samestart') {
			c.seriesSameStartPoint(plot);
		} else {
			c.seriesShift = true;
		}

	};

	$.jqplot.Cursor.prototype.clearShift = function(plot) {
		var c = plot.plugins.cursor;

		var orgData = c.seriesShiftOrgData;
		var series = plot.series;
		/*for(var i=0, slen=series.length; i<slen; i++ ) {
		 series[i].data = $.extend(true,[],orgData[i]);
		 }*/
		$.each(c.shiftedSeries, function(ind, i) {
			series[i].data = $.extend(true, [], orgData[i]);
		});
		c._shift = {
			start : [],
			end : [],
			started : false,
			shifting : false,
			isShifted : false,
			data : []
		};
		c.seriesShiftOrgData = null;
		c.shiftedSeries = [];
		c.seriesShiftStyle = 'horizontal';
		c.seriesShiftIndex = null;
		c.seriesShift = false;
		plot.redraw();
		orgData = null;
		series = null;
		c = null;
	};
	// customizing End (2012-04-24, Roy Choi)

	$.jqplot.preInitHooks.push($.jqplot.Cursor.init);
	$.jqplot.postDrawHooks.push($.jqplot.Cursor.postDraw);

	function updateTooltip(gridpos, datapos, plot) {
		var c = plot.plugins.cursor;
		var s = '';
		var addbr = false;
		if (c.showTooltipGridPosition) {
			s = gridpos.x + ', ' + gridpos.y;
			addbr = true;
		}
		if (c.showTooltipUnitPosition) {
			var g;
			for (var i = 0; i < c.tooltipAxisGroups.length; i++) {
				g = c.tooltipAxisGroups[i];
				if (addbr) {
					s += '<br />';
				}
				if (c.useAxesFormatters) {
					var xf = plot.axes[g[0]]._ticks[0].formatter;
					var yf = plot.axes[g[1]]._ticks[0].formatter;
					var xfstr = plot.axes[g[0]]._ticks[0].formatString;
					var yfstr = plot.axes[g[1]]._ticks[0].formatString;
					s += xf(xfstr, datapos[g[0]]) + ', ' + yf(yfstr, datapos[g[1]]);
				} else {
					s += $.jqplot.sprintf(c.tooltipFormatString, datapos[g[0]], datapos[g[1]]);
				}
				addbr = true;
			}
		}

		if (c.showTooltipDataPosition) {
			var series = plot.series;
			var ret = getIntersectingPoints(plot, gridpos.x, gridpos.y);
			var addbr = false;

			for (var i = 0; i < series.length; i++) {
				if (series[i].show) {
					var idx = series[i].index;
					var label = series[i].label.toString();
					var cellid = $.inArray(idx, ret.indices);
					var sx = undefined;
					var sy = undefined;
					if (cellid != -1) {
						var data = ret.data[cellid].data;
						if (c.useAxesFormatters) {
							var xf = series[i]._xaxis._ticks[0].formatter;
							var yf = series[i]._yaxis._ticks[0].formatter;
							var xfstr = series[i]._xaxis._ticks[0].formatString;
							var yfstr = series[i]._yaxis._ticks[0].formatString;
							sx = xf(xfstr, data[0]);
							sy = yf(yfstr, data[1]);
						} else {
							sx = data[0];
							sy = data[1];
						}
						if (addbr) {
							s += '<br />';
						}
						s += $.jqplot.sprintf(c.tooltipFormatString, label, sx, sy);
						addbr = true;
					}
				}
			}

		}
		c._tooltipElem.html(s);
	}

	// customizing (2016-06-20, Carrie bae) : add shapeDrawOption 
	function moveLine(gridpos, plot) {
		var c = plot.plugins.cursor;
		var ctx = c.cursorCanvas._ctx;
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		if (c.showVerticalLine) {
			c.shapeRenderer.draw(ctx, [[gridpos.x, 0], [gridpos.x, ctx.canvas.height]], c.shapeDrawOption);
		}
		if (c.showHorizontalLine) {
			c.shapeRenderer.draw(ctx, [[0, gridpos.y], [ctx.canvas.width, gridpos.y]], c.shapeDrawOption);
		}
		var ret = getIntersectingPoints(plot, gridpos.x, gridpos.y);
		if (c.showCursorLegend) {
			var cells = $(plot.targetId + ' td.jqplot-cursor-legend-label');
			for (var i = 0; i < cells.length; i++) {
				var idx = $(cells[i]).data('seriesIndex');
				var series = plot.series[idx];
				var label = series.label.toString();
				var cellid = $.inArray(idx, ret.indices);
				var sx = undefined;
				var sy = undefined;
				if (cellid != -1) {
					var data = ret.data[cellid].data;
					if (c.useAxesFormatters) {
						var xf = series._xaxis._ticks[0].formatter;
						var yf = series._yaxis._ticks[0].formatter;
						var xfstr = series._xaxis._ticks[0].formatString;
						var yfstr = series._yaxis._ticks[0].formatString;
						sx = xf(xfstr, data[0]);
						sy = yf(yfstr, data[1]);
					} else {
						sx = data[0];
						sy = data[1];
					}
				}
				if (plot.legend.escapeHtml) {
					$(cells[i]).text($.jqplot.sprintf(c.cursorLegendFormatString, label, sx, sy));
				} else {
					$(cells[i]).html($.jqplot.sprintf(c.cursorLegendFormatString, label, sx, sy));
				}
			}
		}
		ctx = null;
	}

	function getIntersectingPoints(plot, x, y) {
		var ret = {
			indices : [],
			data : []
		};
		var s, i, d0, d, j, r, p;
		var threshold;
		var c = plot.plugins.cursor;
		for (var i = 0; i < plot.series.length; i++) {
			s = plot.series[i];
			r = s.renderer;
			if (s.show) {
				threshold = c.intersectionThreshold;
				if (s.showMarker) {
					threshold += s.markerRenderer.size / 2;
				}
				for (var j = 0; j < s.gridData.length; j++) {
					p = s.gridData[j];
					// check vertical line
					if (c.showVerticalLine) {
						if (Math.abs(x - p[0]) <= threshold) {
							ret.indices.push(i);
							ret.data.push({
								seriesIndex : i,
								pointIndex : j,
								gridData : p,
								data : s.data[j]
							});
						}
					}
				}
			}
		}
		return ret;
	}

	function moveTooltip(gridpos, plot) {
		var c = plot.plugins.cursor;
		var elem = c._tooltipElem;
		switch (c.tooltipLocation) {
			case 'nw':
				var x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - c.tooltipOffset;
				var y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(true);
				break;
			case 'n':
				var x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) / 2;
				var y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(true);
				break;
			case 'ne':
				var x = gridpos.x + plot._gridPadding.left + c.tooltipOffset;
				var y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(true);
				break;
			case 'e':
				var x = gridpos.x + plot._gridPadding.left + c.tooltipOffset;
				var y = gridpos.y + plot._gridPadding.top - elem.outerHeight(true) / 2;
				break;
			case 'se':
				var x = gridpos.x + plot._gridPadding.left + c.tooltipOffset;
				var y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
				break;
			case 's':
				var x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) / 2;
				var y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
				break;
			case 'sw':
				var x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - c.tooltipOffset;
				var y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
				break;
			case 'w':
				var x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - c.tooltipOffset;
				var y = gridpos.y + plot._gridPadding.top - elem.outerHeight(true) / 2;
				break;
			default:
				var x = gridpos.x + plot._gridPadding.left + c.tooltipOffset;
				var y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
				break;
		}

		elem.css('left', x);
		elem.css('top', y);
		elem = null;
	}

	function positionTooltip(plot) {
		// fake a grid for positioning
		var grid = plot._gridPadding;
		var c = plot.plugins.cursor;
		var elem = c._tooltipElem;
		switch (c.tooltipLocation) {
			case 'nw':
				var a = grid.left + c.tooltipOffset;
				var b = grid.top + c.tooltipOffset;
				elem.css('left', a);
				elem.css('top', b);
				break;
			case 'n':
				var a = (grid.left + (plot._plotDimensions.width - grid.right)) / 2 - elem.outerWidth(true) / 2;
				var b = grid.top + c.tooltipOffset;
				elem.css('left', a);
				elem.css('top', b);
				break;
			case 'ne':
				var a = grid.right + c.tooltipOffset;
				var b = grid.top + c.tooltipOffset;
				elem.css({
					right : a,
					top : b
				});
				break;
			case 'e':
				var a = grid.right + c.tooltipOffset;
				var b = (grid.top + (plot._plotDimensions.height - grid.bottom)) / 2 - elem.outerHeight(true) / 2;
				elem.css({
					right : a,
					top : b
				});
				break;
			case 'se':
				var a = grid.right + c.tooltipOffset;
				var b = grid.bottom + c.tooltipOffset;
				elem.css({
					right : a,
					bottom : b
				});
				break;
			case 's':
				var a = (grid.left + (plot._plotDimensions.width - grid.right)) / 2 - elem.outerWidth(true) / 2;
				var b = grid.bottom + c.tooltipOffset;
				elem.css({
					left : a,
					bottom : b
				});
				break;
			case 'sw':
				var a = grid.left + c.tooltipOffset;
				var b = grid.bottom + c.tooltipOffset;
				elem.css({
					left : a,
					bottom : b
				});
				break;
			case 'w':
				var a = grid.left + c.tooltipOffset;
				var b = (grid.top + (plot._plotDimensions.height - grid.bottom)) / 2 - elem.outerHeight(true) / 2;
				elem.css({
					left : a,
					top : b
				});
				break;
			default:
				// same as 'se'
				var a = grid.right - c.tooltipOffset;
				var b = grid.bottom + c.tooltipOffset;
				elem.css({
					right : a,
					bottom : b
				});
				break;
		}
		elem = null;
	}

	function handleClick(ev, gridpos, datapos, neighbor, plot) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var c = plot.plugins.cursor;
		if (c.clickReset) {
			c.resetZoom(plot, c);
		}
		var sel = window.getSelection;
		if (document.selection && document.selection.empty) {
			document.selection.empty();
		} else if (sel && !sel().isCollapsed) {
			sel().collapse();
		}
		return false;
	}

	function handleDblClick(ev, gridpos, datapos, neighbor, plot) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var c = plot.plugins.cursor;
		if (c.dblClickReset) {
			c.resetZoom(plot, c);
		}
		var sel = window.getSelection;
		if (document.selection && document.selection.empty) {
			document.selection.empty();
		} else if (sel && !sel().isCollapsed) {
			sel().collapse();
		}
		return false;
	}

	function handleMouseLeave(ev, gridpos, datapos, neighbor, plot) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var c = plot.plugins.cursor;
		c.onGrid = false;
		if (c.show) {
			$(ev.target).css('cursor', c.previousCursor);
			if (c.showTooltip && !(c._zoom.zooming && c.showTooltipOutsideZoom && !c.constrainOutsideZoom)) {
				c._tooltipElem.hide();
			}
			if (c.zoom) {
				c._zoom.gridpos = gridpos;
				c._zoom.datapos = datapos;
			}
			if (c.showVerticalLine || c.showHorizontalLine) {
				var ctx = c.cursorCanvas._ctx;
				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				ctx = null;
			}
			if (c.showCursorLegend) {
				var cells = $(plot.targetId + ' td.jqplot-cursor-legend-label');
				for (var i = 0; i < cells.length; i++) {
					var idx = $(cells[i]).data('seriesIndex');
					var series = plot.series[idx];
					var label = series.label.toString();
					if (plot.legend.escapeHtml) {
						$(cells[i]).text($.jqplot.sprintf(c.cursorLegendFormatString, label, undefined, undefined));
					} else {
						$(cells[i]).html($.jqplot.sprintf(c.cursorLegendFormatString, label, undefined, undefined));
					}

				}
			}
		}
	}

	function handleMouseEnter(ev, gridpos, datapos, neighbor, plot) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var c = plot.plugins.cursor;
		c.onGrid = true;
		if (c.show) {
			c.previousCursor = ev.target.style.cursor;
			ev.target.style.cursor = c.style;
			if (c.showTooltip) {
				updateTooltip(gridpos, datapos, plot);
				if (c.followMouse) {
					moveTooltip(gridpos, plot);
				} else {
					positionTooltip(plot);
				}
				c._tooltipElem.show();
			}
			if (c.showVerticalLine || c.showHorizontalLine) {
				moveLine(gridpos, plot);
			}
		}

	}

	function handleMouseMove(ev, gridpos, datapos, neighbor, plot) {
		var c = plot.plugins.cursor;
		if (c.zoomProxy && c._zoom.isZoomed) {// cusomizing for zoom box (2013-02-22, Roy Choi)
			var overType = checkOverZoomBoxLine(ev, gridpos, c);
			if (!c._zoom.zooming && overType !== null) {
				if (c.prevCursorStyle === null) {
					c.prevCursorStyle = ev.target.style.cursor;
					if (c.constrainZoomTo == 'x' || c.constrainZoomTo == '')
						switch(overType) {//s, sv, sh, svh, e, ev, eh, evh
							case 'sv':
							case 'ev':
								ev.target.style.cursor = 'col-resize';
								break;
							case 'sh':
							case 'eh':
								ev.target.style.cursor = 'row-resize';
								break;
							case 'svh':
							case 'evh':
								//TODO
								break;
						}
				}
				/*} else if(!c._zoom.zooming && isInnerZoomBox(ev, gridpos, c)) {
				 if(c.prevCursorStyle === null) {
				 c.prevCursorStyle = ev.target.style.cursor;
				 ev.target.style.cursor = 'move';
				 }*/
			} else if (!c._zoom.zooming) {
				ev.target.style.cursor = c.style;
				c.prevCursorStyle = null;
			}
		} else if (c._zoom.zooming) {
			ev.target.style.cursor = c.style;
		}
		if (c.show) {
			if (c.showTooltip) {
				updateTooltip(gridpos, datapos, plot);
				if (c.followMouse) {
				    ev.preventDefault();
                    ev.stopImmediatePropagation();
					moveTooltip(gridpos, plot);
				}
			}
			if (c.showVerticalLine || c.showHorizontalLine) {
			    // ev.preventDefault();
                // ev.stopImmediatePropagation();
				moveLine(gridpos, plot);
			}
		}
	}

	function getEventPosition(ev) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var plot = ev.data.plot;
		var go = plot.eventCanvas._elem.offset();
		var gridPos = {
			x : ev.pageX - go.left,
			y : ev.pageY - go.top
		};
		//////
		// TO DO: handle yMidAxis
		//////
		var dataPos = {
			xaxis : null,
			yaxis : null,
			x2axis : null,
			y2axis : null,
			y3axis : null,
			y4axis : null,
			y5axis : null,
			y6axis : null,
			y7axis : null,
			y8axis : null,
			y9axis : null,
			yMidAxis : null
		};
		var an = ['xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
		var ax = plot.axes;
		var n, axis;
		for ( n = 11; n > 0; n--) {
			axis = an[n - 1];
			if (ax[axis].show) {
				dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);
			}
		}

		return {
			offsets : go,
			gridPos : gridPos,
			dataPos : dataPos
		};
	}

	function handleZoomMove(ev) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var plot = ev.data.plot;
		var start = ev.data.start;
		var c = plot.plugins.cursor;
		// don't do anything if not on grid.
		if (c.show && c.zoom && c._zoom.started && !c.zoomTarget) {
			var ctx = c.zoomCanvas._ctx;
			var positions = getEventPosition(ev);
			var gridpos = positions.gridPos;
			if (Math.abs(gridpos.x - start.x) * Math.abs(gridpos.y - start.y) < 10)
				return;
			var datapos = positions.dataPos;
			c._zoom.gridpos = gridpos;
			c._zoom.datapos = datapos;
			c._zoom.zooming = true;
			var xpos = gridpos.x;
			var ypos = gridpos.y;
			var height = ctx.canvas.height;
			var width = ctx.canvas.width;
			if (c.showTooltip && !c.onGrid && c.showTooltipOutsideZoom) {
				updateTooltip(gridpos, datapos, plot);
				if (c.followMouse) {
					moveTooltip(gridpos, plot);
				}
			}
			if (c.constrainZoomTo == 'x') {
				c._zoom.end = [xpos, height];
			} else if (c.constrainZoomTo == 'y') {
				c._zoom.end = [width, ypos];
			} else {
				c._zoom.end = [xpos, ypos];
			}
			var sel = window.getSelection;
			if (document.selection && document.selection.empty) {
				document.selection.empty();
			} else if (sel && !sel().isCollapsed) {
				try{
				    sel().collapse();
				} catch(e){}
			}
			drawZoomBox.call(c);
			ctx = null;
		}
	}

	function forceMin(val, min) {
		return val < min ? min : val;
	}

	function forceMax(val, max) {
		return val > max ? max : val;
	}

	function forceValue(val, min, max) {
		return forceMax(forceMin(val, min), max);
	}

	function forceCompareValue(val1, val2, add, min, max) {
		if (val1 > val2) {
			if (val1 > max) {
				val1 = forceMax(val1, max);
				val2 = val1 - add;
			} else if (val2 < min) {
				val2 = forceMin(val2, min);
				val1 = val2 + add;
			}
		} else {
			if (val2 > max) {
				val2 = forceMax(val2, max);
				val1 = val2 - add;
			} else if (val1 < min) {
				val1 = forceMin(val1, min);
				val2 = val1 + add;
			}
		}

		return [val1, val2];
	}

	// customizing for move zoom box (2013-02-21, Roy Choi)
	function handleMoveZoomBox(ev) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var plot = ev.data.plot;
		var start = ev.data.start;
		// mouse down point
		var overType = ev.data.overType;
		var c = plot.plugins.cursor;
		c._zoom = $.extend(true, {}, c.prevZoomInfo);
		// don't do anything if not on grid.
		if (c.show && c.zoom && c._zoom && c.zoomProxy) {
			var ctx = c.zoomCanvas._ctx;
			var positions = getEventPosition(ev);
			var gridpos = positions.gridPos;

			var movingX = gridpos.x - start.x;
			var movingY = gridpos.y - start.y;

			var boxWidth = Math.abs(c.prevZoomInfo.end[0] - c.prevZoomInfo.start[0]);
			var boxHeight = Math.abs(c.prevZoomInfo.end[1] - c.prevZoomInfo.start[1]);

			var height = ctx.canvas.height;
			var width = ctx.canvas.width;

			var go = plot.eventCanvas._elem.offset();
			var offsetLeft = go.left;
			var offsetTop = go.top;

			var x, y, xs, xe, ys, ye;

			if ( typeof overType == 'undefined') {
				if (c.constrainZoomTo == 'x') {
					xs = c._zoom.start[0] + movingX;
					xe = c._zoom.end[0] + movingX;

					x = forceCompareValue(xs, xe, boxWidth, 0, width);

					c._zoom.start = [x[0], 0];
					c._zoom.end = [x[1], 0];
				} else if (c.constrainZoomTo == 'y') {
					ys = c._zoom.start[1] + movingY;
					ye = c._zoom.end[1] + movingY;

					y = forceCompareValue(ys, ye, boxHeight, 0, height);

					c._zoom.start = [0, y[0]];
					c._zoom.end = [0, y[1]];
				} else {
					xs = c._zoom.start[0] + movingX;
					xe = c._zoom.end[0] + movingX;

					x = forceCompareValue(xs, xe, boxWidth, 0, width);

					ys = c._zoom.start[1] + movingY;
					ye = c._zoom.end[1] + movingY;

					y = forceCompareValue(ys, ye, boxHeight, 0, height);

					c._zoom.start = [x[0], y[0]];
					c._zoom.end = [x[1], y[1]];
				}
			} else {
				if (c.constrainZoomTo == 'x') {
					//console.log('box width', boxWidth);
					if (overType == 'sv') {
						x = forceValue(c._zoom.start[0] + movingX, 0, width);
						c._zoom.start = [x, 0];
					} else if (overType == 'ev') {
						x = forceValue(c._zoom.end[0] + movingX, 0, width);
						c._zoom.end = [x, 0];
					}
				} else if (c.constrainZoomTo == 'y') {
					if (overType == 'sh') {
						y = forceValue(c._zoom.start[1] + movingY, 0, height);
						c._zoom.start = [0, y];
					} else if (overType == 'eh') {
						y = forceValue(c._zoom.end[1] + movingY, 0, height);
						c._zoom.end = [0, y];
					}
				} else {
					/// TODO:
				}
			}

			x = y = xs = xe = ys = ye = null;

			var startEv = $.extend(true, {}, ev);
			startEv.pageX = c._zoom.start[0] + offsetLeft;
			startEv.pageY = c._zoom.start[1] + offsetTop;

			var startPosition = getEventPosition(startEv);
			var startDatapos = startPosition.dataPos;

			c._zoom.started = true;
			for (var ax in startDatapos) {
				// get zoom starting position.
				c._zoom.axes.start[ax] = startDatapos[ax];
			}
			startEv = startDatapos = startPosition = ax = null;

			var endEv = $.extend(true, {}, ev);
			endEv.pageX = c._zoom.end[0] + offsetLeft;
			endEv.pageY = c._zoom.end[0] + offsetTop;

			var endPosition = getEventPosition(endEv);
			var datapos = endPosition.dataPos;
			gridpos = endPosition.gridPos;

			endEv = null;

			c._zoom.gridpos = gridpos;
			c._zoom.datapos = datapos;
			c._zoom.zooming = true;

			var xpos = gridpos.x;
			var ypos = gridpos.y;

			if (c.constrainZoomTo == 'x') {
				c._zoom.end = [xpos, height];
				ypos = height;
			} else if (c.constrainZoomTo == 'y') {
				c._zoom.end = [width, ypos];
				xpos = width;
			} else {
				c._zoom.end = [xpos, ypos];
			}

			var sel = window.getSelection;
			if (document.selection && document.selection.empty) {
				document.selection.empty();
			} else if (sel && !sel().isCollapsed) {
				sel().collapse();
			}

			if (Math.abs(c._zoom.start[0] - c._zoom.end[0]) * Math.abs(c._zoom.start[1] - c._zoom.end[1]) < 10) {
				return;
			}

			drawZoomBox.call(c);
			ctx = null;

			/* doZoom prepare start */
			var axes = plot.axes;

			c.endGridPoint = [xpos, ypos];
			//customizing (2012-04-13, Roy Choi)

			if (c.constrainOutsideZoom && !c.onGrid) {
				if (xpos < 0) {
					xpos = 0;
				} else if (xpos > width) {
					xpos = width;
				}
				if (ypos < 0) {
					ypos = 0;
				} else if (ypos > height) {
					ypos = height;
				}

				for (var axis in datapos) {
					if (datapos[axis]) {
						if (axis.charAt(0) == 'x') {
							datapos[axis] = axes[axis].series_p2u(xpos);
						} else {
							datapos[axis] = axes[axis].series_p2u(ypos);
						}
					}
				}
			}

			c.endDataPos = datapos;

			if (c.drawOnZoomBoxMove) {
				c.doZoom(c._zoom.gridpos, datapos, plot, c);
			}
		}

	}

	// customizing for move zoom box (2013-02-21, Roy Choi)
	function handleZoomBoxStop(ev) {
		$(document).unbind('mousemove.jqplotCursor', handleMoveZoomBox);
		//$(document).unbind('mousemove.jqplotCursor', handleDragZoomBoxLine);

		var plot = ev.data.plot;
		var c = plot.plugins.cursor;

		if (!c.drawOnZoomBoxMove) {
			c.doZoom(c.endGridPoint, c.endDataPos, plot, c);
		}

		c._zoom.started = false;
		c._zoom.zooming = false;

		c.zoomboxMoving = false;
		c.zoomboxDraging = false;

		ev.target.style.cursor = c.prevCursorStyle;
		c.prevCursorStyle = null;

		c.prevZoomInfo = $.extend(true, {}, c._zoom);

		//if (document.onselectstart != undefined && c._oldHandlers.onselectstart != null){
		document.onselectstart = c._oldHandlers.onselectstart;
		c._oldHandlers.onselectstart = null;
		//}
		if (document.ondrag != undefined && c._oldHandlers.ondrag != null) {
			document.ondrag = c._oldHandlers.ondrag;
			c._oldHandlers.ondrag = null;
		}
		if (document.onmousedown != undefined && c._oldHandlers.onmousedown != null) {
			document.onmousedown = c._oldHandlers.onmousedown;
			c._oldHandlers.onmousedown = null;
		}
		plot = c = null;
	}

	/* customizing start (2012-04-23, Roy Choi) */
	function handleDragMove(ev) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var plot = ev.data.plot;
		var c = plot.plugins.cursor;
		// don't do anything if not on grid.
		if (c.show && c.zoom && c._zoom.isZoomed && c.draggable && c._drag.started && !c.zoomTarget) {
			var positions = getEventPosition(ev);
			var gridpos = positions.gridPos;
			var datapos = positions.dataPos;

			c._drag.dragging = true;
			var xpos = gridpos.x;
			var ypos = gridpos.y;

			if (c.constrainDragTo == 'x') {
				ypos = 0;
			} else if (c.constrainDragTo == 'y') {
				xpos = 0;
			}

			c.endGridPoint = [xpos, ypos];

			c._drag.end = [xpos, ypos];
			c._drag.gridpos = {
				x : xpos,
				y : ypos
			};

			var x_move_pos = c.endGridPoint[0] - c.startGridPoint[0];
			var y_move_pos = c.endGridPoint[1] - c.startGridPoint[1];

			c.doDrag.call(c, x_move_pos, y_move_pos, datapos, plot, c);
		}
	}

	/* customizing end (2012-04-23, Roy Choi) */

	/* customizing start (2012-04-23, Roy Choi) */
	function handleShiftMove(ev) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var plot = ev.data.plot;
		var c = plot.plugins.cursor;
		// don't do anything if not on grid.
		if (c.show && c.seriesShift && c.seriesShiftIndex != null && c._shift.started) {
			var positions = getEventPosition(ev);
			var gridpos = positions.gridPos;
			var datapos = positions.dataPos;

			c._shift.shifting = true;
			var xpos = gridpos.x;
			var ypos = gridpos.y;

			if (c.seriesShiftStyle == 'horizontal') {
				ypos = 0;
			} else if (c.seriesShiftStyle == 'vertical') {
				xpos = 0;
			}

			c.endGridPoint = [xpos, ypos];

			c._shift.end = [xpos, ypos];
			c._shift.gridpos = {
				x : xpos,
				y : ypos
			};

			var p2u_series_index = 0;

			for (var i = 0, slen = plot.series.length; i < slen; i++) {
				if ($.inArray(i, c.shiftedSeries) < 0 && c.seriesShiftIndex) {
					var p2u_series_index = i;
					break;
				}
			}

			var xaxis = plot.axes[plot.series[p2u_series_index].xaxis];
			var yaxis = plot.axes[plot.series[p2u_series_index].yaxis];

			var x_move_pos = xaxis.series_p2u(c.endGridPoint[0]) - xaxis.series_p2u(c.startGridPoint[0]);
			var y_move_pos = yaxis.series_p2u(c.endGridPoint[1]) - yaxis.series_p2u(c.startGridPoint[1]);

			//console.log(x_move_pos, c.endGridPoint[0]-c.startGridPoint[0]);

			//console.log(c,x_move_pos, y_move_pos, datapos, plot, c);

			c.doShift(x_move_pos, y_move_pos, datapos, plot, c);
		}
	}

	/* customizing end (2012-04-23, Roy Choi) */

	/* customizing start (2013-02-22, Roy Choi) */
	function isInnerZoomBox(ev, gridpos, cursor) {
		var c = cursor;
		var prevZoomInfo = c.prevZoomInfo;
		var prevStart = prevZoomInfo.start;
		var prevEnd = prevZoomInfo.end;

		var innerOfPrevZoomBox = false;

		switch(c.constrainZoomTo) {
			case 'none':
				if ((gridpos.x > prevStart[0] + c.zoomboxThreshold && gridpos.x < prevEnd[0] + c.zoomboxThreshold && gridpos.y > prevStart[1] + c.zoomboxThreshold && gridpos.y < prevEnd[1] - c.zoomboxThreshold) || (gridpos.x > prevStart[0] + c.zoomboxThreshold && gridpos.x < prevEnd[0] + c.zoomboxThreshold && gridpos.y < prevStart[1] - c.zoomboxThreshold && gridpos.y > prevEnd[1] + c.zoomboxThreshold) || (gridpos.x < prevStart[0] + c.zoomboxThreshold && gridpos.x > prevEnd[0] + c.zoomboxThreshold && gridpos.y > prevStart[1] + c.zoomboxThreshold && gridpos.y < prevEnd[1] - c.zoomboxThreshold) || (gridpos.x < prevStart[0] + c.zoomboxThreshold && gridpos.x > prevEnd[0] + c.zoomboxThreshold && gridpos.y < prevStart[1] - c.zoomboxThreshold && gridpos.y > prevEnd[1] + c.zoomboxThreshold)) {
					innerOfPrevZoomBox = true;
				}
				break;
			case 'y':
				if (gridpos.y > prevStart[1] + c.zoomboxThreshold && gridpos.y < prevEnd[1] - c.zoomboxThreshold || gridpos.y < prevStart[1] - c.zoomboxThreshold && gridpos.y > prevEnd[1] + c.zoomboxThreshold) {
					innerOfPrevZoomBox = true;
				}
				break;
			case 'x':
			default:
				if (gridpos.x > prevStart[0] + c.zoomboxThreshold && gridpos.x < prevEnd[0] + c.zoomboxThreshold || gridpos.x < prevStart[0] + c.zoomboxThreshold && gridpos.x > prevEnd[0] + c.zoomboxThreshold) {
					innerOfPrevZoomBox = true;
				}
				break;
		}
		c = prevZoomInfo = prevStart = prevEnd = null;

		return innerOfPrevZoomBox;
	}

	function checkOverZoomBoxLine(ev, gridpos, cursor) {
		var c = cursor;
		var prevZoomInfo = c.prevZoomInfo;
		var prevStart = prevZoomInfo.start;
		var prevEnd = prevZoomInfo.end;

		var overType = null;

		switch(c.constrainZoomTo) {
			case 'none':
				//if (false) {
				/// TODO: both zoom box resize
				//}
				break;
			case 'y':
				if (gridpos.y <= prevStart[1] + c.zoomboxThreshold && gridpos.y >= prevStart[1] - c.zoomboxThreshold) {
					overType = 'sh';
				} else if (gridpos.y <= prevEnd[1] + c.zoomboxThreshold && gridpos.y >= prevEnd[1] - c.zoomboxThreshold) {
					overType = 'eh';
				}
				break;
			case 'x':
			default:
				if (gridpos.x <= prevStart[0] + c.zoomboxThreshold && gridpos.x >= prevStart[0] - c.zoomboxThreshold) {
					overType = 'sv';
				} else if (gridpos.x <= prevEnd[0] + c.zoomboxThreshold && gridpos.x >= prevEnd[0] - c.zoomboxThreshold) {
					overType = 'ev';
				}
				break;
		}
		c = prevZoomInfo = prevStart = prevEnd = null;

		return overType;
	}

	/* customizing end (2013-02-22, Roy Choi) */

	function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var c = plot.plugins.cursor;

		// customizing for move zoombox on the zoomProxy plot (2013-02-21, Roy Choi) start
		if (c.zoomProxy/* && c._zoom.isZoomed*/) {
			//c.prevZoomInfo = $.extend(true, {}, c._zoom);

			var overType = checkOverZoomBoxLine(ev, gridpos, c);

			if (overType !== null) {
				c.zoomboxDraging = true;
				$(document).bind('mousemove.jqplotCursor', {
					plot : plot,
					start : gridpos,
					overType : overType
				}, handleMoveZoomBox);
				$(document).one('mouseup.jqplot_cursor', {
					plot : plot
				}, handleZoomBoxStop);

				c._oldHandlers.onselectstart = document.onselectstart;
				document.onselectstart = function() {
					return false;
				};

				if (document.ondrag != undefined) {
					c._oldHandlers.ondrag = document.ondrag;
					document.ondrag = function() {
						return false;
					};
				}
				if (document.onmousedown != undefined) {
					c._oldHandlers.onmousedown = document.onmousedown;
					document.onmousedown = function() {
						return false;
					};
				}

				return;
			} else if (isInnerZoomBox(ev, gridpos, c)) {
				c.zoomboxMoving = true;
				$(document).bind('mousemove.jqplotCursor', {
					plot : plot,
					start : gridpos
				}, handleMoveZoomBox);
				$(document).one('mouseup.jqplot_cursor', {
					plot : plot
				}, handleZoomBoxStop);

				c._oldHandlers.onselectstart = document.onselectstart;
				document.onselectstart = function() {
					return false;
				};

				if (document.ondrag != undefined) {
					c._oldHandlers.ondrag = document.ondrag;
					document.ondrag = function() {
						return false;
					};
				}
				if (document.onmousedown != undefined) {
					c._oldHandlers.onmousedown = document.onmousedown;
					document.onmousedown = function() {
						return false;
					};
				}

				return;
			}

			$(document).unbind('mousemove.jqplotCursor', handleMoveZoomBox);
		}
		// customizing for move zoombox on the zoomProxy plot (2013-02-21, Roy Choi) end

		$(document).one('mouseup.jqplot_cursor', {
			plot : plot
		}, handleMouseUp);
		//if (document.onselectstart != undefined) {
		c._oldHandlers.onselectstart = document.onselectstart;
		document.onselectstart = function() {
			return false;
		};
		//}
		if (document.ondrag != undefined) {
			c._oldHandlers.ondrag = document.ondrag;
			document.ondrag = function() {
				return false;
			};
		}
		if (document.onmousedown != undefined) {
			c._oldHandlers.onmousedown = document.onmousedown;
			document.onmousedown = function() {
				return false;
			};
		}
		if (c.seriesShift) {//customizing (2012-05-13, Roy Choi)
			if (neighbor == null) {
				neighbor = plot.plugins.highlighter.isLineOver(gridpos, plot);
			}
			if (!c._shift.started && neighbor && c.seriesShiftIndex != neighbor.seriesIndex) {
				if (plot.series.length > 1) {
					if (plot.series.length > c.shiftedSeries.length) {
						if (plot.series.length - c.shiftedSeries.length == 1 && $.inArray(neighbor.seriesIndex, c.shiftedSeries) < 0) {
							alert('You can not shift the last series because it is base data series to compare the other one');
						} else {
							if ($.inArray(neighbor.seriesIndex, c.shiftedSeries) < 0)
								c.shiftedSeries.push(neighbor.seriesIndex);
							c.seriesShiftIndex = neighbor.seriesIndex;
						}
					}
				} else {
					alert('You can not shift the last series because it is base data series to compare the other one');
				}

			} else if (c.seriesShiftIndex != null) {
				c.startGridPoint = [gridpos.x, gridpos.y];
				if (c.seriesShiftStyle == 'vertical') {
					c._shift.start = [gridpos.x, 0];
					c.startGridPoint[0] = 0;
				} else if (c.seriesShiftStyle == 'horizontal') {
					c._shift.start = [0, gridpos.y];
					c.startGridPoint[1] = 0;
				} else {
					c._shift.start = [gridpos.x, gridpos.y];
				}
				c._shift.data = $.extend(true, [], plot.series[c.seriesShiftIndex].data);
				c._shift.started = true;
				$(document).bind('mousemove.jqplotCursor', {
					plot : plot,
					start : gridpos
				}, handleShiftMove);
			}
		} else if (c.zoom) {
			c.startGridPoint = [gridpos.x, gridpos.y];
			//customizing (2012-04-13, Roy Choi)
			if (!c.zoomProxy) {
				var ctx = c.zoomCanvas._ctx;
				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				ctx = null;
			}
			if (c.constrainZoomTo == 'x') {
				c._zoom.start = [gridpos.x, 0];
			} else if (c.constrainZoomTo == 'y') {
				c._zoom.start = [0, gridpos.y];
			} else {
				c._zoom.start = [gridpos.x, gridpos.y];
			}
			c._zoom.started = true;
			for (var ax in datapos) {
				// get zoom starting position.
				c._zoom.axes.start[ax] = datapos[ax];
			}
			$(document).bind('mousemove.jqplotCursor', {
				plot : plot,
				start : gridpos
			}, handleZoomMove);
		}
	}

	/* customizing start (2012-04-23, Roy Choi) */
	function handleRightDown(ev, gridpos, datapos, neighbor, plot) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var c = plot.plugins.cursor;
		var startAxes = c.dragStartAxes;
		$(document).one('mouseup.jqplot_cursor', {
			plot : plot
		}, handleRightUp);
		var axes = plot.axes;
		if (document.onselectstart != undefined) {
			c._oldHandlers.onselectstart = document.onselectstart;
			document.onselectstart = function() {
				return false;
			};
		}
		if (document.ondrag != undefined) {
			c._oldHandlers.ondrag = document.ondrag;
			document.ondrag = function() {
				return false;
			};
		}
		if (document.onmousedown != undefined) {
			c._oldHandlers.onmousedown = document.onmousedown;
			document.onmousedown = function() {
				return false;
			};
		}
		if (c.zoom && c._zoom.isZoomed && c.draggable) {
			for (var ax in datapos) {
				startAxes[ax] = $.extend(true, {}, axes[ax]);
			}

			c.startGridPoint = [gridpos.x, gridpos.y];
			//customizing (2012-04-13, Roy Choi)
			if (c.constrainDragTo == 'x') {
				c._drag.start = [gridpos.x, 0];
			} else if (c.constrainDragTo == 'y') {
				c._drag.start = [0, gridpos.y];
			} else {
				c._drag.start = [gridpos.x, gridpos.y];
			}
			c._drag.started = true;
			for (var ax in datapos) {
				// get zoom starting position.
				c._drag.axes.start[ax] = datapos[ax];
			}
			$(document).bind('mousemove.jqplotCursor', {
				plot : plot
			}, handleDragMove);
		}
	}

	/* customizing end (2012-04-23, Roy Choi) */

	function handleMouseUp(ev, neighbor) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var plot = ev.data.plot;
		var c = plot.plugins.cursor;
		if (c.seriesShift && c._shift.shifting) {
			var ctx = plot.seriesHighlightCanvas._ctx;
			ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
			ctx = null;
			plot.redraw();
			//plot.replot({resetAxes:true});
			c._shift.shifting = false;
		} else if (c.zoom && c._zoom.zooming && !c.zoomTarget) {
			var xpos = c._zoom.gridpos.x;
			var ypos = c._zoom.gridpos.y;
			var datapos = c._zoom.datapos;
			var height = c.zoomCanvas._ctx.canvas.height;
			var width = c.zoomCanvas._ctx.canvas.width;
			var axes = plot.axes;

			c.endGridPoint = [xpos, ypos];
			//customizing (2012-04-13, Roy Choi)

			if (c.constrainOutsideZoom && !c.onGrid) {
				if (xpos < 0) {
					xpos = 0;
				} else if (xpos > width) {
					xpos = width;
				}
				if (ypos < 0) {
					ypos = 0;
				} else if (ypos > height) {
					ypos = height;
				}

				for (var axis in datapos) {
					if (datapos[axis]) {
						if (axis.charAt(0) == 'x') {
							datapos[axis] = axes[axis].series_p2u(xpos);
						} else {
							datapos[axis] = axes[axis].series_p2u(ypos);
						}
					}
				}
			}

			if (c.constrainZoomTo == 'x') {
				ypos = height;
			} else if (c.constrainZoomTo == 'y') {
				xpos = width;
			}
			c._zoom.end = [xpos, ypos];
			c._zoom.gridpos = {
				x : xpos,
				y : ypos
			};

			// customizing Start (2012-04-12, Roy Choi)
			var right2left = 0;
			var direction = 0;
			if (c.right2leftUndo && !c.zoomProxy) {
				if (c.constrainZoomTo == 'x') {
					right2left = Math.abs(c.startGridPoint[1] - c.endGridPoint[1]);
					direction = Math.abs(c.startGridPoint[0] - c.endGridPoint[0]);
				} else if (c.constrainZoomTo == 'y') {
					right2left = Math.abs(c.startGridPoint[0] - c.endGridPoint[0]);
					direction = Math.abs(c.startGridPoint[1] - c.endGridPoint[1]);
				} else {
					right2left = c.startGridPoint[0] - c.endGridPoint[0];
				}
			}
			if (direction < c.right2leftUndoDirection && right2left >= c.right2leftUndoWidth && right2left < c.right2leftResetWidth) {
				plot.undoZoom();
			} else if (direction < c.right2leftUndoDirection && right2left > c.right2leftResetWidth) {
				plot.resetZoom();
			} else {
				c.doZoom(c._zoom.gridpos, datapos, plot, c);
			}
			// customizing End (2012-04-12, Roy Choi)

		}

		/*if(c.zoomProxy) {
		 c._zoom.isZoomed = true;
		 }*/

		c._zoom.started = false;
		c._zoom.zooming = false;

		c._shift.started = false;
		c._shift.shifting = false;
		c._shift.data = null;

		$(document).unbind('mousemove.jqplotCursor', handleZoomMove);
		$(document).unbind('mousemove.jqplotCursor', handleShiftMove);

		//if (document.onselectstart != undefined && c._oldHandlers.onselectstart != null){
		document.onselectstart = c._oldHandlers.onselectstart;
		c._oldHandlers.onselectstart = null;
		//}
		if (document.ondrag != undefined && c._oldHandlers.ondrag != null) {
			document.ondrag = c._oldHandlers.ondrag;
			c._oldHandlers.ondrag = null;
		}
		if (document.onmousedown != undefined && c._oldHandlers.onmousedown != null) {
			document.onmousedown = c._oldHandlers.onmousedown;
			c._oldHandlers.onmousedown = null;
		}
		plot = c = null;
	}

	/* customizing start (2012-04-23, Roy Choi) */
	function handleRightUp(ev) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		var plot = ev.data.plot;
		var c = plot.plugins.cursor;

		c._drag.started = false;
		c._drag.dragging = false;
		c.dragStartAxes = {};

		$(document).unbind('mousemove.jqplotCursor', handleDragMove);

		if (document.onselectstart != undefined && c._oldHandlers.onselectstart != null) {
			document.onselectstart = c._oldHandlers.onselectstart;
			c._oldHandlers.onselectstart = null;
		}
		if (document.ondrag != undefined && c._oldHandlers.ondrag != null) {
			document.ondrag = c._oldHandlers.ondrag;
			c._oldHandlers.ondrag = null;
		}
		if (document.onmousedown != undefined && c._oldHandlers.onmousedown != null) {
			document.onmousedown = c._oldHandlers.onmousedown;
			c._oldHandlers.onmousedown = null;
		}
	}

	/* customizing end (2012-04-23, Roy Choi) */

	function drawZoomBox() {
		var start = this._zoom.start;
		var end = this._zoom.end;

		var ctx = this.zoomCanvas._ctx;
		var l, t, h, w;
		if (end[0] > start[0]) {
			l = start[0];
			w = end[0] - start[0];
		} else {
			l = end[0];
			w = start[0] - end[0];
		}
		if (end[1] > start[1]) {
			t = start[1];
			h = end[1] - start[1];
		} else {
			t = end[1];
			h = start[1] - end[1];
		}
		ctx.fillStyle = 'rgba(0,0,0,0.2)';
		ctx.strokeStyle = '#999999';
		ctx.lineWidth = 1.0;
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		ctx.clearRect(l, t, w, h);
		// IE won't show transparent fill rect, so stroke a rect also.
		//ctx.strokeRect(l,t,w,h);
		ctx = null;
	}

})(jQuery); 

/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can
 * choose the license that best suits your project and use it accordingly.
 *
 * Although not required, the author would appreciate an email letting him
 * know of any substantial use of jqPlot.  You can reach the author at:
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 *
 */
(function($) {
  $.jqplot.eventListenerHooks.push(['jqplotMouseMove', handleMove]);
  $.jqplot.eventListenerHooks.push(['jqplotMouseLeave', handleLeave]);
  $.jqplot.eventListenerHooks.push(['jqplotClick', handleClick]);
  $.jqplot.eventListenerHooks.push(['jqplotMouseDown', handleMouseDown]);
  // customizing (2012-04-23, Roy Choi)
  $.jqplot.eventListenerHooks.push(['jqplotRightClick', handleRightClick]);
  // customizing (2012-05-02, Roy Choi)
  $.jqplot.eventListenerHooks.push(['jqplotRightDown', handleRightDown]);
  // customizing (2016-10-26, Roy Choi)
  $.jqplot.eventListenerHooks.push(['jqplot.showTooltip', showTooltip]);
  $.jqplot.eventListenerHooks.push(['jqplot.clearTooltip', clearTooltip]);

  /**
   * Class: $.jqplot.Highlighter
   * Plugin which will highlight data points when they are moused over.
   *
   * To use this plugin, include the js
   * file in your source:
   *
   * > <script type="text/javascript" src="plugins/jqplot.highlighter.js"></script>
   *
   * A tooltip providing information about the data point is enabled by default.
   * To disable the tooltip, set "showTooltip" to false.
   *
   * You can control what data is displayed in the tooltip with various
   * options.  The "tooltipAxes" option controls wether the x, y or both
   * data values are displayed.
   *
   * Some chart types (e.g. hi-low-close) have more than one y value per
   * data point. To display the additional values in the tooltip, set the
   * "yvalues" option to the desired number of y values present (3 for a hlc chart).
   *
   * By default, data values will be formatted with the same formatting
   * specifiers as used to format the axis ticks.  A custom format code
   * can be supplied with the tooltipFormatString option.  This will apply
   * to all values in the tooltip.
   *
   * For more complete control, the "formatString" option can be set.  This
   * Allows conplete control over tooltip formatting.  Values are passed to
   * the format string in an order determined by the "tooltipAxes" and "yvalues"
   * options.  So, if you have a hi-low-close chart and you just want to display
   * the hi-low-close values in the tooltip, you could set a formatString like:
   *
   * > highlighter: {
   * >     tooltipAxes: 'y',
   * >     yvalues: 3,
   * >     formatString:'<table class="jqplot-highlighter">
   * >         <tr><td>hi:</td><td>%s</td></tr>
   * >         <tr><td>low:</td><td>%s</td></tr>
   * >         <tr><td>close:</td><td>%s</td></tr></table>'
   * > }
   *
   */
  $.jqplot.Highlighter = function(options) {
    // Group: Properties
    //
    //prop: show
    // true to show the highlight.
    this.show = $.jqplot.config.enablePlugins;
    // prop: markerRenderer
    // Renderer used to draw the marker of the highlighted point.
    // Renderer will assimilate attributes from the data point being highlighted,
    // so no attributes need set on the renderer directly.
    // Default is to turn off shadow drawing on the highlighted point.
    this.markerRenderer = new $.jqplot.MarkerRenderer({
      shadow : false
    });
    // prop: showMarker
    // true to show the marker
    this.showMarker = true;
    // prop: lineWidthAdjust
    // Pixels to add to the lineWidth of the highlight.
    this.lineWidthAdjust = 4.5;
    // prop: sizeAdjust
    // Pixels to add to the overall size of the highlight.
    this.sizeAdjust = 5;
    // prop: showTooltip
    // Show a tooltip with data point values.
    this.showTooltip = true;
    // prop: tooltipLocation
    // Where to position tooltip, 'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'
    this.tooltipLocation = 'nw';
    // prop: fadeTooltip
    // true = fade in/out tooltip, flase = show/hide tooltip
    this.fadeTooltip = true;
    // prop: tooltipFadeSpeed
    // 'slow', 'def', 'fast', or number of milliseconds.
    this.tooltipFadeSpeed = "fast";
    // prop: tooltipOffset
    // Pixel offset of tooltip from the highlight.
    this.tooltipOffset = 2;
    // prop: tooltipAxes
    // Which axes to display in tooltip, 'x', 'y' or 'both', 'xy' or 'yx'
    // 'both' and 'xy' are equivalent, 'yx' reverses order of labels.
    this.tooltipAxes = 'both';
    // prop; tooltipSeparator
    // String to use to separate x and y axes in tooltip.
    this.tooltipSeparator = ', ';
    // prop; tooltipContentEditor
    // Function used to edit/augment/replace the formatted tooltip contents.
    // Called as str = tooltipContentEditor(str, seriesIndex, pointIndex)
    // where str is the generated tooltip html and seriesIndex and pointIndex identify
    // the data point being highlighted. Should return the html for the tooltip contents.
    this.tooltipContentEditor = null;
    // prop: useAxesFormatters
    // Use the x and y axes formatters to format the text in the tooltip.
    this.useAxesFormatters = true;
    // prop: tooltipFormatString
    // sprintf format string for the tooltip.
    // Uses Ash Searle's javascript sprintf implementation
    // found here: http://hexmen.com/blog/2007/03/printf-sprintf/
    // See http://perldoc.perl.org/functions/sprintf.html for reference.
    // Additional "p" and "P" format specifiers added by Chris Leonello.
    this.tooltipFormatString = '%.5P';
    // prop: formatString
    // alternative to tooltipFormatString
    // will format the whole tooltip text, populating with x, y values as
    // indicated by tooltipAxes option.  So, you could have a tooltip like:
    // 'Date: %s, number of cats: %d' to format the whole tooltip at one go.
    // If useAxesFormatters is true, values will be formatted according to
    // Axes formatters and you can populate your tooltip string with
    // %s placeholders.
    this.formatString = null;
    // prop: yvalues
    // Number of y values to expect in the data point array.
    // Typically this is 1.  Certain plots, like OHLC, will
    // have more y values in each data point array.
    this.yvalues = 1;
    // prop: bringSeriesToFront
    // This option requires jQuery 1.4+
    // True to bring the series of the highlighted point to the front
    // of other series.
    this.bringSeriesToFront = false;
    this._tooltipElem = null;
    this.isHighlighting = false;
    this.currentNeighbor = null;

    this.isClickHighlighting = false;
    // customizing (2012-04-19, Roy Choi)
    this.isMultiTooltip = false;
    // customizing (2012-04-19, Roy Choi)
    this.isClickTooltip = false;
    // customizing (2012-04-19, Roy Choi)
    this.multiTooltipPoint = [];
    // customizing (2012-05-23, Roy Choi)
    this.multiTooltipElem = [];
    // customizing (2012-04-19, Roy Choi)
    this.multiTooltipLineNames = [];
    // customizing (2012-04-20, Roy Choi)
    this.tooltipLineName = 'highlighter_tooltip_line';
    // customizing (2012-04-20, Roy Choi)
    this.clickStart = {
      x : null,
      y : null
    };
    // customizing (2012-04-20, Roy Choi)

    // point variation customizing (2012-04-27, Roy Choi)
    this.pointVariation = false;
    this.pointVariationStart = false;
    this.pointVariationTooltipElem = null;
    this.pointVariationLineName = 'highlighter_pointvariation_line';
    this.pointVariationLineColor = '#000000';
    this.pointVariationLineWidth = 0.8;
    this.pointVariationStartPos = null;
    this.pointVariationEndPos = {};
    this.pointVariationThreshold = 6;

    // context menu customizing modified (2013-01-22, Roy Choi)
    this.contextMenu = false;
    /*this.contextMenuElem = null;*/
    this.contextMenuSeriesOptions = {};
    this.contextMenuBackgroundOptions = {};

    // point cross line customizing (2012-05-03, Roy Choi)
    this.pointCrossLine = false;
    this.pointCrossLineStart = false;
    this.pointCrossLineSeriesIndex = null;
    this.pointCrossLineCanvas = null;
    
    // customizing to hide tooltip on click outside (2014-06-02, Roy Choi)
    this.clearTooltipOnClickOutside = false;
    
    // customizing to show tooltip on mouse over a point (2014-10-16, Roy Choi)
    this.overTooltip = false;
    this.overTooltipOptions = {
        showMarker: false,
        showTooltip: true,
        lineOver: false
    };
    this.clickTooltip = true;
    this.currentOverNeighbor = null;
    this.highlightOnlyMarker = false;
    this.isTooltipDragging = false;
    this.stroke = false;
    this.strokeStyle = null;
    this.tooltipDraggable = true;
    
    //customizing (2015-09-11, Eric Leem)
    this.selectable = {
      show: false,
      multiSelect: true,
      seriesHighlight: false,
      selectLimited: null,
      zoom: false,
      selected: [],
      tooltipContentEditor: null,
      selectChanged: null,
      tooltipOpend: false,
      seriesFadeOut: 1,
      selectColumnIndex: null,
      unselect: false,
      ctrlRemove: true,
      _selected: [],
      _selectedInfo: [],
      _oldSelected: []
    };
    
    $.extend(true, this, options);
  };

  var locations = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
  var locationIndicies = {
    'nw' : 0,
    'n' : 1,
    'ne' : 2,
    'e' : 3,
    'se' : 4,
    's' : 5,
    'sw' : 6,
    'w' : 7
  };
  var oppositeLocations = ['se', 's', 'sw', 'w', 'nw', 'n', 'ne', 'e'];

  // axis.renderer.tickrenderer.formatter

  // called with scope of plot
  $.jqplot.Highlighter.init = function(target, data, opts) {
    var options = opts || {};
    // add a highlighter attribute to the plot
    this.plugins.highlighter = new $.jqplot.Highlighter(options.highlighter);
  };

  // customizing (2012-04-20, Roy Choi)
  $.jqplot.Highlighter.prototype.clearMultiTooltip = function(plot) {
    var hl = plot.plugins.highlighter;
    $.each(hl.multiTooltipElem, function(ind, elem) {
      elem.hide();
      elem.remove();
    });
    hl.multiTooltipElem = [];
    hl.multiTooltipPoint = [];
    // customizing (2012-05-23, Roy Choi)
    hideTooltip(plot);
    plot.restoreOriginalSeriesOrder();
    hl.isClickHighlighting = false;
    hl.currentNeighbor = null;
    /*$.each(plot.series, function(ind, series){
     $(series.canvas._elem).fadeTo('fast',1.0);
     });*/

    var co = plot.plugins.canvasOverlay;
    $.each(hl.multiTooltipLineNames, function(ind, lineName) {
      co.removeObject(lineName);
    });
    hl.multiTooltipLineNames = [];
    co.draw(plot);
    hideTooltipLine(plot);
  };

  // customizing (2012-04-23, Roy Choi)
  $.jqplot.Highlighter.prototype.moveToFrontMultiTooltip = function(plot) {
    var hl = plot.plugins.highlighter;
    $.each(hl.multiTooltipElem, function(ind, elem) {
      
      var elemInfo = hl.multiTooltipPoint[ind];
      
      plot.eventCanvas._elem.after(elem);
      elem.css({
        cursor : 'default',
        'border-color' : elemInfo.color
      });
      
      if (hl.tooltipDraggable) {
        elem.draggable({
          cursor : 'default',
          containment : plot.target
        }).bind('drag', {
          plot : plot,
          series : elemInfo.series,
          name : elemInfo.name,
          color : elemInfo.color,
          start : elemInfo.start,
          stop : false
        }, handleDragToolTip).bind('dragstop', {
          plot : plot,
          series : elemInfo.series,
          name : elemInfo.name,
          color : elemInfo.color,
          start : elemInfo.start,
          stop : true
        }, handleDragToolTip);
  
        elem.trigger('dragstop');
      }
    });
  };

  // customizing (2012-04-23, Roy Choi)
  $.jqplot.Highlighter.prototype.offVariation = function(plot) {
    var hl = plot.plugins.highlighter;
    hl.pointVariation = false;
    clearVariation(plot);
  };

  // customizing (2012-05-31, Roy Choi) for point cross line
  $.jqplot.Highlighter.prototype.setCrossLine = function(plot) {
    this.pointCrossLine = true;
  };

  // customizing (2012-05-31, Roy Choi) for point cross line
  $.jqplot.Highlighter.prototype.unsetCrossLine = function(plot) {
    this.pointCrossLine = false;
  };

  // customizing (2012-05-03, Roy Choi)
  $.jqplot.Highlighter.prototype.clearCrossLine = function(plot) {
    var hl = plot.plugins.highlighter;
    var ctx = hl.pointCrossLineCanvas._ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx = null;
  };

  // customizing (2012-06-15, Roy Choi)
  $.jqplot.Highlighter.prototype.clearHighlight = function(plot) {
    var hl = plot.plugins.highlighter;
    var ctx = hl.highlightCanvas._ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (hl.fadeTooltip) {
      if (hl.isMultiTooltip && hl.multiTooltipElem.length > 0) {
        //hl.clearMultiTooltip(plot);
      } else {
        hideTooltipLine(plot);
        fadeoutTooltip(plot);;
      }
    } else {
      if (hl.isMultiTooltip && hl.multiTooltipElem.length > 0) {
        //hl.clearMultiTooltip(plot);
      } else {
        hideTooltipLine(plot);
        hideTooltip(plot);
      }
    }
    if (hl.bringSeriesToFront) {
      plot.restoreOriginalSeriesOrder();
    }
    hl.isClickTooltip = false;
    hl.isClickHighlighting = false;
    hl.currentNeighbor = null;
    ctx = null;
  };

  // called within scope of series
  $.jqplot.Highlighter.parseOptions = function(defaults, options) {
    // Add a showHighlight option to the series
    // and set it to true by default.
    this.showHighlight = true;
  };
  
  $.jqplot.Highlighter.preParseOptions = function(options) {
    if (this.plugins.highlighter.selectable &&  this.plugins.highlighter.selectable.show && options.highlighter.selectable && $.isArray(options.highlighter.selectable.selected)) {
      this.plugins.highlighter.selectable._selected = options.highlighter.selectable.selected;
    }
  };

  // called within context of plot
  // create a canvas which we can draw on.
  // insert it before the eventCanvas, so eventCanvas will still capture events.
  $.jqplot.Highlighter.postPlotDraw = function() {
    // Memory Leaks patch
    if (this.plugins.highlighter && this.plugins.highlighter.highlightCanvas) {
      this.plugins.highlighter.highlightCanvas.resetCanvas();
      this.plugins.highlighter.highlightCanvas = null;
    }

    if (this.plugins.highlighter && this.plugins.highlighter._tooltipElem) {
      this.plugins.highlighter._tooltipElem.emptyForce();
      // customizing start (2012-05-03, Roy Choi)
      try {
        this.plugins.highlighter._tooltipElem.draggable();
        this.plugins.highlighter._tooltipElem.draggable('destroy');
      } catch (e) {
      }

      this.plugins.highlighter._tooltipElem.remove();
      // customizing end (2012-05-03, Roy Choi)
      this.plugins.highlighter._tooltipElem = null;
      hideTooltipLine(this);
    }

    this.plugins.highlighter.highlightCanvas = new $.jqplot.GenericCanvas();

    this.eventCanvas._elem.before(this.plugins.highlighter.highlightCanvas.createElement(this._gridPadding, 'jqplot-highlight-canvas', this._plotDimensions, this));
    this.plugins.highlighter.highlightCanvas.setContext();

    var elem = document.createElement('div');
    this.plugins.highlighter._tooltipElem = $(elem);
    this.plugins.highlighter._tooltipElem.addClass('jqplot-highlighter-tooltip-wrapper');
    elem = null;

    //this.plugins.highlighter._tooltipElem.addClass('jqplot-highlighter-tooltip');
    this.plugins.highlighter._tooltipElem.css({
      position : 'absolute',
      display : 'none'
    });

    this.eventCanvas._elem.after(this.plugins.highlighter._tooltipElem);
    
    if (this.plugins.highlighter.selectable.show) {
      var selectable = this.plugins.highlighter.selectable;
      
      this.plugins.highlighter.canvas = new $.jqplot.GenericCanvas();
      this.eventCanvas._elem.before(this.plugins.highlighter.canvas.createElement(this._gridPadding, 'jqplot-cursor-canvas', this._plotDimensions, this));
      this.plugins.highlighter.canvas.setContext();
      
      if ($.isArray(selectable._selected) && selectable._selected.length > 0) {
        highlightByData(this, selectable._selected);
      }
    }
    


    // customizing start (2012-04-25, Roy Choi)
    /*this.target.unbind('jqplotPostReplot', moveToFrontMultiTooltipPostReplot);
    this.target.bind('jqplotPostReplot', {
      plot : this
    }, moveToFrontMultiTooltipPostReplot);*/
    // customizing end (2012-04-25, Roy Choi)

    // customizing start (2012-04-27, Roy Choi)
    if (this.plugins.highlighter.pointVariationTooltipElem) {
      this.plugins.highlighter.pointVariationTooltipElem.remove();
    }
    var elem = document.createElement('div');
    this.plugins.highlighter.pointVariationTooltipElem = $(elem);
    this.plugins.highlighter.pointVariationTooltipElem.addClass('jqplot-highlighter-variation-tooltip');
    elem = null;
    this.eventCanvas._elem.before(this.plugins.highlighter.pointVariationTooltipElem);
    if ( typeof (this.plugins.canvasOverlay.get(this.plugins.highlighter.pointVariationLineName)) != 'object')
      addTooltipLine(this, this.plugins.highlighter.pointVariationLineName);
    // customizing end (2012-04-27, Roy Choi)

    // customizing start (2012-05-02, Roy Choi)
    /*if(this.plugins.highlighter.contextMenu) {

    if(this.plugins.highlighter.contextMenuElem) {
    this.plugins.highlighter.contextMenuElem.empty();
    this.plugins.highlighter.contextMenuElem.remove();
    }

    var elem = document.createElement('ul');

    this.plugins.highlighter.contextMenuElem = $(elem);
    this.plugins.highlighter.contextMenuElem.addClass('jqplot-highlighter-contextmenu');
    elem = null;

    this.plugins.highlighter.contextMenuElem.appendTo('body');
    this.plugins.highlighter.contextMenuElem.css({zIndex:'20000'});

    $(window).on('blur',{plot:this},rightClickBlur);
    $(document).on('click',{plot:this},rightClickBlur);
    $(document).on('mousedown',{plot:this},function(ev){if(ev.which == 3) rightClickBlur(ev)});
    }*/
    // customizing end (2012-05-02, Roy Choi)

    // customizing start (2012-05-03, Roy Choi) - canvas create for point cross line
    this.plugins.highlighter.pointCrossLineCanvas = new $.jqplot.GenericCanvas();
    this.eventCanvas._elem.before(this.plugins.highlighter.pointCrossLineCanvas.createElement(this._gridPadding, 'jqplot-crossline-canvas', this._plotDimensions, this));
    this.plugins.highlighter.pointCrossLineCanvas.setContext();
    // customizing end (2012-05-03, Roy Choi)
    /*this.target.off('jqplotResetZoom',  function(ev) {
      ev.data.plot.plugins.highlighter.moveToFrontMultiTooltip(ev.data.plot);
    });
    this.target.on('jqplotResetZoom', {
      plot : this
    }, function(ev) {
      ev.data.plot.plugins.highlighter.moveToFrontMultiTooltip(ev.data.plot);
    });
    this.target.off('jqplotUndoZoom', function(ev) {
      ev.data.plot.plugins.highlighter.moveToFrontMultiTooltip(ev.data.plot);
    });
    this.target.on('jqplotUndoZoom', {
      plot : this
    }, function(ev) {
      ev.data.plot.plugins.highlighter.moveToFrontMultiTooltip(ev.data.plot);
    });
    this.target.off('jqplotZoom', function(ev) {
      ev.data.plot.plugins.highlighter.moveToFrontMultiTooltip(ev.data.plot);
    });
    this.target.on('jqplotZoom', {
      plot : this
    }, function(ev) {
      ev.data.plot.plugins.highlighter.moveToFrontMultiTooltip(ev.data.plot);
    });*/

    this.target.unbind('jqPlot.PreviousSeriesOrder', handleRemoveHighlight);
    this.target.unbind('jqPlot.OriginalSeriesOrder', handleRemoveHighlight);
    this.target.unbind('jqPlot.seriesVisibleChange', handleVisibleChange);

    this.target.bind('jqPlot.PreviousSeriesOrder', handleRemoveHighlight);
    this.target.bind('jqPlot.OriginalSeriesOrder', handleRemoveHighlight);
    this.target.bind('jqPlot.seriesVisibleChange', handleVisibleChange);

    this.plugins.highlighter.moveToFrontMultiTooltip(this);

    $(document).unbind('click.jqplot_highlighter.'+this.targetId);
    if (this.plugins.highlighter.clearTooltipOnClickOutside) {
      $(document).on('click.jqplot_highlighter.'+this.targetId, {plot: this}, this.plugins.highlighter.clearHighlightByEvent);
    }

    if (this.highlightSeriesIndexes.length > 0) {

      this.highlightSeriesIndexes.slice(0).forEach(function(highlightSeriesIndex, index) {
        this.moveSeriesToFront(highlightSeriesIndex, index !== 0);
      }, this);
    }
  };
  
  $.jqplot.Highlighter.preReinitOptions = function(target, data, options) {
    if (this.options.highlighter && this.options.highlighter.selectable && options && options.highlighter && options.highlighter.selectable && $.isArray(options.highlighter.selectable.selected)) {
      this.options.highlighter.selectable.selected = [];
    }
  };

  $.jqplot.preInitHooks.push($.jqplot.Highlighter.init);
  $.jqplot.preParseOptionsHooks.push($.jqplot.Highlighter.preParseOptions);
  $.jqplot.preParseSeriesOptionsHooks.push($.jqplot.Highlighter.parseOptions);
  $.jqplot.postDrawHooks.push($.jqplot.Highlighter.postPlotDraw);
  
  $.jqplot.preReinitHooks.push($.jqplot.Highlighter.preReinitOptions);

  // customizing (2014-06-02, Roy Choi)
  $.jqplot.Highlighter.prototype.clearHighlightByEvent = function(ev) {
    var plot = ev.data.plot;
    if (plot.target.is(':visible') && plot.target.length && plot.target.find(ev.target).length === 0) {
      plot.plugins.highlighter.clearHighlight(plot);
    }
  };
  
  $.jqplot.Highlighter.prototype.highlightByData = function(plot, selected) {
      highlightByData(plot, selected);
  };

  // customizing (2012-04-25, Roy Choi)
  function moveToFrontMultiTooltipPostReplot(ev) {
    var plot = ev.data.plot;
    var hl = plot.plugins.highlighter;
    $.each(hl.multiTooltipElem, function(ind, elem) {
      plot.eventCanvas._elem.after(elem);
      elem.trigger('postReplot');
    });
  }

  // customizing (2012-04-25, Roy Choi)
  function moveToFrontMultiTooltipEnd(ev) {
    var plot = ev.data.plot;
    var hl = plot.plugins.highlighter;
    $.each(hl.multiTooltipElem, function(ind, elem) {
      plot.eventCanvas._elem.after(elem);
      elem.trigger('drag');
    });
  }

  // customizing (2012-04-25, Roy Choi)
  $.jqplot.Highlighter.prototype.clearVariation = function(plot) {
    clearVariation(plot);
  };

  // customizing (2012-04-25, Roy Choi)
  function clearVariation(plot) {
    var co = plot.plugins.canvasOverlay;
    var hl = plot.plugins.highlighter;
    hl.pointVariationStart = false;
    hl.pointVariationTooltipElem.hide();
    var obj = co.get(hl.pointVariationLineName);
    obj.options.show = false;
    co.draw(plot);
    hl.pointVariationStartPos = null;
    hl.pointVariationEndPos = null;
  }

  // customizing (2012-04-23, Roy Choi)
  function addTooltipLine(plot, name) {
    var co = plot.plugins.canvasOverlay;
    var opts = {
      show : true,
      name : name,
      lineWidth : 0,
      lineBehind : false,
      showTooltip : false,
      shadow : false,
      isDragable : false,
      start : [0, 0],
      stop : [0, 0]
    };
    co.addLine(opts);
  }

  // customizing (2012-04-23, Roy Choi)
  function hideTooltipLine(plot) {
    var co = plot.plugins.canvasOverlay;
    var hl = plot.plugins.highlighter;
    var obj = co.get(hl.tooltipLineName);
    if (obj) {
      co.removeObject(hl.tooltipLineName);
      co.draw(plot);
    }
  }
  
  function hideTooltip(plot) {
    var hl = plot.plugins.highlighter;
    
    hl._tooltipElem.hide().empty();
    if (hl.selectable) {
      hl.selectable.tooltipOpend = false;
    }
  }
  
  function fadeoutTooltip(plot) {
    var hl = plot.plugins.highlighter;
    
    hl._tooltipElem.fadeOut(hl.tooltipFadeSpeed).empty();
    if (hl.selectable) {
      hl.selectable.tooltipOpend = false;
    }
  }

  function draw(plot, neighbor) {
    var hl = plot.plugins.highlighter;
    var s = plot.series[neighbor.seriesIndex];
    if (s.renderer.constructor === $.jqplot.LineRenderer ||
                      s.renderer.constructor === $.jqplot.BigDataScatterRenderer) {
        var smr = s.markerRenderer;
        var mr = hl.markerRenderer;

        // customizing (2017-01-18, Carrie Bae) : apply fillStyleFilter
        if ($.isFunction(smr.fillStyleFilter)) { 
            smr.color = smr.fillStyleFilter.call(smr, s.data[neighbor.pointIndex], neighbor.pointIndex);
        }; 

        mr.style = smr.style;
        mr.lineWidth = smr.lineWidth + hl.lineWidthAdjust;
        mr.size = smr.size + hl.sizeAdjust;
        var rgba = $.jqplot.getColorComponents(smr.color);
        var newrgb = [rgba[0], rgba[1], rgba[2]];
        var alpha = (rgba[3] >= 0.6) ? rgba[3] * 0.6 : rgba[3] * (2 - rgba[3]);
        mr.color = 'rgba(' + newrgb[0] + ',' + newrgb[1] + ',' + newrgb[2] + ',' + alpha + ')';
        mr.shapeRenderer.color = mr.color;
        mr.stroke = hl.stroke;
        mr.strokeStyle = hl.strokeStyle;
        mr.init();
        var y;
        if (s.renderer.constructor === $.jqplot.BoxplotRenderer || s.renderer.constructor === $.jqplot.BigDataScatterRenderer) {
          y = neighbor.gridData[1];
        } else {
          y = s.gridData[neighbor.pointIndex][1];
        }
        mr.draw(neighbor.gridData[0], y, hl.highlightCanvas._ctx);
    } else {
        var smr = s.markerRenderer,
            rgba = $.jqplot.getColorComponents(s.color),
            newrgb = [Math.floor(rgba[0] * 0.9), Math.floor(rgba[1] * 0.9), Math.floor(rgba[2] * 0.9)],
            alpha = (rgba[3] >= 0.6) ? rgba[3] * 0.6 : rgba[3] * (2 - rgba[3]),
            color = 'rgba(' + newrgb[0] + ',' + newrgb[1] + ',' + newrgb[2] + ',' + alpha + ')',
            opts = {fillStyle: color, strokeStyle: smr.strokeStyle};
        
        s.renderer.shapeRenderer.draw(hl.highlightCanvas._ctx, neighbor.points, opts);
    }
  }

  // customizing (2012-04-23, Roy Choi)
  function handleDragToolTip(ev) {
    var plot = ev.data.plot;
    var series = ev.data.series;
    var co = plot.plugins.canvasOverlay;
    var hl = plot.plugins.highlighter;
    var name = ev.data.name;
    var color = ev.data.color;
    var stop = ev.data.stop;
    var obj = co.get(name);
    
    if (!obj) {
        addTooltipLine(plot, name);
        obj = co.get(name);
    }
       
    if (stop) {
      hl.isTooltipDragging = false;
    } else {
      hl.isTooltipDragging = true;
    }
    
    if (obj) {
      obj.options.xaxis = series.xaxis;
      obj.options.yaxis = series.yaxis;
        
      var start = ev.data.start;
      start = [plot.axes[obj.options.xaxis].series_p2u(plot.axes[series.xaxis].series_u2p(start[0])), plot.axes[obj.options.yaxis].series_p2u(plot.axes[series.yaxis].series_u2p(start[1]))];
      var go = plot.eventCanvas._elem.offset();
      var offset = $('div.jqplot-highlighter-tooltip', this).offset();
      if (!offset) {
          return;
      }
      var gridPos = {
        x : offset.left - go.left,
        y : offset.top - go.top
      };
      var stop = [plot.axes[obj.options.xaxis].series_p2u(gridPos.x), plot.axes[obj.options.yaxis].series_p2u(gridPos.y)];
      var opts = {
        show: true,
        lineWidth : 1.5,
        color : color,
        start : start,
        stop : stop
      };
      $.extend(true, obj.options, opts);
      co.draw(plot);
    }
  }

  function clearTooltip(ev, plot) {
    var hl = plot.plugins.highlighter;
    hideTooltipLine(plot);
    if (hl.fadeTooltip) {
      fadeoutTooltip(plot);
    } else {
      hideTooltip(plot);
    }
  }

  function showTooltip(ev, plot, series, neighbor, over) {
    // neighbor looks like: {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]}
    // gridData should be x,y pixel coords on the grid.
    // add the plot._gridPadding to that to get x,y in the target.
    
    if (series.hide || !series.show) {
      return;
    }
    var hl = plot.plugins.highlighter;

    clearTooltip(ev, plot);

    if (hl.showMarker) {
      draw(plot, neighbor);
    }

    // customizing Start (2012-04-23, Roy Choi)
    if (hl.isMultiTooltip) {
      var isAleady = false;
      $.each(hl.multiTooltipPoint, function(ind, savedTooltip) {
        if (savedTooltip.neighbor.seriesIndex == neighbor.seriesIndex && savedTooltip.neighbor.data[0] == neighbor.data[0] && savedTooltip.neighbor.data[1] == neighbor.data[1]) {
          isAleady = true;
          return false;
        }
      });
      if (isAleady)
        return;
      var elem = hl._tooltipElem.clone(false);
      elem.css({
        position : 'absolute',
        display : 'none'
      });

      //$(elem).live('mouseup',{plot:plot},function(ev){ev.data.plot.eventCanvas._elem.trigger('mouseup');}).live('mousemove',{plot:plot},function(ev){ev.data.plot.eventCanvas._elem.trigger('mousemove');}).live('mouseenter',{plot:plot},function(ev){ev.data.plot.eventCanvas._elem.trigger('mouseenter');}).live('mouseleave',{plot:plot},function(ev){ev.data.plot.eventCanvas._elem.trigger('mouseleave');});  // customizing (2012-04-23, Roy Choi)
      //hl._tooltipElem.addClass('jqplot-highlighter-tooltip');

      plot.eventCanvas._elem.after(elem);
    } else {
      var elem = hl._tooltipElem;
    }

    // customizing End (2012-04-23, Roy Choi)

    var serieshl = series.highlighter || {};

    var opts = $.extend(true, {}, hl, serieshl);

    if (opts.useAxesFormatters) {
      var xf = series._xaxis._ticks[0].formatter;
      var yf = series._yaxis._ticks[0].formatter;
      var xfstr = series._xaxis._ticks[0].formatString;
      var yfstr = series._yaxis._ticks[0].formatString;
      var str;
      var xstr = xf(xfstr, neighbor.data[0]);
      var ystrs = [];
      for (var i = 1; i < opts.yvalues + 1; i++) {
        ystrs.push(yf(yfstr, neighbor.data[i]));
      }
      if ( typeof opts.formatString === 'string') {
        switch (opts.tooltipAxes) {
          case 'both':
          case 'xy':
            ystrs.unshift(xstr);
            ystrs.unshift(opts.formatString);
            str = $.jqplot.sprintf.apply($.jqplot.sprintf, ystrs);
            break;
          case 'yx':
            ystrs.push(xstr);
            ystrs.unshift(opts.formatString);
            str = $.jqplot.sprintf.apply($.jqplot.sprintf, ystrs);
            break;
          case 'x':
            str = $.jqplot.sprintf.apply($.jqplot.sprintf, [opts.formatString, xstr]);
            break;
          case 'y':
            ystrs.unshift(opts.formatString);
            str = $.jqplot.sprintf.apply($.jqplot.sprintf, ystrs);
            break;
          default:
            // same as xy
            ystrs.unshift(xstr);
            ystrs.unshift(opts.formatString);
            str = $.jqplot.sprintf.apply($.jqplot.sprintf, ystrs);
            break;
        }
      } else {
        switch (opts.tooltipAxes) {
          case 'both':
          case 'xy':
            str = xstr;
            for (var i = 0; i < ystrs.length; i++) {
              str += opts.tooltipSeparator + ystrs[i];
            }
            break;
          case 'yx':
            str = '';
            for (var i = 0; i < ystrs.length; i++) {
              str += ystrs[i] + opts.tooltipSeparator;
            }
            str += xstr;
            break;
          case 'x':
            str = xstr;
            break;
          case 'y':
            str = ystrs.join(opts.tooltipSeparator);
            break;
          default:
            // same as 'xy'
            str = xstr;
            for (var i = 0; i < ystrs.length; i++) {
              str += opts.tooltipSeparator + ystrs[i];
            }
            break;

        }
      }
    } else {
      var str;
      if ( typeof opts.formatString === 'string') {
        str = $.jqplot.sprintf.apply($.jqplot.sprintf, [opts.formatString].concat(neighbor.data));
      } else {
        if (opts.tooltipAxes == 'both' || opts.tooltipAxes == 'xy') {
          str = $.jqplot.sprintf(opts.tooltipFormatString, neighbor.data[0]) + opts.tooltipSeparator + $.jqplot.sprintf(opts.tooltipFormatString, neighbor.data[1]);
        } else if (opts.tooltipAxes == 'yx') {
          str = $.jqplot.sprintf(opts.tooltipFormatString, neighbor.data[1]) + opts.tooltipSeparator + $.jqplot.sprintf(opts.tooltipFormatString, neighbor.data[0]);
        } else if (opts.tooltipAxes == 'x') {
          str = $.jqplot.sprintf(opts.tooltipFormatString, neighbor.data[0]);
        } else if (opts.tooltipAxes == 'y') {
          str = $.jqplot.sprintf(opts.tooltipFormatString, neighbor.data[1]);
        }
      }
    }

    var tooltipContentProc = function(str) {
      var x, y;
      var innerElem = null;
      elem.emptyForce();
      if (typeof str !== 'object') {
        innerElem = $('<div></div>');
        innerElem.addClass('jqplot-highlighter-tooltip');
        elem.append(innerElem);
        innerElem.html(str);
      } else if (typeof str === 'object') {
        innerElem = str;
        elem.empty().append(str);
      }
      
      
      var gridpos = {
        x : neighbor.gridData[0],
        y : neighbor.gridData[1]
      };
      var ms = 0;
      var fact = 0.707;
      var tooltipPaddingSize = 0;
      var tooltipPadding = {
        marginLeft: 0,
        marginRight: 0,
        marginTop: 0,
        marginBottom: 0
      };
      if (series.markerRenderer.show == true) {
        ms = (series.markerRenderer.size + opts.sizeAdjust) / 2;
        tooltipPaddingSize = (series.markerRenderer.size + opts.sizeAdjust);
      } else {
        tooltipPaddingSize = opts.tooltipOffset;
      }

      var loc = locations;
      if (series.fillToZero && series.fill && neighbor.data[1] < 0) {
        loc = oppositeLocations;
      }
      
      var locStr = loc[locationIndicies[opts.tooltipLocation]];
      
      if (series.renderer.constructor !== $.jqplot.LineRenderer && series.renderer.constructor !== $.jqplot.BigDataScatterRenderer) {
          var offset = plot.target.offset();
          gridpos.x = ev.pageX - offset.left - plot._gridPadding.left;
          gridpos.y = ev.pageY - offset.top - plot._gridPadding.top;
      }
      
      switch (locStr) {
        case 'nw':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset - fact * ms;
          y = gridpos.y + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true) - fact * ms;
          tooltipPadding.marginBottom = tooltipPaddingSize + 'px';
          break;
        case 'n':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) / 2;
          y = gridpos.y + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true) - ms;
          break;
        case 'ne':
          x = gridpos.x + plot._gridPadding.left + opts.tooltipOffset + fact * ms;
          y = gridpos.y + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true) - fact * ms;
          tooltipPadding.marginBottom = tooltipPaddingSize + 'px';
          break;
        case 'e':
          x = gridpos.x + plot._gridPadding.left + opts.tooltipOffset + ms;
          y = gridpos.y + plot._gridPadding.top - elem.outerHeight(true) / 2;
          break;
        case 'se':
          x = gridpos.x + plot._gridPadding.left + opts.tooltipOffset - tooltipPaddingSize + fact * ms;
          y = gridpos.y + plot._gridPadding.top + opts.tooltipOffset + fact * ms;
          tooltipPadding.marginTop = tooltipPaddingSize + 'px';
          break;
        case 's':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) / 2;
          y = gridpos.y + plot._gridPadding.top + opts.tooltipOffset + ms;
          break;
        case 'sw':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset - fact * ms;
          y = gridpos.y + plot._gridPadding.top + opts.tooltipOffset - tooltipPaddingSize + fact * ms;
          tooltipPadding.marginTop = tooltipPaddingSize + 'px';
          break;
        case 'w':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset - ms;
          y = gridpos.y + plot._gridPadding.top - elem.outerHeight(true) / 2;
          break;
        default:
          // same as 'nw'
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset - fact * ms;
          y = gridpos.y + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true) - fact * ms;
          tooltipPadding.marginBottom = tooltipPaddingSize + 'px';
          break;
      }
      
      innerElem.css(tooltipPadding);
      
      var highlightCanvasElem = hl.highlightCanvas._elem;
      var highlightCanvasOffset = highlightCanvasElem.offset();
      
      if (x < 0 && locStr.indexOf('w') > -1) {
        x = gridpos.x + plot._gridPadding.left + opts.tooltipOffset + ms;
      } else if (x + elem.width() > plot.target.width()) {
        x = gridpos.x + plot._gridPadding.left + opts.tooltipOffset - elem.width() - ms;
      }
      
      if (y < 0) {
        y = gridpos.y + plot._gridPadding.top + opts.tooltipOffset + ms;
        if (tooltipPadding.marginBottom) {
          y -= tooltipPaddingSize;
          tooltipPadding.marginTop = tooltipPadding.marginBottom;
          tooltipPadding.marginBottom = 0;
        }
      }else if (y + elem.height() > plot.target.height()) {
        y = plot.target.height() + opts.tooltipOffset - (elem.outerHeight(true) - tooltipPaddingSize) - ms;
        if (tooltipPadding.marginTop) {
          tooltipPadding.marginBottom = tooltipPadding.marginTop;
          tooltipPadding.marginTop = 0;
        }
      }
      
      if (x < 0) x = 0;
      
      innerElem.css(tooltipPadding);
      
      elem.css('left', x+2);
      elem.css('top', y-1);
      
      var elem_line_name = '';
      var color = series.color;

      /* customizing for stacked series (2013-02-20, Roy Choi) start */
      var start = [];
      if (plot.options.stackSeries) {
        var seriesList = plot.series;
        var starty = 0;
        for (var i = 0; i <= neighbor.seriesIndex; i++) {
          starty += seriesList[i].data[neighbor.pointIndex][1];
        }
        start = [neighbor.data[0], starty];
        seriesList = startx = starty = null;
      } else if (plot.series[neighbor.seriesIndex].renderer.constructor === $.jqplot.BarRenderer && neighbor.points) {
        var xu = plot.series[neighbor.seriesIndex]._xaxis.series_p2u;
        var points = neighbor.points;
        start = [xu(points[0][0]+(points[2][0]-points[0][0])/2), neighbor.data[1]];
      } else if (plot.series[neighbor.seriesIndex].renderer.constructor === $.jqplot.BoxplotRenderer && neighbor.points) {
        var yu = plot.series[neighbor.seriesIndex]._yaxis.series_p2u;
        var points = neighbor.points;
        start = [neighbor.data[0], yu(points[0][1]+(points[2][1]-points[0][1])/2)];
      } else if (plot.series[neighbor.seriesIndex].renderer.constructor === $.jqplot.BoxplotRenderer && neighbor.start) {
        start = neighbor.start;
      } else {
        var xu = plot.series[neighbor.seriesIndex]._xaxis.series_p2u;
        start = [xu(neighbor.gridData[0]), neighbor.data[1]];
      }
      /* customizing for stacked series (2013-02-20, Roy Choi) end */

      var gridstop = [x, y];

      /* customizing start (2012-04-20, Roy Choi) */
      if (hl.isMultiTooltip) {
        elem_line_name = 'highlighter_multitooltip_line' + hl.multiTooltipLineNames.length;
        hl.multiTooltipLineNames.push(elem_line_name);
        addTooltipLine(plot, elem_line_name);
      } else {
        elem_line_name = hl.tooltipLineName;
        elem.unbind('drag');
        addTooltipLine(plot, elem_line_name);
        /*var co = plot.plugins.canvasOverlay;
         var obj = co.get(elem_line_name);
         var stop = [plot.axes[obj.options.xaxis].series_p2u(gridstop[0]), plot.axes[obj.options.yaxis].series_p2u(gridstop[1])];

         var opts = {
         color: color,
         start:start,
         stop:stop
         }
         $.extend(obj.options,opts);
         plot.redraw(false);

         */
      }
      //elem.parent().css('overflow','hidden');
      elem.css({
        cursor : 'default',
        'border-color' : color
      });
      
      if (hl.tooltipDraggable) {
        elem.draggable({
          cursor : 'default',
          containment : plot.target
        }).bind('drag', {
          plot : plot,
          series : series,
          name : elem_line_name,
          color : color,
          start : start,
          stop : false
        }, handleDragToolTip).bind('dragstop', {
          plot : plot,
          series : series,
          name : elem_line_name,
          color : color,
          start : start,
          stop : true
        }, handleDragToolTip);
      }
      
      if (hl.isMultiTooltip) {
        hl.multiTooltipElem.push(elem);
        hl.multiTooltipPoint.push({
          neighbor: neighbor,
          series: series,
          name: elem_line_name,
          color: color,
          start: start
        });
      }
      
      /* customizing end (2012-04-20, Roy Choi) */

      if (opts.fadeTooltip) {
        // Fix for stacked up animations.  Thnanks Trevor!
        elem.stop(true, true).fadeIn(opts.tooltipFadeSpeed);
      } else {
        elem.show();
      }

      plot.target.trigger('jqplot.tooltipShown', [elem, neighbor, plot]);
      
      elem = null;
    };
    if ($.isFunction(opts.tooltipContentEditor)) {
      // args str, seriesIndex, pointIndex are essential so the hook can look up
      // extra data for the point.
      str = opts.tooltipContentEditor.call(hl, str, neighbor.seriesIndex, neighbor.pointIndex, plot, tooltipContentProc, ev);
    } else {
      tooltipContentProc(str);
    }

  }

  // customizing Start (2014-10-21, Roy Choi), To show selected tooltip
  function showSelectTooltip(ev, plot, selected, oldSelected, selectedData, neighbor) {
    // neighbor looks like: {seriesIndex: i, pointIndex:j, gridData:p, data:s.data[j]}
    // gridData should be x,y pixel coords on the grid.
    // add the plot._gridPadding to that to get x,y in the target.
    var hl = plot.plugins.highlighter;
    
    var elem = hl._tooltipElem;

    //var hl = $.extend(true, {}, hl);
    
    var str = 'Total count : ' + selected.length + ' item(s) selected';

    var tooltipContentProc = function(str) {
      var x, y;
      var innerElem = null;
      elem.emptyForce();
      if (typeof str !== 'object') {
        innerElem = $('<div></div>');
        innerElem.addClass('jqplot-highlighter-tooltip');
        elem.append(innerElem);
        innerElem.html(str);
      } else if (typeof str === 'object') {
        innerElem = str;
        elem.empty().append(str);
      }
      
      var gridpos = {
        x : neighbor.gridPos.x,
        y : neighbor.gridPos.y
      };
      var ms = 0;
      var fact = 0.707;

      var loc = locations;

      switch (loc[locationIndicies[hl.tooltipLocation]]) {
        case 'nw':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - hl.tooltipOffset - fact * ms;
          y = gridpos.y + plot._gridPadding.top - hl.tooltipOffset - elem.outerHeight(true) - fact * ms;
          break;
        case 'n':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) / 2;
          y = gridpos.y + plot._gridPadding.top - hl.tooltipOffset - elem.outerHeight(true) - ms;
          break;
        case 'ne':
          x = gridpos.x + plot._gridPadding.left + hl.tooltipOffset + fact * ms;
          y = gridpos.y + plot._gridPadding.top - hl.tooltipOffset - elem.outerHeight(true) - fact * ms;
          break;
        case 'e':
          x = gridpos.x + plot._gridPadding.left + hl.tooltipOffset + ms;
          y = gridpos.y + plot._gridPadding.top - elem.outerHeight(true) / 2;
          break;
        case 'se':
          x = gridpos.x + plot._gridPadding.left + hl.tooltipOffset - tooltipPaddingSize + fact * ms;
          y = gridpos.y + plot._gridPadding.top + hl.tooltipOffset + fact * ms;
          break;
        case 's':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) / 2;
          y = gridpos.y + plot._gridPadding.top + hl.tooltipOffset + ms;
          break;
        case 'sw':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - hl.tooltipOffset - fact * ms;
          y = gridpos.y + plot._gridPadding.top + hl.tooltipOffset - tooltipPaddingSize + fact * ms;
          break;
        case 'w':
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - hl.tooltipOffset - ms;
          y = gridpos.y + plot._gridPadding.top - elem.outerHeight(true) / 2;
          break;
        default:
          // same as 'nw'
          x = gridpos.x + plot._gridPadding.left - elem.outerWidth(true) - hl.tooltipOffset - fact * ms;
          y = gridpos.y + plot._gridPadding.top - hl.tooltipOffset - elem.outerHeight(true) - fact * ms;
          break;
      }
      
      var highlightCanvasElem = hl.highlightCanvas._elem;
      var highlightCanvasOffset = highlightCanvasElem.offset();

      if (gridpos.x < 0 || gridpos.x > hl.highlightCanvas._ctx.canvas.width || gridpos.y < 0 || gridpos.y > hl.highlightCanvas._ctx.canvas.height) {
        x += ev.pageX - gridpos.x - highlightCanvasOffset.left;
        y += ev.pageY - gridpos.y - highlightCanvasOffset.top;
      }
      
      x = x < 0 ? 0 : x + elem.width() > plot.target.width() ? plot.target.width() - elem.width() : x;
      y = y < 0 ? 0 : y + elem.height() > plot.target.height() ? plot.target.height() - elem.height() : y;
      
      if (x < 0) x = 0;
      
      elem.css('left', x);
      elem.css('top', y);

      elem.unbind('drag');
      
      elem.draggable();
      elem.draggable('destroy');

      elem.css({
        cursor : 'default'
      });

      if (hl.fadeTooltip) {
        // Fix for stacked up animations.  Thnanks Trevor!
        elem.stop(true, true).fadeIn(hl.tooltipFadeSpeed);
      } else {
        elem.show();
      }
      elem = null;
    };
    if ($.isFunction(hl.selectable.tooltipContentEditor)) {
      // args str, seriesIndex, pointIndex are essential so the hook can look up
      // extra data for the point.
      str = hl.selectable.tooltipContentEditor.call(hl, hl.selectable._selected, oldSelected, neighbor, plot, tooltipContentProc, ev);
    } else {
      tooltipContentProc(str);
    }

  }
  
  function handleLeave(ev, gridpos, datapos, neighbor, plot) {
      var eventCanvasElem = $(ev.target),
        width = eventCanvasElem.width(),
        height = eventCanvasElem.height();
      if (gridpos.x <= 0 || gridpos.y <= 0 || gridpos.x >= width || gridpos.y >= height) {
          handleMove(ev, gridpos, datapos, neighbor, plot);
      }
  }

  function handleMove(ev, gridpos, datapos, neighbor, plot) {// customizing (2012-04-19, Roy Choi)
    var hl = plot.plugins.highlighter;
    var c = plot.plugins.cursor;
    if (hl.pointCrossLine) {
      moveCrossLine(ev, gridpos, datapos, plot);
    } else if (hl.show) {
      if (hl.pointVariation && hl.pointVariationStart) {
        handleVariationMove(ev, gridpos, datapos, plot);
      } else if (hl.selectable && hl.selectable.show && hl.selectable.selecting && hl.selectable.tooltipOpend) {
        setTimeout(function() {
          hl.selectable.selecting = false;
        }, 500);
      } else if (hl.overTooltip && !hl.isTooltipDragging && !hl.selectable.selecting) {
        // customizing (2012-04-30, Roy Choi)
        if (!hl.selectable.show && neighbor === null && hl.overTooltipOptions.lineOver) {
          neighbor = isLineOver(gridpos, plot);
        }
        
        if (neighbor && !plot.series[neighbor.seriesIndex].showHighlight) {
            neighbor = null;
        }
        
        if (neighbor == null) {
          if (!hl.isClickTooltip && !hl.selectable.show && hl.overTooltipOptions.showMarker) {
            var ctx = hl.highlightCanvas._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
          }
          if (hl.fadeTooltip) {
            if (!hl.isMultiTooltip && !hl.isClickTooltip) {
              hideTooltipLine(plot);
              fadeoutTooltip(plot);
            }
          } else if (!hl.isMultiTooltip && !hl.isClickTooltip) {
            hideTooltipLine(plot);
            hideTooltip(plot);
          }
          hl.currentOverNeighbor = null;
          ctx = null;
        } else if (neighbor != null && (hl.currentOverNeighbor == null || (neighbor.seriesIndex !== hl.currentOverNeighbor.seriesIndex || neighbor.pointIndex !== hl.currentOverNeighbor.pointIndex))) {
          if (hl.showTooltip && (!c || !c._zoom.started)) {
            if (!hl.isMultiTooltip && (hl.overTooltipOptions.showMarker || hl.overTooltipOptions.showTooltip)) {
              hideTooltipLine(plot);
              hl.isClickTooltip = false;
              hl.currentOverNeighbor = neighbor;
              
              if (!hl.selectable.show && hl.overTooltipOptions.showMarker) {
                var ctx = hl.highlightCanvas._ctx;
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                draw(plot, neighbor);
              }

              if (hl.overTooltipOptions.showTooltip) {
                showTooltip(ev, plot, plot.series[neighbor.seriesIndex], neighbor, true);
              }
            }
          }
        }
      }
    }
  }

  function harfSearchArray(x, startValue, endValue, start, end) {
    if (x > (startValue - endValue) / 2 + startValue) {
      start += Math.floor(end / 2);
    } else {
      end -= Math.floor(end / 2);
    }
  }

  function searchGridData(series, gridpos) {
    var grid_data = series.gridData;
    var sr_data = series.data;
    var x = gridpos.x;

    var start = 0;
    var end = grid_data.length - 1;

    if (x <= grid_data[start][0])
      return {
        pointIndex : start,
        gridData : grid_data[start],
        data : sr_data[start]
      };
    if (x >= grid_data[end][0])
      return {
        pointIndex : end,
        gridData : grid_data[end],
        data : sr_data[end]
      };

    // harf search  10.
    for (var i = 0; i < 10; i++) {
      if (end - start <= 4)
        break;
      harfSearchArray(x, grid_data[start][0], grid_data[end][0], start, end);
    }

    for (var k = start; k <= end; k++) {
      if (end > k) {
        var p = grid_data[k];
        var p1 = grid_data[k + 1];
        if (x > p[0] && x < p1[0]) {
          var ret_data;
          if (Math.abs(p[0] - x) > Math.abs(p1[0] - x)) {
            k++;
            p = p1;
          }
          var ret_data = sr_data[k];
          grid_data = null;
          sr_data = null;
          return {
            pointIndex : k,
            gridData : p,
            data : ret_data
          };
        }
      } else {
        var p = grid_data[k];
        var ret_data = sr_data[k];
        grid_data = null;
        sr_data = null;
        return {
          pointIndex : k,
          gridData : p,
          data : ret_data
        };
      }
    }

  }

  function moveCrossLine(ev, gridpos, datapos, plot) {// customizing (2012-05-03, Roy Choi) - Point Cross Line draw on mouse move
    var hl = plot.plugins.highlighter;

    if (hl.pointCrossLine && hl.pointCrossLineStart && !isNaN(hl.pointCrossLineSeriesIndex)) {
      var sr = plot.series[hl.pointCrossLineSeriesIndex];
      var sr_index = hl.pointCrossLineSeriesIndex;
      var x = gridpos.x;

      var neighbor = searchGridData(sr, gridpos);
      $.extend(neighbor, {
        seriesIndex : sr_index
      });

      var ctx = hl.highlightCanvas._ctx;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx = null;
      hideTooltipLine(plot);
      draw(plot, neighbor);
      showTooltip(ev, plot, sr, neighbor);

      var c = plot.plugins.cursor;
      var ctx = hl.pointCrossLineCanvas._ctx;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      var options = {
        lineWidth : 1,
        color : '#0000ff'
      };
      c.shapeRenderer.draw(ctx, [[neighbor.gridData[0], 0], [neighbor.gridData[0], ctx.canvas.height]], options);
      c.shapeRenderer.draw(ctx, [[0, neighbor.gridData[1]], [ctx.canvas.width, neighbor.gridData[1]]], options);
      ctx = null;
      options = null;
    }
  }


  $.jqplot.Highlighter.prototype.isLineOver = function(gridpos, plot) {// customizing (2012-05-14, Roy Choi)
    return isLineOver(gridpos, plot);
  };

  function isLineOver(gridpos, plot) {// customizing (2012-06-01, Roy Choi)
    var hl = plot.plugins.highlighter;
    var seriesStack = plot.seriesStack;
    var point_color;
    
    var dMin0, dMax0;

    if (plot.options.multiCanvas) {
      for (var si = seriesStack.length - 1; si >= 0; si--) {
        var i = seriesStack[si];
        var sr = plot.series[i];
        
        if (sr.hide || !sr.show || !sr.highlight)
          continue;
        
        if (sr.renderer.constructor === $.jqplot.LineRenderer && sr.showLine) {
          var lineWidth = sr.lineWidth < hl.pointVariationThreshold ? hl.pointVariationThreshold : Math.ceil(sr.lineWidth);
          var fix = Math.floor(lineWidth / 2);
          var left = gridpos.x - fix;
          var top = gridpos.y - fix;
          var imgd = sr.canvas._ctx.getImageData(left, top, lineWidth, lineWidth);
          var data = imgd.data;
          for (var j = 0; j < data.length; j += 4) {
            point_color = $.jqplot.rgb2hex($.jqplot.normalize2rgb("rgb(" + data[j] + "," + data[j + 1] + "," + data[j + 2] + ")"));
            //if(point_color == sr_color) {
            if (point_color != '#000000') {
              var sr_index = sr.index;
              var x = gridpos.x;
              for (var k = 0, grid_len = sr.gridData.length; k < grid_len; k++) {
                if (grid_len > k) {
                  var p = sr.gridData[k];
                  var p1 = sr.gridData[k + 1];
                  if (x > p[0] && x < p1[0]) {
                    /*if(Math.abs(p[0]-x) > Math.abs(p1[0]-x)) {
                     k++;
                     p = p1;
                     }*/
                    var ret_data = sr.data[k];
                    data = null;
                    sr = null;
                    return {
                      seriesIndex : sr_index,
                      pointIndex : k,
                      gridData : p,
                      data : ret_data
                    };
                  }
                } else {
                  var p = sr.gridData[k];
                  var ret_data = sr.data[k];
                  data = null;
                  sr = null;
                  return {
                    seriesIndex : sr_index,
                    pointIndex : k,
                    gridData : p,
                    data : ret_data
                  };
                }
              }
            }
          }
          
          data = null;
        }  else if (sr.renderer.constructor === $.jqplot.BoxplotRenderer) {
          var x = gridpos.x;
          var y = gridpos.y;
          var sdata = sr.data, data;
          var boxPoints = sr._boxPoints;
      
          var dMin, dMax, gridData, maxY, points;
          var t = sr.markerRenderer.size/2+sr.neighborThreshold;
          var threshold = (t > 0) ? t : 0;
          var yp = sr._yaxis.series_u2p;
          
          for (var j=0, l=sdata.length; j<l; j++) {
              gridData = sr.gridData[j];
              data = sdata[j];
      
              dMin = Math.sqrt( (x-gridData[0]) * (x-gridData[0]) + (y-gridData[1]) * (y-gridData[1]) );
              if (dMin <= threshold && (dMin <= dMin0 || dMin0 == null)) {
                 dMin0 = dMin;
                 return {seriesIndex: i, pointIndex:j, gridData:gridData, data:data};
              }
              
              maxY = yp(data[5]);
              dMax = Math.sqrt( (x-gridData[0]) * (x-gridData[0]) + (y-maxY) * (y-maxY) );
              if (dMax <= threshold && (dMax <= dMax0 || dMax0 == null)) {
                 dMax0 = dMax;
                 return {seriesIndex: i, pointIndex:j, gridData:[gridData[0], maxY], data:data, start:[data[0], data[5]]};
              }
              
              points = sr._boxPoints[j];
              if (x>points[0][0] && x<points[2][0] && y<points[2][1] && y>points[0][1]) {
                 return {seriesIndex:i, pointIndex:j, gridData:[x, y], data:data, points:points};
              }

              data = gridData = null;
          }
          sdata = boxPoints = null;
        }

        sr = null;
        
      }
      return null;
    } else {
      var x = gridpos.x;
      var y = gridpos.y;
      var sr, sd, pd, nd, ret_data;
      var tanD, tanYP;

      try {
        for (var si = seriesStack.length - 1; si >= 0; si--) {
          var i = seriesStack[si];
          sr = plot.series[i];
          
          if (sr.hide || !sr.show)
            continue;
            
          if (sr.renderer.constructor === $.jqplot.LineRenderer && sr.showLine && !sr.renderer.smooth) {
            var lineWidth = sr.lineWidth < hl.pointVariationThreshold ? hl.pointVariationThreshold : Math.ceil(sr.lineWidth);
            var fix = lineWidth / 2;
            var top = y + fix;
            var bottom = y - fix;
            var left = x - fix;
            var right = x + fix;
            
            var equation, leftEq, rightEq, topEq, bottomEq;
            var prevX, prevY, nextX, nextY, tempAdd;
            
            sd = sr.gridData;
            
            //sd = sr.gridData;
  
            for (var j = 1, sdlen = sd.length; j < sdlen; j++) {
              pd = sd[j - 1];
              nd = sd[j];
              
              if (isNaN(pd[0]) || pd[0] == null || isNaN(pd[1]) || pd[1] == null
                  || isNaN(nd[0]) || nd[0] == null || isNaN(nd[1]) || nd[1] == null) {
                  continue;
              }
              
              if (pd[0] > nd[0]) {
                prevX = nd[0];
                prevY = nd[1];
                nextX = pd[0];
                nextY = pd[1];
              } else {
                prevX = pd[0];
                prevY = pd[1];
                nextX = nd[0];
                nextY = nd[1];
              }
              
              if (x >= Math.floor(prevX) && x <= Math.ceil(nextX) && ((y >= Math.floor(prevY) && y <= Math.ceil(nextY)) || (y <= Math.ceil(prevY) && y >= Math.floor(nextY)))) {
                if (!$.isNumeric(prevX) || !$.isNumeric(nextX) || !$.isNumeric(prevY) || !$.isNumeric(nextY) ||
                  (sr.breakOnDiff !== null && sr.data[j-1][sr.breakOnDiff] !== sr.data[j][sr.breakOnDiff])) {
                  return null;
                }
                /*if (nextX - prevX <= hl.pointVariationThreshold && ((nextY >= prevY && y <= nextY && y >= prevY) || (nextY <= prevY && y >= nextY && y <= prevY))) {
                  ret_data = sr.data[j - 1];
                  return {
                    seriesIndex : i,
                    pointIndex : j - 1,
                    gridData : sd[j - 1],
                    data : ret_data
                  };
                }*/
                
                equation = (nextY - prevY) / (nextX - prevX);
                
                if (left < prevX) {
                  tempAdd = prevX - left + 0.1;
                  prevX -= tempAdd;
                  nextX -= tempAdd;
                } else if (left == prevX) {
                  tempAdd = 0.1;
                  prevX -= tempAdd;
                  nextX -= tempAdd;
                }
                
                leftEq = (y - prevY) / (left - prevX);
                rightEq = (y - prevY) / (right - prevX);
                topEq = (top - prevY) / (x - prevX);
                bottomEq = (bottom - prevY) / (x - prevX);
                
                if ((((leftEq < rightEq && leftEq <= equation && rightEq >= equation) || (leftEq >= rightEq && leftEq >= equation && rightEq <= equation))) ||
                    (((bottomEq < topEq && bottomEq <= equation && topEq >= equation) || (bottomEq > topEq && bottomEq >= equation && topEq <= equation)))) {
                  return {
                    seriesIndex : i,
                    pointIndex : j - 1,
                    gridData : sd[j - 1],
                    data : sr.data[j - 1]
                  };
                }
              }
  
            }
          } else if (sr.renderer.constructor === $.jqplot.BoxplotRenderer) {
            var x = gridpos.x;
            var y = gridpos.y;
            var sdata = sr.data, data;
            var boxPoints = sr._boxPoints;
        
            var dMin, dMax, gridData, maxY, points;
            var t = sr.markerRenderer.size/2+sr.neighborThreshold;
            var threshold = (t > 0) ? t : 0;
            var yp = sr._yaxis.series_u2p;
            
            for (var j=0, l=sdata.length; j<l; j++) {
                gridData = sr.gridData[j];
                data = sdata[j];
        
                dMin = Math.sqrt( (x-gridData[0]) * (x-gridData[0]) + (y-gridData[1]) * (y-gridData[1]) );
                if (dMin <= threshold && (dMin <= dMin0 || dMin0 == null)) {
                   dMin0 = dMin;
                   return {seriesIndex: i, pointIndex:j, gridData:gridData, data:data};
                }
                
                maxY = yp(data[5]);
                dMax = Math.sqrt( (x-gridData[0]) * (x-gridData[0]) + (y-maxY) * (y-maxY) );
                if (dMax <= threshold && (dMax <= dMax0 || dMax0 == null)) {
                   dMax0 = dMax;
                   return {seriesIndex: i, pointIndex:j, gridData:[gridData[0], maxY], data:data, start:[data[0], data[5]]};
                }
                
                points = sr._boxPoints[j];
                if (x>points[0][0] && x<points[2][0] && y<points[2][1] && y>points[0][1]) {
                   return {seriesIndex:i, pointIndex:j, gridData:[x, y], data:data, points:points};
                }
  
                data = gridData = null;
            }
            sdata = boxPoints = null;
          }

        }
        return null;
      } finally {
        x = y = hl = seriesStack = ret = point_color = null;
        sr = sd = pd = nd = ret_data = null;
      }
    }
  }

  function handleVariationMove(ev, gridpos, datapos, plot) {
    var hl = plot.plugins.highlighter;
    var co = plot.plugins.canvasOverlay;

    if (hl.pointVariationStart || hl.pointVariationEndPos != null) {
      var x_interval = $.jqplot.DateTickFormatter('%H:%M:%S:%#N', datapos.xaxis - hl.pointVariationStartPos.x);
      var y_interval = Math.floor((datapos.yaxis - hl.pointVariationStartPos.y) * 100) / 100;
      hl.pointVariationTooltipElem.offset({
        top : ev.pageY,
        left : ev.pageX
      }).html("x:" + x_interval + "<br />y:" + y_interval).show();
      obj = co.get(hl.pointVariationLineName);
      var opts = {
        show : true,
        lineWidth : hl.pointVariationLineWidth,
        color : hl.pointVariationLineColor,
        start : [hl.pointVariationStartPos.x, hl.pointVariationStartPos.y],
        stop : [datapos.xaxis, datapos.yaxis]
      };
      $.extend(true, obj.options, opts);
      co.draw(plot);
    }
  }
  
  function seriesFadeOut(plot, opacity) {
    $('.jqplot-series-canvas',plot.target).each(function() {
      $(this).fadeTo(0, $.isNumeric(opacity) ? opacity : .4);
    });
  }
  
  function seriesFadeIn(plot) {
    $('.jqplot-series-canvas',plot.target).each(function() {
      $(this).fadeTo(0, 1.0);
    });
  }

  function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {// customizing (2012-04-19, Roy Choi)
    var hl = plot.plugins.highlighter;
    var c = plot.plugins.cursor;
    var co = plot.plugins.canvasOverlay;
    var continuous = plot.checkCtrlKey(ev.originalEvent);
    
    if (hl.show) {
      if (neighbor == null) {
        neighbor = isLineOver(gridpos, plot);
      } else if (plot.series[neighbor.seriesIndex].hide || !plot.series[neighbor.seriesIndex].show) {
        neighbor = null;
      }
      if (hl.pointVariation) {
        if (neighbor) {
          if (hl.pointVariationStart) {
            hl.pointVariationStart = false;
            hl.pointVariationEndPos = {
              x : neighbor.data[0],
              y : neighbor.data[1]
            };
            handleVariationMove(ev, gridpos, {
              xaxis : neighbor.data[0],
              yaxis : neighbor.data[1]
            }, plot);
          } else {
            clearVariation(plot);
            hl.pointVariationStartPos = {
              x : neighbor.data[0],
              y : neighbor.data[1]
            };
            hl.pointVariationStart = true;
            handleVariationMove(ev, gridpos, {
              xaxis : neighbor.data[0],
              yaxis : neighbor.data[1]
            }, plot);
          }
        }
      } else if (hl.pointCrossLine) {
        hl.isClickTooltip = false;
        if (neighbor) {
          hl.pointCrossLineStart = true;
          hl.pointCrossLineSeriesIndex = neighbor.seriesIndex;
          if (hl.bringSeriesToFront && !plot.series[neighbor.seriesIndex].highlighted) {
            plot.moveSeriesToFront(neighbor.seriesIndex, continuous);
          }
          moveCrossLine.call(this, ev, gridpos, datapos, plot);
        } else {
          hl.pointCrossLineStart = false;
          hl.pointCrossLineSeriesIndex = null;
          //var c = plot.plugins.cursor;
          hl.clearCrossLine(plot);
        }
      } else if (hl.selectable.show && hl.selectable.multiSelect) {
        hl.selectable.start = gridpos;
        hl.selectable.selecting = true;
        hl.selectable.dragging = false;
        
        // TODO: modify window object
        if (window && window.event && hl.selectable.ctrlRemove) {
          hl.selectable.removing = window.event.ctrlKey;
        }
        
        //customizing (2015-09-11, Eric Leem)
        if(hl.selectable.zoom){
          $(document).unbind('mouseup', {plot: plot}, handleSelectStop);
          $(document).unbind('mousemove', {plot: plot}, handleSelectDrag);
          $(document).bind('mouseup', {plot: plot}, handleSelectStop);
        } else{
          if(hl.selectable.selectLimited != null){
            $(document).unbind('mouseup', {plot: plot}, handleSelectStop);
            $(document).unbind('mousemove', {plot: plot}, handleSelectDrag);
            $(document).bind('mouseup', {plot: plot}, handleSelectStop);
          } else{
            $(document).unbind('mouseup', {plot: plot}, handleSelectStop);
            $(document).bind('mousemove', {plot: plot}, handleSelectDrag);
            $(document).bind('mouseup', {plot: plot}, handleSelectStop);
          }
        }
      }
    }
  }
  
  function isSelected(plot, conditionData) {
    var hl = plot.plugins.highlighter;
    
    return $.inArray(conditionData, hl.selectable._selected) > -1;
  }
  
  function drawSelectBox(start, end) {
    var ctx = this.canvas._ctx;
    
    ctx.save();
    
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    var l, t, h, w;
    if (end[0] > start[0]) {
      l = start[0];
      w = end[0] - start[0];
    } else {
      l = end[0];
      w = start[0] - end[0];
    }
    if (end[1] > start[1]) {
      t = start[1];
      h = end[1] - start[1];
    } else {
      t = end[1];
      h = start[1] - end[1];
    }
    ctx.fillStyle = 'rgba(42,127,213,0.2)';
    ctx.strokeStyle = 'rgb(42,127,213)';
    ctx.lineWidth = 1.0;
    
    //ctx.fillRect(l,t,w,h);
    ctx.strokeRect(l,t,w,h);
    ctx.fillRect(l,t,w,h);
    // IE won't show transparent fill rect, so stroke a rect also.
    //ctx.strokeRect(l,t,w,h);
    
    ctx.restore();
    ctx = null;
  }
  
  function handleSelectDrag(ev) {
    ev.preventDefault();
    ev.stopImmediatePropagation();
    
    var plot = ev.data.plot;
    var hl = plot.plugins.highlighter;
    
    var positions = plot.getEventPosition(ev);
    var gridpos = positions.gridPos;
    
    if (gridpos.x < 0) {
      gridpos.x = 0;
    } else if (gridpos.x >= hl.canvas._ctx.canvas.width) {
      gridpos.x = hl.canvas._ctx.canvas.width - 1;
    }
    if (gridpos.y < 0) {
      gridpos.y = 0;
    } else if (gridpos.y >= hl.canvas._ctx.canvas.height) {
      gridpos.y = hl.canvas._ctx.canvas.height - 1;
    }

    if (Math.abs(gridpos.x - hl.selectable.start.x) * Math.abs(gridpos.y - hl.selectable.start.y) < 5) {
      return;
    }
    
    hl.selectable.dragging = true;
    
    var start = [hl.selectable.start.x, hl.selectable.start.y];
    var end = [gridpos.x, gridpos.y];
    
    drawSelectBox.call(hl, start, end);
  }
  
  function handleSelectStop(ev) {
    //customizing (2015-09-11, Eric Leem)
    var plot = ev.data.plot;
    var hl = plot.plugins.highlighter;    
      var ctx = hl.canvas._ctx;
    var position = plot.getEventPosition(ev);
    var neighbor = plot.checkIntersection(ev, position.gridPos, plot);
    var limitedFlag = true;
    
    $(document).unbind('mousemove', handleSelectDrag);
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    if (hl.selectable.start && hl.selectable.selecting) {
        hl.selectable.stop = position.gridPos;
      
        
        if(hl.selectable.selectLimited != null){
          if(hl.selectable.start.x != hl.selectable.stop.x && hl.selectable.start.y != hl.selectable.stop.y){
            limitedFlag = false;
          }
          if(neighbor != null){
            if(hl.selectable._selected.length < hl.selectable.selectLimited){
              limitedFlag = true;
            } else if(hl.selectable._selected.length == hl.selectable.selectLimited){
              for (var i = 0; i < hl.selectable._selected.length; i++) {
              if(hl.selectable._selected[i] == neighbor.pointIndex){
                limitedFlag = true;
                break;
              } else{
                limitedFlag = false;
              }
            }           
            } else{
              limitedFlag = false;
            }
          }
        }
        
        if(hl.selectable.zoom){
          if(hl.selectable.start.x != hl.selectable.stop.x && hl.selectable.start.y != hl.selectable.stop.y){
            limitedFlag = false;
          }
        }
        
        if(limitedFlag){
          if (hl.selectable.removing) {
            removeSelected(ev, plot, hl.selectable.start, hl.selectable.stop);
          } else {
              if (!hl.selectable.dragging && neighbor !== null && isSelected(plot, plot.series[neighbor.seriesIndex].data[neighbor.pointIndex][hl.selectable.selectColumnIndex])) {
                removeSelectedPoint(plot, plot.series[neighbor.seriesIndex].data[neighbor.pointIndex][hl.selectable.selectColumnIndex]);
              } else {
                highlightSelected(ev, plot, hl.selectable.start, hl.selectable.stop, position);
              }
          }
            
          hl.selectable.start = null;
          hl.selectable.stop = null;
          hl.selectable.dragging = false;
        }
    }
  }
  
  function removeIntersect(source, target) {
    return $.grep(source, function(i)
    {
        return $.inArray(i, target) === -1;
    });
  }
  
  function removeSelectedPoint(plot, conditionData) {
    var hl = plot.plugins.highlighter;
    
    hl.selectable._selectedInfo = [];
    var oldSelected = hl.selectable._selected.concat([]);
    hl.selectable._selected.splice(hl.selectable._selected.indexOf(conditionData), 1);
    highlightByData(plot, hl.selectable._selected);
    
    if ($.isFunction(hl.selectable.selectChanged)) {
      hl.selectable.selectChanged(hl.selectable._selected, oldSelected);
    }
    
    hl.selectable.selecting = false;
  }
  
  function removeSelected(ev, plot, start, stop) {
    var hl = plot.plugins.highlighter;
    var series = plot.series;
    var seriesStack = plot.seriesStack;
    var removeCount = 0;
    var s, i, j;
    
    var minX, minY, maxX, maxY;
    var dataX, dataY;
    var series_xu2p, series_yu2p;
    var markerSize = 0;
    var removed = [];
    var condition;
    var columnIndex = hl.selectable.selectColumnIndex;
    var gridPos = {
      x: null,
      y: null
    };
    
    if (hl.selectable.unselect) {
      hl.selectable._selected = [];
      hl.selectable._selectedInfo = [];
    }
    
    if (!$.isNumeric(columnIndex)) {
      console.warn('selectColumnIndex is not numeric');
      return;
    }
     
    search: {
      for (i = seriesStack.length - 1; i >= 0; i--) {
        s = series[seriesStack[i]];
        
        if (s.hide || !s.show) {
          continue;
        }
        
        if (s.showMarker) {
          markerSize = s.markerOptions.size / 2;
        }
  
        if (start.x < stop.x) {
          gridPos.x = stop.x;
          minX = start.x - markerSize;
          maxX = stop.x + markerSize;
        } else {
          gridPos.x = start.x;
          minX = stop.x - markerSize;
          maxX = start.x + markerSize;
        }
        if (start.y < stop.y) {
          gridPos.y = stop.y;
          minY = start.y - markerSize;
          maxY = stop.y + markerSize;
        } else {
          gridPos.y = start.y;
          minY = stop.y - markerSize;
          maxY = start.y + markerSize;
        }
        
        series_xu2p = s._xaxis.series_u2p;
        series_yu2p = s._yaxis.series_u2p;
  
        for (j = 0, slen = s.data.length; j < slen; j++) {
          dataX = series_xu2p(s.data[j][0]);
          dataY = series_yu2p(s.data[j][1]);
          condition = s.data[j][columnIndex];
          
          if (dataX >= minX && dataX <= maxX && dataY >= minY && dataY <= maxY) {
            if (!hl.selectable.unselect && $.inArray(condition, hl.selectable._selected) > -1) {
              removed.push(condition);
              
              if (!hl.selectable.dragging) {
                break search;
              }
            }
          }
        }
      }
    }
    
    if (removed.length > 0) {
      var oldSelected = hl.selectable._selected.concat([]);
      plot.options.highlighter.selectable._selected = hl.selectable._selected = removeIntersect(hl.selectable._selected, removed);
      
      hl.selectable._selectedInfo = [];
      highlightByData(plot, hl.selectable._selected);
      
      if ($.isFunction(hl.selectable.selectChanged)) {
        hl.selectable.selectChanged(hl.selectable._selected, oldSelected);
      }
    } else {
      if (hl.selectable.unselect) {
        if (hl.fadeTooltip) {
          hideTooltipLine(plot);
          fadeoutTooltip(plot);
        } else {
          hideTooltipLine(plot);
          hideTooltip(plot);
        }
        if (hl.bringSeriesToFront) {
          plot.restoreOriginalSeriesOrder();
        }
      }
      
      hl.selectable.selecting = false;
    }

    snapshotData = null;
    pushed_count = null;
  }
  
  function highlightByData(plot, selected) {
    var hl = plot.plugins.highlighter;
    
    hl.selectable._selectedInfo = [];

    var ctx = hl.highlightCanvas._ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    if (selected.length === 0) {
      plot.restoreOriginalSeriesOrder();
      return;
    }
    
    var snapshotData = [];
    var series = plot.series;
    var pushed_count = 0;
    var seriesData = [], pointData = [], gridData = [];
    var s, i, j;
    
    var series_xu2p, series_yu2p;
    var dataX, dataY;
    var markerSize = 0;
    var condition;
    var columnIndex = hl.selectable.selectColumnIndex;
    var seriesIndex;
    
    if (!$.isNumeric(columnIndex)) {
      console.warn('selectColumnIndex is not numeric');
      return;
    }
     
    for (i = plot.seriesStack.length - 1; i >= 0; i--) {
      seriesData = [];
      pointData = [];
      gridData = [];
      seriesIndex = plot.seriesStack[i];
      s = series[seriesIndex];
      
      if (s.showMarker) {
        markerSize = s.markerOptions.size / 2;
      }
      
      series_xu2p = s._xaxis.series_u2p;
      series_yu2p = s._yaxis.series_u2p;

      for (j = 0, slen = s.data.length; j < slen; j++) {
        condition = s.data[j][columnIndex];
        
        if ($.inArray(condition, selected) > -1) {
          dataX = series_xu2p(s.data[j][0]);
          dataY = series_yu2p(s.data[j][1]);
          seriesData.push(s.data[j]);
          pointData.push(j);
          gridData.push([dataX, dataY]);
        }
      }

      if (seriesData.length > 0) {
        snapshotData.push({
          data : seriesData,
          gridData: gridData,
          pointIndexes : pointData,
          seriesIndex : seriesIndex,
          label : series[seriesIndex].label
        });
      }
    }
    
    hl.selectable._selectedInfo = snapshotData;
    
    seriesFadeOut(plot, hl.selectable.seriesFadeOut);
    drawMarkers(plot, hl.selectable._selectedInfo);

    snapshotData = null;
    pushed_count = null;
  }
  
  function highlightSelected(ev, plot, start, stop, neighbor) {
    var hl = plot.plugins.highlighter;
    var snapshotData = [];
    var series = plot.series;
    var seriesStack = plot.seriesStack;
    var pushed_count = 0;
    var seriesData = [], pointData = [], gridData = [];
    var s, i, j;
    
    var minX, minY, maxX, maxY;
    var dataX, dataY;
    var series_xu2p, series_yu2p;
    var markerSize = 0;
    var selected = [];
    var condition;
    var columnIndex = hl.selectable.selectColumnIndex;
    var gridPos = {
      x: null,
      y: null
    };
    
    if (hl.selectable.unselect) {
      hl.selectable._selected = [];
      hl.selectable._selectedInfo = [];
    }
    
    if (!$.isNumeric(columnIndex)) {
      console.warn('selectColumnIndex is not numeric');
      return;
    }
     
    search: {
      for (i = seriesStack.length - 1; i >= 0; i--) {
        seriesData = [];
        pointData = [];
        gridData = [];
        s = series[seriesStack[i]];
        
        if (s.hide || !s.show) {
          continue;
        }
        
        if (s.showMarker) {
          markerSize = s.markerOptions.size / 2;
        }
  
        if (start.x < stop.x) {
          gridPos.x = stop.x;
          minX = start.x - markerSize;
          maxX = stop.x + markerSize;
        } else {
          gridPos.x = start.x;
          minX = stop.x - markerSize;
          maxX = start.x + markerSize;
        }
        if (start.y < stop.y) {
          gridPos.y = stop.y;
          minY = start.y - markerSize;
          maxY = stop.y + markerSize;
        } else {
          gridPos.y = start.y;
          minY = stop.y - markerSize;
          maxY = start.y + markerSize;
        }
        
        series_xu2p = s._xaxis.series_u2p;
        series_yu2p = s._yaxis.series_u2p;
  
        for (j = 0, slen = s.data.length; j < slen; j++) {
          dataX = series_xu2p(s.data[j][0]);
          dataY = series_yu2p(s.data[j][1]);
          condition = s.data[j][columnIndex];
          
          if (dataX >= minX && dataX <= maxX && dataY >= minY && dataY <= maxY) {
            if (!hl.selectable.unselect && $.inArray(condition, hl.selectable._selected) > -1) {
              continue;
            }
            
            seriesData.push(s.data[j]);
            pointData.push(j);
            gridData.push([dataX, dataY]);
            selected.push(s.data[j][columnIndex]);
            if (!hl.selectable.dragging) {
              pushed_count += seriesData.length;
              
              snapshotData.push({
                data : seriesData,
                gridData: gridData,
                pointIndexes : pointData,
                seriesIndex : seriesStack[i],
                label : series[seriesStack[i]].label
              });
              
              break search;
            }
          }
        }
        
        pushed_count += seriesData.length;
        
        if (seriesData.length > 0) {
          snapshotData.push({
            data : seriesData,
            gridData: gridData,
            pointIndexes : pointData,
            seriesIndex : seriesStack[i],
            label : series[seriesStack[i]].label
          });
        }
      }
    }
     

    
    if (pushed_count > 0) {
      var oldSelected = hl.selectable._selected.concat([]);
      plot.options.highlighter.selectable._selected = hl.selectable._selected = hl.selectable._selected.concat(selected);
      hl.selectable._selectedInfo = hl.selectable._selectedInfo.concat(snapshotData);
      
      seriesFadeOut(plot, hl.selectable.seriesFadeOut);
      drawMarkers(plot, hl.selectable._selectedInfo);
      if (hl.selectable.showTooltip && ev) {
        showSelectTooltip(ev, plot, hl.selectable._selected, oldSelected, snapshotData, $.extend(true, {}, neighbor, {gridPos: {x: stop.x, y: stop.y}}));
        hl.selectable.tooltipOpend = true;
      }
      
      if ($.isFunction(hl.selectable.selectChanged)) {
        hl.selectable.selectChanged(hl.selectable._selected, oldSelected);
      }
    } else {
      if (hl.selectable.unselect) {
        if (hl.fadeTooltip) {
          hideTooltipLine(plot);
          fadeoutTooltip(plot);
        } else {
          hideTooltipLine(plot);
          hideTooltip(plot);
        }
        if (hl.bringSeriesToFront) {
          plot.restoreOriginalSeriesOrder();
        }
      }
      
      hl.selectable.selecting = false;
    }

    snapshotData = null;
    pushed_count = null;
  }
  
  function drawMarkers(plot, selectedData) {
    var hl = plot.plugins.highlighter;
    
    var mr = hl.markerRenderer;
    var ctx = hl.highlightCanvas._ctx;
    
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    for (var i = selectedData.length - 1; i >= 0; i--) {
      var seriesInfo = selectedData[i];
      var s = plot.series[seriesInfo.seriesIndex];
      
      if (s.hide || !s.show) {
        return;
      }
      
      var smr = s.markerRenderer;
      
      mr.style = smr.style;
      mr.lineWidth = smr.lineWidth + hl.lineWidthAdjust;
      mr.size = smr.size + hl.sizeAdjust;
      var rgba = $.jqplot.getColorComponents(smr.color);
      var newrgb = [rgba[0], rgba[1], rgba[2]];
      var alpha = (rgba[3] >= 0.6) ? rgba[3] * 0.6 : rgba[3] * (2 - rgba[3]);
      mr.color = 'rgba(' + newrgb[0] + ',' + newrgb[1] + ',' + newrgb[2] + ',' + alpha + ')';
      mr.shapeRenderer.color = mr.color;
      mr.stroke = hl.stroke;
      mr.strokeStyle = hl.strokeStyle;
      mr.init();
      
      seriesInfo.gridData.forEach(function(point, index) {
        if ($.isFunction(smr.fillStyleFilter)) {
          mr.shapeRenderer.fillStyle = smr.fillStyleFilter.call(s, s.data[seriesInfo.pointIndexes[index]]);
        }
        
        mr.draw(point[0], point[1], ctx);
      });
    }
  }
  
  function handleClick(ev, gridpos, datapos, neighbor, plot) {// customizing (2014-10-20, Roy Choi)
    // TODO: if multiSelect enabled and dragging, do nothing and return.
    var hl = plot.plugins.highlighter;
    var c = plot.plugins.cursor;
    var co = plot.plugins.canvasOverlay;
    var continuous = plot.checkCtrlKey(ev.originalEvent);
    if (hl.show && hl.clickTooltip) {
      if (neighbor == null) {
        neighbor = isLineOver(gridpos, plot);
      } else if (plot.series[neighbor.seriesIndex].hide || !plot.series[neighbor.seriesIndex].show) {
        neighbor = null;
      }
      
      if (neighbor && !plot.series[neighbor.seriesIndex].highlight) {
        neighbor = null;
      }

      if (hl.selectable && hl.selectable.show && hl.selectable.selecting) {
        return;
      }

      plot.eventCanvas._elem.trigger('jqplot.preSelectSinglePoint', [plot, neighbor, continuous]);

      if (!hl.isMultiTooltip) {
        var ctx = hl.highlightCanvas._ctx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx = null;
      }
      
      if (neighbor == null) { // Case  
        if (!continuous) {
          hl.clearHighlight(plot);
        }
      } else {  // Case   
        if (continuous && $.inArray(neighbor.seriesIndex, plot.highlightSeriesIndexes) > -1) { //  highlight    
          if (hl.showTooltip) {
            showTooltip(ev, plot, plot.series[neighbor.seriesIndex], neighbor, false);
          }
        } else {
          if (!continuous) {
            hl.clearHighlight(plot);
          }
          if (hl.showTooltip) {
            showTooltip(ev, plot, plot.series[neighbor.seriesIndex], neighbor, false);
          }
          if (hl.bringSeriesToFront) {
            plot.moveSeriesToFront(neighbor.seriesIndex, continuous);
          } else if (hl.highlightOnlyMarker) {
            seriesFadeOut(plot);
          }
        }
      }
      plot.eventCanvas._elem.trigger('jqplot.selectSinglePoint', [plot, neighbor, continuous]);
    }
  }

  function handleRightClick(ev, gridpos, datapos, neighbor, plot) {// customizing (2012-05-02, Roy Choi)
    var hl = plot.plugins.highlighter;
    if (hl.contextMenu) {
      if (neighbor == null) {
        neighbor = isLineOver(gridpos, plot);
      } else if (plot.series[neighbor.seriesIndex].hide || !plot.series[neighbor.seriesIndex].show) {
        neighbor = null;
        neighbor = isLineOver(gridpos, plot);
      }

      /*hl.contextMenuElem.empty();
       hl.contextMenuElem.html('');*/

      if (neighbor && typeof hl.contextMenuSeriesOptions == 'object' && Object.keys(hl.contextMenuSeriesOptions).length > 0) {
        if ( typeof hl.contextMenuSeriesOptions.items == 'function') {
          var items = hl.contextMenuSeriesOptions.items(ev, gridpos, datapos, neighbor, plot);

          hl.contextMenuSeriesOptions.seriesInfo = {
            plot : plot,
            seriesIndex : neighbor.seriesIndex
          };
          $.contextMenu('destroy', plot.targetId);
          $.contextMenu({
            selector : plot.targetId,
            zIndex : 1000,
            build : function($trigger, e) {
              return $.extend(true, {}, hl.contextMenuSeriesOptions, {
                items : items
              });
            }
          });

          $(plot.target).contextMenu({
            x : ev.pageX,
            y : ev.pageY
          });
        } else if ( typeof hl.contextMenuSeriesOptions.items == 'object' && Object.keys(hl.contextMenuSeriesOptions.items).length > 0) {
          hl.contextMenuSeriesOptions.seriesInfo = {
            plot : plot,
            seriesIndex : neighbor.seriesIndex
          };
          $.contextMenu('destroy', plot.targetId);
          $.contextMenu({
            selector : plot.targetId,
            zIndex : 1000,
            build : function($trigger, e) {
              return hl.contextMenuSeriesOptions;
            }
          });

          $(plot.target).contextMenu({
            x : ev.pageX,
            y : ev.pageY
          });

          /*ev.stopImmediatePropagation();
           $(plot.target).contextmenu({});

           var evt = jQuery.Event('contextmenu');
           evt.pageX = ev.pageX;
           evt.pageY = ev.pageY;
           evt.data = {plot: plot, seriesIndex: ev.data.seriesIndex};
           $(plot.target).contextmenu(hl.contextMenuSeriesOptions).trigger(evt);*/

        }
        /*var li = document.createElement('li');
         $(li).addClass('jqplot-highlighter-contextmenu');
         $(li).html('<span class="jqplot-highlighter-contextmenu-text">Hide Series</span>');
         $(li).prepend('<span class="jqplot-highlighter-contextmenu-icon"></span>');
         $(li).bind('click', {plot:plot,seriesIndex:neighbor.seriesIndex}, function(ev) {
         var plot = ev.data.plot;
         var hl = plot.plugins.highlighter;
         plot.legend.renderer.toggleLegend(plot, ev.data.seriesIndex);
         //$(plot.legend._elem.find('.jqplot-table-legend-label').get(ev.data.seriesIndex)).trigger('click');

         hl.contextMenuElem.hide();
         });
         $(li).appendTo(hl.contextMenuElem);

         li = null;*/
      } else {
        if (hl.contextMenuBackgroundOptions.items && Object.keys(hl.contextMenuBackgroundOptions.items).length > 0) {
          $.contextMenu('destroy', plot.targetId);
          $.contextMenu({
            selector : plot.targetId,
            zIndex : 1000,
            build : function($trigger, e) {
              return hl.contextMenuBackgroundOptions;
            }
          });

          $(plot.target).contextMenu({
            x : ev.pageX,
            y : ev.pageY
          });
        }

        /*ev.stopImmediatePropagation();
        $(plot.target).contextmenu({});

        var evt = jQuery.Event('contextmenu');
        evt.pageX = ev.pageX;
        evt.pageY = ev.pageY;
        $(plot.target).contextmenu(hl.contextMenuBackgroundOptions).trigger(evt);*/
        //$(plot.target).unbind('contextmenu');
        /*var menuList = hl.contextMenuBackgroundOptions;
         $.each(menuList, function(ind, menu) {
         var li = document.createElement('li');
         $(li).addClass('jqplot-highlighter-contextmenu');
         $(li).html('<span class="jqplot-highlighter-contextmenu-text">'+menu.text+'</span>');
         if(menu.icon) {
         $(li).append('<img src="'+menu.icon+'" class="jqplot-highlighter-contextmenu-icon" />');
         }
         //$(li).attr({id:menu.id});
         if($.isArray(menu.events)) {
         $.each(menu.events, function(eind, e){
         $(li).bind(e.name, {plot:plot}, e.callback);
         });
         }
         $(li).appendTo(hl.contextMenuElem);

         li = null;
         });*/
      }
      /*var height = hl.contextMenuElem.outerHeight();
       var width = hl.contextMenuElem.outerWidth();

       var wHeight = $(window).height();
       var wWidth = $(window).width();

       var sTop = $(document).scrollTop();
       var sLeft = $(document).scrollLeft();

       var x = (ev.pageX > (sLeft+wWidth-width)) ? sLeft+wWidth-width: ev.pageX;
       var y = (ev.pageY > (sTop+wHeight-height)) ? sTop+wHeight-height: ev.pageY;

       hl.contextMenuElem.show();
       hl.contextMenuElem.offset({top:y, left:x});*/
    }
  }

  /*var rightClickBlur = function(ev) {       // customizing (2012-05-02, Roy Choi)
   var hl = ev.data.plot.plugins.highlighter;
   hl.contextMenuElem.hide();
   }*/

  /*function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {  // customizing (2012-04-19, Roy Choi)
   var hl = plot.plugins.highlighter;
   hl.clickStart = gridpos;
   }*/

  function handleRightDown(ev, gridpos, datapos, neighbor, plot) {// customizing (2012-04-19, Roy Choi)
    var hl = ev.data.plot.plugins.highlighter;

    var ctx = hl.highlightCanvas._ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (hl.fadeTooltip) {
      hideTooltipLine(plot);
      fadeoutTooltip(plot);;
    } else {
      hideTooltipLine(plot);
      hideTooltip(plot);
    }
  }

  // customizing (2012-08-30, Roy Choi)
  function postSeriesRedraw() {
    var plot = this;
    var hl = plot.plugins.highlighter;
    var c = plot.plugins.cursor;
    var co = plot.plugins.canvasOverlay;
    var neighbor = hl.currentNeighbor;
    if (hl.show) {
      if (neighbor == null && typeof plot.highlightSeriesIndex == 'number') {
        var ctx = hl.highlightCanvas._ctx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        if (hl.fadeTooltip) {
          if (hl.isMultiTooltip && hl.multiTooltipElem.length > 0) {
            //hl.clearMultiTooltip(plot);
          } else {
            hideTooltipLine(plot);
            fadeoutTooltip(plot);;
          }
        } else {
          if (hl.isMultiTooltip && hl.multiTooltipElem.length > 0) {
            //hl.clearMultiTooltip(plot);
          } else {
            hideTooltipLine(plot);
            hideTooltip(plot);
          }
        }
        if (hl.bringSeriesToFront && !$.isNumeric(plot.highlightSeriesIndex)) {
          plot.restoreOriginalSeriesOrder();
        }
        hl.isClickTooltip = false;
        hl.isClickHighlighting = false;
        hl.currentNeighbor = null;
        ctx = null;
      } else if (neighbor != null) {
        // highlighting the wrong point.

        // if new series allows highlighting, highlight new point.
        if (plot.series[neighbor.seriesIndex].showHighlight) {
          var ctx = hl.highlightCanvas._ctx;
          ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
          ctx = null;

          if (plot.highlightSeriesIndex === neighbor.seriesIndex) {
            if (hl.showMarker) {
              draw(plot, neighbor);
            }
            if (hl.showTooltip && (!c || !c._zoom.started)) {
              hl._tooltipElem.trigger('drag');
            }
          } else {
            if (hl.fadeTooltip) {
              if (hl.isMultiTooltip && hl.multiTooltipElem.length > 0) {
                //hl.clearMultiTooltip(plot);
              } else {
                hideTooltipLine(plot);
                fadeoutTooltip(plot);;
              }
            } else {
              if (hl.isMultiTooltip && hl.multiTooltipElem.length > 0) {
                //hl.clearMultiTooltip(plot);
              } else {
                hideTooltipLine(plot);
                hideTooltip(plot);
              }
            }
          }

        }
      }
      
      if (hl.selectable.show && hl.selectable._selected.length > 0) {
        highlightByData(plot, hl.selectable._selected);
      } 
    }
    plot = hl = co = c = null;
  }

  function postSeriesPointRemove(pointIndex, plot) {
    var series = this;
    var hl = plot.plugins.highlighter;

    if (hl.currentNeighbor != null && series.index == hl.currentNeighbor.seriesIndex) {
      if (pointIndex == hl.currentNeighbor.pointIndex) {
        hl.currentNeighbor = null;
      } else if (pointIndex < hl.currentNeighbor.pointIndex) {
        hl.currentNeighbor.pointIndex--;
        hl.currentNeighbor.gridData = series.gridData[hl.currentNeighbor.pointIndex];
      }
    }
    hl = series = null;
  }

  function handleRemoveHighlight(ev, plot) {
    if (!plot.options.multiCanvas) {
      var ctx = plot.seriesHighlightCanvas._ctx;
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx = null;
    }
    var hl = plot.plugins.highlighter;
    var ctx = hl.highlightCanvas._ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (hl.fadeTooltip) {
      if (hl.isMultiTooltip && hl.multiTooltipElem.length > 0) {
        //hl.clearMultiTooltip(plot);
      } else {
        hideTooltipLine(plot);
        fadeoutTooltip(plot);;
      }
    } else {
      if (hl.isMultiTooltip && hl.multiTooltipElem.length > 0) {
        //hl.clearMultiTooltip(plot);
      } else {
        hideTooltipLine(plot);
        hideTooltip(plot);
      }
    }
    hl.isClickTooltip = false;
    hl.isClickHighlighting = false;
    hl.currentNeighbor = null;
    ctx = null;
    
    if (hl.selectable.show && hl.selectable._selected.length > 0) {
      highlightByData(plot, hl.selectable._selected);
    }
  }

  function handleVisibleChange(ev, plot, series) {
    var hl = plot.plugins.highlighter;
    if (hl.currentNeighbor && plot.series[hl.currentNeighbor.seriesIndex].hide) {
      hl.clearHighlight(plot);
      //handleRemoveHighlight(ev, plot);
    }
    if ($.isArray(hl.selectable._selected) && hl.selectable._selected.length > 0) {
      highlightByData(plot, hl.selectable._selected);
    }
  }


  $.jqplot.postRedrawSeriesHooks.push(postSeriesRedraw);
  $.jqplot.postRemoveSeriesPointHooks.push(postSeriesPointRemove);
})(jQuery);

/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function($) {   
    $.jqplot.CategoryAxisRenderer.prototype.createTicks = function() {
        // we're are operating on an axis here
        var ticks = this._ticks;
        var userTicks = this.ticks;
        var name = this.name;
        // databounds were set on axis initialization.
        var db = this._dataBounds;
        var dim, interval;
        var min, max;
        var pos1, pos2;
        var tt, i;

        // if we already have ticks, use them.
        if (userTicks.length) {
            // adjust with blanks if we have groups
            if (this.groups > 1 && !this._grouped) {
                var l = userTicks.length;
                var skip = parseInt(l/this.groups, 10);
                var count = 0;
                for (var i=skip; i<l; i+=skip) {
                    userTicks.splice(i+count, 0, ' ');
                    count++;
                }
                this._grouped = true;
            }
            this.min = 0.5;
            this.max = userTicks.length + 0.5;
            var range = this.max - this.min;
            this.numberTicks = 2*userTicks.length + 1;
            for (i=0; i<userTicks.length; i++){
                tt = this.min + 2 * i * range / (this.numberTicks-1);
                // need a marker before and after the tick
                var t = new this.tickRenderer(this.tickOptions);
                t.showLabel = false;
                // t.showMark = true;
                t.setTick(tt, this.name);
                this._ticks.push(t);
                var t = new this.tickRenderer(this.tickOptions);
                t.label = userTicks[i];
                // t.showLabel = true;
                t.showMark = false;
                t.showGridline = false;
                t.setTick(tt+0.5, this.name);
                this._ticks.push(t);
            }
            // now add the last tick at the end
            var t = new this.tickRenderer(this.tickOptions);
            t.showLabel = false;
            // t.showMark = true;
            t.setTick(tt+1, this.name);
            this._ticks.push(t);
        }

        // we don't have any ticks yet, let's make some!
        else {
            if (name == 'xaxis' || name == 'x2axis') {
                dim = this._plotDimensions.width;
            }
            else {
                dim = this._plotDimensions.height;
            }
            
            // if min, max and number of ticks specified, user can't specify interval.
            if (this.min != null && this.max != null && this.numberTicks != null) {
                this.tickInterval = null;
            }
            
            // if max, min, and interval specified and interval won't fit, ignore interval.
            if (this.min != null && this.max != null && this.tickInterval != null) {
                if (parseInt((this.max-this.min)/this.tickInterval, 10) != (this.max-this.min)/this.tickInterval) {
                    this.tickInterval = null;
                }
            }
        
            // find out how many categories are in the lines and collect labels
            var labels = [];
            var numcats = 0;
            var min = (this.min != null) ? Math.ceil(this.min)-0.5 : 0.5;	// customizing
            var max, val;
            var isMerged = false;
            
            // customizing for zoom (2013-02-20, Roy Choi)
            max = (this.max != null) ? Math.floor(this.max, 10)+0.5 : null;
            
            for (var i=0; i<this._series.length; i++) {
                var s = this._series[i];
                for (var j=0; j<s.data.length; j++) {
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        val = s.data[j][0];
                    }
                    else {
                        val = s.data[j][1];
                    }
                    if ($.inArray(val, labels) == -1) {
                        isMerged = true;
                        numcats += 1;      
                        labels.push(val);
                    }
                }
            }
            
            if (isMerged && this.sortMergedLabels) {
                if (typeof labels[0] == "string") {
                    labels.sort();
                } else {
                    labels.sort(function(a,b) { return a - b; });
                }
            }
            

            
            // keep a reference to these tick labels to use for redrawing plot (see bug #57)
            this.ticks = labels;
            
            // now bin the data values to the right lables.
            for (var i=0; i<this._series.length; i++) {
                var s = this._series[i];
                for (var j=0; j<s.data.length; j++) {
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        val = s.data[j][0];
                    }
                    else {
                        val = s.data[j][1];
                    }
                    // for category axis, force the values into category bins.
                    // we should have the value in the label array now.
                    var idx = $.inArray(val, labels)+1;
                    if (this.name == 'xaxis' || this.name == 'x2axis') {
                        s.data[j][0] = idx;
                    }
                    else {
                        s.data[j][1] = idx;
                    }
                }
            }
            
            // customizing for zoom (2013-02-20, Roy Choi) start
            if(min != null && max != null && (parseInt(min, 10) > 0 || parseInt(max, 10) < labels.length)) {
            	var newLabels = [];
            	for(i=parseInt(min, 10); i<=parseInt(max, 10); i++) {
            		newLabels.push(labels[i]);
            	}
            	this.ticks = labels = newLabels;
            	numcats = labels.length-1;
            }
            
            // adjust with blanks if we have groups
            if (this.groups > 1 && !this._grouped) {
                var l = labels.length;
                var skip = parseInt(l/this.groups, 10);
                var count = 0;
                for (var i=skip; i<l; i+=skip+1) {
                    labels[i] = ' ';
                }
                this._grouped = true;
            }
        		
        		// customizing
            if(max == null) {
            	max = numcats + 0.5;
            }
            if (this.numberTicks == null) {
                this.numberTicks = 2*numcats + 1;
            }

            var range = max - min;
            this.min = min;
            this.max = max;
            var track = 0;
            
            // todo: adjust this so more ticks displayed.
            var maxVisibleTicks = parseInt(3+dim/10, 10);
            var skip = parseInt(numcats/maxVisibleTicks, 10);

            if (this.tickInterval == null) {

                this.tickInterval = range / (this.numberTicks-1);

            }
            // if tickInterval is specified, we will ignore any computed maximum.
            for (var i=0; i<this.numberTicks; i++){
                tt = this.min + i * this.tickInterval;
                var t = new this.tickRenderer(this.tickOptions);
                // if even tick, it isn't a category, it's a divider
                if (i/2 == parseInt(i/2, 10)) {
                    t.showLabel = false;
                    t.showMark = true;
                }
                else {
                    if (skip>0 && track<skip) {
                        t.showLabel = false;
                        track += 1;
                    }
                    else {
                        t.showLabel = true;
                        track = 0;
                    } 
                    t.label = t.formatter(t.formatString, labels[(i-1)/2]);
                    t.showMark = false;
                    t.showGridline = false;
                }
                t.setTick(tt, this.name);
                this._ticks.push(t);
            }
        }
        
    };
})(jQuery);
/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function($) {
    // called with scope of legend.
    $.jqplot.EnhancedLegendRenderer.prototype.init = function(options) {
        // prop: numberRows
        // Maximum number of rows in the legend.  0 or null for unlimited.
        this.numberRows = null;
        // prop: numberColumns
        // Maximum number of columns in the legend.  0 or null for unlimited.
        this.numberColumns = null;
        // prop: seriesToggle
        // false to not enable series on/off toggling on the legend.
        // true or a fadein/fadeout speed (number of milliseconds or 'fast', 'normal', 'slow') 
        // to enable show/hide of series on click of legend item.
        this.seriesToggle = 'normal';
        // prop: disableIEFading
        // true to toggle series with a show/hide method only and not allow fading in/out.  
        // This is to overcome poor performance of fade in some versions of IE.
        this.disableIEFading = true;
        
        this.showCheckBox = true;
        this.showSwatches = true;
        
        $.extend(true, this, options);

        /*if (this.seriesToggle) {
            $.jqplot.postDrawHooks.push(postDraw);
        }*/
    };

    // customizing Start (2012-05-03, Roy Choi) legend visible
 $.jqplot.EnhancedLegendRenderer.prototype.toggleLegend = function(plot, index) {
		var s = plot.series;
		if(index == undefined) {
			if(s.length > 0) {
				var show = false;
				for(var i=0, len=s.length; i<len; i++) {
					if(!s[i].hide) {
						show = true;
						break;
					}
				}
				
				for(var i=0, len=s.length; i<len; i++) {
					if(show && !s[i].hide) {
						s[i].hide = true;
					} else if(!show && s[i].hide) {
						s[i].hide = false;
					}
				}
				
				plot.series[0].toggleDisplay({data:{plot:plot, series:s}});
				
				/*if(plot.options.multiCanvas) {
					var show = false;
					for(var i=0, len=s.length; i<len; i++) {
						if(!s[i].hide) {
							show = true;
							break;
						}
					}
					
					if(plot.legend.show) {
						plot.legend._elem.find('.jqplot-table-legend-label').each(function(ind){
							if((show && !s[ind].hide) || (!show && s[ind].hide)) {
								$(this).trigger('click');
							}
						});
					} else {
						for(var i=0, len=s.length; i<len; i++) {
							if(show && !s[i].hide) {
								s[i].hide = true;
								s[i].toggleDisplay({data:{series:s[i]}});
							} else if(!show && s[i].hide) {
								s[i].hide = false;
								s[i].toggleDisplay({data:{series:s[i]}});
							}
						}
					}
				} else {
					var show = true;
					var xor = true;
					for(var i=0, len=s.length; i<len; i++) {
						if(i>0 && s[i-1].hide != s[i].hide) xor = false;
						if(!s[i].hide) {
							show = false;
						}
					}
					if(plot.legend.show) {
				        plot.legend._elem.find('.jqplot-table-legend-label').each(function(ind){
							if(show && s[ind].hide) {
								$(this).removeClass('jqplot-series-hidden');
					            $(this).next('.jqplot-table-legend-label').removeClass('jqplot-series-hidden');
					            $(this).prev('.jqplot-table-legend-swatch').removeClass('jqplot-series-hidden');
							} else if(!show && !s[ind].hide) {
								$(this).addClass('jqplot-series-hidden');
								$(this).next('.jqplot-table-legend-label').addClass('jqplot-series-hidden');
					            $(this).prev('.jqplot-table-legend-swatch').addClass('jqplot-series-hidden');
							}
						});
					}

					if(show) {
						for(var i=0, len=s.length; i<len; i++) {
							s[i].hide = false;
						}
						plot.drawSeries();
					} else {
						for(var i=0, len=s.length; i<len; i++) {
							s[i].hide = true;
						}
						var ctx = plot.seriesCanvas._ctx;
						ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
						ctx = null;
					}
				}*/
			}
		} else {
			plot.series[index].hide = true;
			plot.series[index].toggleDisplay({data:{plot:plot, series:plot.series[index]}});
			/*if(plot.legend.show) {
				$(plot.legend._elem.find('.jqplot-table-legend-label').get(index)).trigger('click');
			} else {
				s[index].hide = !s[index].hide;
				s[index].toggleDisplay({data:{plot:plot,index:index,series:s[index]}});			// customizing (2012-05-03, Roy Choi) for one canvas series
			}*/
		}
		s = null;
	};
    
    // called with scope of legend
    $.jqplot.EnhancedLegendRenderer.prototype.draw = function(offsets, plot) {
        var legend = this;
        if (this.show) {
            var series = this._series;
			var s;
            var ss = 'position:absolute;';
            ss += (this.background) ? 'background:'+this.background+';' : '';
            ss += (this.border) ? 'border:'+this.border+';' : '';
            ss += (this.fontSize) ? 'font-size:'+this.fontSize+';' : '';
            ss += (this.fontFamily) ? 'font-family:'+this.fontFamily+';' : '';
            ss += (this.textColor) ? 'color:'+this.textColor+';' : '';
            ss += (this.marginTop != null) ? 'margin-top:'+this.marginTop+';' : '';
            ss += (this.marginBottom != null) ? 'margin-bottom:'+this.marginBottom+';' : '';
            ss += (this.marginLeft != null) ? 'margin-left:'+this.marginLeft+';' : '';
            ss += (this.marginRight != null) ? 'margin-right:'+this.marginRight+';' : '';
						if(this._elem) {
							//this._elem.resizable('destroy');
							this._elem.unbind();
							this._elem.remove();
						}
            this._elem = $('<table class="jqplot-table-legend" style="'+ss+'"></table>');
            /*
            if (this.seriesToggle) {
                            this._elem.css('z-index', '3');
                        }*/
            
        
            var pad = false, 
                reverse = false,
                nr, nc;
            if (this.numberRows) {
                nr = this.numberRows;
                if (!this.numberColumns){
                    nc = Math.ceil(series.length/nr);
                }
                else{
                    nc = this.numberColumns;
                }
            }
            else if (this.numberColumns) {
                nc = this.numberColumns;
                nr = Math.ceil(series.length/this.numberColumns);
            }
            else {
                nr = series.length;
                nc = 1;
            }
                
            var i, j, tr, td1, td2, lt, rs, div, div0, div1, chk;
            var idx = 0;
            // check to see if we need to reverse
            for (i=series.length-1; i>=0; i--) {
                if (nc == 1 && series[i]._stack || series[i].renderer.constructor == $.jqplot.BezierCurveRenderer){
                    reverse = true;
                }
            }    
                
            for (i=0; i<nr; i++) {
                tr = $(document.createElement('tr'));
                tr.addClass('jqplot-table-legend');
                if (reverse){
                    tr.prependTo(this._elem);
                }
                else{
                    tr.appendTo(this._elem);
                }
                for (j=0; j<nc; j++) {
                    if (idx < series.length && series[idx].show && series[idx].showLabel){
						tr.data('seriesIndex', idx);

                        s = series[idx];
                        tr.attr('id', 'jqplot_'+plot.target.attr('id')+'_enhanced_legend_'+s.label); 	//customizing for series visible (2013-03-13, Roy Choi)
                        lt = this.labels[idx] || s.label.toString();
                        if (lt) {
                            var color = s.color;
                            if (!reverse){
                                if (i>0){
                                    pad = true;
                                }
                                else{
                                    pad = false;
                                }
                            }
                            else{
                                if (i == nr -1){
                                    pad = false;
                                }
                                else{
                                    pad = true;
                                }
                            }
                            rs = (pad) ? this.rowSpacing : '0';

                            td1 = $(document.createElement('td'));
                            td1.attr('id', 'jqplot_'+plot.target.attr('id')+'_table_legend_td1_'+s.label);	//customizing for series visible (2013-03-13, Roy Choi)
                            td1.addClass('jqplot-table-legend-header');
                            td1.css({textAlign: 'center', paddingTop: rs});
                            if(s.hide) td1.addClass('jqplot-series-hidden');
                            
                            /* modified by Boram - add checkbox, delete colorbox */
                            if (this.showCheckBox) {
                              /* modified by Boram - add checkbox, delete colorbox */
                              chk = $(document.createElement('input')).attr({type: 'checkbox', checked: true}).addClass('jqplot-table-legend-cbox');
                              td1.append(chk);
                            }

                            if (this.showSwatches) {
                              div0 = $(document.createElement('div'));
                              div0.addClass('jqplot-table-legend-swatch-outline');
                              div0.css({backgroundColor: color, borderColor: color});
                              if(s.hide) div0.addClass('jqplot-series-hidden');                              
                              if (reverse) {
                                  td1.prepend(div0);
                              } else {
                                  td1.append(div0);
                              }
                            }

                            td2 = $(document.createElement('td'));
                            td2.attr('id', 'jqplot_'+plot.target.attr('id')+'_table_legend_td2_'+s.label);	//customizing for series visible (2013-03-13, Roy Choi)
                            td2.addClass('jqplot-table-legend-label');
                            td2.css('paddingTop', rs);
                            //td2.css('color', color);
							if(s.hide) td2.addClass('jqplot-series-hidden');
                    
                            // td1 = $('<td class="jqplot-table-legend" style="text-align:center;padding-top:'+rs+';">'+
                            //     '<div><div class="jqplot-table-legend-swatch" style="background-color:'+color+';border-color:'+color+';"></div>'+
                            //     '</div></td>');
                            // td2 = $('<td class="jqplot-table-legend" style="padding-top:'+rs+';"></td>');
                            if (this.escapeHtml){
                                td2.text(lt);
                                td2.attr('title', lt);
                            }
                            else {
                                td2.html(lt);
                                td2.attr('title', lt.replace(/(<([^>]+)>)/ig,""));
                            }
                            if (reverse) {
                                if (this.showLabels) {td2.prependTo(tr);}
                                if (this.showSwatches) {td1.prependTo(tr);}
                            }
                            else {
                                if (this.showSwatches) {td1.appendTo(tr);}
                                if (this.showLabels) {td2.appendTo(tr);}
                            }
                            
                            if (this.seriesToggle) {

                                // add an overlay for clicking series on/off
                                // div0 = $(document.createElement('div'));
                                // div0.addClass('jqplot-table-legend-overlay');
                                // div0.css({position:'relative', left:0, top:0, height:'100%', width:'100%'});
                                // tr.append(div0);

                                var speed;
                                if (typeof(this.seriesToggle) == 'string' || typeof(this.seriesToggle) == 'number') {
                                    if (!$.jqplot.use_excanvas || !this.disableIEFading) {
                                        speed = this.seriesToggle;
                                    }
                                } 
                                if (this.showCheckBox || this.showSwatches) {
    	                        	chk.bind('change', {plot:plot, index:idx, series:s, speed:speed}, handleToggle);	// customizing (2012-05-03, Roy Choi) for one canvas series
    	                        	chk.addClass('jqplot-seriesToggle');
    	                        }
                                /*if (this.showSwatches) {
                                    td1.bind('click', {plot:plot, index:idx, series:s, speed:speed}, handleToggle);	// customizing (2012-05-03, Roy Choi) for one canvas series
                                    td1.addClass('jqplot-seriesToggle');
                                }*/
                                if (this.showLabels)  {
                                    td2.bind('click', {plot:plot, index:idx, series:s, speed:speed}, handleToggle);	// customizing (2012-05-03, Roy Choi) for one canvas series
                                    td2.addClass('jqplot-seriesToggle');
                                }
                            }
                            
                            pad = true;
                        }
                    }
                    idx++;
                }
                
                //td1 = td2 = div0 = div1 = null;   
                td1 = td2 = chk = null;   
            }
			// customizing Start (2012-05-03, Roy Choi) legend location
			var wrap = $('<div></div>');
			wrap.addClass('jqplot-table-legend-wrap');
			var elem = this._elem.detach();
			wrap.append(elem);
			elem = null;
			
			var chartHeight = plot.target.height(), chartWidth = plot.target.width();
			var maxHeight = chartHeight * .8, maxWidth = chartWidth * .8;

			switch(this.location.charAt(this.location.length-1)) {
				case 'n':
					wrap.addClass('jqplot-table-legend-wrap-top');
					if ($.isNumeric(this._height) && this._height > 0) {
					    wrap.height(this._height < maxHeight ? this._height : maxHeight);
					} else {
					    wrap.height(50);
					}
					break;
				case 's':
					wrap.addClass('jqplot-table-legend-wrap-bottom');
					if ($.isNumeric(this._height) && this._height > 0) {
                        wrap.height(this._height < maxHeight ? this._height : maxHeight);
                    } else {
                        wrap.height(50);
                    }
					break;
				case 'w':
					wrap.addClass('jqplot-table-legend-wrap-left');
					wrap.height(plot.baseCanvas._elem.height()-plot._defaultGridPadding.top-plot._defaultGridPadding.bottom-2);
					if ($.isNumeric(this._width) && this._width > 0) {
                        wrap.width(this._width < maxWidth ? this._width : maxWidth);
                    } else {
                        wrap.width(100);
                    }
					wrap.offset({top: plot._defaultGridPadding.top});
					break;
				case 'e':
					wrap.addClass('jqplot-table-legend-wrap-right');
					wrap.height(plot.baseCanvas._elem.height()-plot._defaultGridPadding.top-plot._defaultGridPadding.bottom-2);
					if ($.isNumeric(this._width) && this._width > 0) {
                        wrap.width(this._width < maxWidth ? this._width : maxWidth);
                    } else {
                        wrap.width(100);
                    }
					wrap.offset({top: plot._defaultGridPadding.top});
					break;
			}
			
			//elem = resize_elem = null;

			if(this.width > 0) {
				wrap.width(this.width);
				this.width = 0;
			}
			if(this.height > 0) {
				wrap.height(this.height);
				this.height = 0;
			}

			this._elem = wrap;
			plot.baseCanvas._elem.after(this._elem);
			
			var offset = this._elem.offset();
			offset.left = Math.floor(offset.left);
			this._elem.offset(offset);
			offset = null;
			
			this._elem.bind('click', function(ev) {
				if(ev.target.type != 'checkbox') {
					plot.restorePreviousSeriesOrder();
		    	}
			});

			// customizing End (2012-05-03, Roy Choi) legend location
        }


        return this._elem;
    };
    
    $.jqplot.EnhancedLegendRenderer.prototype.addSeries = function(plot, series) {
        var pad = false, 
        reverse = false,
        nr, nc;
        
        if (this.show) {
        	if (typeof this._elem === 'undefined') {
        		var series = this._series;
    			var s;
                var ss = 'position:absolute;';
                ss += (this.background) ? 'background:'+this.background+';' : '';
                ss += (this.border) ? 'border:'+this.border+';' : '';
                ss += (this.fontSize) ? 'font-size:'+this.fontSize+';' : '';
                ss += (this.fontFamily) ? 'font-family:'+this.fontFamily+';' : '';
                ss += (this.textColor) ? 'color:'+this.textColor+';' : '';
                ss += (this.marginTop != null) ? 'margin-top:'+this.marginTop+';' : '';
                ss += (this.marginBottom != null) ? 'margin-bottom:'+this.marginBottom+';' : '';
                ss += (this.marginLeft != null) ? 'margin-left:'+this.marginLeft+';' : '';
                ss += (this.marginRight != null) ? 'margin-right:'+this.marginRight+';' : '';
    			if(this._elem) {
    				//this._elem.resizable('destroy');
    				this._elem.unbind();
    				this._elem.remove();
    			}
                this._elem = $('<table class="jqplot-table-legend" style="'+ss+'"></table>');
                /*
                if (this.seriesToggle) {
                                    this._elem.css('z-index', '3');
                                }*/
                
    	    }
        	
        	if (this.numberRows) {
    	        nr = this.numberRows;
    	        if (!this.numberColumns){
    	            nc = Math.ceil(series.length/nr);
    	        }
    	        else{
    	            nc = this.numberColumns;
    	        }
    	    }
    	    else if (this.numberColumns) {
    	        nc = this.numberColumns;
    	        nr = Math.ceil(series.length/this.numberColumns);
    	    }
    	    else {
    	        nr = series.length;
    	        nc = 1;
    	    }
    	        
    	    var i, j, tr, td1, td2, lt, rs, div, div0, div1;
    	    var idx = 0;
    	    // check to see if we need to reverse
    /*	    for (i=series.length-1; i>=0; i--) {
    	        if (nc == 1 && series[i]._stack || series[i].renderer.constructor == $.jqplot.BezierCurveRenderer){
    	            reverse = true;
    	        }
    	    }*/
    	    
    	    
    	    
    	    var elem = $('table',this._elem);
    	    for (i=0; i<nr; i++) {
    	        tr = $(document.createElement('tr'));
    	        tr.addClass('jqplot-table-legend');
    	        if (reverse){
    	            tr.prependTo(elem);
    	        }
    	        else{
    	            tr.appendTo(elem);
    	        }
    	        for (j=0; j<nc; j++) {
    	            if (idx < series.length && series[idx].show && series[idx].showLabel){
						tr.data('seriesIndex', idx);
						
    	                s = series[idx];
    	                lt = this.labels[idx] || s.label.toString();
    	                if (lt) {
    	                    var color = s.color;
    	                    if (!reverse){
    	                        if (i>0){
    	                            pad = true;
    	                        }
    	                        else{
    	                            pad = false;
    	                        }
    	                    }
    	                    else{
    	                        if (i == nr -1){
    	                            pad = false;
    	                        }
    	                        else{
    	                            pad = true;
    	                        }
    	                    }
    	                    rs = (pad) ? this.rowSpacing : '0';
    	
                            td1 = $(document.createElement('td'));
                            td1.attr('id', 'jqplot_'+plot.target.attr('id')+'_table_legend_td1_'+s.label);	//customizing for series visible (2013-03-13, Roy Choi)
                            td1.addClass('jqplot-table-legend-header');
                            td1.css({textAlign: 'center', paddingTop: rs});
                            if(s.hide) td1.addClass('jqplot-series-hidden');
                            
                            if (this.showCheckBox) {
                              /* modified by Boram - add checkbox, delete colorbox */
                              chk = $(document.createElement('input')).attr({type: 'checkbox', checked: true}).addClass('jqplot-table-legend-cbox');
                              td1.append(chk);
                            }

                            if (this.showSwatches) {
                              div0 = $(document.createElement('div'));
                              div0.addClass('jqplot-table-legend-swatch-outline');
                              div0.css({backgroundColor: color, borderColor: color});
                              if(s.hide) div0.addClass('jqplot-series-hidden');                              
                              if (reverse) {
                                  td1.prepend(div0);
                              } else {
                                  td1.append(div0);
                              }
                            }

                            td2 = $(document.createElement('td'));
                            td2.attr('id', 'jqplot_'+plot.target.attr('id')+'_table_legend_td2_'+s.label);	//customizing for series visible (2013-03-13, Roy Choi)
                            td2.addClass('jqplot-table-legend jqplot-table-legend-label');
                            td2.css('paddingTop', rs);
                            //td2.css('color', color);
    						if(s.hide) td2.addClass('jqplot-series-hidden');
                    
                            // td1 = $('<td class="jqplot-table-legend" style="text-align:center;padding-top:'+rs+';">'+
                            //     '<div><div class="jqplot-table-legend-swatch" style="background-color:'+color+';border-color:'+color+';"></div>'+
                            //     '</div></td>');
                            // td2 = $('<td class="jqplot-table-legend" style="padding-top:'+rs+';"></td>');
    						if (this.escapeHtml){
                                td2.text(lt);
                                td2.attr('title', lt);
                            }
                            else {
                                td2.html(lt);
                                td2.attr('title', lt.replace(/(<([^>]+)>)/ig,""));
                            }
    	                    if (reverse) {
    	                        if (this.showLabels) {td2.prependTo(tr);}
    	                        if (this.showCheckBox || this.showSwatches) {td1.prependTo(tr);}
    	                    }
    	                    else {
    	                        if (this.showCheckBox || this.showSwatches) {td1.appendTo(tr);}
    	                        if (this.showLabels) {td2.appendTo(tr);}
    	                    }
    	                    
    	                    if (this.seriesToggle) {
    	
    	                        // add an overlay for clicking series on/off
    	                        // div0 = $(document.createElement('div'));
    	                        // div0.addClass('jqplot-table-legend-overlay');
    	                        // div0.css({position:'relative', left:0, top:0, height:'100%', width:'100%'});
    	                        // tr.append(div0);
    	
    	                        var speed;
    	                        if (typeof(this.seriesToggle) == 'string' || typeof(this.seriesToggle) == 'number') {
    	                            if (!$.jqplot.use_excanvas || !this.disableIEFading) {
    	                                speed = this.seriesToggle;
    	                            }
    	                        } 
    	                        if (this.showSwatches) {
    	                        	chk.bind('change', {plot:plot, index:idx, series:s, speed:speed}, handleToggle);	// customizing (2012-05-03, Roy Choi) for one canvas series
    	                        	chk.addClass('jqplot-seriesToggle');
    	                        }
    	                        /*if (this.showSwatches) {
    	                            td1.bind('click', {plot:plot, index:idx, series:s, speed:speed}, handleToggle);	// customizing (2012-05-03, Roy Choi) for one canvas series
    	                            td1.addClass('jqplot-seriesToggle');
    	                        }*/
    	                        if (this.showLabels)  {
    	                            td2.bind('click', {plot:plot, index:idx, series:s, speed:speed}, handleToggle);	// customizing (2012-05-03, Roy Choi) for one canvas series
    	                            td2.addClass('jqplot-seriesToggle');
    	                        }
    	                    }
    	                    
    	                    pad = true;
    	                }
    	            }
    	            idx++;
    	        }
    	        
    	        td1 = td2 = div0 = div1 = null;   
    	    }
        }
    };
    
    // customizing (2014-06-03, Roy)
    $.jqplot.EnhancedLegendRenderer.prototype.pack = function(offsets) {
    	return;
    };

    /* modified by Boram - checkbox click:series show/hide, label click:series highlighted/unhighlighted */
    var handleToggle = function (ev) {
    	/* init legend label style */
    	ev.preventDefault();
        ev.stopImmediatePropagation();
        
        var plot = ev.data.plot;
        var series = ev.data.series;
        
        if(ev.target.type == "checkbox"){
        	if (!ev.target.checked) {
        		if(series.highlighted) {
        			plot.moveSeriesToBack(series.index);
        			if(plot.plugins.highlighter && plot.plugins.highlighter.show) {
        					plot.plugins.highlighter.isClickHighlighting = false;
        			}
        		}
    			series.hide = true;
    			$('td[id="jqplot_'+plot.target.attr('id')+'_table_legend_td2_'+series.label+'"]', plot.legend._elem).addClass('jqplot-series-hidden');
                //$(this).parent().parent().addClass('jqplot-series-hidden');                
                //$(this).prev('.jqplot-table-legend-swatch').addClass('jqplot-series-hidden');
            }
            else {
                series.hide = false;
                $('td[id="jqplot_'+plot.target.attr('id')+'_table_legend_td2_'+series.label+'"]', plot.legend._elem).removeClass('jqplot-series-hidden');
    			//$(this).parent().parent().removeClass('jqplot-series-hidden');                
                //$(this).parent().prev('.jqplot-table-legend-swatch').removeClass('jqplot-series-hidden');
            }
        	plot.target.unbind('jqPlot.seriesVisibleChange', handleVisible);
        	series.toggleDisplay(ev);
        	plot.target.bind('jqPlot.seriesVisibleChange', handleVisible);
        	/*plot.target.trigger('jqPlot.seriesVisibleChange', [plot]);*/
        }
        else{
        	$('.jqplot-table-legend-highlighted', plot).each(function(ind){
    			$(this).removeClass('jqplot-table-legend-highlighted');
    		});
        	if (!series.hide){
        		if (plot.options.multicanvas) {
        			plot.restorePreviousSeriesOrder();
        		}
        		plot.moveSeriesToFront(series.index);
            }
            var evt = $.Event('jqPlot.legendClick', {originalEvent: ev, data: ev.data, pageX: ev.pageX, pageY: ev.pageY, target: ev.target});
            plot.target.trigger(evt, [series.index, series, plot]);
        }
        
        plot = series = null;
    };
    
    // called with scope of plot.
    var postDraw = function () {
        if (this.legend.renderer.constructor == $.jqplot.EnhancedLegendRenderer && this.legend.seriesToggle && this.legend.show){
        	this.legend._elem.show();
        } else if(this.legend._elem) {		// customizing End (2012-05-03, Roy Choi) legend visible
					this.legend._elem.hide();
				}
		
				for(var i=0; i < this.series.length; i++) {
					var s = this.series[i];
					var r = this.legend.renderer;
					if(s.hide) {
						s.toggleDisplay({data:{plot:this,series:s}});
					}
				}
				
				this.target.unbind('jqPlot.SeriesToFront', handleFocus);
				this.target.unbind('jqPlot.SeriesToBack', handleUnFocus);
				this.target.unbind('jqPlot.PreviousSeriesOrder', handleRemoveFocus);
				this.target.unbind('jqPlot.OriginalSeriesOrder', handleRemoveFocus);
				this.target.unbind('jqPlot.seriesVisibleChange', handleVisible);
				
				this.target.bind('jqPlot.SeriesToFront', handleFocus);
				this.target.bind('jqPlot.SeriesToBack', handleUnFocus);
				this.target.bind('jqPlot.PreviousSeriesOrder', handleRemoveFocus);
				this.target.bind('jqPlot.OriginalSeriesOrder', handleRemoveFocus);
				this.target.bind('jqPlot.seriesVisibleChange', handleVisible);
    };
    
    var handleFocus = function(ev, idx, plot) {
        if (plot.legend.show) {
            plot.legend._elem.find('tr.jqplot-table-legend-highlighted').each(function(ind){
				var seriesIndex = $(this).data('seriesIndex');
				if (!plot.series[seriesIndex].highlighted) {
					$(this).removeClass('jqplot-table-legend-highlighted');
				}
            });
            var trs = plot.legend._elem.find('tr.jqplot-table-legend');
            
            if(plot.options.stackSeries) {
                idx = plot.series.length -1 - idx;
            }
            
            if (idx >= 0 && trs.length > idx) {
                $(plot.legend._elem.find('tr.jqplot-table-legend').get(idx)).addClass('jqplot-table-legend-highlighted');
            }
        }
    };

	var handleUnFocus = function(ev, idx, plot) {
        if (plot.legend.show) {
            plot.legend._elem.find('tr.jqplot-table-legend-highlighted').each(function(ind){
				var seriesIndex = $(this).data('seriesIndex');
				if (!plot.series[seriesIndex].highlighted) {
					$(this).removeClass('jqplot-table-legend-highlighted');
				}
            });
        }
    };
    
    var handleRemoveFocus = function(ev, plot) {
    	$('.jqplot-table-legend-highlighted', plot.target).each(function(ind){
			$(this).removeClass('jqplot-table-legend-highlighted');
		});
    };
    
    var handleVisible = function(ev, plot, series) {
    	if ($.isArray(series)) {
    		var s = plot.series;
    		for(var i=0, len=s.length; i<len; i++) {
    			var cbox = $('.jqplot-table-legend-cbox', 'td[id="jqplot_'+plot.target.attr('id')+'_table_legend_td1_'+s[i].label+'"]', plot.legend._elem);
    			var td2 = $('td[id="jqplot_'+plot.target.attr('id')+'_table_legend_td2_'+s[i].label+'"]', plot.legend._elem);
    			
    			if (s[i].hide) {
    				if (cbox.length > 0) {
    					cbox.get(0).checked = false;
    				}
    				td2.addClass('jqplot-series-hidden');
    			} else {
    				if (cbox.length > 0) {
    					cbox.get(0).checked = true;
    				}
    				td2.removeClass('jqplot-series-hidden');
    			}
    			
    			cbox = td2 = null;
    		}
    	} else {
    		var cbox = $('.jqplot-table-legend-cbox', 'td[id="jqplot_'+plot.target.attr('id')+'_table_legend_td1_'+series.label+'"]', plot.legend._elem);
			var td2 = $('td[id="jqplot_'+plot.target.attr('id')+'_table_legend_td2_'+series.label+'"]', plot.legend._elem);
			
			if (series.hide) {
				if (cbox.length > 0) {
					cbox.get(0).checked = false;
				}
				td2.addClass('jqplot-series-hidden');
			} else {
				if (cbox.length > 0) {
					cbox.get(0).checked = true;
				}
				td2.removeClass('jqplot-series-hidden');
			}
			
			cbox = td2 = null;
    	}
    };
    
	$.jqplot.postDrawHooks.push(postDraw);
})(jQuery);
/**
 jqPlot Group View Plugin
 2012-05-10, Roy Choi
 */
(function($) {
	/**
	 * Class: $.jqplot.GroupPlot
	 * Plugin which will show by group plot.
	 */
	$.jqplot.GroupPlot = function(options) {
		// Group: Properties
		//
		//prop: enable
		// true to enable the Show By Group.
		this.enable = $.jqplot.config.enablePlugins;
		// prop: showByGroup
		// true to show by group plot
		this.show = false;
		// prop: parent
		// parent plot.
		this.parent = null;
		// prop: groupid
		// if this plot is child then plot groupid.
		this.groupid = null;
		// prop: listStyle
		// horizontal, vertical, matrix.
		this.listStyle = 'horizontal';
		// prop: matrixOption
		// If listStyle is 'matrix'.
		this.matrixOption = [1, 1];
		// prop: groupZoom
		// sync zoom all plot.
		this.groupZoom = false;
		// prop: syncXAxis
		// sync x axis all plot
		this.syncXAxis = false;
		this.syncAxis = false;
		
		this.showAllAxis = false;
		
		this.sizeRate = [];

		//this.plotOptions = {};

		this.ischild = false;
		this.plots = [];
		this.container = null;
		this.groupContainer = null;

		$.extend(true, this, options);
	};

	// axis.renderer.tickrenderer.formatter

	// called with scope of plot
	$.jqplot.GroupPlot.init = function(target, data, opts) {
		var options = opts || {};

		// add a highlighter attribute to the plot
		this.plugins.groupplot = new $.jqplot.GroupPlot(options.groupplot);

		this.plugins.groupplot.container = $('#' + target).parent();

		//this.plugins.groupplot.plotOptions = options;

	};

	// called within context of plot
	// create a canvas which we can draw on.
	// insert it before the eventCanvas, so eventCanvas will still capture events.
	$.jqplot.GroupPlot.postPlotDraw = function() {
		// Memory Leaks patch
		if (this.plugins.groupplot.show)
			this.plugins.groupplot.showByGroup(this);
	};

	$.jqplot.preInitHooks.push($.jqplot.GroupPlot.init);
	$.jqplot.postDrawHooks.push($.jqplot.GroupPlot.postPlotDraw);

	$.jqplot.GroupPlot.prototype.showByGroup = function(plot, opts) {
		var options = opts || {};
		var gp = plot.plugins.groupplot;

		if (gp.enable && gp.show && !gp.ischild) {

			/*if(gp.groupContainer) {
			 gp.clearGroupPlot(plot);
			 gp.groupContainer.remove();
			 }*/
			gp.container.children('.jqplot-group-container').remove();

			var elem = document.createElement('ul');
			$(elem).css({
				width : '100%',
				height : '100%',
				overflowY : 'auto',
				overflowX : 'hidden'
			}).addClass('jqplot-group-container');

			$(elem).appendTo(gp.container);

			gp.groupContainer = $(elem);
			elem = null;

			//gp.groupContainer.show();

			//   series copy.
			var groupSeriesList = [];
			var groupDataList = [];
			var groupCount = 0;
			var gid;
			var series = plot.series;
			var so;
			for (var i = 0, slen = series.length; i < slen; i++) {
				var si = series[i];
				gid = si.group;
				if (!$.isArray(groupSeriesList[gid])) {
					groupCount++;
					groupSeriesList[gid] = [];
					groupDataList[gid] = [];
				}
				if ($.isArray(plot.options.series) &&  plot.options.series[i]) {
					so = plot.options.series[i];
				} else {
					so = {
						label : si.label,
						group : si.group,
						color : si.color
					};
				}

				groupDataList[gid].push(si.data);
				groupSeriesList[gid].push(so);
				si = so = null;
			}
			//grouCount = groupSeriesList.length;
			series = null;

			// Group  
			plot.target.empty();
			plot.target.append(gp.groupContainer);

			// Group Style       .
			var plotWidth = plot.target.innerWidth()-10;
			var plotHeight = plot.target.innerHeight()-10;
			var gwidth, gheight;
			switch(gp.listStyle) {
				case 'vertical':
					gwidth = plotWidth / groupCount;
					gheight = plotHeight;
					break;
				case 'horizontal':
					gwidth = plotWidth;
					gheight = plotHeight / groupCount;
					break;
				case 'matrix':
					gwidth = plotWidth / gp.matrixOption[0];
					gheight = plotHeight / gp.matrixOption[1] - 1;
					break;
			}

			var xaxis = plot.axes.xaxis;
			for (var i = 0; i < groupCount; i++) {
				// Group    .
				var gdata = groupDataList.shift();
				var gseries = groupSeriesList.shift();
				var gid = gseries[0].group;
				var opts = $.extend(true, {}, plot.options, options);
				if (gp.syncAxis) {
					for (var axis in plot.axes) {
						opts.axes[axis].min = plot.axes[axis].min;
						opts.axes[axis].max = plot.axes[axis].max;
					}
				} else {
					for (var axis in opts.axes) {
						delete opts.axes[axis].min;
						delete opts.axes[axis].max;
					}
				}

				if (!gp.showAllAxis) {
					switch(gp.listStyle) {
						case 'vertical':
							if (i > 0) {
								opts.axes.yaxis.show = true;
								opts.axes.yaxis.showLabel = false;
								opts.axes.yaxis.showTicks = false;
							}
							break;
						case 'horizontal':
							if (groupCount - 1 > i) {
								opts.axes.xaxis.show = true;
								opts.axes.xaxis.showLabel = false;
								opts.axes.xaxis.showTicks = false;
							}
							break;
					}
				}
				
				opts.series = gseries;
				opts.groupplot = {
					groupid : gid,
					show : false,
					parent : plot,
					ischild : true
				};
				var gli = document.createElement('li');
				var gchart_id = plot.target.attr('id') + '-group-' + gid;

				$(gli).css({
					display : 'inline-block',
					listStyle : 'none',
					margin : 0,
					padding : 0,
					width : (gp.listStyle === 'vertical' && !isNaN(gp.sizeRate[i]) ? plotWidth * gp.sizeRate[i] : gwidth) + 'px',
					height : (gp.listStyle === 'horizontal' && !isNaN(gp.sizeRate[i]) ? plotWidth * gp.sizeRate[i] : gheight) + 'px'
				}).appendTo(gp.groupContainer);

				var gchart = document.createElement('div');

				$(gchart).attr('id', gchart_id).css({
					width : '100%',
					height : '100%',
					margin : 0,
					padding : 0
				}).appendTo(gli);
				// Group  .
				
				var isDefinedXaxis = false;
				opts.series.forEach(function(s, ind) {
					if (s.xaxis === 'xaxis') {
						isDefinedXaxis = true;
						return false;
					}
				});
				
				if (!isDefinedXaxis) {
					opts.series.push({
						xaxis: 'xaxis',
						show: false
					});
					
					if (gdata.length > 0 && gdata[0].length > 0) {
						gdata = $.merge(gdata, gdata[0][0]);
					}
				}
				
				
				var gplot = $.jqplot(gchart_id, gdata, opts);
				gp.plots[gid] = gplot;

			}

		}
	};

	$.jqplot.GroupPlot.prototype.clearGroupPlot = function(plot) {
		var gp = plot.plugins.groupplot;

		$.each(gp.plots, function(gid, gplot) {
			gplot.destroy(true);
			delete gplot;
		});
		gp.plots = [];

		gp.groupContainer.empty();
		gp.groupContainer.html('');
	};

	$.jqplot.GroupPlot.prototype.restorePlot = function(plot) {
		var gp = plot.plugins.groupplot;
		gp.show = false;
		gp.clearGroupPlot(plot);
		plot.target.show();
		plot.replot({
			resetAxes : true
		});
	};

	$.jqplot.GroupPlot.prototype.setGroupZoom = function(plot, flag) {
		var gp = plot.plugins.groupplot;

		if (flag) {
			resetGroupChildZoom(plot);
		}

		gp.groupZoom = flag;
	};

	$.jqplot.GroupPlot.prototype.setSyncXAxis = function(plot, flag) {
		var gp = plot.plugins.groupplot;
		var min, max;
		var xaxis = null;

		if (flag) {
			//resetGroupChildZoom(plot);

			xaxis = plot.axes.xaxis;
			$.each(gp.plots, function(gid, gplot) {
				var xa = gplot.options.axes.xaxis;
				xa.min = xaxis.min;
				xa.max = xaxis.max;
				//gplot.replot({resetAxes:true,axes:{xaxis:xa}});
			});
		} else {
			$.each(gp.plots, function(gid, gplot) {
				var xa = gplot.options.axes.xaxis;
				delete xa.min;
				delete xa.max;
				//gplot.replot({resetAxes:true,axes:{xaxis:xa}});
			});
		}

		gp.syncXAxis = flag;
	};

	function resetGroupChildZoom(plot) {
		var gp = plot.plugins.groupplot;
		var tmp = gp.groupZoom;
		gp.groupZoom = false;

		var gplots = plot.plugins.groupplot.plots;
		$.each(gplots, function(gid, gplot) {
			gplot.resetZoom();
		});
		gp.groupZoom = tmp;
	}

	function clearGroupPlot(plot) {
		$.jqplot.GroupPlot.clearGroupPlot(plot);
	}

	function restorePlot(plot) {
		$.jqplot.GroupPlot.restorePlot(plot);
	}

	function showByGroup(plot) {
		$.jqplot.GroupPlot.showByGroup(plot);
	}

})(jQuery); 
(function($) { 
  /** 
   * Class: $.jqplot.BoxplotRenderer 
   * jqPlot Plugin to draw box plots <http://en.wikipedia.org/wiki/Box_plot>. 
   *  
   * To use this plugin, include the renderer js file in  
   * your source: 
   *  
   * > <script type="text/javascript" src="plugins/jqplot.boxplotRenderer.js"></script> 
    *  
    * Then you set the renderer in the series options on your plot: 
    *  
    * > series: [{renderer:$.jqplot.BoxplotRenderer}] 
    *  
    * Data should be specified like so: 
    *  
    * > dat = [[sample_id, min, q1, median, q3, max], ...] 
    *  
    */ 
   $.jqplot.BoxplotRenderer = function(){ 
       // subclass line renderer to make use of some of its methods. 
       $.jqplot.LineRenderer.call(this); 
       // prop: boxWidth 
       // Default will auto calculate based on plot width and number 
       // of boxes displayed. 
       this.boxWidth = 'auto'; 
       this._boxMaxWidth = 100; // if 'auto', cap at this max 
       // prop: lineWidth 
       // The thickness of all lines drawn. Default is 1.5 pixels. 
       this.lineWidth = 1.5;
       
       this.colorFilter = null;
   }; 
    
   $.jqplot.BoxplotRenderer.prototype = new $.jqplot.LineRenderer(); 
   $.jqplot.BoxplotRenderer.prototype.constructor = $.jqplot.BoxplotRenderer; 
    
   // called with scope of series. 
   $.jqplot.BoxplotRenderer.prototype.init = function(options) { 
       this.lineWidth = options.lineWidth || this.renderer.lineWidth;
       this.colorFilter = options.colorFilter; 
       $.jqplot.LineRenderer.prototype.init.call(this, options); 
   }; 
    
   // called within scope of series. 
   $.jqplot.BoxplotRenderer.prototype.draw = function(ctx, gd, options) { 
       var d = this.data; 
       var r = this.renderer; 
       var xp = this._xaxis.series_u2p; 
       var yp = this._yaxis.series_u2p; 
       var strokeStyle = options.strokeStyle || '#888888';
       var seriesColorArr = $.jqplot.getColorComponents(this.color);
       var boxColor = $.jqplot.sprintf('rgba(%s,%s,%s,.3)', seriesColorArr[0], seriesColorArr[1], seriesColorArr[2]);
       var medianColor = $.jqplot.sprintf('rgba(%s,%s,%s,.5)', seriesColorArr[0], seriesColorArr[1], seriesColorArr[2]);
       if (!options) 
           options = {}; 
       if (!('lineWidth' in options)) 
           $.extend(true, options, {lineWidth: this.lineWidth}); 
       
       var opts = $.extend(true, {}, options, {strokeStyle: strokeStyle});
       var fillBoxopts = $.extend(true, {}, opts, {fillRect: true, fillStyle: boxColor}); 
       var strokeBoxopts = $.extend(true, {}, opts, {strokeRect: true, strokeStyle: strokeStyle});
       var boxW = opts.boxWidth || r.boxWidth; 
       if (boxW == 'auto') 
           boxW = Math.min(r._boxMaxWidth, 0.6 * ctx.canvas.width/d.length); 
       var endW = boxW / 2; // min and max ticks are half the box width 
       
       var newColor, newSeriesColorArr, newMedianColor, newFillBoxopts;
       
       boxW -= this.lineWidth*2; 
       ctx.save(); 
       if (this.show) {
       	this._boxPoints = [];
           for (var i=0, di=d[i]; i<d.length; di=d[++i]) { 
              var  x = xp(di[0]), 
                 min = yp(di[1]), 
                  q1 = yp(di[2]), 
                 med = yp(di[3]), 
                  q3 = yp(di[4]), 
                 max = yp(di[5]); 

              var endL = x - endW/2; // start (left) x coord of min/max ticks 
              var endR = x + endW/2; // end (right) x coord of min/max ticks 
              var medL = x - boxW/2; // start (left) x coord of median tick 
              var medR = x + boxW/2; // end (right) x coord of median tick 
              
              // draw box 
              boxH = q1 - q3; 
              boxpoints = [medL, q3, boxW, boxH]; 
              this._boxPoints.push([[medL, q3], [medR, q3], [medR, q1], [medL, q1]]);
              
              if ($.isFunction(this.colorFilter)) {
              	newColor = this.colorFilter.call(this, di, i);
              	if (newColor) {
              		newSeriesColorArr = $.jqplot.getColorComponents(newColor);
              		newFillBoxopts = $.extend(true, {}, fillBoxopts, {fillStyle: $.jqplot.sprintf('rgba(%s,%s,%s,.3)', newSeriesColorArr[0], newSeriesColorArr[1], newSeriesColorArr[2])});
              		newMedianColor = $.jqplot.sprintf('rgba(%s,%s,%s,.5)', newSeriesColorArr[0], newSeriesColorArr[1], newSeriesColorArr[2]);
              	} else {
              		newFillBoxopts = fillBoxopts;
              		newMedianColor = medianColor;
              	}
              } else {
            		newFillBoxopts = fillBoxopts;
            		newMedianColor = medianColor;
              }
              
              r.shapeRenderer.draw(ctx, boxpoints, newFillBoxopts); 
              r.shapeRenderer.draw(ctx, boxpoints, strokeBoxopts); 

              // draw whiskers 
              r.shapeRenderer.draw(ctx, [[x, min], [x, q1]], opts);  
              r.shapeRenderer.draw(ctx, [[x, q3], [x, max]], opts);  

              // draw min and max ticks 
              r.shapeRenderer.draw(ctx, [[endL, min], [endR, min]], opts); 
              r.shapeRenderer.draw(ctx, [[endL, max], [endR, max]], opts); 
              // median tick is full box width 
              r.shapeRenderer.draw(ctx, [[medL, med], [medR, med]], $.extend(true, {}, opts, {strokeStyle: newMedianColor})); 
           } 
       } 
       ctx.restore(); 
   };   
     
    $.jqplot.BoxplotRenderer.prototype.drawShadow = function(ctx, gd, options) { 
        // This is a no-op, shadows drawn with lines. 
    }; 
     
    // called with scope of plot. 
    $.jqplot.BoxplotRenderer.checkOptions = function(target, data, options, plot) { 
        // provide some sensible highlighter options by default 
        hldefaults = { 
            showMarker: false, 
            tooltipAxes: 'y', 
            yvalues: 5, 
            formatString: '<table class="jqplot-highlighter">' + 
            							'<tr><td>index:</td><td>%s</td></tr>' + 
                          '<tr><td>min:</td><td>%s</td></tr>' + 
                          '<tr><td>q1:</td><td>%s</td></tr>' + 
                          '<tr><td>med:</td><td>%s</td></tr>' + 
                          '<tr><td>q3:</td><td>%s</td></tr>' + 
                          '<tr><td>max:</td><td>%s</td></tr>' + 
                          '</table>' 
            }; 
        if (!options.highlighter) 
            options.highlighter = {show: true}; 
        if (options.highlighter.show) {
        	if ($.isArray(options.series)) {
        		var s;
        		for (var i=0; i<this.series.length; i++) {
        			s = this.series[i];
        			if (s.renderer.constructor === $.jqplot.BoxplotRenderer)
        				s.highlighter = $.extend(true, {}, s.highlighter || {}, hldefaults);
        		}
        	}
        } 
    }; 
     
    $.jqplot.postInitHooks.push($.jqplot.BoxplotRenderer.checkOptions); 
     
})(jQuery); 
/**
 jqPlot Big Data Scatter Renderer Plugin
 2013-04-17, Roy Choi
 */
(function($) {
	'use strict';

	// Class: $.jqplot.BigDataScatterRenderer
	// The default line renderer for jqPlot, this class has no options beyond the <Series> class.
	// Draws series as a line.
	$.jqplot.BigDataScatterRenderer = function() {
	};

	// called with scope of series.
	$.jqplot.BigDataScatterRenderer.prototype.init = function(options, plot) {
		// Group: Properties
		//
		options = options || {};
		this._type = 'scatter';
		this.renderer.lineWidth = 1;
		this.renderer.fastMode = options.fastMode || false;

		options.stroke = options.stroke || false;
		delete (options.highlightMouseOver);
		delete (options.highlightMouseDown);
		delete (options.highlightColor);

		$.extend(true, this.renderer, options);

		this.renderer.options = options;

		//this._imgPlotData = null;

		if (!this.isTrendline && plot) {
			plot.plugins.lineRenderer = {};
		}

	};

	$.jqplot.BigDataScatterRenderer.prototype.initBands = function(options, plot) {
	};

	// setGridData
	// converts the user data values to grid coordinates and stores them
	// in the gridData array.
	// Called with scope of a series.
	$.jqplot.BigDataScatterRenderer.prototype.setGridData = function(plot) {
	    this.gridData = [];
		return;
		// recalculate the grid data
		/*var xp = this._xaxis.series_u2p;
		 var yp = this._yaxis.series_u2p;
		 var data = this._plotData;
		 var pdata = this._prevPlotData;
		 this.gridData = [];

		 if (!xp) {
		 return;
		 }

		 for (var i=0, l=this.data.length; i < l; i++) {
		 // if not a line series or if no nulls in data, push the converted point onto the array.
		 this.gridData.push([Math.round(xp.call(this._xaxis, data[i][0])), Math.round(yp.call(this._yaxis, data[i][1]))]);
		 }

		 data = pdata = null;*/
	};

	// makeGridData
	// converts any arbitrary data values to grid coordinates and
	// returns them.  This method exists so that plugins can use a series'
	// linerenderer to generate grid data points without overwriting the
	// grid data associated with that series.
	// Called with scope of a series.
	$.jqplot.BigDataScatterRenderer.prototype.makeGridData = function(data, plot) {
		// recalculate the grid data
		/*var xp = this._xaxis.series_u2p;
		var yp = this._yaxis.series_u2p;
		var gd = [];
		this.renderer._smoothedData = [];
		this.renderer._smoothedPlotData = [];
		this.renderer._hiBandGridData = [];
		this.renderer._lowBandGridData = [];
		this.renderer._hiBandSmoothedData = [];
		this.renderer._lowBandSmoothedData = [];

		for (var i = 0; i < data.length; i++) {
			gd.push([Math.round(xp.call(this._xaxis, data[i][0])), Math.round(yp.call(this._yaxis, data[i][1]))]);
		}

		return gd;*/
	};

	/*function makeGridData(plot) {
	 var series = plot.series;
	 var i, j, sl, dl, data;

	 var max, min, offsets, offmax,offmin, pixellength, unitlength;

	 sl = series.length;

	 $.jqplot.config.pluginLocation = '';
	 var worker = new Worker($.jqplot.config.pluginLocation+'jqplot.bigDataGridDataWorker.js');
	 worker.addEventListener('message', function(event) {

	 }, false);

	 for (i=0; i<sl; i++) {
	 s = series[i];
	 max = s.max;
	 min = s.min;
	 offsets = s._offsets;
	 offmax = offsets.max;
	 offmin = offsets.min;

	 pixellength = offmax - offmin;
	 unitlength = max - min;

	 data = s.data;

	 }

	 }*/

	$.jqplot.BigDataScatterRenderer.prototype.draw = function(ctx, sdata, opts, plot) {
		if (this === plot) {
			if (plot.series.length > 0) {
  			draw(ctx, sdata, opts, plot);
  		} 
		} else {
			opts.stroke = this.markerOptions.stroke;

  		draw(ctx, sdata, opts, plot, this.index);
		}
	};

	$.jqplot.BigDataScatterRenderer.prototype.drawShadow = function(ctx, gd, options) {
		// This is a no-op, shadows drawn with lines.
	};
	
	// with series object
	$.jqplot.BigDataScatterRenderer.prototype.getBigGridData = function() {
		var tempCalcResult_u2p_x = this._xaxis.tempCalcResult_u2p;
		var tempCalcResult_u2p_y = this._yaxis.tempCalcResult_u2p;
		var tempCalcMin = this._xaxis.tempCalcMin;
		var tempCalcMax = this._yaxis.tempCalcMax;
		var d = this.data;
		var point;
		
		var gd = [];
		
        for (var i=0, l=d.length; i<l; i++) {
            point = d[i];
            gd.push([isNaN(point[0]) || point[0] == null ? point[0] : (0.5 + (point[0] - tempCalcMin) * tempCalcResult_u2p_x) | 0, isNaN(point[1]) || point[1] == null ? point[1] : (0.5 + (point[1] - tempCalcMax) * tempCalcResult_u2p_y) | 0]);
        }
		
		return gd;
	};
	
	function draw(ctx, sdata, options, plot, seriesIndex) {
		options = options || {};
		
        var seriesList, series, color, i, j,
    		width = ctx.canvas.width,
    		height = ctx.canvas.height,
    		dataWidth = width * 4,
    		zooming = (plot.plugins.cursor && (plot.plugins.cursor._zoom.zooming || plot.plugins.cursor._zoom.isZoomed)),
    		resetzooming = (plot.plugins.cursor && plot.plugins.cursor.resetzooming),
    		isZoomed = zooming && !resetzooming,
    		imgData = ctx.getImageData(0,0,width,height),
    		plotData = imgData.data,
    		borderWidth = plot.grid.borderWidth || 0,
    		opts = {};
		
		if (typeof seriesIndex == 'number') {
			seriesList = [seriesIndex];
		} else {
			seriesList = plot.seriesStack;
		}

		for(i=0; i<seriesList.length; i++) {
		    opts = {};
			series = plot.series[seriesList[i]];
			//series.gridData = [];
			
			color = $.jqplot.getColorComponents(series.color);
			color[3] *= 255;

			opts = $.extend(true, {}, opts, {
				fill: series.fill,
				borderWidth: borderWidth,
				color: color,
				fastMode: series.renderer.fastMode,
				markerOptions: series.markerOptions
			}, options);

			if (series.show && !series.hide) {
				
				//gridData = gd[i] || series.renderer.setBigGridData.call(series);
				
				// hooks get called even if series not shown
        	    // we don't clear canvas here, it would wipe out all other series as well.
        	    for (j=0; j<$.jqplot.preDrawSeriesHooks.length; j++) {
        	        $.jqplot.preDrawSeriesHooks[j].call(series, ctx, opts);
        	    }
        	    
        	    if (series.showLine && series.showMarker) {
        	    	drawLines(plotData, sdata, series, width, height, dataWidth, opts, isZoomed);
        	    	if (opts.markerOptions.stroke) {
        	    		drawStrokeMarkers(plotData, sdata, series, width, height, dataWidth, opts, isZoomed);
        		    } else {
        		    	drawMarkers(plotData, sdata, series, width, height, dataWidth, opts, isZoomed);
        		    }
        	    } else if (series.showLine && !series.showMarker) {
        				drawLines(plotData, sdata, series, width, height, dataWidth, opts, isZoomed);
        	    } else if (opts.markerOptions.stroke) {
        	    	drawStrokeMarkers(plotData, sdata, series, width, height, dataWidth, opts, isZoomed);
        	    } else {
        	    	drawMarkers(plotData, sdata, series, width, height, dataWidth, opts, isZoomed);
        	    }
        
        	    //dataProc(plotData, data, series, width, height, dataWidth, zooming && !resetzooming, color, strokeColor);
        	
        	    for (j=0; j<$.jqplot.postDrawSeriesHooks.length; j++) {		// customizing(2012-05-31, Roy Choi)
        	        $.jqplot.postDrawSeriesHooks[j].call(series, ctx, opts, plot);
        	    }
			}
			
		}
		//
		//
		ctx.putImageData(imgData, 0, 0);
		//ctx.save();
		ctx = null;

		width = height = null;
		color = i = j = null;
		imgData = plotData = series = null;
		zooming = resetzooming = null;
		dataWidth = null;
	}
	
	function getGraphFunction(x0, y0, x1, y1) {
        var equation, additional;
        
      	equation = (y1 - y0) / (x1 - x0);
      	additional = y1 - x1 * equation;
        
        return {
        	y: function(x) {
    	      return equation * x + additional;
    	    },
    	    x: function(y) {
    	    	return (y - additional) / equation;
    	    }
        };
	}

	function drawLines(plotData, data, series, width, height, dataWidth, opts, isZoomed) {
		var dataIndex, i, j, point, l,
    		x, y,
    		xLowerLimit = opts.borderWidth,
    		yLowerLimit = opts.borderWidth,
    		xUpperLimit = width - opts.borderWidth,
    		yUpperLimit = height - opts.borderWidth,
    		tempCalcResult_u2p_x = series._xaxis.tempCalcResult_u2p,
    		tempCalcResult_u2p_y = series._yaxis.tempCalcResult_u2p,
    		tempCalcMin = series._xaxis.tempCalcMin,
    		tempCalcMax = series._yaxis.tempCalcMax,
    		color = opts.color,
    		r = color[0], g = color[1], b = color[2], a = color[3],
    		fastMode = opts.fastMode || false,
    		dx, dy, steep,
    		t,
    		gradient, xend, yend, xgap, xpxl1, ypxl1,
    		intery, xpxl2, ypxl2, fpart,
    		x0, x1, y0, y1,
    		ox0, ox1, oy0, oy1,
    		startPoint, move,
    		xMinY, xMaxY,
    		graphFunc, condition,
    		alpha0, alpha1, rAlpha0, rAlpha1,
    		xdiff, ydiff, started = false;

		if (!data) data = series.data;

		l = data.length;
		
		if (fastMode) {
            xLowerLimit = Math.ceil(xLowerLimit);
            yLowerLimit = Math.ceil(yLowerLimit);
            xUpperLimit = Math.ceil(xUpperLimit);
            yUpperLimit = Math.ceil(yUpperLimit);
		    
			var fastAlpha = 0.05;
			
			if (isZoomed) {
				move = true;
				
				point = data[0];
				ox0 = (point[0] - tempCalcMin) * tempCalcResult_u2p_x;
				oy0 = (point[1] - tempCalcMax) * tempCalcResult_u2p_y;
	
				for (i = 1; i < l; i++) {
					point = data[i];
					ox1 = (point[0] - tempCalcMin) * tempCalcResult_u2p_x;
					oy1 = (point[1] - tempCalcMax) * tempCalcResult_u2p_y;
					
					x0 = ox0 - 0.5;
					y0 = oy0 - 0.5;
					x1 = ox1 - 0.5;
					y1 = oy1 - 0.5;
					
					if (((x0 < xLowerLimit || x0 > xUpperLimit || y0 < yLowerLimit || y0 > yUpperLimit) 
								&& (x1 < xLowerLimit || x1 > xUpperLimit || y1 < yLowerLimit || y1 > yUpperLimit))
							&& ((x0 < xLowerLimit && x1 < xLowerLimit) || (x0 > xUpperLimit && x1 > xUpperLimit)
								|| (y0 < yLowerLimit && y1 < yLowerLimit) || (y0 > yUpperLimit && y1 > yUpperLimit))) {
						move = series.breakOnNull || !(isNaN(x0) || x0 == null || isNaN(x1) || x1 == null || isNaN(y0) || y0 == null || isNaN(y1) || y1 == null);
						
						//ctx.moveTo(x1, y1);
					} else {
					    started = true;
					    move = true;
						condition = x0 == x1 && x0 > 0 && x0 < width;
						graphFunc = getGraphFunction(x0, y0, x1, y1);
						if (!condition) {
							xMinY = graphFunc.y(0);
							xMaxY = graphFunc.y(width);
							
							condition = (xMinY > xMaxY && xMinY > yLowerLimit && xMaxY < yUpperLimit) || (xMinY <= xMaxY && xMaxY > yLowerLimit && xMinY < yUpperLimit);
						}
						
						if (condition) {
							x0 = (x0 + 0.5) | 0;
							y0 = (y0 + 0.5) | 0;
							x1 = (x1 + 0.5) | 0;
							y1 = (y1 + 0.5) | 0;
							
							if (x0 > xUpperLimit) {
								x0 = xUpperLimit;
								y0 = (graphFunc.y(xUpperLimit) + 0.5) | 0;
							} else if (x0 < xLowerLimit) {
								x0 = xLowerLimit;
								y0 = (graphFunc.y(xLowerLimit) + 0.5) | 0;
							}
							if (y0 > yUpperLimit) {
								x0 = (graphFunc.x(yUpperLimit) + 0.5) | 0;
								y0 = yUpperLimit;
							} else if (y0 < yLowerLimit) {
								x0 = (graphFunc.x(yLowerLimit) + 0.5) | 0;
								y0 = yLowerLimit;
							}
	
							if (x1 > xUpperLimit) {
								x1 = xUpperLimit;
								y1 = (graphFunc.y(xUpperLimit) + 0.5) | 0;
							} else if (x1 < xLowerLimit) {
								x1 = xLowerLimit;
								y1 = (graphFunc.y(xLowerLimit) + 0.5) | 0;
							}
							if (y1 > yUpperLimit) {
								y1 = yUpperLimit;
								x1 = (graphFunc.x(yUpperLimit) + 0.5) | 0;
							} else if (y1 < yLowerLimit) {
								y1 = yLowerLimit;
								x1 = (graphFunc.x(yLowerLimit) + 0.5) | 0;
							}

    					    dy = y1 - y0;
    					    dx = x1 - x0;
    		
    					    if (dy < 0) {
    					    	dy = -dy;
    					    	stepy = -width;
    					    } else {
    					    	stepy = width;
    					    }
    					    if (dx < 0) {
    					    	dx = -dx;
    					    	stepx = -1;
    					    } else {
    					    	stepx = 1;
    					    }
    					    
    					    dy <<= 1;                                     
    					    dx <<= 1;                                     
    					    y0 *= width;
    					    y1 *= width;
    					    
    					    dataIndex = (y0 + x0) * 4;
    					    plotData[dataIndex] = r;
    					    plotData[dataIndex+1] = g;
    					    plotData[dataIndex+2] = b;
    					    plotData[dataIndex+3] = a;
    		
    					    if (dx > dy) {
        				        fraction = dy - (dx >> 1);    
        				        while (x0 != x1) {
            			            if (fraction >= 0) {
                		                y0 += stepy;
                		                fraction -= dx;                
            			            }
            			            x0 += stepx;
            			            fraction += dy;
            			            
            					    dataIndex = (y0 + x0) * 4;
            					    plotData[dataIndex] = r;
            					    plotData[dataIndex+1] = g;
            					    plotData[dataIndex+2] = b;
            					    plotData[dataIndex+3] = a;
        				        }
    					    } else {
        				        fraction = dx - (dy >> 1);
            		            while (y0 != y1) {
            		                if (fraction >= 0) {
            		                  x0 += stepx;
            		                  fraction -= dy;
            		                }
            		                y0 += stepy;
            		                fraction += dx;
            		              
            		            	dataIndex = (y0 + x0) * 4;
            					    plotData[dataIndex] = r;
            					    plotData[dataIndex+1] = g;
            					    plotData[dataIndex+2] = b;
            					    plotData[dataIndex+3] = a;
            		            }
    					    }
						}
					}
    			    if (move || !started) {
                        ox0 = ox1;
                        oy0 = oy1;
                    }
				}
			} else {
				var fraction, stepx, stepy;
				
				point = data[0];
				ox0 = point[0];
				oy0 = point[1];
				
				for (i=1; i<l; i++) {
					point = data[i];
					ox1 = point[0];
					oy1 = point[1];
					
					if (isNaN(ox0) || ox0 == null || isNaN(ox1) || ox1 == null || isNaN(oy0) || oy0 == null || isNaN(oy1) || oy1 == null) {
                        move = series.breakOnNull;
                    } else {
                        started = true;
                        move = true;
                        x0 = ((ox0 - tempCalcMin) * tempCalcResult_u2p_x) | 0;
                        y0 = ((oy0 - tempCalcMax) * tempCalcResult_u2p_y) | 0;
                        x1 = ((ox1 - tempCalcMin) * tempCalcResult_u2p_x) | 0;
                        y1 = ((oy1 - tempCalcMax) * tempCalcResult_u2p_y) | 0;
                        
                        dy = y1 - y0;
                        dx = x1 - x0;
        
                        if (dy < 0) {
                            dy = -dy;
                            stepy = -width;
                        } else {
                            stepy = width;
                        }
                        if (dx < 0) {
                            dx = -dx;
                            stepx = -1;
                        } else {
                            stepx = 1;
                        }
                        
                        dy <<= 1;                                     
                        dx <<= 1;                                     
                        y0 *= width;
                        y1 *= width;
                        
                        dataIndex = (y0 + x0) * 4;
                        plotData[dataIndex] = r;
                        plotData[dataIndex+1] = g;
                        plotData[dataIndex+2] = b;
                        plotData[dataIndex+3] = a;
        
                        if (dx > dy) {
                            fraction = dy - (dx >> 1);    
                            while (x0 != x1) {
                                if (fraction >= 0) {
                                y0 += stepy;
                                fraction -= dx;                
                                }
                                x0 += stepx;
                                fraction += dy;
                            
                                dataIndex = (y0 + x0) * 4;
                                plotData[dataIndex] = r;
                                plotData[dataIndex+1] = g;
                                plotData[dataIndex+2] = b;
                                plotData[dataIndex+3] = a;
                            }
                        } else {
                            fraction = dx - (dy >> 1);
                            while (y0 != y1) {
                              if (fraction >= 0) {
                                x0 += stepx;
                                fraction -= dy;
                              }
                              y0 += stepy;
                              fraction += dx;
                              
                                dataIndex = (y0 + x0) * 4;
                                        plotData[dataIndex] = r;
                                        plotData[dataIndex+1] = g;
                                        plotData[dataIndex+2] = b;
                                        plotData[dataIndex+3] = a;
                            }
                        }
                    }
			        if (move || !started) {
                        ox0 = ox1;
                        oy0 = oy1;
                    }
				}
			}
		} else {
			if (isZoomed) {
				point = data[0];
				ox0 = (point[0] - tempCalcMin) * tempCalcResult_u2p_x;
				oy0 = (point[1] - tempCalcMax) * tempCalcResult_u2p_y;
	
				for (i = 1; i < l; i++) {
					point = data[i];
					ox1 = (point[0] - tempCalcMin) * tempCalcResult_u2p_x;
					oy1 = (point[1] - tempCalcMax) * tempCalcResult_u2p_y;
					
					x0 = ox0 - 0.5;
					y0 = oy0 - 0.5;
					x1 = ox1 - 0.5;
					y1 = oy1 - 0.5;
					
					if (((x0 < xLowerLimit || x0 > xUpperLimit || y0 < yLowerLimit || y0 > yUpperLimit) 
								&& (x1 < xLowerLimit || x1 > xUpperLimit || y1 < yLowerLimit || y1 > yUpperLimit))
							&& ((x0 < xLowerLimit && x1 < xLowerLimit) || (x0 > xUpperLimit && x1 > xUpperLimit)
								|| (y0 < yLowerLimit && y1 < yLowerLimit) || (y0 > yUpperLimit && y1 > yUpperLimit))) {
						move = series.breakOnNull || !(isNaN(x0) || x0 == null || isNaN(x1) || x1 == null || isNaN(y0) || y0 == null || isNaN(y1) || y1 == null);
						
						//ctx.moveTo(x1, y1);
					} else {
					    started = true;
					    move = true;
						condition = x0 == x1 && x0 > 0 && x0 < width;
						graphFunc = getGraphFunction(x0, y0, x1, y1);
						if (!condition) {
							xMinY = graphFunc.y(0);
							xMaxY = graphFunc.y(width);
							
							condition = (xMinY > xMaxY && xMinY > yLowerLimit && xMaxY < yUpperLimit) || (xMinY <= xMaxY && xMaxY > yLowerLimit && xMinY < yUpperLimit);
						}
						
						if (condition) {
							if (x0 > xUpperLimit) {
								x0 = xUpperLimit;
								y0 = graphFunc.y(xUpperLimit);
							} else if (x0 < xLowerLimit) {
								x0 = xLowerLimit;
								y0 = graphFunc.y(xLowerLimit);
							}
							if (y0 > yUpperLimit) {
								x0 = graphFunc.x(yUpperLimit);
								y0 = yUpperLimit;
							} else if (y0 < yLowerLimit) {
								x0 = graphFunc.x(yLowerLimit);
								y0 = yLowerLimit;
							}
	
							if (x1 > xUpperLimit) {
								x1 = xUpperLimit;
								y1 = graphFunc.y(xUpperLimit);
							} else if (x1 < xLowerLimit) {
								x1 = xLowerLimit;
								y1 = graphFunc.y(xLowerLimit);
							}
							if (y1 > yUpperLimit) {
								y1 = yUpperLimit;
								x1 = graphFunc.x(yUpperLimit);
							} else if (y1 < yLowerLimit) {
								y1 = yLowerLimit;
								x1 = graphFunc.x(yLowerLimit);
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
			
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
			
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
					}
    				if (move || !started) {
    				    ox0 = ox1;
                        oy0 = oy1;
    				}
				}
			} else {
				point = data[0];
				ox0 = (point[0] - tempCalcMin) * tempCalcResult_u2p_x;
				oy0 = (point[1] - tempCalcMax) * tempCalcResult_u2p_y;
				
				for (i=1; i<l; i++) {
					point = data[i];
					ox1 = (point[0] - tempCalcMin) * tempCalcResult_u2p_x;
					oy1 = (point[1] - tempCalcMax) * tempCalcResult_u2p_y;
					
					x0 = ox0 - 0.5;
					y0 = oy0 - 0.5;
					x1 = ox1 - 0.5;
					y1 = oy1 - 0.5;
					
					if (isNaN(x0) || x0 == null || isNaN(x1) || x1 == null || isNaN(y0) || y0 == null || isNaN(y1) || y1 == null) {
                        move = series.breakOnNull;
                    } else {
                        started = true;
                        move = true;
                        
                        xdiff = x1 - x0;
                        ydiff = y1 - y0;
                        steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
                                
                        if (steep) {
                          t = x0; x0 = y0; y0 = t;
                          t = x1; x1 = y1; y1 = t;
                        }
                        if (x0 > x1) {
                            t = x0; x0 = x1; x1 = t;
                            t = y0; y0 = y1; y1 = t;
                        }
        
                        dx = x1 - x0;
                        dy = y1 - y0;
                        gradient = dy / dx;
                        
                        // handle first endpoint
                        xend = (0.5 + x0) | 0;
                        yend = y0 + gradient * (xend - x0);
                        xpxl1 = xend;   //this will be used in the main loop
                        ypxl1 = yend | 0;
                        
                        fpart = yend - (yend | 0);
        
                        if (steep) {
                            dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
            
                            alpha0 = plotData[dataIndex + 3] / 255;
                            alpha1 = 1 - fpart;
                            rAlpha0 = (1 - alpha0);
                            rAlpha1 = (1 - alpha1);
            
                            plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                            plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                            plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                            plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                            
                            if (ypxl1 + 1 < xUpperLimit) {
                                dataIndex += 4;
                            
                                alpha0 = plotData[dataIndex + 3] / 255;
                                alpha1 = fpart;
                                rAlpha0 = (1 - alpha0);
                                rAlpha1 = (1 - alpha1);
                
                                plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                                plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                                plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                                plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                            }
                        } else {
                            dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
                            
                            alpha0 = plotData[dataIndex + 3] / 255;
                            alpha1 = 1 - fpart;
                            rAlpha0 = (1 - alpha0);
                            rAlpha1 = (1 - alpha1);
            
                            plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                            plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                            plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                            plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                            
                            if (ypxl1 + 1 <= yUpperLimit) {
                                dataIndex += dataWidth;
                            
                                alpha0 = plotData[dataIndex + 3] / 255;
                                alpha1 = fpart;
                                rAlpha0 = (1 - alpha0);
                                rAlpha1 = (1 - alpha1);
                
                                plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                                plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                                plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                                plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                            }
                        }
        
                        intery = yend + gradient; // first y-intersection for the main loop
                        
                        // handle second endpoint
                        xend = (0.5 + x1) | 0;
                        yend = y1 + gradient * (xend - x1);
                        xpxl2 = xend; //this will be used in the main loop
                        ypxl2 = yend | 0;
                        
                        fpart = yend - (yend | 0);
                        
                        if (steep) {
                            dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
            
                            alpha0 = plotData[dataIndex + 3] / 255;
                            alpha1 = 1 - fpart;
                            rAlpha0 = (1 - alpha0);
                            rAlpha1 = (1 - alpha1);
            
                            plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                            plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                            plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                            plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                            
                            if (ypxl2 + 1 < xUpperLimit) {
                                dataIndex += 4;
                            
                                alpha0 = plotData[dataIndex + 3] / 255;
                                alpha1 = fpart;
                                rAlpha0 = (1 - alpha0);
                                rAlpha1 = (1 - alpha1);
                
                                plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                                plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                                plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                                plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                            }
                        } else {
                            dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
                            
                            alpha0 = plotData[dataIndex + 3] / 255;
                            alpha1 = 1 - fpart;
                            rAlpha0 = (1 - alpha0);
                            rAlpha1 = (1 - alpha1);
            
                            plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                            plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                            plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                            plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                            
                            if (y + 1 <= yUpperLimit) {
                                dataIndex += dataWidth;
                            
                                alpha0 = plotData[dataIndex + 3] / 255;
                                alpha1 = fpart;
                                rAlpha0 = (1 - alpha0);
                                rAlpha1 = (1 - alpha1);
                
                                plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                                plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                                plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                                plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                            }
                        }
        
                        // main loop
                        
                        for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
                            y = intery | 0;
                            fpart = intery - (intery | 0);
                        
                            if (steep) {
                                dataIndex = dataWidth * x + y * 4;
                
                                alpha0 = plotData[dataIndex + 3] / 255;
                                alpha1 = 1 - fpart;
                                rAlpha0 = (1 - alpha0);
                                rAlpha1 = (1 - alpha1);
                
                                plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                                plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                                plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                                plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                                
                                if (y + 1 < xUpperLimit) {
                                    dataIndex += 4;
                                    
                                    alpha0 = plotData[dataIndex + 3] / 255;
                                    alpha1 = fpart;
                                    rAlpha0 = (1 - alpha0);
                                    rAlpha1 = (1 - alpha1);
                    
                                    plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                                    plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                                    plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                                    plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                                }
                            } else {
                                dataIndex = dataWidth * y + x * 4;
                                
                                alpha0 = plotData[dataIndex + 3] / 255;
                                alpha1 = 1 - fpart;
                                rAlpha0 = (1 - alpha0);
                                rAlpha1 = (1 - alpha1);
                
                                plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                                plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                                plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                                plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                                
                                if (y + 1 <= yUpperLimit) {
                                    dataIndex += dataWidth;
                                    
                                    alpha0 = plotData[dataIndex + 3] / 255;
                                    alpha1 = fpart;
                                    rAlpha0 = (1 - alpha0);
                                    rAlpha1 = (1 - alpha1);
                    
                                    plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
                                    plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
                                    plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
                                    plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
                                }
                            }
                
                          intery = intery + gradient;
                        }
                    }
                    if (move || !started) {
                        ox0 = ox1;
                        oy0 = oy1;
                    }
				}
			}
		}


		data = null;
		tempCalcResult_u2p_x = tempCalcResult_u2p_y = tempCalcMin = tempCalcMax = null;
		dataIndex = i = j = l = null;
		x = y = null;
	}
	
	function drawMarkers(plotData, data, series, width, height, dataWidth, opts, isZoomed) {
		var dataIndex, i, j, newIndex, point, l,
    		xLowerLimit = opts.borderWidth,
    		yLowerLimit = opts.borderWidth,
    		borderWidth = opts.borderWidth,
    		xUpperLimit = width - borderWidth * 2,
    		yUpperLimit = height - borderWidth * 2,
    		x, y,
    		color = opts.color,
    		r = color[0], g = color[1], b = color[2], a = color[3], af = a / 255,
    		or = r, og = g, ob = b, oa = a, oaf = af,
    		fillStyleFilter = series.markerOptions.fillStyleFilter, isFunctionFillStyleFilter = typeof fillStyleFilter == 'function', filteredColor,
    		getColorComponents = $.jqplot.getColorComponents,
    		markSize = opts.markerOptions.size || 3,
    		fastMode = opts.markerOptions.fastMode,
    		tempCalcResult_u2p_x = series._xaxis.tempCalcResult_u2p,
    		tempCalcResult_u2p_y = series._yaxis.tempCalcResult_u2p,
    		tempCalcMin = series._xaxis.tempCalcMin,
    		tempCalcMax = series._yaxis.tempCalcMax,
    		fpart,
    		x0, y0, x1, y1, xf0, yf0,
    		xf, yf, rxf, ryf,
    		distance = (markSize / 2) / 1.0,
    		alpha0, alpha1, rAlpha0, rAlpha1,
    		xLowerDistanceLimit, yLowerDistanceLimit, xUpperDistanceLimit, yUpperDistanceLimit;
		

		if (!data) data = series.data;

		l = data.length;
		
		
		if (l) {
			if (isZoomed) {
				if (fastMode) {
					markSize--;
					xLowerDistanceLimit = xLowerLimit - distance;
                    yLowerDistanceLimit = yLowerLimit - distance;
                    xUpperDistanceLimit = xUpperLimit + distance;
                    yUpperDistanceLimit = yUpperLimit + distance;
					for ( j = 0; j < l; j++) {
						point = data[j];
						
						x = point[0];
						y = point[1];
						
						if (isNaN(x) || x == null || isNaN(y) || y == null) {
							continue;
						}
						
						x = (x - tempCalcMin) * tempCalcResult_u2p_x;
						y = (y - tempCalcMax) * tempCalcResult_u2p_y;
		
						if (x > xUpperDistanceLimit || x < xLowerDistanceLimit || y < yLowerDistanceLimit || y > yUpperDistanceLimit) {
							continue;
						}
						
						if (isFunctionFillStyleFilter) {
						    filteredColor = fillStyleFilter.call(series, point);
						    if (filteredColor == series.color) {
						        r = or;
						        g = og;
						        b = ob;
						        a = oa;
						        af = oaf;
						    } else {
						        color = getColorComponents(filteredColor);
                                r = color[0];
                                g = color[1];
                                b = color[2];
                                a = color[3] * 255;
                                af = a / 255;
						    }
						}

						x0 = (x - distance + 0.5) | 0;
						y0 = (y - distance + 0.5) | 0;
	
						x1 = x0 + markSize;
						y1 = y0 + markSize;
						
						if (x0 < xLowerLimit) {
							x0 = xLowerLimit;
						}
						if (x1 > xUpperLimit) {
							x1 = xUpperLimit;
						}
						
						if (y0 < yLowerLimit) {
							y0 = xLowerLimit;
						}
						if (y1 > yUpperLimit) {
							y1 = yUpperLimit;
						}

						for (x = x0; x <= x1; x++) {
							dataIndex = dataWidth * y0 + x * 4;

							for (y = y0; y <= y1; y++) {
								plotData[dataIndex] = r;
								plotData[dataIndex + 1] = g;
								plotData[dataIndex + 2] = b;
								plotData[dataIndex + 3] = 255;
								
								dataIndex += dataWidth;
							}
						}
					}
				} else {
				    xLowerDistanceLimit = xLowerLimit - distance;
                    yLowerDistanceLimit = yLowerLimit - distance;
                    xUpperDistanceLimit = xUpperLimit + distance;
                    yUpperDistanceLimit = yUpperLimit + distance;
					for ( j = 0; j < l; j++) {
						point = data[j];
						
						x = point[0];
						y = point[1];
						
						if (isNaN(x) || x == null || isNaN(y) || y == null) {
							continue;
						}
						
						x = (x - tempCalcMin) * tempCalcResult_u2p_x;
						y = (y - tempCalcMax) * tempCalcResult_u2p_y;
		
						if (x > xUpperDistanceLimit || x < xLowerDistanceLimit || y < yLowerDistanceLimit || y > yUpperDistanceLimit) {
							continue;
						}
						
						if (isFunctionFillStyleFilter) {
                            filteredColor = fillStyleFilter.call(series, point);
                            if (filteredColor == series.color) {
                                r = or;
                                g = og;
                                b = ob;
                                a = oa;
                                af = oaf;
                            } else {
                                color = getColorComponents(filteredColor);
                                r = color[0];
                                g = color[1];
                                b = color[2];
                                a = color[3] * 255;
                                af = a / 255;
                            }
                        }
						
						xf0 = x - distance;
						yf0 = y - distance;
						
						x0 = xf0 | 0;
						y0 = yf0 | 0;
						
						xf = xf0 - x0;
						yf = yf0 - y0;
						rxf = 1 - xf;
						ryf = 1 - yf;

						x1 = x0 + markSize;
						y1 = y0 + markSize;
						
						if (x0 < xLowerLimit) {
							x0 = xLowerLimit;
							rxf = 1;
						}
						if (x1 > xUpperLimit) {
							x1 = xUpperLimit;
							xf = 1;
						}
						
						if (y0 < yLowerLimit) {
							y0 = yLowerLimit;
							ryf = 1;
						}
						if (y1 > yUpperLimit) {
							y1 = yUpperLimit;
							yf = 1;
						}
						
						dataIndex = dataWidth * y0 + x0 * 4;
	
						alpha1 = rxf * ryf * af;
						
						alpha0 = plotData[dataIndex + 3] / 255;
						rAlpha0 = (1 - alpha0);
						rAlpha1 = (1 - alpha1);
		
						plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
						plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
						plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
						plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
						alpha1 = rxf * af;
	
						for (y = y0+1; y < y1; y++) {
							dataIndex += dataWidth;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
						}
						
						if (y0 < y1) {
							dataIndex += dataWidth;
							
							alpha1 = rxf * yf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
						}
	
						for (x = x0+1; x < x1; x++) {
							dataIndex = dataWidth * y0 + x * 4;
	
							alpha1 = ryf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
							alpha1 = af;
	
							for (y = y0+1; y < y1; y++) {
								dataIndex += dataWidth;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
							
							if (y0 < y1) {
								dataIndex += dataWidth;
								
								alpha1 = yf * af;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
						}
						
						if (x0 < x1) {
							dataIndex = dataWidth * y0 + x1 * 4;
	
							alpha1 = xf * ryf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
							alpha1 = xf * af;
	
							for (y = y0+1; y < y1; y++) {
								dataIndex += dataWidth;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
							
							if (y0 < y1) {
								dataIndex += dataWidth;
								
								alpha1 = xf * yf * af;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
						}
					}
				}
			} else {
				if (fastMode) {
					markSize--;
					
					xLowerDistanceLimit = xLowerLimit - distance;
					yLowerDistanceLimit = yLowerLimit - distance;
					xUpperDistanceLimit = xUpperLimit + distance;
					yUpperDistanceLimit = yUpperLimit + distance;
					
					for ( j = 0; j < l; j++) {
						point = data[j];
						
						x = point[0];
						y = point[1];
						if (isNaN(x) || x == null || isNaN(y) || y == null) {
						    continue;
						}
						
						x = (x - tempCalcMin) * tempCalcResult_u2p_x;
						y = (y - tempCalcMax) * tempCalcResult_u2p_y;
		
						if (x > xUpperDistanceLimit || x < xLowerDistanceLimit || y < yLowerDistanceLimit || y > yUpperDistanceLimit) {
							continue;
						}
						
						if (isFunctionFillStyleFilter) {
                            filteredColor = fillStyleFilter.call(series, point);
                            if (filteredColor == series.color) {
                                r = or;
                                g = og;
                                b = ob;
                                a = oa;
                                af = oaf;
                            } else {
                                color = getColorComponents(filteredColor);
                                r = color[0];
                                g = color[1];
                                b = color[2];
                                a = color[3] * 255;
                                af = a / 255;
                            }
                        }

						x0 = (x - distance + 0.5) | 0;
						y0 = (y - distance + 0.5) | 0;
	
						x1 = x0 + markSize;
						y1 = y0 + markSize;
						
						if (x0 < xLowerLimit) {
							x0 = xLowerLimit;
						}
						if (x1 > xUpperLimit) {
							x1 = xUpperLimit;
						}
						
						if (y0 < yLowerLimit) {
							y0 = yLowerLimit;
						}
						if (y1 > yUpperLimit) {
							y1 = yUpperLimit;
						}
                        /*console.log({
                            x0: x0,
                            y0: y0,
                            x1: x1,
                            y1: y1,
                            xLowerLimit: xLowerLimit,
                            yLowerLimit: yLowerLimit,
                            xUpperLimit: xUpperLimit,
                            yUpperLimit: yUpperLimit
                        });*/
						for (x = x0; x <= x1; x++) {
							dataIndex = dataWidth * y0 + x * 4;

							for (y = y0; y <= y1; y++) {
								plotData[dataIndex] = r;
								plotData[dataIndex + 1] = g;
								plotData[dataIndex + 2] = b;
								plotData[dataIndex + 3] = 255;
								
								dataIndex += dataWidth;
							}
						}
					}
				} else {
				    xLowerDistanceLimit = xLowerLimit - distance;
                    yLowerDistanceLimit = yLowerLimit - distance;
                    xUpperDistanceLimit = xUpperLimit + distance;
                    yUpperDistanceLimit = yUpperLimit + distance;
					for ( j = 0; j < l; j++) {
						point = data[j];
						
						x = point[0];
                        y = point[1];
                        if (isNaN(x) || x == null || isNaN(y) || y == null) {
                            continue;
                        }
                        
                        x = (x - tempCalcMin) * tempCalcResult_u2p_x;
                        y = (y - tempCalcMax) * tempCalcResult_u2p_y;
        
                        if (x > xUpperDistanceLimit || x < xLowerDistanceLimit || y < yLowerDistanceLimit || y > yUpperDistanceLimit) {
                            continue;
                        }
                        
                        if (isFunctionFillStyleFilter) {
                            filteredColor = fillStyleFilter.call(series, point);
                            if (filteredColor == series.color) {
                                r = or;
                                g = og;
                                b = ob;
                                a = oa;
                                af = oaf;
                            } else {
                                color = getColorComponents(filteredColor);
                                r = color[0];
                                g = color[1];
                                b = color[2];
                                a = color[3] * 255;
                                af = a / 255;
                            }
                        }

						xf0 = x - distance;
						yf0 = y - distance;
						
						x0 = xf0 | 0;
						y0 = yf0 | 0;
						
						xf = xf0 - x0;
						yf = yf0 - y0;
						rxf = 1 - xf;
						ryf = 1 - yf;
	
						x1 = x0 + markSize;
						y1 = y0 + markSize;
						
						if (x0 < xLowerLimit) {
							x0 = xLowerLimit;
							rxf = 1;
						}
						if (x1 > xUpperLimit) {
							x1 = xUpperLimit;
							xf = 1;
						}
						
						if (y0 < yLowerLimit) {
							y0 = xLowerLimit;
							ryf = 1;
						}
						if (y1 > yUpperLimit) {
							y1 = yUpperLimit;
							yf = 1;
						}
						
						dataIndex = dataWidth * y0 + x0 * 4;
	
						alpha1 = rxf * ryf * af;
						
						alpha0 = plotData[dataIndex + 3] / 255;
						rAlpha0 = (1 - alpha0);
						rAlpha1 = (1 - alpha1);
		
						plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
						plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
						plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
						plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
						alpha1 = rxf * af;
	
						for (y = y0+1; y < y1; y++) {
							dataIndex += dataWidth;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
						}
						
						if (y0 < y1) {
							dataIndex += dataWidth;
							
							alpha1 = rxf * yf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
						}
	
						for (x = x0+1; x < x1; x++) {
							dataIndex = dataWidth * y0 + x * 4;
	
							alpha1 = ryf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
							alpha1 = af;
	
							for (y = y0+1; y < y1; y++) {
								dataIndex += dataWidth;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
							
							if (y0 < y1) {
								dataIndex += dataWidth;
								
								alpha1 = yf * af;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
						}
						
						if (x0 < x1) {
							dataIndex = dataWidth * y0 + x1 * 4;
	
							alpha1 = xf * ryf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
							alpha1 = xf * af;
	
							for (y = y0+1; y < y1; y++) {
								dataIndex += dataWidth;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
							
							if (y0 < y1) {
								dataIndex += dataWidth;
								
								alpha1 = xf * yf * af;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
						}
					}
				}
			}

		}

		tempCalcResult_u2p_x = tempCalcResult_u2p_y = tempCalcMin = tempCalcMax = null;
		dataIndex = j = newIndex = l = null;
		x = y = null;
	}
	
	function drawStrokeMarkers(plotData, data, series, width, height, dataWidth, opts, isZoomed) {
		var dataIndex, i, j, newIndex, point, l,
    		xLowerLimit = opts.borderWidth,
    		yLowerLimit = opts.borderWidth,
    		xUpperLimit = width - opts.borderWidth,
    		yUpperLimit = height - opts.borderWidth,
    		x, y,
    		color = opts.color,
    		scolor = series.markerOptions.strokeStyle ? $.jqplot.getColorComponents(series.markerOptions.strokeStyle) : [color[0] * .8, color[1] * .8, color[2] * .8, color[3]],
    		r = color[0], g = color[1], b = color[2], a = color[3], af = a / 255,
    		or = r, og = g, ob = b, oa = a, oaf = af,
    		sr = scolor[0], sg = scolor[1], sb = scolor[2], sa = scolor[3], saf = af,
    		osr = sr, osg = sg, osb = sb, osa = sa, osaf = saf,
            fillStyleFilter = series.markerOptions.fillStyleFilter, isFunctionFillStyleFilter = typeof fillStyleFilter == 'function', filteredColor,
            strokeStyleFilter = series.markerOptions.strokeStyleFilter, isFunctionStrokeStyleFilter = typeof strokeStyleFilter == 'function', filteredStrokeColor,
            getColorComponents = $.jqplot.getColorComponents,
    		markSize = opts.markerOptions.size || 3,
    		fastMode = opts.markerOptions.fastMode,
    		tempCalcResult_u2p_x = series._xaxis.tempCalcResult_u2p,
    		tempCalcResult_u2p_y = series._yaxis.tempCalcResult_u2p,
    		tempCalcMin = series._xaxis.tempCalcMin,
    		tempCalcMax = series._yaxis.tempCalcMax,
    		fpart,
    		x0, y0, x1, y1, xf0, yf0, xf1, yf1,
    		xf, yf, rxf, ryf,
    		distance = (markSize / 2) / 1.0,
    		dx, dy, steep,
    		t,
    		gradient, xend, yend, xgap, xpxl1, ypxl1,
    		intery, xpxl2, ypxl2, fpart,
    		x0, x1, y0, y1,
    		xMinY, xMaxY,
    		graphFunc, condition,
    		alpha0, alpha1, rAlpha0, rAlpha1,
    		xdiff, ydiff,
            xLowerDistanceLimit = xLowerLimit - distance,
            yLowerDistanceLimit = yLowerLimit - distance,
            xUpperDistanceLimit = xUpperLimit + distance,
            yUpperDistanceLimit = yUpperLimit + distance;
            
		if (!data) data = series.data;

		l = data.length;

		if (l) {
			if (isZoomed) {
				if (fastMode) {
					for ( j = 0; j < l; j++) {
						point = data[j];
						
						x = point[0];
						y = point[1];
						
						if (isNaN(x) || x == null || isNaN(y) || y == null) {
							continue;
						}
						
						x = (x - tempCalcMin) * tempCalcResult_u2p_x;
						y = (y - tempCalcMax) * tempCalcResult_u2p_y;
		
						if (x > xUpperDistanceLimit || x < xLowerDistanceLimit || y < yLowerDistanceLimit || y > yUpperDistanceLimit) {
                            continue;
                        }
                        
                        if (isFunctionFillStyleFilter) {
                            filteredColor = fillStyleFilter.call(series, point);
                            if (filteredColor == series.color) {
                                r = or;
                                g = og;
                                b = ob;
                                a = oa;
                                af = oaf;
                            } else {
                                color = getColorComponents(filteredColor);
                                r = color[0];
                                g = color[1];
                                b = color[2];
                                a = color[3] * 255;
                                af = a / 255;
                            }
                        }
                        
                        if (isFunctionStrokeStyleFilter) {
                            filteredStrokeColor = strokeStyleFilter.call(series, point);
                            if (filteredStrokeColor == series.markerOptions.strokeStyle) {
                                sr = osr;
                                sg = osg;
                                sb = osb;
                                sa = osa;
                                saf - osaf;
                            } else {
                                color = getColorComponents(filteredStrokeColor);
                                sr = color[0];
                                sg = color[1];
                                sb = color[2];
                                sa = color[3];
                                saf = sa / 255;
                            }
                        }

						x0 = (x - distance) | 0;
						y0 = (y - distance) | 0;
	
						x1 = x0 + markSize;
						y1 = y0 + markSize;

                        if (x0 < xLowerLimit) {
                            x0 = xLowerLimit;
                        }
                        if (x1 > xUpperLimit) {
                            x1 = xUpperLimit;
                        }
                        
                        if (y0 < yLowerLimit) {
                            y0 = xLowerLimit;
                        }
                        if (y1 > yUpperLimit) {
                            y1 = yUpperLimit;
                        }
						
						for (x = x0; x <= x1; x++) {
							if (x < xLowerLimit || x > xUpperLimit) {
								continue;
							}
							dataIndex = dataWidth * y0 + x * 4;

							for (y = y0; y <= y1; y++) {
								if (y >= yLowerLimit && y <= yUpperLimit) {
									if (x == x0 || y == y0 || x == x1 || y == y1) {
										plotData[dataIndex] = sr;
										plotData[dataIndex + 1] = sg;
										plotData[dataIndex + 2] = sb;
										plotData[dataIndex + 3] = 255;
									} else {
										plotData[dataIndex] = r;
										plotData[dataIndex + 1] = g;
										plotData[dataIndex + 2] = b;
										plotData[dataIndex + 3] = 255;
									}
								}

								dataIndex += dataWidth;
							}
						}
					}
				} else {
					for ( j = 0; j < l; j++) {
						point = data[j];
						
						x = point[0];
						y = point[1];
						
						if (isNaN(x) || x == null || isNaN(y) || y == null) {
							continue;
						}
						
						x = (x - tempCalcMin) * tempCalcResult_u2p_x;
						y = (y - tempCalcMax) * tempCalcResult_u2p_y;
		
						if (x > xUpperDistanceLimit || x < xLowerDistanceLimit || y < yLowerDistanceLimit || y > yUpperDistanceLimit) {
                            continue;
                        }
                        
                        if (isFunctionFillStyleFilter) {
                            filteredColor = fillStyleFilter.call(series, point);
                            if (filteredColor == series.color) {
                                r = or;
                                g = og;
                                b = ob;
                                a = oa;
                                af = oaf;
                            } else {
                                color = getColorComponents(filteredColor);
                                r = color[0];
                                g = color[1];
                                b = color[2];
                                a = color[3] * 255;
                                af = a / 255;
                            }
                        }
                        
                        if (isFunctionStrokeStyleFilter) {
                            filteredStrokeColor = strokeStyleFilter.call(series, point);
                            if (filteredStrokeColor == series.markerOptions.strokeStyle) {
                                sr = osr;
                                sg = osg;
                                sb = osb;
                                sa = osa;
                                saf - osaf;
                            } else {
                                color = getColorComponents(filteredStrokeColor);
                                sr = color[0];
                                sg = color[1];
                                sb = color[2];
                                sa = color[3];
                                saf = sa / 255;
                            }
                        }

						xf0 = x - distance;
						yf0 = y - distance;
						xf1 = xf0 + markSize - 0.5;
						yf1 = yf0 + markSize - 0.5;
						
						x0 = xf0 | 0;
						y0 = yf0 | 0;
						
						xf = xf0 - x0;
						yf = yf0 - y0;
						rxf = 1 - xf;
						ryf = 1 - yf;
	
						x1 = x0 + markSize;
						y1 = y0 + markSize;
						
						if (x0 < xLowerLimit) {
							x0 = xLowerLimit;
							rxf = 1;
						}
						if (x1 > xUpperLimit) {
							x1 = xUpperLimit;
							xf = 1;
						}
						
						if (y0 < yLowerLimit) {
							y0 = xLowerLimit;
							ryf = 1;
						}
						if (y1 > yUpperLimit) {
							y1 = yUpperLimit;
							yf = 1;
						}
						
						dataIndex = dataWidth * y0 + x0 * 4;
	
						alpha1 = rxf * ryf * af;
						
						alpha0 = plotData[dataIndex + 3] / 255;
						rAlpha0 = (1 - alpha0);
						rAlpha1 = (1 - alpha1);
		
						plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
						plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
						plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
						plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
						alpha1 = rxf * af;
	
						for (y = y0+1; y < y1; y++) {
							dataIndex += dataWidth;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
						}
						
						if (y0 < y1) {
							dataIndex += dataWidth;
							
							alpha1 = rxf * yf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
						}
	
						for (x = x0+1; x < x1; x++) {
							dataIndex = dataWidth * y0 + x * 4;
	
							alpha1 = ryf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
							alpha1 = af;
	
							for (y = y0+1; y < y1; y++) {
								dataIndex += dataWidth;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
							
							if (y0 < y1) {
								dataIndex += dataWidth;
								
								alpha1 = yf * af;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
						}
						
						if (x0 < x1) {
							dataIndex = dataWidth * y0 + x1 * 4;
	
							alpha1 = xf * ryf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
							alpha1 = xf * af;
	
							for (y = y0+1; y < y1; y++) {
								dataIndex += dataWidth;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
							
							if (y0 < y1) {
								dataIndex += dataWidth;
								
								alpha1 = xf * yf * af;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
						}
						
						xf0 -= 0.5;
						yf0 -= 0.5;
						
						x0 = xf0;
						y0 = yf0;
						x1 = xf1;
						y1 = yf0;
				
						if (((x0 >= xLowerLimit && x0 <= xUpperLimit) || (x1 >= xLowerLimit && x1 <= xUpperLimit)) && (y0 >= yLowerLimit && y0 <= yUpperLimit)) {
							if (x0 > xUpperLimit) {
								x0 = xUpperLimit;
							} else if (x0 < xLowerLimit) {
								x0 = xLowerLimit;
							}
				
							if (x1 > xUpperLimit) {
								x1 = xUpperLimit;
							} else if (x1 < xLowerLimit) {
								x1 = xLowerLimit;
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
				
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
				
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
						
						x0 = xf1;
						y0 = yf0;
						x1 = xf1;
						y1 = yf1;
				
						if (((y0 >= yLowerLimit && y0 <= yUpperLimit) || (y1 >= yLowerLimit && y1 <= yUpperLimit)) && (x1 >= xLowerLimit && x1 <= xUpperLimit)) {
							if (y0 > yUpperLimit) {
								y0 = yUpperLimit;
							} else if (y0 < yLowerLimit) {
								y0 = yLowerLimit;
							}
							if (y1 > yUpperLimit) {
								y1 = yUpperLimit;
							} else if (y1 < yLowerLimit) {
								y1 = yLowerLimit;
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
				
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
				
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
						
						x0 = xf1;
						y0 = yf1;
						x1 = xf0;
						y1 = yf1;
				
						if (((x0 >= xLowerLimit && x0 <= xUpperLimit) || (x1 >= xLowerLimit && x1 <= xUpperLimit)) && (y1 >= yLowerLimit && y1 <= yUpperLimit)) {
							if (x0 > xUpperLimit) {
								x0 = xUpperLimit;
							} else if (x0 < xLowerLimit) {
								x0 = xLowerLimit;
							}
				
							if (x1 > xUpperLimit) {
								x1 = xUpperLimit;
							} else if (x1 < xLowerLimit) {
								x1 = xLowerLimit;
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
				
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
				
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
						
						x0 = xf0;
						y0 = yf1;
						x1 = xf0;
						y1 = yf0;
				
						if (((y0 >= yLowerLimit && y0 <= yUpperLimit) || (y1 >= yLowerLimit && y1 <= yUpperLimit)) && (x0 >= xLowerLimit && x0 <= xUpperLimit)) {
							if (y0 > yUpperLimit) {
								y0 = yUpperLimit;
							} else if (y0 < yLowerLimit) {
								y0 = yLowerLimit;
							}
							if (y1 > yUpperLimit) {
								y1 = yUpperLimit;
							} else if (y1 < yLowerLimit) {
								y1 = yLowerLimit;
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
				
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
				
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
					}
				}
			} else {
				if (fastMode) {
					for ( j = 0; j < l; j++) {
						point = data[j];
						
						x = point[0];
						y = point[1];
						if (isNaN(x) || x == null || isNaN(y) || y == null) continue;
						
						x = (x - tempCalcMin) * tempCalcResult_u2p_x;
						y = (y - tempCalcMax) * tempCalcResult_u2p_y;
		
						if (x > xUpperDistanceLimit || x < xLowerDistanceLimit || y < yLowerDistanceLimit || y > yUpperDistanceLimit) {
                            continue;
                        }
                        
                        if (isFunctionFillStyleFilter) {
                            filteredColor = fillStyleFilter.call(series, point);
                            if (filteredColor == series.color) {
                                r = or;
                                g = og;
                                b = ob;
                                a = oa;
                                af = oaf;
                            } else {
                                color = getColorComponents(filteredColor);
                                r = color[0];
                                g = color[1];
                                b = color[2];
                                a = color[3] * 255;
                                af = a / 255;
                            }
                        }
                        
                        if (isFunctionStrokeStyleFilter) {
                            filteredStrokeColor = strokeStyleFilter.call(series, point);
                            if (filteredStrokeColor == series.markerOptions.strokeStyle) {
                                sr = osr;
                                sg = osg;
                                sb = osb;
                                sa = osa;
                                saf - osaf;
                            } else {
                                color = getColorComponents(filteredStrokeColor);
                                sr = color[0];
                                sg = color[1];
                                sb = color[2];
                                sa = color[3];
                                saf = sa / 255;
                            }
                        }
                        
						x0 = (x - distance) | 0;
						y0 = (y - distance) | 0;
	
						x1 = x0 + markSize;
						y1 = y0 + markSize;
						
                        if (x0 < xLowerLimit) {
                            x0 = xLowerLimit;
                        }
                        if (x1 > xUpperLimit) {
                            x1 = xUpperLimit;
                        }
                        
                        if (y0 < yLowerLimit) {
                            y0 = xLowerLimit;
                        }
                        if (y1 > yUpperLimit) {
                            y1 = yUpperLimit;
                        }
                        
						for (x = x0; x <= x1; x++) {
							if (x < xLowerLimit || x > xUpperLimit) {
								continue;
							}
							dataIndex = dataWidth * y0 + x * 4;

							for (y = y0; y <= y1; y++) {
								if (y >= yLowerLimit && y <= yUpperLimit) {
									if (x == x0 || y == y0 || x == x1 || y == y1) {
										plotData[dataIndex] = sr;
										plotData[dataIndex + 1] = sg;
										plotData[dataIndex + 2] = sb;
										plotData[dataIndex + 3] = 255;
									} else {
										plotData[dataIndex] = r;
										plotData[dataIndex + 1] = g;
										plotData[dataIndex + 2] = b;
										plotData[dataIndex + 3] = 255;
									}
								}

								dataIndex += dataWidth;
							}
						}
					}
				} else {
					for ( j = 0; j < l; j++) {
						point = data[j];
						
						x = point[0];
                        y = point[1];
                        if (isNaN(x) || x == null || isNaN(y) || y == null) continue;
                        
						x = (x - tempCalcMin) * tempCalcResult_u2p_x;
						y = (y - tempCalcMax) * tempCalcResult_u2p_y;
						
						if (isFunctionFillStyleFilter) {
                            filteredColor = fillStyleFilter.call(series, point);
                            if (filteredColor == series.color) {
                                r = or;
                                g = og;
                                b = ob;
                                a = oa;
                                af = oaf;
                            } else {
                                color = getColorComponents(filteredColor);
                                r = color[0];
                                g = color[1];
                                b = color[2];
                                a = color[3] * 255;
                                af = a / 255;
                            }
                        }
                        
                        if (isFunctionStrokeStyleFilter) {
                            filteredStrokeColor = strokeStyleFilter.call(series, point);
                            if (filteredStrokeColor == series.markerOptions.strokeStyle) {
                                sr = osr;
                                sg = osg;
                                sb = osb;
                                sa = osa;
                                saf - osaf;
                            } else {
                                color = getColorComponents(filteredStrokeColor);
                                sr = color[0];
                                sg = color[1];
                                sb = color[2];
                                sa = color[3];
                                saf = sa / 255;
                            }
                        }
						
						xf0 = x - distance;
						yf0 = y - distance;
						xf1 = xf0 + markSize - 0.5;
						yf1 = yf0 + markSize - 0.5;
						
						x0 = xf0 | 0;
						y0 = yf0 | 0;
						
						xf = xf0 - x0;
						yf = yf0 - y0;
						rxf = 1 - xf;
						ryf = 1 - yf;
	
						x1 = x0 + markSize;
						y1 = y0 + markSize;
						
						if (x0 < xLowerLimit) {
							x0 = xLowerLimit;
							rxf = 1;
						}
						if (x1 > xUpperLimit) {
							x1 = xUpperLimit;
							xf = 1;
						}
						
						if (y0 < yLowerLimit) {
							y0 = xLowerLimit;
							ryf = 1;
						}
						if (y1 > yUpperLimit) {
							y1 = yUpperLimit;
							yf = 1;
						}
						
						dataIndex = dataWidth * y0 + x0 * 4;
	
						alpha1 = rxf * ryf * af;
						
						alpha0 = plotData[dataIndex + 3] / 255;
						rAlpha0 = (1 - alpha0);
						rAlpha1 = (1 - alpha1);
		
						plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
						plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
						plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
						plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
						alpha1 = rxf * af;
	
						for (y = y0+1; y < y1; y++) {
							dataIndex += dataWidth;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
						}
						
						if (y0 < y1) {
							dataIndex += dataWidth;
							
							alpha1 = rxf * yf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
						}
	
						for (x = x0+1; x < x1; x++) {
							dataIndex = dataWidth * y0 + x * 4;
	
							alpha1 = ryf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
							alpha1 = af;
	
							for (y = y0+1; y < y1; y++) {
								dataIndex += dataWidth;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
							
							if (y0 < y1) {
								dataIndex += dataWidth;
								
								alpha1 = yf * af;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
						}
						
						if (x0 < x1) {
							dataIndex = dataWidth * y0 + x1 * 4;
	
							alpha1 = xf * ryf * af;
							
							alpha0 = plotData[dataIndex + 3] / 255;
							rAlpha0 = (1 - alpha0);
							rAlpha1 = (1 - alpha1);
			
							plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
							plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
							plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
							plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
	
							alpha1 = xf * af;
	
							for (y = y0+1; y < y1; y++) {
								dataIndex += dataWidth;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
							
							if (y0 < y1) {
								dataIndex += dataWidth;
								
								alpha1 = xf * yf * af;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = r * rAlpha0 + (r * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = g * rAlpha0 + (g * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = b * rAlpha0 + (b * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
							}
						}
						
						xf0 -= 0.5;
						yf0 -= 0.5;
						
						x0 = xf0;
						y0 = yf0;
						x1 = xf1;
						y1 = yf0;
				
						if (((x0 >= xLowerLimit && x0 <= xUpperLimit) || (x1 >= xLowerLimit && x1 <= xUpperLimit)) && (y0 >= yLowerLimit && y0 <= yUpperLimit)) {
							if (x0 > xUpperLimit) {
								x0 = xUpperLimit;
							} else if (x0 < xLowerLimit) {
								x0 = xLowerLimit;
							}
				
							if (x1 > xUpperLimit) {
								x1 = xUpperLimit;
							} else if (x1 < xLowerLimit) {
								x1 = xLowerLimit;
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
				
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
				
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
						
						x0 = xf1;
						y0 = yf0;
						x1 = xf1;
						y1 = yf1;
				
						if (((y0 >= yLowerLimit && y0 <= yUpperLimit) || (y1 >= yLowerLimit && y1 <= yUpperLimit)) && (x1 >= xLowerLimit && x1 <= xUpperLimit)) {
							if (y0 > yUpperLimit) {
								y0 = yUpperLimit;
							} else if (y0 < yLowerLimit) {
								y0 = yLowerLimit;
							}
							if (y1 > yUpperLimit) {
								y1 = yUpperLimit;
							} else if (y1 < yLowerLimit) {
								y1 = yLowerLimit;
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
				
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
				
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
						
						x0 = xf1;
						y0 = yf1;
						x1 = xf0;
						y1 = yf1;
				
						if (((x0 >= xLowerLimit && x0 <= xUpperLimit) || (x1 >= xLowerLimit && x1 <= xUpperLimit)) && (y1 >= yLowerLimit && y1 <= yUpperLimit)) {
							if (x0 > xUpperLimit) {
								x0 = xUpperLimit;
							} else if (x0 < xLowerLimit) {
								x0 = xLowerLimit;
							}
				
							if (x1 > xUpperLimit) {
								x1 = xUpperLimit;
							} else if (x1 < xLowerLimit) {
								x1 = xLowerLimit;
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
				
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
				
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
						
						x0 = xf0;
						y0 = yf1;
						x1 = xf0;
						y1 = yf0;
				
						if (((y0 >= yLowerLimit && y0 <= yUpperLimit) || (y1 >= yLowerLimit && y1 <= yUpperLimit)) && (x0 >= xLowerLimit && x0 <= xUpperLimit)) {
							if (y0 > yUpperLimit) {
								y0 = yUpperLimit;
							} else if (y0 < yLowerLimit) {
								y0 = yLowerLimit;
							}
							if (y1 > yUpperLimit) {
								y1 = yUpperLimit;
							} else if (y1 < yLowerLimit) {
								y1 = yLowerLimit;
							}
							
							xdiff = x1 - x0;
							ydiff = y1 - y0;
							steep = (ydiff < 0 ? -ydiff : ydiff) > (xdiff < 0 ? -xdiff : xdiff);
									
							if (steep) {
							  t = x0; x0 = y0; y0 = t;
							  t = x1; x1 = y1; y1 = t;
							}
							if (x0 > x1) {
								t = x0; x0 = x1; x1 = t;
								t = y0; y0 = y1; y1 = t;
							}
							
							
							dx = x1 - x0;
							dy = y1 - y0;
							gradient = dy / dx;
							
							// handle first endpoint
							xend = (0.5 + x0) | 0;
							yend = y0 + gradient * (xend - x0);
							xpxl1 = xend;   //this will be used in the main loop
							ypxl1 = yend | 0;
							
							fpart = yend - (yend | 0);
				
							if (steep) {
								dataIndex = dataWidth * xpxl1 + ypxl1 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl1 + xpxl1 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl1 + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
				
							intery = yend + gradient; // first y-intersection for the main loop
							
							// handle second endpoint
							xend = (0.5 + x1) | 0;
							yend = y1 + gradient * (xend - x1);
							xpxl2 = xend; //this will be used in the main loop
							ypxl2 = yend | 0;
							
							fpart = yend - (yend | 0);
							
							if (steep) {
								dataIndex = dataWidth * xpxl2 + ypxl2 * 4;
				
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (ypxl2 + 1 < xUpperLimit) {
									dataIndex += 4;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							} else {
								dataIndex = dataWidth * ypxl2 + xpxl2 * 4;
								
								alpha0 = plotData[dataIndex + 3] / 255;
								alpha1 = 1 - fpart;
								rAlpha0 = (1 - alpha0);
								rAlpha1 = (1 - alpha1);
				
								plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
								plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
								plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
								plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								
								if (y + 1 <= yUpperLimit) {
									dataIndex += dataWidth;
								
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
								}
							}
					
							// main loop
							
							for (x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
								y = intery | 0;
								fpart = intery - (intery | 0);
							
								if (steep) {
									dataIndex = dataWidth * x + y * 4;
					
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 < xUpperLimit) {
										dataIndex += 4;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								} else {
									dataIndex = dataWidth * y + x * 4;
									
									alpha0 = plotData[dataIndex + 3] / 255;
									alpha1 = 1 - fpart;
									rAlpha0 = (1 - alpha0);
									rAlpha1 = (1 - alpha1);
					
									plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
									plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
									plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
									plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									
									if (y + 1 <= yUpperLimit) {
										dataIndex += dataWidth;
									
										alpha0 = plotData[dataIndex + 3] / 255;
										alpha1 = fpart;
										rAlpha0 = (1 - alpha0);
										rAlpha1 = (1 - alpha1);
						
										plotData[dataIndex] = sr * rAlpha0 + (sr * alpha1 + plotData[dataIndex] * rAlpha1) * alpha0;
										plotData[dataIndex + 1] = sg * rAlpha0 + (sg * alpha1 + plotData[dataIndex+1] * rAlpha1) * alpha0;
										plotData[dataIndex + 2] = sb * rAlpha0 + (sb * alpha1 + plotData[dataIndex+2] * rAlpha1) * alpha0;
										plotData[dataIndex + 3] = (alpha0 + (1-alpha0) * alpha1) * 255;
									}
								}
					
							  intery = intery + gradient;
							}
						}
					}
				}
			}

		}

		tempCalcResult_u2p_x = tempCalcResult_u2p_y = tempCalcMin = tempCalcMax = null;
		dataIndex = j = newIndex = l = null;
		x = y = null;
	}

})(jQuery); 

/**
	jqPlot Custom Axes Plugin
	2013-04-02, Roy Choi
*/
(function($) {
    /**
     * Class: $.jqplot.CustomAxes
     * Plugin which will show with custom axes.
     */
    $.jqplot.CustomAxes = function(name, options) {
        // Group: Properties
        //
        //prop: enable
        // true to enable show with custom axes.
        this.enable = $.jqplot.config.enablePlugins;
        // prop: show
        // true to show with custom axes
        this.show  = false;
        // prop: columnIndex
        // index of custom axis in the point data
        this.columnIndex = null;
        // prop: location
        // 'top' or 'bottom'
        this.location = 'bottom';
        // prop: padding
        // 
        this.padding = 0;
        // prop: showTicks
        //
        //this.showTicks = false;
        // prop: showGridLine
        //
        this.showGridLine = false;
        // prop: renderer
        //
        this.renderer = $.jqplot.CustomAxes.LabelRenderer;
     // prop: markerOptions
        //
        this.rendererOptions = {};
        
        this.showTicks = false;
        this._ticks = null;
        
        this.onlyFirstSeries = false;
        
        this.gridLineColor = '#ccc';
        this.gridLineWidth = 1;
        
        this.fromCurrentMin = false;
        
        this.axis = 'xaxis';
        
        this.data = null;
        this.xaxis = 'xaxis';
        this.yaxis = 'yaxis';
        
        $.extend(true, this, options);
        
        this.name = name;
    };
    
    // axis.renderer.tickrenderer.formatter
    
    // called with scope of plot
    $.jqplot.CustomAxes.init = function (target, data, opts){
        var options = opts || {};
        this.plugins.customAxes = {
        	_labelElem: null,
        	_markElem: null,
        	_canvas: null,
        	axes: {}
        };
        
        for (var ax in options.customAxes) {
        	this.plugins.customAxes.axes[ax] = new $.jqplot.CustomAxes(ax, options.customAxes[ax]);
        }
    };

    // 
    $.jqplot.CustomAxes.postPlotDraw = function() {
    	var ca = this.plugins.customAxes;
    	
    	if (ca._labelElem) {
    		ca._labelElem.emptyForce();
    		ca._labelElem.remove();
    	}
    	if (ca._markElem) {
    		ca._markElem.emptyForce();
    		ca._markElem.remove();
    	}
    	
    	ca._labelElem = $('<div />');
    	ca._markElem = $('<div />');
    	
    	ca._labelElem.css({
    		width: this._plotDimensions.width - this._gridPadding.left - this._gridPadding.right,
    		height: this._plotDimensions.height - this._gridPadding.top - this._gridPadding.bottom,
    		position: 'absolute',
    		left: this._gridPadding.left+'px',
    		top: this._gridPadding.top+'px'
    	});
    	ca._markElem.css({
    		width: this._plotDimensions.width - this._gridPadding.left - this._gridPadding.right,
    		height: this._plotDimensions.height - this._gridPadding.top - this._gridPadding.bottom,
    		position: 'absolute',
    		overflow: 'hidden',
    		left: this._gridPadding.left+'px',
    		top: this._gridPadding.top+'px'
    	});
    	this.eventCanvas._elem.before(ca._labelElem);
    	this.eventCanvas._elem.before(ca._markElem);
    	
    	for (var ax in this.plugins.customAxes.axes) {
    		if(this.plugins.customAxes.axes[ax].show) {
    			this.plugins.customAxes.axes[ax].draw(this);
    		}
        }
    };
    
    $.jqplot.preInitHooks.push($.jqplot.CustomAxes.init);
    $.jqplot.postDrawHooks.push($.jqplot.CustomAxes.postPlotDraw);

	$.jqplot.CustomAxes.prototype.draw = function(plot) {
		if (/*this.enable && */this.show) {
			this.renderer.set.call(this, this.rendererOptions, plot);
			this.renderer.draw.call(this, plot);
		}
	};
	
	$.jqplot.CustomAxes.prototype.drawGridLine = function(points, plot) {
		var ctx;
		
		ctx = plot.grid._ctx;
		
		ctx.save();
		
		ctx.lineWidth = this.gridLineWidth;
		ctx.strokeStyle = this.gridLineColor;
		
		ctx.beginPath();
		ctx.moveTo(points[0][0], points[0][1]);
		ctx.lineTo(points[1][0], points[1][1]);
		
		ctx.stroke();
		ctx.restore();
		
		ctx = null;
	};
	
	$.jqplot.CustomAxes.MarkRenderer = function() {
	};
	
	$.jqplot.CustomAxes.MarkRenderer.set = function(opts) {
		this.size = opts.size || 5;
    	this.style = opts.style || 'filledSquare';
    	this.color = opts.color || 'rgba(0,0,0,0)';
    	this.lineWidth = opts.lineWidth || 3;
    	this.linePattern = opts.linePattern || 'solid';
    	this.lineJoin = opts.lineJoin || 'miter';
    	this.lineCap = opts.lineCap || 'round';
    	this.closePath = opts.closePath || false;
    	this.fill = opts.fill || false;
    	this.fillRect = opts.fillRect || false;
    	this.fillStyle = opts.fillStyle || null;
    	this.stroke = opts.stroke || false;
    	this.strokeRect = opts.strokeRect || false;
    	this.strokeStyle = opts.strokeStyle || null;
    	this.markFormatter = opts.markFormatter || null;
    	this.markCondition = opts.markCondition || function() {return false;};
    	this.fillToNext = opts.fillToNext === false ? false : true;
    	
    	this.shapeRenderer = new $.jqplot.ShapeRenderer();
    	
    	var shopt = {fill:false, isarc:false, stroke:false, strokeStyle:this.strokeStyle, fillStyle:this.color, lineWidth:this.lineWidth, closePath:true};
        if (this.style.indexOf('filled') != -1) {
            shopt.fill = true;
        }
        if (this.style.indexOf('ircle') != -1) {
            shopt.isarc = true;
            shopt.closePath = false;
        }

		if (this.stroke) {
			shopt.stroke = true;
			shopt.strokeStyle = this.strokeStyle;
		}
        this.shapeRenderer.init(shopt);
	};
	
    $.jqplot.CustomAxes.prototype.drawDiamond = function(mark, ctx, fill, options) {
        var stretch = 1.2;
        var x = mark.start + (mark.stop - mark.start)/2;
        var y = this.size / 2;
        var dx = this.size/2/stretch;
        var dy = this.size/2*stretch;
        var points = [[x-dx, y], [x, y+dy], [x+dx, y], [x, y-dy]];

        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.CustomAxes.prototype.drawPlus = function(mark, ctx, fill, options) {
        var stretch = 1.0;
        var x = mark.start + (mark.stop - mark.start)/2;
        var y = this.size / 2;
        var dx = this.size/2*stretch;
        var dy = this.size/2*stretch;
        var points1 = [[x, y-dy], [x, y+dy]];
        var points2 = [[x+dx, y], [x-dx, y]];
        var opts = $.extend(true, {}, this.options, {closePath:false});

        this.shapeRenderer.draw(ctx, points1, opts);
        this.shapeRenderer.draw(ctx, points2, opts);
    };
    
    $.jqplot.CustomAxes.prototype.drawX = function(mark, ctx, fill, options) {
        var stretch = 1.0;
        var x = mark.start + (mark.stop - mark.start)/2;
        var y = this.size / 2;
        var dx = this.size/2*stretch;
        var dy = this.size/2*stretch;
        var opts = $.extend(true, {}, this.options, {closePath:false});
        var points1 = [[x-dx, y-dy], [x+dx, y+dy]];
        var points2 = [[x-dx, y+dy], [x+dx, y-dy]];

        this.shapeRenderer.draw(ctx, points1, opts);
        this.shapeRenderer.draw(ctx, points2, opts);
    };
    
    $.jqplot.CustomAxes.prototype.drawDash = function(mark, ctx, fill, options) {
        var stretch = 1.0;
        var x = mark.start + (mark.stop - mark.start)/2;
        var y = this.size / 2;
        var dx = this.size/2*stretch;
        var dy = this.size/2*stretch;
        var points = [[x-dx, y], [x+dx, y]];

        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.CustomAxes.prototype.drawLine = function(mark, ctx, fill, options) {
    	var y = this.size / 2;
    	var p1 = [mark.start, y];
    	var p2 = [mark.stop, y];
        var points = [p1, p2];

        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.CustomAxes.prototype.drawSquare = function(mark, ctx, fill, options) {
        var points = [[mark.start, 0], [mark.start, this.size], [mark.stop, this.size], [mark.stop, 0]];

        this.shapeRenderer.draw(ctx, points, options);
    };
    
    $.jqplot.CustomAxes.prototype.drawCircle = function(mark, ctx, fill, options) {
    	var y = this.size / 2;
        var radius = this.size/2;
        var end = 2*Math.PI;
        var points = [mark.x, y, radius, 0, end, true];

        this.shapeRenderer.draw(ctx, points, options);
    };
	
	$.jqplot.CustomAxes.MarkRenderer.draw = function(plot) {
		if (typeof this.markCondition != 'function' || plot.data.length <= 0) {
			return;
		}
		
		var series = plot.series;
		var i, j, sd, min, max;

		var start = false;
		var condition;
		var mark;
		
		this._canvas = new $.jqplot.GenericCanvas();
		
		var gridPadding = {
			left: plot._gridPadding.left,
			right: plot._gridPadding.right,
			top: plot._gridPadding.top+(this.location=='top'?-this.padding:0),
			bottom: plot._gridPadding.bottom+(this.location=='bottom'?this.padding:0)
		};

		plot.grid.canvas._elem.before(this._canvas.createElement(gridPadding, 'jqplot-customaxes-canvas',
				{width:plot._plotDimensions.width, height: this.size+gridPadding.top+gridPadding.bottom}, plot));
		this._canvas.setContext();
		
		this._canvas._elem.css({
			position: 'absolute'
		});
		
		var ctx = this._canvas._ctx;
		ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
		
		if (this.color && !this.fillStyle) {
            this.fillStyle = this.color;
        }
        if (this.color && !this.strokeStyle) {
        	this.strokeStyle = this.color;
        }
        
        var drawFunction;
        var fill;
        
    	switch (this.style) {
	        case 'diamond':
	        	drawFunction = this.drawDiamond;
	        	fill = false;
	            break;
	        case 'filledDiamond':
	            drawFunction = this.drawDiamond;
	        	fill = true;
	            break;
	        case 'circle':
	            drawFunction = this.drawCircle;
	        	fill = false;
	            break;
	        case 'filledCircle':
	            drawFunction = this.drawCircle;
	        	fill = true;
	            break;
	        case 'square':
	            drawFunction = this.drawSquare;
	        	fill = false;
	            break;
	        case 'filledSquare':
	            drawFunction = this.drawSquare;
	        	fill = true;
	            break;
	        case 'x':
	            drawFunction = this.drawX;
	        	fill = true;
	            break;
	        case 'plus':
	            drawFunction = this.drawPlus;
	        	fill = true;
	            break;
	        case 'dash':
	            drawFunction = this.drawDash;
	        	fill = true;
	            break;
	        case 'line':
	            drawFunction = this.drawLine;
	        	fill = false;
	            break;
	        default:
		        drawFunction = this.drawSquare;
		    	fill = true;
	            break;
    	}
    	
    	var draw = function(mark) {
    		if (this.fillToNext && mark.stop - mark.start < 1) {
        		mark.stop = mark.start + 1;
        	}
        	drawFunction.call(this, mark, ctx, fill, this);
    	};
		
		for(i=0; i<series.length; i++) {
			sd = series[i].data;
			
			min = plot.axes[series[i].xaxis].min;
			max = plot.axes[series[i].xaxis].max;
			
			mark = {
				x: null,
				start: null,
				stop: null
			};
			
			for(j=0; j<sd.length; j++) {
				if (min !== null && sd[j][0] < min) {
					continue;
				} else if (max !== null && max < sd[j][0]) {
					break;
				}
				
				condition = this.markCondition.call(this, sd[j][this.columnIndex]);
				
				if (start  && !condition) {
					mark.stop = series_u2p(sd[j][0])-plot._gridPadding.left;
					draw.call(this, mark);
					mark = {
						start: null,
						stop: null
					};
					start = false;
				} else if (!start && condition) {
					mark.x = series_u2p(sd[j][0])-plot._gridPadding.left;
					mark.start = mark.x;
					if (!this.fillToNext) {
						mark.start -= this.size / 2;
						mark.stop = mark.start + this.size;
						draw.call(this, mark);
						mark = {
							start: null,
							stop: null
						};
						start = false;
					} else {
						start = true;
					}
				}
			}
			
			if (typeof mark.start === 'number' && !mark.stop) {
				mark.stop = mark.start+this.size;
				draw.call(this, mark);
			}
			
			mark = null;
		}
        
        ctx = drawFunction = fill = null;

	};
	
	$.jqplot.CustomAxes.LabelRenderer = function() {
	};
	
	$.jqplot.CustomAxes.LabelRenderer.set = function(opts, plot) {
      this.mergedLabel = opts.mergedLabel === false ? false : true;
      this.labelStyle = opts.labelStyle || null;
      this.labelAlign = opts.labelAlign || 'middle';
      this.formatter = opts.formatter || null;
      this.showLabel = opts.showLabel === false ? false : true;
      this.labelType = opts.labelType || 'single';
      this.labelOffset = $.extend(true, {top: 0, left: 0}, opts.labelOffset ? opts.labelOffset : {});
      this.selectArea = {
      	height: 0,
      	show: false,
      	color: '#ccc',
      	lineColor: '#fff',
      	selectedColor: {},
      	fitLabel: true,
      	toggleBodyEvent: null,
      	toggleSelect: null,
      	selected: []
      };
      
      this.tooltip = {
          show: true,
          enableHtml: false,
          formatter: undefined,
          delayTime: 500,
          waitTime: 3000,
          fadeOut: 1000,
          fadeIn: 0,
          followMouse: false,
          style: {}
      };
      $.extend(true, this.tooltip, opts.tooltip);
      
      $.extend(true, this.selectArea, opts.selectArea);
      this.selectArea.selectBlocks = [];
    	if (this.selectArea.show && (this.onlyFirstSeries || $.isArray(this.data)) && this.mergedLabel && this.labelType === 'block') {
    		this._canvas = new $.jqplot.GenericCanvas();
    		var gridPadding = {
                top: plot._gridPadding.top - this.selectArea.height,
                left: plot._gridPadding.left,
                right: plot._gridPadding.right,
                bottom: plot._plotDimensions.height - plot._gridPadding.top
            };
            
    		plot.grid._elem.after(this._canvas.createElement(gridPadding, 'jqplot-customaxes-canvas', plot._plotDimensions, plot));
    		
    		this._canvas.setContext();
    		this._canvas._elem.bind('selectstart', false);
    		
    		if (this.location === 'bottom') {
                this._canvas._elem.css({
                    top: 'inherit',
                    bottom: this.padding + 'px'
                });
            }
    	}
	};
	
	$.jqplot.CustomAxes.LabelRenderer.fillBlock = function(x1, x2, color) {
		var ctx = this._canvas._ctx;
		
		ctx.save();
		
		ctx.fillStyle = color;
		
		ctx.fillRect(x1, 0, x2-x1, ctx.canvas.height, color);
		
		ctx.restore();
		ctx = null;
	};
	
    $.jqplot.CustomAxes.LabelRenderer.showTooltip = function(ev, index, selectedBlocks, plot) {
        var ca = plot.plugins.customAxes;
        
        if (!this.tooltip.show || (!this.tooltip.followMouse && ca._tooltipCache && ca._tooltipCache.name === this.name && ca._tooltipCache.index === index)) {
            return;
        }
        
        if (ca._tooltipTimeout) {
            clearTimeout(ca._tooltipTimeout);
            ca._tooltipTimeout = null;
        }
        if (ca._tooltipElem) {
            ca._tooltipCache = null;
            ca._tooltipElem.remove();
        }
        
        var tooltip = this.tooltip;
        var name = this.name;
        var str = selectedBlocks[index].data[this.columnIndex];
        
        var elem = $('<div></div>');
        elem.addClass('jqplot-custom-axes-tooltip');
        elem.css({
            display: 'none'
        });
        if (typeof tooltip.style === 'string') {
            elem.addClass(tooltip.style);
        } else if ($.isPlainObject(tooltip.style)) {
            elem.css(tooltip.style);
        }
        
        if ($.isFunction(tooltip.formatter)) {
            str = tooltip.formatter(ev, str, this, plot);
        }
        
        if (tooltip.enableHtml) {
            elem.html(str);
        }  else {
            elem.text(str);
        }
        
        ca._labelElem.append(elem);
        
        elem.offset({
            top: ev.offsetY - plot._gridPadding.top - elem.height() - 3,
            left: ev.offsetX + 3
        });
        
        ca._tooltipElem = elem;
        
        ca._tooltipTimeout = setTimeout(function() {
            ca._tooltipCache = {
                name: name,
                index: index
            };
            
            elem.fadeIn(tooltip.fadeIn);
            
            ca._tooltipTimeout = setTimeout(function() {
                elem.fadeOut(tooltip.fadeOut);
                ca._tooltipCache = null;
            }, tooltip.waitTime);
        }, tooltip.delayTime);
        
        
    };
	
	$.jqplot.CustomAxes.LabelRenderer.onMouseOver = function(ev, xaxis, selectArea, plot) {
        var series_p2u = xaxis.series_p2u,
            series_u2p = xaxis.series_u2p,
            selectBlocks = selectArea.selectBlocks,
            l = selectBlocks.length,
            last = l - 1,
            nextX, next,
            go = this._canvas._elem.offset(),
            eventX = ev.pageX - go.left,
            ca = plot.plugins.customAxes;

        for (var i = 0 ; i < l; i++) {
            if (i === 0 && eventX < selectBlocks[i].x) {
                break;
            }
            
            nextX = (i === last) ? this._canvas._ctx.canvas.width - 1 : selectBlocks[i+1].x;
            next = (i === last) ? plot.axes.xaxis.max : selectBlocks[i+1].data[0];
            
            if (eventX >= selectBlocks[i].x && eventX < nextX) {
				// customizing 2017-04-18, Smith Kim
				// add 'onMouseOver' event
				if (typeof this.tooltip.onMouseOver === 'function') {
					this.tooltip.onMouseOver.call(this, ev, i, selectBlocks, plot);
				}
                this.renderer.showTooltip.call(this, ev, i, selectBlocks, plot);
                return;
            }
        }
        
        ca._tooltipElem.remove();
        if (ca._tooltipTimeout) {
            clearTimeout(ca._tooltipTimeout);
        }
	};
	
	$.jqplot.CustomAxes.LabelRenderer.onMouseOut = function(ev, plot) {
	    var ca = plot.plugins.customAxes;
        
        if (ca._tooltipTimeout && ca._tooltipElem.is(':hidden')) {
            clearTimeout(ca._tooltipTimeout);
            ca._tooltipTimeout = null;
        }

		// customizing 2017-04-18, Smith Kim
		// add 'onMouseOut' event
		if (typeof this.tooltip.onMouseOut === 'function') {
			this.tooltip.onMouseOut.call(this, ev, plot);
		}
	};
	
	$.jqplot.CustomAxes.LabelRenderer.onSelectBlock = function(ev, xaxis, selectArea, plot) {
		var series_p2u = xaxis.series_p2u;
		var series_u2p = xaxis.series_u2p;
	
		var selectBlocks = selectArea.selectBlocks;
		var l = selectBlocks.length;
		var last = l - 1;
		var nextX, next;
		
		var go = this._canvas._elem.offset();
		
		var eventX = ev.pageX - go.left;

		for (var i = 0 ; i < l; i++) {
			if (i === 0 && eventX < selectBlocks[i].x) {
				return;
			}
			
			nextX = (i === last) ? this._canvas._ctx.canvas.width - 1 : selectBlocks[i+1].x;
			next = (i === last) ? plot.axes.xaxis.max : selectBlocks[i+1].data[0];
			
			if (eventX >= selectBlocks[i].x && eventX < nextX) {
				selectBlocks[i].selected = !selectBlocks[i].selected;
				if (selectBlocks[i].selected) {
					this.renderer.fillBlock.call(this, selectBlocks[i].x + 2, nextX - 2, selectArea.selectedColor);
				} else {
					this.renderer.fillBlock.call(this, selectBlocks[i].x + 1, nextX - 1, selectArea.color);
				}
				
				if ($.isFunction(selectArea.toggleSelect)) {
					selectArea.toggleSelect.call(this, ev, selectBlocks[i].selected, {
						start: selectBlocks[i].data[0],
						next: next
					}, selectBlocks[i].pointIndex, selectBlocks[i].seriesIndex, selectBlocks[i].data, plot);
				}
				return;
			}
		}
	};
	
	$.jqplot.CustomAxes.LabelRenderer.drawSelectAreaLine = function(x, color, plot) {
		var ctx;
		
		ctx = this._canvas._ctx;
		
		ctx.save();

		ctx.lineWidth = 1;
		ctx.strokeStyle = color;
		
		ctx.beginPath();
		ctx.moveTo(x, 0);
		ctx.lineTo(x, ctx.canvas.height);
		
		ctx.stroke();
		ctx.restore();
		
		ctx = null;
	};
	
	$.jqplot.CustomAxes.LabelRenderer.findNext = function(data, currentIndex) {
	    var columnIndex = this.columnIndex,
	        current = data[currentIndex][columnIndex],
	        next = currentIndex + 1;
	       
	    for (; next < data.length; next++) {
	        if (data[next][columnIndex] !== current) {
	            return next;
	        }
	    }
	    
	    return -1;
	};
	
	$.jqplot.CustomAxes.LabelRenderer.draw = function(plot) {
		var series = plot.series;
		var i, j, sd, min, max;
		var lastValue = null;
		var lastData = null;

		var css = {
				position: 'absolute',
				overflowX: 'hidden',
				pointerEvents: 'none'
			};
		
		var x, xaxis, yaxis, yMin, yMax;
		var series_u2p = null;
		var selectArea = this.selectArea;
		var str;
		var elem;
		var columnIndex = this.columnIndex;
		var renderer = this.renderer;
		var self = this;
		var align, axis;
		var gridPadding = plot._gridPadding;
		var ctx;
		
		var axisIndex = this.axis === 'xaxis' ? 0 : 1;
		
		// TODO: support yaxis
		if ($.isArray(this.data)) {
			if (this.data.length === 0 || series.length === 0) {
				return;
			}
			
			sd = this.data;
			
			xaxis = plot.axes[this.xaxis];
			series_u2p = xaxis.u2p;
			yaxis = plot.axes[this.yaxis];
			
			min = plot.axes[this.axis].min;
			max = plot.axes[this.axis].max;
			
			if (selectArea.show && this.mergedLabel && this.labelType === 'block') {
				this._canvas._elem.on('click', function(ev) {
					renderer.onSelectBlock.call(self, ev, xaxis, selectArea, plot);
				});
				
				this._canvas._elem.on('mouseover mousemove', function(ev) {
				    if ($.isFunction(renderer.onMouseOver)) {
				        renderer.onMouseOver.call(self, ev, xaxis, selectArea, plot);
				    }
                });
                
                this._canvas._elem.on('mouseout', function(ev) {
                    if ($.isFunction(renderer.onMouseOut)) {
                        renderer.onMouseOut.call(self, ev, plot);
                    }
                });
				
    		    ctx = this._canvas._ctx;
				ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);

				ctx.fillStyle = this.selectArea.color;
				
				ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
				ctx.restore();
			}
			
			for(j=0; j<sd.length; j++) {
				if ( sd[j][columnIndex] === null || (this.mergedLabel && lastValue === sd[j][columnIndex])) {
					continue;
				}
				
				x = series_u2p(sd[j][axisIndex] === 'min' ? min :  sd[j][axisIndex]);
				
                if (selectArea.show && (this.onlyFirstSeries || $.isArray(this.data)) && this.mergedLabel && this.labelType === 'block') {
                  selectArea.selectBlocks.push({
                    selected: false,
                    pointIndex: j,
                    seriesIndex: i,
                    data: sd[j],
                    x: x - gridPadding.left
                  });
                  
                  renderer.drawSelectAreaLine.call(this, x - gridPadding.left, selectArea.lineColor, plot);
                }
				
				if ( min !== null && sd[j][axisIndex] < min ) {
					lastValue = sd[j][columnIndex];
					continue;
				} else if (max !== null && max < sd[j][axisIndex]) {
					break;
				}
				
				str = '';
				if (typeof this.formatter === 'function') {
					str = this.formatter.call(this, sd[j][columnIndex], sd[j]);
					if (str === false) {
						continue;
					}
				} else {
					str = sd[j][columnIndex];
				}

				if (this.showLabel) {
					var elem = $('<div />');
                    var nextIndex = renderer.findNext.call(this, sd, j);
                    var nextStart;
                    if (nextIndex < 0 || series_u2p(sd[nextIndex][axisIndex]) > series_u2p(max)) {
                        nextStart = series_u2p(max);
                    } else {
                        nextStart = series_u2p(sd[nextIndex][axisIndex]);
                    }
					
					elem.html(str);
					
					elem.addClass('jqplot-axis jqplot-custom-axis-'+this.name);
					elem.css(css);
					if (selectArea.fitLabel) {
					    elem.width(nextStart - x - this.labelOffset.left - 2);
					}
					
					if (this.labelStyle && typeof this.labelStyle === 'object') {
						elem.css(this.labelStyle);
					} else if (typeof this.labelStyle === 'string') {
						elem.addClass(this.labelStyle);
					}
					elem.appendTo(plot.plugins.customAxes._labelElem);
					
					switch(this.labelAlign) {
                        case 'center':
                            align = plot.target.offset().left + x + (nextStart - x) / 2 - elem.outerWidth()/2;
                            break;
                        case 'right':
                            align = plot.target.offset().left + nextStart  - elem.outerWidth();
                            break;
                        case 'left':
                            align = plot.target.offset().left + x;
                            break;
                        case 'middle':
                            align = plot.target.offset().left + x - elem.outerWidth()/2;
                            break;
                        case 'end':
                            align = plot.target.offset().left + x - elem.outerWidth();
                            break;
                        case 'start':
                        default:
                            align = plot.target.offset().left + x;
                            break;
                    }
					
					elem.offset({
						top: this.location === 'bottom' ? plot.target.outerHeight() - this.padding + this.labelOffset.top : plot.grid._elem.offset().top + this.labelOffset.top
                                 + (plot.legend.location === 'n' ? plot.legend._elem.outerHeight(true) + 10 : 0),
						left: align + this.labelOffset.left
					});
				}

				if (this.showGridLine) {
					yMin = yaxis.u2p(yaxis.min);
					yMax = yaxis.u2p(yaxis.max);
					
					this.drawGridLine([[x, yMin], [x, yMax]], plot);
				}
				
				lastValue = sd[j][columnIndex];
			}

			lastValue = null;
			lastData = null;
		} else {
			var l = this.onlyFirstSeries ? Math.min(1, series.length) : series.length;
			for(i=0; i<l; i++) {
				sd = series[i].data;
				
				xaxis = plot.axes[series[i].xaxis];
				series_u2p = xaxis.u2p;
				yaxis = plot.axes[series[i].yaxis];
				
				min = plot.axes[series[i][this.axis]].min;
				max = plot.axes[series[i][this.axis]].max;
				
				if (i===0 && selectArea.show && this.onlyFirstSeries && this.mergedLabel && this.labelType === 'block') {
					series_xaxis = plot.axes[series[i].xaxis];
					
					this._canvas._elem.bind('click', function(ev) {
						renderer.onSelectBlock.call(self, ev, series_xaxis, selectArea, plot);
					});
					
	    		ctx = this._canvas._ctx;
					ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
	
					ctx.fillStyle = this.selectArea.color;
					
					ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
					ctx.restore();
				}
				
				for(j=0; j<sd.length; j++) {
					if ( sd[j][columnIndex] === null || (this.mergedLabel && lastValue === sd[j][columnIndex])) {
						continue;
					}
					
					x = series_u2p(sd[j][axisIndex] === 'min' ? min :  sd[j][axisIndex]);
					
                    if (selectArea.show && this.onlyFirstSeries && this.mergedLabel && this.labelType === 'block') {
                      
                      selectArea.selectBlocks.push({
                        selected: false,
                        pointIndex: j,
                        seriesIndex: i,
                        data: sd[j],
                        x: x - gridPadding.left
                      });
                      
                      renderer.drawSelectAreaLine.call(this, x - gridPadding.left, selectArea.lineColor, plot);
                    }
					
					if ( min !== null && sd[j][axisIndex] < min ) {
						lastValue = sd[j][columnIndex];
						continue;
					} else if (max !== null && max < sd[j][axisIndex]) {
						break;
					}
					
					str = '';
					if (typeof this.formatter === 'function') {
						str = this.formatter.call(this, sd[j][columnIndex], sd[j]);
						if (str === false) {
							continue;
						}
					} else {
						str = sd[j][columnIndex];
					}
	
					gridPadding = plot._gridPadding;
	
					if (this.showLabel) {
						var elem = $('<div />');
                        var nextIndex = renderer.findNext.call(this, sd, j);
                        var nextStart;
                        if (nextIndex < 0 || series_u2p(sd[nextIndex][axisIndex]) > series_u2p(max)) {
                            nextStart = series_u2p(max);
                        } else {
                            nextStart = series_u2p(sd[nextIndex][axisIndex]);
                        }
						
						elem.html(str);
						
						elem.addClass('jqplot-axis jqplot-custom-axis-'+this.name);
						elem.css(css);
						elem.width(nextStart - x - this.labelOffset.left - 2);
						if (selectArea.fitLabel) {
                            elem.width(nextStart - x - this.labelOffset.left - 2);
                        }
                        
						if (this.labelStyle && typeof this.labelStyle === 'object') {
							elem.css(this.labelStyle);
						} else if (typeof this.labelStyle === 'string') {
							elem.addClass(this.labelStyle);
						}
						elem.appendTo(plot.plugins.customAxes._labelElem);
						
                        switch(this.labelAlign) {
                            case 'center':
                                align = plot.target.offset().left + x + (nextStart - x) / 2 - elem.outerWidth()/2;
                                break;
                            case 'right':
                                align = plot.target.offset().left + nextStart  - elem.outerWidth();
                                break;
                            case 'left':
                                align = plot.target.offset().left + x;
                                break;
                            case 'middle':
                                align = plot.target.offset().left + x - elem.outerWidth()/2;
                                break;
                            case 'end':
                                align = plot.target.offset().left + x - elem.outerWidth();
                                break;
                            case 'start':
                            default:
                                align = plot.target.offset().left + x;
                                break;
                        }
	
						elem.offset({
							top: this.location === 'bottom' ? plot.target.outerHeight() - this.padding + this.labelOffset.top : plot.grid._elem.offset().top + this.labelOffset.top
							     + (plot.legend.location === 'n' ? plot.legend._elem.outerHeight(true) + 10 : 0),
							left: align + this.labelOffset.left
						});
					}

					if (this.showGridLine) {
						yMin = yaxis.u2p(yaxis.min);
						yMax = yaxis.u2p(yaxis.max);
						
						this.drawGridLine([[x, yMin], [x, yMax]], plot);
					}
					
					lastValue = sd[j][columnIndex];
				}
	
				lastValue = null;
				lastData = null;
			}
		}

	};

})(jQuery);
/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can
 * choose the license that best suits your project and use it accordingly.
 *
 * Although not required, the author would appreciate an email letting him
 * know of any substantial use of jqPlot.  You can reach the author at:
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 *
 */
(function($) {
	var objCounter = 0;
	// class: $.jqplot.CanvasOverlay
	$.jqplot.CanvasOverlay = function(opts) {
		var options = opts || {};
		this.options = {
			show : $.jqplot.config.enablePlugins,
			deferDraw : false
			//outsideDraw : false, // customizing for outside tooltip (2013-03-05, Roy Choi)
			//outsideDirection : null
		};
		// prop: objects
		this.objects = [];
		this.objectNames = [];
		this.canvas = null;
		this.markerRenderer = new $.jqplot.MarkerRenderer({
			style : 'line'
		});
		this.markerRenderer.init();
		this.highlightObjectIndex = null;

		this.bcanvas = null;
		// customizing
		//this.outsideCanvas = null;
		// customizing for outside tooltip (2013-03-09, Roy Choi)
		//this.outsideBCanvas = null;
		// customizing for outside tooltip (2013-03-09, Roy Choi)
		this._neighbor = null;
		this.isDragging = false;
		//this.preZoomStatus = [];
		//this._paddingDirection = null;
		// customizing for outside tooltip (2013-03-06, Roy Choi)
		//this._paddingWidth = 0;
		// customizing for outside tooltip (2013-03-06, Roy Choi)
		this._oldHandlers = {};
		
		this._prevCursorShow = false;

		if (options.objects) {
			var objs = options.objects, obj;
			for (var i = 0; i < objs.length; i++) {
				obj = objs[i];
				for (var n in obj) {
					switch (n) {
						case 'line':
							this.addLine(obj[n]);
							break;
						case 'horizontalLine':
							this.addHorizontalLine(obj[n]);
							break;
						case 'dashedHorizontalLine':
							this.addDashedHorizontalLine(obj[n]);
							break;
						case 'verticalLine':
							this.addVerticalLine(obj[n]);
							break;
						case 'dashedVerticalLine':
							this.addDashedVerticalLine(obj[n]);
							break;
						case 'rectangle':
							this.addRectangle(obj[n]);
							break;
                        case 'circle':
                            this.addCircle(obj[n]);
						default:
							break;
					}
				}
			}
		}
		$.extend(true, this.options, options);
	};

	// called with scope of a plot object
	$.jqplot.CanvasOverlay.postPlotInit = function(target, data, opts) {
		var options = opts || {};
		// add a canvasOverlay attribute to the plot
		this.plugins.canvasOverlay = new $.jqplot.CanvasOverlay(options.canvasOverlay);
	};

	// customizing
	function ShapeBase() {
		this.uid = null;
		this.type = null;
		this.gridStart = null;
		this.gridStop = null;
		this.tooltipWidthFactor = 0;
		this.draggableArrows = [];
		this.options = {
			// prop: name
			// Optional name for the overlay object.
			// Can be later used to retrieve the object by name.
			name : null,
			// prop: show
			// true to show (draw), false to not draw.
			show : true,
			// prop: lineWidth
			// Width of the line.
			lineWidth : 2,
			// prop: lineCap
			// Type of ending placed on the line ['round', 'butt', 'square']
			lineCap : 'round',
			// prop: color
			// color of the line
			color : '#666666',
			// prop: shadow
			// wether or not to draw a shadow on the line
			shadow : true,
			// prop: shadowAngle
			// Shadow angle in degrees
			shadowAngle : 45,
			// prop: shadowOffset
			// Shadow offset from line in pixels
			shadowOffset : 1,
			// prop: shadowDepth
			// Number of times shadow is stroked, each stroke offset shadowOffset from the last.
			shadowDepth : 3,
			// prop: shadowAlpha
			// Alpha channel transparency of shadow.  0 = transparent.
			shadowAlpha : '0.07',
			// prop: xaxis
			// X axis to use for positioning/scaling the line.
			xaxis : 'xaxis',
			// prop: yaxis
			// Y axis to use for positioning/scaling the line.
			yaxis : 'yaxis',
			// prop: showTooltip
			// Show a tooltip with data point values.
			showTooltip : false,
			// prop: showTooltipPrecision
			// Controls how close to line cursor must be to show tooltip.
			// Higher number = closer to line, lower number = farther from line.
			// 1.0 = cursor must be over line.
			showTooltipPrecision : 0.6,
			// prop: tooltipLocation
			// Where to position tooltip, 'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'
			tooltipLocation : 'nw',
			// prop: fadeTooltip
			// true = fade in/out tooltip, flase = show/hide tooltip
			fadeTooltip : true,
			// prop: tooltipFadeSpeed
			// 'slow', 'def', 'fast', or number of milliseconds.
			tooltipFadeSpeed : "fast",
			// prop: tooltipOffset
			// Pixel offset of tooltip from the highlight.
			tooltipOffset : 4,
			// prop: tooltipFormatString
			// Format string passed the x and y values of the cursor on the line.
			// e.g., 'Dogs: %.2f, Cats: %d'.
			tooltipFormatString : '%d, %d',
			
			// overlay or underlay
			isBackground : false,
			isFullLine : false,
			fillBehind : false
		};
	}

	// customizing
	function LineBase() {
		ShapeBase.call(this);
		
		this.cursor = [];
		this.isOver = false;

		var opts = {
			// customizing (2011-11-03, Roy Choi)
			// dragable line
			isDraggable : false,
			dragable : {
				color : 'rgba(200,200,200,0.5)',
				constrainTo : 'y',
				min: null,
				max: null,
				afterRedraw : null,
				notifyOnDrag : false,		// customizing (2013-03-07, Roy Choi)
				showArrow: false,
				arrowOptions: {
				  gapWidth: 3,
				  width: 10,
				  height: 10,
          showHighArrow: false,
          showLowArrow: false,
          stroke: false,
          strokeWidth: 1,
          fill: true,
          color: null,
          fillStyle: null
				}
			},
			fillArea : false,
			fillStyle : null,
			fillToValue : 0,
			fillToMax : false,
			fillToMin : false,
			fillToBind : null,
			showLabel: false,
      labelOptions: {
        formatter: null,
        classes: '',
        location: '',
        offset: {
          top: 0,
          left: 0
        }
      }
			/*
			 observableKey : null, // customizing (2013-03-06, Roy Choi)
			 _observableKey : null,
			 _observableSubscription : null, // customizing (2013-03-06, Roy Choi)
			 showOutsideTooltip : false, // customizing (2013-03-06, Roy Choi)
			 outsideTooltipElem : null, // customizing (2013-03-06, Roy Choi)
			 outsideTooltipEditable : false, // customizing (2013-03-06, Roy Choi)
			 outsideTooltipStyle : {}, // customizing (2013-03-06, Roy Choi)
			 outsideTooltipFormatter : null	// customizing (2013-03-07, Roy Choi)*/

		};

		$.extend(true, this.options, opts);
	}

	function Rectangle(options) {
		ShapeBase.call(this);
		this.type = 'rectangle';
		var opts = {
			// prop: xmin
			// x value for the start of the line, null to scale to axis min.
			xmin : null,
			// prop: xmax
			// x value for the end of the line, null to scale to axis max.
			xmax : null,
			// prop xOffset
			// offset ends of the line inside the grid. Number
			xOffset : '6px', // number or string. Number interpreted as units, string as pixels.
			xminOffset : null,
			xmaxOffset : null,

			ymin : null,
			ymax : null,
			yOffset : '6px', // number or string. Number interpreted as units, string as pixels.
			yminOffset : null,
			ymaxOffset : null,
			
			// customizing (2014-04-16, Roy Choi)
			xminBind: null,
			xmaxBind: null,
			yminBind: null,
			ymaxBind: null
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}

	// customizing (2015-04-20, Carrie bae)
    function Circle(options) {
        ShapeBase.call(this);
        this.type = 'circle';
        var opts = {
            // prop: xmin
            // x value for the start of the line, null to scale to axis min.
            xmin : null,
            // prop: xmax
            // x value for the end of the line, null to scale to axis max.
            xmax : null,
            // prop xOffset
            // offset ends of the line inside the grid. Number
            xOffset : '6px', // number or string. Number interpreted as units, string as pixels.
            xminOffset : null,
            xmaxOffset : null,

            ymin : null,
            ymax : null,
            yOffset : '6px', // number or string. Number interpreted as units, string as pixels.
            yminOffset : null,
            ymaxOffset : null,
            
            // customizing (2014-04-16, Roy Choi)
            xminBind: null,
            xmaxBind: null,
            yminBind: null,
            ymaxBind: null,
            color:null,
            fillColor: null
        };
        $.extend(true, this.options, opts, options);

        if (this.options.showTooltipPrecision < 0.01) {
            this.options.showTooltipPrecision = 0.01;
        }
    } 

	/**
	 * Class: Line
	 * A straight line.
	 */
	function Line(options) {
		LineBase.call(this);
		this.type = 'line';
		var opts = {
			// prop: start
			// [x, y] coordinates for the start of the line.
			start : [],
			// prop: stop
			// [x, y] coordinates for the end of the line.
			stop : []
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	Line.prototype = new LineBase();
	Line.prototype.constructor = Line;

	/**
	 * Class: HorizontalLine
	 * A straight horizontal line.
	 */
	function HorizontalLine(options) {
		LineBase.call(this);
		this.type = 'horizontalLine';
		var opts = {
			// prop: y
			// y value to position the line
			y : null,
			// prop: xmin
			// x value for the start of the line, null to scale to axis min.
			xmin : null,
			// prop: xmax
			// x value for the end of the line, null to scale to axis max.
			xmax : null,
			// prop xOffset
			// offset ends of the line inside the grid.  Number
			xminBind : null,
			xmaxBind : null,
			xOffset : '6px', // number or string.  Number interpreted as units, string as pixels.
			xminOffset : null,
			xmaxOffset : null,
      labelOptions: {
        location: 'right'   // right | left | center
      }
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	HorizontalLine.prototype = new LineBase();
	HorizontalLine.prototype.constructor = HorizontalLine;

	/**
	 * Class: DashedHorizontalLine
	 * A straight dashed horizontal line.
	 */
	function DashedHorizontalLine(options) {
		LineBase.call(this);
		this.type = 'dashedHorizontalLine';
		var opts = {
			y : null,
			xmin : null,
			xmax : null,
			xminBind : null,
			xmaxBind : null,
			xOffset : '6px', // number or string.  Number interpreted as units, string as pixels.
			xminOffset : null,
			xmaxOffset : null,
			// prop: dashPattern
			// Array of line, space settings in pixels.
			// Default is 8 pixel of line, 8 pixel of space.
			// Note, limit to a 2 element array b/c of bug with higher order arrays.
			dashPattern : [8, 8],
      labelOptions: {
        location: 'right'   // right | left | center
      }
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	DashedHorizontalLine.prototype = new LineBase();
	DashedHorizontalLine.prototype.constructor = DashedHorizontalLine;

	/**
	 * Class: VerticalLine
	 * A straight vertical line.
	 */
	function VerticalLine(options) {
		LineBase.call(this);
		this.type = 'verticalLine';
		var opts = {
			x : null,
			ymin : null,
			ymax : null,
			yOffset : '6px', // number or string.  Number interpreted as units, string as pixels.
			yminOffset : null,
			ymaxOffset : null,
      labelOptions: {
        location: 'top'   // top | bottom | middle
      }
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	VerticalLine.prototype = new LineBase();
	VerticalLine.prototype.constructor = VerticalLine;

	/**
	 * Class: DashedVerticalLine
	 * A straight dashed vertical line.
	 */
	function DashedVerticalLine(options) {
		LineBase.call(this);
		this.type = 'dashedVerticalLine';
		this.start = null;
		this.stop = null;
		var opts = {
			x : null,
			ymin : null,
			ymax : null,
			yOffset : '6px', // number or string.  Number interpreted as units, string as pixels.
			yminOffset : null,
			ymaxOffset : null,
			// prop: dashPattern
			// Array of line, space settings in pixels.
			// Default is 8 pixel of line, 8 pixel of space.
			// Note, limit to a 2 element array b/c of bug with higher order arrays.
			dashPattern : [8, 8],
      labelOptions: {
        location: 'top'   // top | bottom | middle
      }
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	DashedVerticalLine.prototype = new LineBase();
	DashedVerticalLine.prototype.constructor = DashedVerticalLine;

	$.jqplot.CanvasOverlay.prototype.addLine = function(opts) {
		var line = new Line(opts);
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasOverlay.prototype.addHorizontalLine = function(opts) {
		var line = new HorizontalLine(opts);
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasOverlay.prototype.addDashedHorizontalLine = function(opts) {
		var line = new DashedHorizontalLine(opts);
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasOverlay.prototype.addVerticalLine = function(opts) {
		var line = new VerticalLine(opts);
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasOverlay.prototype.addDashedVerticalLine = function(opts) {
		var line = new DashedVerticalLine(opts);
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasOverlay.prototype.addRectangle = function(opts) {
		var line = new Rectangle(opts);
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	// customizing (2015-04-20, Carrie bae)
    $.jqplot.CanvasOverlay.prototype.addCircle = function(opts) {
        var line = new Circle(opts);
        line.uid = objCounter++;
        this.objects.push(line);
        this.objectNames.push(line.options.name);
    };	

	// customizing (2013-01-24, Roy Choi)
	$.jqplot.CanvasOverlay.prototype.modifyObject = function(plot, name, opts) {
		var obj = this.get(name);
		try {
			if (obj) {
				obj.options = $.extend(true, obj.options, opts);
				this.draw(plot, obj);
				return true;
			} else {
				return false;
			}
		} catch(e) {
			return false;
		} finally {
			obj = null;
		}
	};
	
	$.jqplot.CanvasOverlay.prototype.setObjects = function(plot, objects) {
		if ($.isArray(objects)) {
			var co = this;
			co.removeObject();
			objects.forEach(function(object) {
				var type = Object.keys(object).shift();
				var obj = object[type];
				switch (type) {
					case 'line':
						co.addLine(obj);
						break;
					case 'horizontalLine':
						co.addHorizontalLine(obj);
						break;
					case 'dashedHorizontalLine':
						co.addDashedHorizontalLine(obj);
						break;
					case 'verticalLine':
						co.addVerticalLine(obj);
						break;
					case 'dashedVerticalLine':
						co.addDashedVerticalLine(obj);
						break;
					case 'rectangle':
						co.addRectangle(obj);
						break;
                    case 'circle':
                        co.addCircle(obj);
                        break;
					default:
						break;
				}
			});
			co.draw(plot);
		} 
	};
	
	$.jqplot.CanvasOverlay.prototype.addObjects = function(plot, objects) {
		if ($.isArray(objects) && objects.length) {
			var co = this;
			objects.forEach(function(object) {
				var type = Object.keys(object).shift();
				var obj = object[type];
				switch (type) {
					case 'line':
						co.addLine(obj);
						break;
					case 'horizontalLine':
						co.addHorizontalLine(obj);
						break;
					case 'dashedHorizontalLine':
						co.addDashedHorizontalLine(obj);
						break;
					case 'verticalLine':
						co.addVerticalLine(obj);
						break;
					case 'dashedVerticalLine':
						co.addDashedVerticalLine(obj);
						break;
					case 'rectangle':
						co.addRectangle(obj);
						break;
                    case 'circle':
                        co.addCircle(obj);
                        break;
					default:
						break;
				}
			});
			co.draw(plot);
		} 
	};

	$.jqplot.CanvasOverlay.prototype.removeObject = function(idx) {
		// check if integer, remove by index
		if ($.type(idx) == 'number') {
			this.objects.splice(idx, 1);
			this.objectNames.splice(idx, 1);
		}
		// if string, remove by name
		else if ($.type(idx) === 'string') {
			var id = $.inArray(idx, this.objectNames);
			if (id != -1) {
				this.objects.splice(id, 1);
				this.objectNames.splice(id, 1);
			}
			// all objects
		} else {
			this.objectNames.splice(0);
			this.objects.splice(0);
		}
	};

	$.jqplot.CanvasOverlay.prototype.getObject = function(idx) {
		// check if integer, remove by index
		if ($.type(idx) == 'number') {
			return this.objects[idx];
		}
		// if string, remove by name
		else {
			var id = $.inArray(idx, this.objectNames);
			if (id != -1) {
				return this.objects[id];
			}
		}
	};

	// Set get as alias for getObject.
	$.jqplot.CanvasOverlay.prototype.get = $.jqplot.CanvasOverlay.prototype.getObject;

	$.jqplot.CanvasOverlay.prototype.clear = function(plot) {
		if (!this.canvas || !this.bcanvas) {
			return;
		}
		this.canvas._ctx.clearRect(0, 0, this.canvas.getWidth() + 1, this.canvas.getHeight() + 1);
		this.bcanvas._ctx.clearRect(0, 0, this.bcanvas.getWidth() + 1, this.bcanvas.getHeight() + 1);

		/*
		 if (this.options.outsideDraw) {
		 this.outsideCanvas._ctx.clearRect(0, 0, this.outsideCanvas.getWidth() + 1, this.outsideCanvas.getHeight() + 1);
		 this.outsideBCanvas._ctx.clearRect(0, 0, this.outsideBCanvas.getWidth() + 1, this.outsideBCanvas.getHeight() + 1);

		 $('.jqplot-canvasoverlay-outsidetooltip', this.target).each(function() {
		 $(this).children().each(function() {
		 $(this).unbind();
		 $(this).empty();
		 $(this).remove();
		 });
		 $(this).unbind();
		 $(this).empty();
		 $(this).remove();
		 });
		 }*/

	};

	$.jqplot.CanvasOverlay.prototype.draw = function(plot, dragobj, ev) {
		var obj, objs = this.objects, mr = this.markerRenderer, start, stop;
		if (this.options.show) {
			this.clear();
			clearLabel(plot);
			
			if (plot.data.length === 0) {
                return;
            }
			
			/*this.canvas._ctx.clearRect(0,0,this.canvas.getWidth(), this.canvas.getHeight());
			 this.bcanvas._ctx.clearRect(0,0,this.bcanvas.getWidth(), this.bcanvas.getHeight());*/

			for (var k = 0; k < objs.length; k++) {
				obj = objs[k];
				var opts = $.extend(true, {}, obj.options);
				if (obj.options.show) {
					// style and shadow properties should be set before
					// every draw of marker renderer.
					mr.shadow = obj.options.shadow;
					obj.tooltipWidthFactor = obj.options.lineWidth / obj.options.showTooltipPrecision;
					
					// TODO: bug fix plot.axes[obj.options.xaxis].series_u2p
					// Temporary
					if (obj.options.xaxis === 'xaxis' && typeof plot.axes[obj.options.xaxis].series_u2p === 'undefined') {
						var xaxis_series_u2p = plot.axes['x2axis'].series_u2p;
					} else {
						var xaxis_series_u2p = plot.axes[obj.options.xaxis].series_u2p;
					}
					
					if (obj.options.yaxis === 'yaxis' && typeof plot.axes[obj.options.yaxis].series_u2p === 'undefined') {
						var yaxis_series_u2p = plot.axes['y2axis'].series_u2p;
					} else {
						var yaxis_series_u2p = plot.axes[obj.options.yaxis].series_u2p;
					}
					
					
					switch (obj.type) {
						case 'line':
							// style and shadow properties should be set before
							// every draw of marker renderer.
							mr.style = 'line';
							opts.closePath = false;
							start = [xaxis_series_u2p(obj.options.start[0]), yaxis_series_u2p(obj.options.start[1])];
							stop = [xaxis_series_u2p(obj.options.stop[0]), yaxis_series_u2p(obj.options.stop[1])];
							obj.gridStart = start;
							obj.gridStop = stop;
							mr.draw(start, stop, (opts.isBackground ? this.bcanvas._ctx : this.canvas._ctx), opts);
							break;
						case 'horizontalLine':
							// style and shadow properties should be set before
							// every draw of marker renderer.
							if (obj.options.y != null) {
								mr.style = 'line';
								opts.closePath = false;
								var xaxis = plot.axes[obj.options.xaxis], yaxis = plot.axes[obj.options.yaxis], xstart = xaxis.series_u2p(xaxis.min), xstop = xaxis.series_u2p(xaxis.max), y = yaxis_series_u2p(obj.options.y), xminoff = obj.options.xminOffset || obj.options.xOffset, xmaxoff = obj.options.xmaxOffset || obj.options.xOffset, fillStart = xaxis.series_u2p(xaxis.min), fillStop = xaxis.series_u2p(xaxis.max);
								if (obj.options.xmin != null) {
									fillStart = xaxis.series_u2p(obj.options.xmin);
									if (!obj.options.isFullLine)
										xstart = fillStart;
								} else if (obj.options.xminBind != null) {
									fillStart = xaxis.series_u2p(this.get(opts.xminBind).options.x);
									if (!obj.options.isFullLine)
										xstart = fillStart;
								} else if (xminoff != null) {
									if ($.type(xminoff) == "number") {
										fillStart = xaxis.series_u2p(xaxis.min + xminoff);
										if (!obj.options.isFullLine)
											xstart = fillStart;
									} else if ($.type(xminoff) == "string") {
										fillStart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff);
										if (!obj.options.isFullLine)
											xstart = fillStart;
									}
								}
								if (obj.options.xmax != null) {
									fillStop = xaxis.series_u2p(obj.options.xmax);
									if (!obj.options.isFullLine)
										xstop = fillStop;
								} else if (obj.options.xmaxBind != null && this.get(opts.xmaxBind).options.show) {
									fillStop = xaxis.series_u2p(this.get(opts.xmaxBind).options.x);
									if (!obj.options.isFullLine)
										xstop = fillStop;
								} else if (xmaxoff != null) {
									if ($.type(xmaxoff) == "number") {
										fillStop = xaxis.series_u2p(xaxis.max - xmaxoff);
										if (!obj.options.isFullLine)
											xstop = fillStop;
									} else if ($.type(xmaxoff) == "string") {
										fillStop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff);
										if (!obj.options.isFullLine)
											xstop = fillStop;
									}
								}
								if (xstop != null && xstart != null) {
									obj.gridStart = [xstart, y];
									obj.gridStop = [xstop, y];

									var ctx = opts.isBackground ? this.bcanvas._ctx : this.canvas._ctx;

									// customizing for outsideTooltip (2013-03-04, Roy choi)
									if (this.options.outsideDraw) {
										xstop += this._paddingWidth;

										drawHorizontalOutsideTooltip.call(this, plot, obj, opts, y);

										ctx = opts.isBackground ? this.outsideBCanvas._ctx : this.outsideCanvas._ctx;
									}

									mr.draw([xstart, y], [xstop, y], ctx, opts);
									
									if (opts.fillArea) {
										if (fillStart < 0) {
											fillStart = 0;
											fillStop += parseFloat(xminoff);
										}

										// customizing for outsideTooltip (2013-03-04, Roy choi)
										if (this.options.outsideDraw) {
											if (this._paddingDirection == 'left') {
												fillStart += this._paddingWidth;
												fillStop += this._paddingWidth;
											}
										}

										ctx.fillStyle = opts.fillStyle;
										var fillToValue = null;
										if (opts.fillToBind && this.get(opts.fillToBind)) {
											fillToValue = this.get(opts.fillToBind).options.y;
										} else if (opts.fillToMin) {
											fillToValue = yaxis.min;
										} else if (opts.fillToMax) {
											fillToValue = yaxis.max;
										} else if (opts.fillToValue != null) {
											fillToValue = opts.fillToValue;
										}
										//var fillToValue = opts.fillToBind && this.get(opts.fillToBind) ? this.get(opts.fillToBind).options.y : opts.fillToValue;
										var ystop = yaxis.series_u2p(opts.y) - yaxis.series_u2p(fillToValue);
										if (opts.fillBehind)
											ctx.fillRect(fillStart, yaxis.series_u2p(fillToValue), fillStop - fillStart, ystop);
										else
											ctx.fillRect(fillStart, yaxis.series_u2p(fillToValue), fillStop - fillStart, ystop);
									}
									
									if (opts.isDraggable && opts.dragable.showArrow) {
									  obj.draggableArrows = [];
                    var start = Math.min(xstart, xstop);
                    var stop = Math.max(xstart, xstop);
                    var max = opts.dragable.max != null ? yaxis.series_u2p(opts.dragable.max) : opts.dragable.max;
                    var min = opts.dragable.min != null ? yaxis.series_u2p(opts.dragable.min) : opts.dragable.min;
                    if (opts.dragable.arrowOptions && opts.dragable.arrowOptions.showHighArrow && (max == null || max > y + opts.dragable.arrowOptions.gapWidth + opts.dragable.arrowOptions.width)) {
                      drawArrow.call(opts, ctx, 'top', [start + (stop - start) / 2, y], opts.dragable.arrowOptions, obj);
                    }
                    if (opts.dragable.arrowOptions && opts.dragable.arrowOptions.showLowArrow && (min == null || min < y - opts.dragable.arrowOptions.gapWidth - opts.dragable.arrowOptions.width)) {
                      drawArrow.call(opts, ctx, 'bottom', [start + (stop - start) / 2, y], opts.dragable.arrowOptions, obj);
                    }
                  }

									ctx = null;
									
									if (opts.showLabel) {
									  showLabel(plot, obj);
									}

								}
								if (opts.isDraggable && opts.dragable && opts.dragable.notifyOnDrag && $.isFunction(obj.options.dragable.afterRedraw) && this.isDragging && dragobj && dragobj.options.name == obj.options.name) {
									obj.options.dragable.afterRedraw.call(obj, ev, false, obj.options.y, plot, this);
								}
							}

							break;

						case 'dashedHorizontalLine':

							var dashPat = obj.options.dashPattern;
							var dashPatLen = 0;
							for (var i = 0; i < dashPat.length; i++) {
								dashPatLen += dashPat[i];
							}

							// style and shadow properties should be set before
							// every draw of marker renderer.
							if (obj.options.y != null) {
								mr.style = 'line';
								opts.closePath = false;
								var xaxis = plot.axes[obj.options.xaxis], xstart = xaxis.series_u2p(xaxis.min), xstop = xaxis.series_u2p(xaxis.max), y = yaxis_series_u2p(obj.options.y), xminoff = obj.options.xminOffset || obj.options.xOffset, xmaxoff = obj.options.xmaxOffset || obj.options.xOffset, fillStart = xaxis.series_u2p(xaxis.min), fillStop = xaxis.series_u2p(xaxis.max);
								if (obj.options.xmin != null) {
									fillStart = xaxis.series_u2p(obj.options.xmin);
									if (!obj.options.isFullLine)
										xstart = fillStart;
								} else if (obj.options.xminBind != null) {
									fillStart = xaxis.series_u2p(this.get(opts.xminBind).options.x);
									if (!obj.options.isFullLine)
										xstart = fillStart;
								} else if (xminoff != null) {
									if ($.type(xminoff) == "number") {
										fillStart = xaxis.series_u2p(xaxis.min + xminoff);
										if (!obj.options.isFullLine)
											xstart = fillStart;
									} else if ($.type(xminoff) == "string") {
										fillStart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff);
										if (!obj.options.isFullLine)
											xstart = fillStart;
									}
								}
								if (obj.options.xmax != null) {
									fillStop = xaxis.series_u2p(obj.options.xmax);
									if (!obj.options.isFullLine)
										xstop = fillStop;
								} else if (obj.options.xmaxBind != null) {
									fillStop = xaxis.series_u2p(this.get(opts.xmaxBind).options.x);
									if (!obj.options.isFullLine)
										xstop = fillStop;
								} else if (xmaxoff != null) {
									if ($.type(xmaxoff) == "number") {
										fillStop = xaxis.series_u2p(xaxis.max - xmaxoff);
										if (!obj.options.isFullLine)
											xstop = fillStop;
									} else if ($.type(xmaxoff) == "string") {
										fillStop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff);
										if (!obj.options.isFullLine)
											xstop = fillStop;
									}
								}
								if (xstop != null && xstart != null) {
									obj.gridStart = [xstart, y];
									obj.gridStop = [xstop, y];

									var ctx = opts.isBackground ? this.bcanvas._ctx : this.canvas._ctx;

									// customizing for outsideTooltip (2013-03-04, Roy choi)
									if (this.options.outsideDraw) {
										xstop += this._paddingWidth;

										drawHorizontalOutsideTooltip.call(this, plot, obj, opts, y);

										ctx = opts.isBackground ? this.outsideBCanvas._ctx : this.outsideCanvas._ctx;
									}

									var numDash = Math.ceil((xstop - xstart) / dashPatLen);
									var b = xstart, e;
									for (var i = 0; i < numDash; i++) {
										for (var j = 0; j < dashPat.length; j += 2) {
											e = b + dashPat[j];
											mr.draw([b, y], [e, y], ctx, opts);
											b += dashPat[j];
											if (j < dashPat.length - 1) {
												b += dashPat[j + 1];
											}
										}
									}
									if (opts.fillArea) {
										if (fillStart < 0) {
											fillStart = 0;
											fillStop += parseFloat(xminoff);
										}

										// customizing for outsideTooltip (2013-03-04, Roy choi)
										if (this.options.outsideDraw) {
											if (this._paddingDirection == 'left') {
												fillStart += this._paddingWidth;
												fillStop += this._paddingWidth;
											}
										}

										ctx.fillStyle = opts.fillStyle;
										var fillToValue = null;
										if (opts.fillToBind && this.get(opts.fillToBind)) {
											fillToValue = this.get(opts.fillToBind).options.y;
										} else if (opts.fillToMin) {
											fillToValue = yaxis.min;
										} else if (opts.fillToMax) {
											fillToValue = yaxis.max;
										} else if (opts.fillToValue != null) {
											fillToValue = opts.fillToValue;
										}
										//var fillToValue = opts.fillToBind && this.get(opts.fillToBind) ? this.get(opts.fillToBind).options.y : opts.fillToValue;
										var ystop = yaxis.series_u2p(opts.y) - yaxis.series_u2p(fillToValue);
										if (opts.fillBehind)
											ctx.fillRect(fillStart, yaxis.series_u2p(fillToValue), fillStop - fillStart, ystop);
										else
											ctx.fillRect(fillStart, yaxis.series_u2p(fillToValue), fillStop - fillStart, ystop);
									}
									
									if (opts.isDraggable && opts.dragable.showArrow) {
                    var start = Math.min(xstart, xstop);
                    var stop = Math.max(xstart, xstop);
                    var max = opts.dragable.max != null ? yaxis.series_u2p(opts.dragable.max) : opts.dragable.max;
                    var min = opts.dragable.min != null ? yaxis.series_u2p(opts.dragable.min) : opts.dragable.min;
                    if (opts.dragable.arrowOptions && opts.dragable.arrowOptions.showHighArrow && (max == null || max > y + opts.dragable.arrowOptions.gapWidth + opts.dragable.arrowOptions.width)) {
                      drawArrow.call(opts, ctx, 'top', [start + (stop - start) / 2, y], opts.dragable.arrowOptions, obj);
                    }
                    if (opts.dragable.arrowOptions && opts.dragable.arrowOptions.showLowArrow && (min == null || min < y - opts.dragable.arrowOptions.gapWidth - opts.dragable.arrowOptions.width)) {
                      drawArrow.call(opts, ctx, 'bottom', [start + (stop - start) / 2, y], opts.dragable.arrowOptions, obj);
                    }
                  }

									ctx = null;
									
									if (opts.showLabel) {
                    showLabel(plot, obj);
                  }
								}

								if (opts.isDraggable && opts.dragable && opts.dragable.notifyOnDrag && $.isFunction(obj.options.dragable.afterRedraw) && this.isDragging && dragobj && dragobj.options.name == obj.options.name) {
									obj.options.dragable.afterRedraw.call(obj, ev, false, obj.options.y, plot, this);
								}
							}
							break;

						case 'verticalLine':

							// style and shadow properties should be set before
							// every draw of marker renderer.
							if (obj.options.x != null) {
								mr.style = 'line';
								opts.closePath = false;
								var yaxis = plot.axes[obj.options.yaxis], xaxis = plot.axes[obj.options.xaxis], ystart, ystop, x = xaxis_series_u2p(obj.options.x), yminoff = obj.options.yminOffset || obj.options.yOffset, ymaxoff = obj.options.ymaxOffset || obj.options.yOffset;
								if (obj.options.ymin != null) {
									ystart = yaxis.series_u2p(obj.options.ymin);
								} else if (yminoff != null) {
									if ($.type(yminoff) == "number") {
										ystart = yaxis.series_u2p(yaxis.min - yminoff);
									} else if ($.type(yminoff) == "string") {
										ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff);
									}
								}
								if (obj.options.ymax != null) {
									ystop = yaxis.series_u2p(obj.options.ymax);
								} else if (ymaxoff != null) {
									if ($.type(ymaxoff) == "number") {
										ystop = yaxis.series_u2p(yaxis.max + ymaxoff);
									} else if ($.type(ymaxoff) == "string") {
										ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff);
									}
								}
								if (ystop != null && ystart != null) {
									obj.gridStart = [x, ystart];
									obj.gridStop = [x, ystop];
									
									var ctx = opts.isBackground ? this.bcanvas._ctx : this.canvas._ctx;

									// customizing for outsideTooltip (2013-03-07, Roy choi)
									if (this.options.outsideDraw) {
										/// TODO : Draw vertical outside tooltip
										/*ystop += this._paddingWidth;

										drawVerticalOutsideTooltip.call(this, plot, obj, opts, x);*/
									}

									mr.draw([x, ystart], [x, ystop], ctx, opts);

									if (opts.fillArea) {

										// customizing for outsideTooltip (2013-03-07, Roy choi)
										if (this.options.outsideDraw) {
											/// TODO : Draw vertical outside tooltip
											/*if (this._paddingDirection == 'top') {
											ystart += this._paddingWidth;
											ystop += this._paddingWidth;
											}*/
										}

										ctx.fillStyle = opts.fillStyle;

										var fillToValue = null;
										if (opts.fillToBind && this.get(opts.fillToBind)) {
											fillToValue = this.get(opts.fillToBind).options.x;
										} else if (opts.fillToMin) {
											fillToValue = xaxis.min;
										} else if (opts.fillToMax) {
											fillToValue = xaxis.max;
										} else if (opts.fillToValue != null) {
											fillToValue = opts.fillToValue;
										}
										//var fillToValue = opts.fillToBind && this.get(opts.fillToBind) ? this.get(opts.fillToBind).options.x : opts.fillToValue;
										var xstop = xaxis.series_u2p(opts.x) - xaxis.series_u2p(fillToValue);
										ctx.fillRect(xaxis.series_u2p(fillToValue), ystart, xstop, ystop - ystart);
									}
									
									if (opts.isDraggable && opts.dragable.showArrow) {
                    var start = Math.min(ystart, ystop);
                    var stop = Math.max(ystart, ystop);
                    var max = opts.dragable.max != null ? xaxis.series_u2p(opts.dragable.max) : opts.dragable.max;
                    var min = opts.dragable.min != null ? xaxis.series_u2p(opts.dragable.min) : opts.dragable.min;
                    if (opts.dragable.arrowOptions && opts.dragable.arrowOptions.showHighArrow && (max == null || max > x + opts.dragable.arrowOptions.gapWidth + opts.dragable.arrowOptions.width)) {
                      drawArrow.call(opts, ctx, 'right', [x, start + (stop - start) / 2], opts.dragable.arrowOptions, obj);
                    }
                    if (opts.dragable.arrowOptions && opts.dragable.arrowOptions.showLowArrow && (min == null || min < x - opts.dragable.arrowOptions.gapWidth - opts.dragable.arrowOptions.width)) {
                      drawArrow.call(opts, ctx, 'left', [x, start + (stop - start) / 2], opts.dragable.arrowOptions, obj);
                    }
                  }
									
									ctx = null;
									
									if (opts.showLabel) {
                    showLabel(plot, obj);
                  }
								}

								if (opts.isDraggable && opts.dragable && opts.dragable.notifyOnDrag && $.isFunction(obj.options.dragable.afterRedraw) && this.isDragging && dragobj && dragobj.options.name == obj.options.name) {
									obj.options.dragable.afterRedraw.call(obj, ev, false, obj.options.x, plot, this);
								}
							}
							break;

						case 'dashedVerticalLine':

							var dashPat = obj.options.dashPattern;
							var dashPatLen = 0;
							for (var i = 0; i < dashPat.length; i++) {
								dashPatLen += dashPat[i];
							}

							// style and shadow properties should be set before
							// every draw of marker renderer.
							if (obj.options.x != null) {
								mr.style = 'line';
								opts.closePath = false;
								var yaxis = plot.axes[obj.options.yaxis], xaxis = plot.axes[obj.options.xaxis], ystart, ystop, x = xaxis_series_u2p(obj.options.x), yminoff = obj.options.yminOffset || obj.options.yOffset, ymaxoff = obj.options.ymaxOffset || obj.options.yOffset;
								if (obj.options.ymin != null) {
									ystart = yaxis.series_u2p(obj.options.ymin);
								} else if (yminoff != null) {
									if ($.type(yminoff) == "number") {
										ystart = yaxis.series_u2p(yaxis.min - yminoff);
									} else if ($.type(yminoff) == "string") {
										ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff);
									}
								}
								if (obj.options.ymax != null) {
									ystop = yaxis.series_u2p(obj.options.ymax);
								} else if (ymaxoff != null) {
									if ($.type(ymaxoff) == "number") {
										ystop = yaxis.series_u2p(yaxis.max + ymaxoff);
									} else if ($.type(ymaxoff) == "string") {
										ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff);
									}
								}

								if (ystop != null && ystart != null) {
									obj.gridStart = [x, ystart];
									obj.gridStop = [x, ystop];
									
									var ctx = opts.isBackground ? this.bcanvas._ctx : this.canvas._ctx;

									// customizing for outsideTooltip (2013-03-07, Roy choi)
									if (this.options.outsideDraw) {
										/// TODO : Draw vertical outside tooltip
										/*ystop += this._paddingWidth;

										drawVerticalOutsideTooltip.call(this, plot, obj, opts, x);*/
									}

									var numDash = Math.ceil((ystart - ystop) / dashPatLen);
									var firstDashAdjust = ((numDash * dashPatLen) - (ystart - ystop)) / 2.0;
									var b = ystart, e, bs, es;
									for (var i = 0; i < numDash; i++) {
										for (var j = 0; j < dashPat.length; j += 2) {
											e = b - dashPat[j];
											if (e < ystop) {
												e = ystop;
											}
											if (b < ystop) {
												b = ystop;
											}
											// es = e;
											// if (i == 0) {
											//  es += firstDashAdjust;
											// }
											mr.draw([x, b], [x, e], ctx, opts);
											b -= dashPat[j];
											if (j < dashPat.length - 1) {
												b -= dashPat[j + 1];
											}
										}
									}
									if (opts.fillArea) {
										// customizing for outsideTooltip (2013-03-07, Roy choi)
										if (this.options.outsideDraw) {
											/// TODO : Draw vertical outside tooltip
											/*if (this._paddingDirection == 'top') {
											ystart += this._paddingWidth;
											ystop += this._paddingWidth;
											}*/
										}

										ctx.fillStyle = opts.fillStyle;

										var fillToValue = null;
										if (opts.fillToBind && this.get(opts.fillToBind)) {
											fillToValue = this.get(opts.fillToBind).options.x;
										} else if (opts.fillToMin) {
											fillToValue = xaxis.min;
										} else if (opts.fillToMax) {
											fillToValue = xaxis.max;
										} else if (opts.fillToValue != null) {
											fillToValue = opts.fillToValue;
										}
										//var fillToValue = opts.fillToBind && this.get(opts.fillToBind) ? this.get(opts.fillToBind).options.x : opts.fillToValue;
										var xstop = xaxis.series_u2p(opts.x) - xaxis.series_u2p(fillToValue);
										ctx.fillRect(xaxis.series_u2p(fillToValue), ystart, xstop, ystop - ystart);
									}
									
									if (opts.isDraggable && opts.dragable.showArrow) {
                    var start = Math.min(ystart, ystop);
                    var stop = Math.max(ystart, ystop);
                    var max = opts.dragable.max != null ? xaxis.series_u2p(opts.dragable.max) : opts.dragable.max;
                    var min = opts.dragable.min != null ? xaxis.series_u2p(opts.dragable.min) : opts.dragable.min;
                    
                    if (opts.dragable.arrowOptions && opts.dragable.arrowOptions.showHighArrow && (max == null || max > x + opts.dragable.arrowOptions.gapWidth + opts.dragable.arrowOptions.width)) {
                      drawArrow.call(opts, ctx, 'right', [x, start + (stop - start) / 2], opts.dragable.arrowOptions, obj);
                    }
                    if (opts.dragable.arrowOptions && opts.dragable.arrowOptions.showLowArrow && (min == null || min < x - opts.dragable.arrowOptions.gapWidth - opts.dragable.arrowOptions.width)) {
                      drawArrow.call(opts, ctx, 'left', [x, start + (stop - start) / 2], opts.dragable.arrowOptions, obj);
                    }
                  }
									
									ctx = null;
									
									if (opts.showLabel) {
                    showLabel(plot, obj);
                  }
								}

								if (opts.isDraggable && opts.dragable && opts.dragable.notifyOnDrag && $.isFunction(obj.options.dragable.afterRedraw) && this.isDragging && dragobj && dragobj.options.name == obj.options.name) {
									obj.options.dragable.afterRedraw.call(obj, ev, false, obj.options.x, plot, this);
								}
							}
							break;

						case 'rectangle':
							// style and shadow properties should be set before
							// every draw of marker renderer.
							mr.style = 'line';
							opts.closePath = true;

							var xaxis = plot.axes[obj.options.xaxis], xstart, xstop, y = yaxis_series_u2p(obj.options.y), xminoff = obj.options.xminOffset || obj.options.xOffset, xmaxoff = obj.options.xmaxOffset || obj.options.xOffset;
							// customizing start (2014-04-16, Roy Choi)
							if (typeof obj.options.xminBind === 'string' && this.get(obj.options.xminBind)) {
								xstart = xaxis.series_u2p(this.get(obj.options.xminBind).options.x);
							// customizing end
							} else if (obj.options.xmin != null) {
								xstart = xaxis.series_u2p(obj.options.xmin);
							} else if (xminoff != null) {
								if ($.type(xminoff) == "number") {
									xstart = xaxis.series_u2p(xaxis.min + xminoff);
								} else if ($.type(xminoff) == "string") {
									xstart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff);
								}
							}
							// customizing start (2014-04-16, Roy Choi)
							if (typeof obj.options.xmaxBind === 'string' && this.get(obj.options.xmaxBind)) {
								xstop = xaxis.series_u2p(this.get(obj.options.xmaxBind).options.x);
							// customizing end
							} else if (obj.options.xmax != null) {
								xstop = xaxis.series_u2p(obj.options.xmax);
							} else if (xmaxoff != null) {
								if ($.type(xmaxoff) == "number") {
									xstop = xaxis.series_u2p(xaxis.max - xmaxoff);
								} else if ($.type(xmaxoff) == "string") {
									xstop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff);
								}
							}

							var yaxis = plot.axes[obj.options.yaxis], ystart, ystop, x = xaxis_series_u2p(obj.options.x), yminoff = obj.options.yminOffset || obj.options.yOffset, ymaxoff = obj.options.ymaxOffset || obj.options.yOffset;
							// customizing start (2014-04-16, Roy Choi)
							if (typeof obj.options.yminBind === 'string' && this.get(obj.options.yminBind)) {
								ystart = yaxis.series_u2p(this.get(obj.options.yminBind).options.y);
							// customizing end
							} else if (obj.options.ymin != null) {
								ystart = yaxis.series_u2p(obj.options.ymin);
							} else if (yminoff != null) {
								if ($.type(yminoff) == "number") {
									ystart = yaxis.series_u2p(yaxis.min - yminoff);
								} else if ($.type(yminoff) == "string") {
									ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff);
								}
							}
							// customizing start (2014-04-16, Roy Choi)
							if (typeof obj.options.ymaxBind === 'string' && this.get(obj.options.ymaxBind)) {
								ystop = yaxis.series_u2p(this.get(obj.options.ymaxBind).options.y);
							// customizing end
							} else if (obj.options.ymax != null) {
								ystop = yaxis.series_u2p(obj.options.ymax);
							} else if (ymaxoff != null) {
								if ($.type(ymaxoff) == "number") {
									ystop = yaxis.series_u2p(yaxis.max + ymaxoff);
								} else if ($.type(ymaxoff) == "string") {
									ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff);
								}
							}

							if (xstop != null && xstart != null && ystop != null && ystart != null) {
								obj.gridStart = [xstart, ystart];
								obj.gridStop = [xstop, ystop];
								
								var yend;
								if (ystop - ystart < -ystart) {	// temporary bug fix
									yend = -ystart;
								} else {
									yend = ystop - ystart;
								}
								
								// TODO: bug if do zoom of many counts
								if (obj.options.isBackground) {
									this.bcanvas._ctx.fillStyle = obj.options.color;
									this.bcanvas._ctx.fillRect(xstart, ystart, xstop - xstart, yend);
								} else {
									this.canvas._ctx.fillStyle = obj.options.color;
									this.canvas._ctx.fillRect(xstart, ystart, xstop - xstart, yend);
								}
							}
							break;

						// customizing for MVA spec (2015-04-20, Carrie bae)
						case 'circle':
							// style and shadow properties should be set before
							// every draw of marker renderer.
							mr.style = 'line';
							opts.closePath = true;

							var xaxis = plot.axes[obj.options.xaxis], xstart, xstop, y = yaxis_series_u2p(obj.options.y), xminoff = obj.options.xminOffset || obj.options.xOffset, xmaxoff = obj.options.xmaxOffset || obj.options.xOffset;
							// customizing start (2014-04-16, Roy Choi)
							if (typeof obj.options.xminBind === 'string' && this.get(obj.options.xminBind)) {
								xstart = xaxis.series_u2p(this.get(obj.options.xminBind).options.x);
							// customizing end
							} else if (obj.options.xmin != null) {
								xstart = xaxis.series_u2p(obj.options.xmin);
							} else if (xminoff != null) {
								if ($.type(xminoff) == "number") {
									xstart = xaxis.series_u2p(xaxis.min + xminoff);
								} else if ($.type(xminoff) == "string") {
									xstart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff);
								}
							}
							// customizing start (2014-04-16, Roy Choi)
							if (typeof obj.options.xmaxBind === 'string' && this.get(obj.options.xmaxBind)) {
								xstop = xaxis.series_u2p(this.get(obj.options.xmaxBind).options.x);
							// customizing end
							} else if (obj.options.xmax != null) {
								xstop = xaxis.series_u2p(obj.options.xmax);
							} else if (xmaxoff != null) {
								if ($.type(xmaxoff) == "number") {
									xstop = xaxis.series_u2p(xaxis.max - xmaxoff);
								} else if ($.type(xmaxoff) == "string") {
									xstop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff);
								}
							}

							var yaxis = plot.axes[obj.options.yaxis], ystart, ystop, x = xaxis_series_u2p(obj.options.x), yminoff = obj.options.yminOffset || obj.options.yOffset, ymaxoff = obj.options.ymaxOffset || obj.options.yOffset;
							// customizing start (2014-04-16, Roy Choi)
							if (typeof obj.options.yminBind === 'string' && this.get(obj.options.yminBind)) {
								ystart = yaxis.series_u2p(this.get(obj.options.yminBind).options.y);
							// customizing end
							} else if (obj.options.ymin != null) {
								ystart = yaxis.series_u2p(obj.options.ymin);
							} else if (yminoff != null) {
								if ($.type(yminoff) == "number") {
									ystart = yaxis.series_u2p(yaxis.min - yminoff);
								} else if ($.type(yminoff) == "string") {
									ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff);
								}
							}
							// customizing start (2014-04-16, Roy Choi)
							if (typeof obj.options.ymaxBind === 'string' && this.get(obj.options.ymaxBind)) {
								ystop = yaxis.series_u2p(this.get(obj.options.ymaxBind).options.y);
							// customizing end
							} else if (obj.options.ymax != null) {
								ystop = yaxis.series_u2p(obj.options.ymax);
							} else if (ymaxoff != null) {
								if ($.type(ymaxoff) == "number") {
									ystop = yaxis.series_u2p(yaxis.max + ymaxoff);
								} else if ($.type(ymaxoff) == "string") {
									ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff);
								}
							}

							if (xstop != null && xstart != null && ystop != null && ystart != null) {
								obj.gridStart = [xstart, ystart];
								obj.gridStop = [xstop, ystop];
								
								var yend;
								if (ystop - ystart < -ystart) {	// temporary bug fix
									yend = -ystart;
								} else {
									yend = ystop - ystart;
								}
								
								// TODO: bug if do zoom of many counts
								var ctx = (obj.options.isBackground) ? this.bcanvas._ctx : this.canvas._ctx;
                                var width = xstop - xstart;
                                var height = (yend<0) ? yend*-1 : yend;

                                if (obj.options.color) {
                                	ctx.strokeStyle = obj.options.color;
                                }
                                if (obj.options.fillColor) {
                                	ctx.fillStyle = obj.options.fillColor;
                                }                                
                                drawEllipse(ctx, xstart, ystop, width, height);                                    

							}
							break;

						default:
							break;
					}
				}
			}
			/*debugger;
			 var coelem = this.canvas._elem.detach();*/
			var cobelem = this.bcanvas._elem.detach();
			if (plot.series.length > 0)
				plot.series[plot.seriesStack[0]].canvas._elem.before(cobelem);
			cobelem = null;

			if (this.options.outsideDraw) {
				var cobelem = this.outsideBCanvas._elem.detach();
				if (plot.series.length > 0)
					plot.series[plot.seriesStack[0]].canvas._elem.before(cobelem);
				cobelem = null;
			}
		}
	};

	// add for canvasOverlay circle (2015-04-20, Carrie bae)
	function drawEllipse(ctx, x, y, w, h) {
		var kappa = .5522848;

		ox = (w / 2) * kappa, // control point offset horizontal
		oy = (h / 2) * kappa, // control point offset vertical

		xe = x + w,           // x-end
		ye = y + h,           // y-end
		xm = x + w / 2,       // x-middle
		ym = y + h / 2;       // y-middle

		ctx.beginPath();

		ctx.moveTo(x, ym);

		ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
		ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
		ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
		ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

		ctx.closePath();

		ctx.stroke();
		ctx.fill();
	}	
	
	// called within context of plot
	// create a canvas which we can draw on.
	// insert it before the eventCanvas, so eventCanvas will still capture events.
	$.jqplot.CanvasOverlay.postPlotDraw = function() {
		var co = this.plugins.canvasOverlay;
		// Memory Leaks patch
		if (co && co.highlightCanvas) {
			co.highlightCanvas.resetCanvas();
			co.highlightCanvas = null;
		}
		co.canvas = new $.jqplot.GenericCanvas();
		co.bcanvas = new $.jqplot.GenericCanvas();

		/*
		 // customizing for outside tooltip (2013-03-04, Roy Choi)
		 if (co.options.outsideDraw) {
		 co.outsideCanvas = new $.jqplot.GenericCanvas();
		 co.outsideBCanvas = new $.jqplot.GenericCanvas();

		 $('.jqplot-canvasoverlay-outsidetooltip', this.target).each(function() {
		 $(this).children().each(function() {
		 $(this).unbind();
		 $(this).empty();
		 $(this).remove();
		 });
		 $(this).unbind();
		 $(this).empty();
		 $(this).remove();
		 });

		 co._paddingDirection = co.options.outsideDirection;
		 var dimentions = $.extend({}, this._plotDimensions);
		 var gridPadding = $.extend({}, this._gridPadding);
		 switch (co.options.outsideDirection) {
		 case 'left':
		 co._paddingWidth = parseInt(this.target.parent().css('padding-' + co.options.outsideDirection).replace(/[^\d]/, ''), 10);
		 //dimentions.width += padding;
		 gridPadding.left -= co._paddingWidth;
		 break;
		 case 'right':
		 co._paddingWidth = parseInt(this.target.parent().css('padding-' + co.options.outsideDirection).replace(/[^\d]/, ''), 10);
		 dimentions.width += co._paddingWidth;
		 break;
		 case 'top':
		 co._paddingWidth = parseInt(this.target.parent().css('padding-' + co.options.outsideDirection).replace(/[^\d]/, ''), 10);
		 //dimentions.height += this._paddingWidth;
		 gridPadding.top -= co._paddingWidth;
		 break;
		 case 'bottom':
		 co._paddingWidth = parseInt(this.target.parent().css('padding-' + co.options.outsideDirection).replace(/[^\d]/, ''), 10);
		 dimentions.height += co._paddingWidth;
		 break;
		 }
		 this.eventCanvas._elem.before(co.outsideCanvas.createElement(gridPadding, 'jqplot-overlayCanvas-canvas', dimentions, this));
		 this.eventCanvas._elem.after(co.outsideBCanvas.createElement(gridPadding, 'jqplot-overlayCanvas-canvas', dimentions, this));

		 co.outsideCanvas.setContext();
		 co.outsideBCanvas.setContext();

		 dimentions = gridPadding = null;
		 }*/

		this.eventCanvas._elem.before(co.canvas.createElement(this._gridPadding, 'jqplot-overlayCanvas-canvas', this._plotDimensions, this));
		this.eventCanvas._elem.after(co.bcanvas.createElement(this._gridPadding, 'jqplot-overlayCanvas-canvas', this._plotDimensions, this));

		co.canvas.setContext();
		co.bcanvas.setContext();

		if (!co.deferDraw) {
			co.draw(this);
		}

		var elem = document.createElement('div');
		co._tooltipElem = $(elem);
		elem = null;
		co._tooltipElem.addClass('jqplot-canvasOverlay-tooltip');
		co._tooltipElem.css({
			position : 'absolute',
			display : 'none'
		});

		this.eventCanvas._elem.before(co._tooltipElem);
		this.eventCanvas._elem.bind('mouseleave', {
			elem : co._tooltipElem
		}, function(ev) {
			ev.data.elem.hide().empty();
		});

		var co = null;
	};

	/*
	 // customizing for outside tooltip (2013-03-07)
	 function drawHorizontalOutsideTooltip(plot, obj, opts, y) {
	 var direction = this._paddingDirection;

	 if (opts.showOutsideTooltip) {
	 if (!obj.options.outsideTooltipElem || !obj.options.outsideTooltipElem.parent().offset()) {
	 if (obj.options.outsideTooltipElem) {
	 obj.options.outsideTooltipElem.each(function() {
	 $(this).children().each(function() {
	 $(this).unbind();
	 $(this).empty();
	 $(this).remove();
	 });
	 $(this).unbind();
	 $(this).empty();
	 $(this).remove();
	 });
	 obj.options.outsideTooltipElem.unbind();
	 }
	 obj.options.outsideTooltipElem = obj.options.outsideTooltipElem = $('<div></div>');
	 obj.options.outsideTooltipElem.addClass('jqplot-canvasoverlay-outsidetooltip');
	 obj.options.outsideTooltipElem.css({
	 width : (this._paddingWidth - plot._gridPadding[direction]) + 'px',
	 maxWidth : (this._paddingWidth - plot._gridPadding[direction]) + 'px'
	 });

	 plot.eventCanvas._elem.after(obj.options.outsideTooltipElem);

	 if ( typeof opts.outsideTooltipStyle == 'string') {
	 obj.options.outsideTooltipElem.addClass(opts.outsideTooltipStyle);
	 } else if ( typeof opts.outsideTooltipStyle == 'object') {
	 obj.options.outsideTooltipElem.css(opts.outsideTooltipStyle);
	 }

	 if (opts.outsideTooltipEditable && ko && opts._observableKey && ko.isObservable(opts._observableKey)) {
	 var tmpViewModel = new function() {
	 this.value = opts.observableKey;
	 this.textValue = opts._observableKey;
	 this.text = typeof opts.outsideTooltipFormatter == 'function' ? ko.computed(function() {
	 return opts.outsideTooltipFormatter(this.textValue());
	 }, this) : opts._observableKey;
	 };
	 var inputElem = $('<input type="text" data-bind="value: value" />');
	 inputElem.css({
	 overflow : 'hidden',
	 width : (this._paddingWidth - plot._gridPadding[direction]) + 'px',
	 maxWidth : (this._paddingWidth - plot._gridPadding[direction]) + 'px',
	 textAlign : direction,
	 display : 'none'
	 });
	 obj.options.outsideTooltipElem.append(inputElem);

	 var textElem = $('<div data-bind="text: text"></div>');
	 textElem.css({
	 width : (this._paddingWidth - plot._gridPadding[direction]) + 'px',
	 maxWidth : (this._paddingWidth - plot._gridPadding[direction]) + 'px',
	 textAlign : direction
	 });
	 obj.options.outsideTooltipElem.append(textElem);

	 inputElem.bind('blur', {
	 textElem : textElem
	 }, function(ev) {
	 $(this).hide();
	 ev.data.textElem.show();
	 }).bind('keydown', {
	 textElem : textElem
	 }, function(ev) {
	 if (ev.keyCode == 13) {
	 $(this).hide();
	 ev.data.textElem.show();
	 }
	 });

	 ko.applyBindings(tmpViewModel, obj.options.outsideTooltipElem.get(0));
	 tmpViewModel = null;

	 obj.options.outsideTooltipElem.css({
	 textAlign : direction
	 });

	 obj.options.outsideTooltipElem.bind('click', {
	 inputElem : inputElem,
	 textElem : textElem
	 }, function(ev) {
	 ev.data.textElem.hide();
	 ev.data.inputElem.show().focus().select();
	 });

	 inputElem = textElem = null;
	 } else if (opts.outsideTooltipEditable && (!ko || !opts._observableKey || !ko.isObservable(opts._observableKey))) {
	 ///TODO : Use DOM node
	 }
	 else {
	 obj.options.outsideTooltipElem.text( typeof opts.outsideTooltipFormatter == 'function' ? opts.outsideTooltipFormatter(plot.axes[obj.options.yaxis].series_p2u(y)) : plot.axes[obj.options.yaxis].series_p2u(y));
	 }
	 } else if (!(opts.outsideTooltipEditable && ko && opts._observableKey && ko.isObservable(opts._observableKey))) {
	 obj.options.outsideTooltipElem.text( typeof opts.outsideTooltipFormatter == 'function' ? opts.outsideTooltipFormatter(plot.axes[obj.options.yaxis].series_p2u(y)) : plot.axes[obj.options.yaxis].series_p2u(y));
	 }

	 if (opts.outsideTooltipEditable && ko && opts._observableKey && ko.isObservable(opts._observableKey)) {
	 opts._observableKey(plot.axes[obj.options.yaxis].series_p2u(y));
	 }

	 var po = obj.options.outsideTooltipElem.parent().offset();
	 var pm = {
	 left : parseInt(obj.options.outsideTooltipElem.parent().css('margin-left').replace(/[^\d]/g, ''), 10),
	 right : parseInt(obj.options.outsideTooltipElem.parent().css('margin-right').replace(/[^\d]/g, ''), 10),
	 top : parseInt(obj.options.outsideTooltipElem.parent().css('margin-top').replace(/[^\d]/g, ''), 10),
	 bottom : parseInt(obj.options.outsideTooltipElem.parent().css('margin-bottom').replace(/[^\d]/g, ''), 10)
	 };
	 var top;
	 if (direction == 'right') {
	 var pw = obj.options.outsideTooltipElem.parent().innerWidth();
	 top = (y + pm.top + plot._gridPadding.bottom + obj.options.outsideTooltipElem.outerHeight() + 10 > plot._plotDimensions.height) ? y - 10 : y + 15;
	 top += po.top;
	 obj.options.outsideTooltipElem.offset({
	 left : po.left + pm.left + pw + this._paddingWidth - plot._gridPadding[direction] - obj.options.outsideTooltipElem.outerWidth(),
	 top : top
	 });
	 pw = null;
	 } else {
	 top = (y + pm.top + plot._gridPadding.bottom + obj.options.outsideTooltipElem.outerHeight() + 10 > plot._plotDimensions.height) ? y - 10 : y + 15;
	 top += po.top;
	 obj.options.outsideTooltipElem.offset({
	 left : po.left + pm.left - this._paddingWidth + plot._gridPadding.left,
	 top : top
	 });
	 }
	 po = pm = top = null;
	 }
	 }*/

	/*
	 function drawVerticalOutsideTooltip(plot, obj, opts, x) {
	 /// TODO : Draw vertical outside tooltip
	 }*/

	function showTooltip(plot, obj, gridpos, datapos) {
		var co = plot.plugins.canvasOverlay;
		var elem = co._tooltipElem;

		var opts = obj.options, x, y;

		elem.html($.jqplot.sprintf(opts.tooltipFormatString, datapos[0], datapos[1]));

		switch (opts.tooltipLocation) {
			case 'nw':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true);
				break;
			case 'n':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) / 2;
				y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true);
				break;
			case 'ne':
				x = gridpos[0] + plot._gridPadding.left + opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true);
				break;
			case 'e':
				x = gridpos[0] + plot._gridPadding.left + opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - elem.outerHeight(true) / 2;
				break;
			case 'se':
				x = gridpos[0] + plot._gridPadding.left + opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset;
				break;
			case 's':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) / 2;
				y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset;
				break;
			case 'sw':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset;
				break;
			case 'w':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - elem.outerHeight(true) / 2;
				break;
			default:
				// same as 'nw'
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true);
				break;
		}

		elem.css('left', x);
		elem.css('top', y);
		if (opts.fadeTooltip) {
			// Fix for stacked up animations.  Thnanks Trevor!
			elem.stop(true, true).fadeIn(opts.tooltipFadeSpeed);
		} else {
			elem.show();
		}
		elem = null;
	}
	
	function clearLabel(plot) {
	  $('.jqplot-canvasoverlay-label', plot.target).each(function(index, elem) {
	    $(elem).remove();
	  });
	}
	
  function showLabel(plot, obj) {
    var xaxis = plot.axes[obj.options.xaxis], yaxis = plot.axes[obj.options.yaxis];
    var co = plot.plugins.canvasOverlay;
    
    if (!co._tooltipElem) {
      return;
    }
    
    var elem = co._tooltipElem.clone();
    var offset = {
      top: plot._gridPadding.top,
      left: plot._gridPadding.left
    };
    
    elem.addClass('jqplot-canvasoverlay-label');
    
    var opts = obj.options, x, y, labelOptions = opts.labelOptions;
    
    if (typeof labelOptions.classes === 'string') {
      elem.addClass(labelOptions.classes);
    }
    
    plot.target.append(elem);
    
    switch(obj.constructor) {
      case HorizontalLine:
      case DashedHorizontalLine:
        elem.html($.isFunction(labelOptions.formatter) ? labelOptions.formatter.call(obj, opts.y, plot) : opts.y);
        
        var gridStart = Math.max(obj.gridStart[0], obj.gridStop[0]), gridStop = Math.min(obj.gridStart[0], obj.gridStop[0]);
        
        switch(labelOptions.location) {
          case 'right':
            offset.left += gridStop;
            break;
          case 'center':
            offset.left += gridStart + ((gridStop - gridStart) / 2) - (elem.width() / 2);
            break;
          case 'left':
          default:
            offset.left -= elem.width() / 2;
            break;
        }
        
        offset.left += ($.isNumeric(labelOptions.offset.left) ? labelOptions.offset.left : 0);
        offset.top += yaxis.series_u2p(opts.y) + ($.isNumeric(labelOptions.offset.top) ? labelOptions.offset.top : 0) - (elem.height() / 2);
        break;
      case VerticalLine:
      case DashedVerticalLine:
        elem.html($.isFunction(labelOptions.formatter) ? labelOptions.formatter.call(obj, opts.x, plot) : opts.x);
        
        var gridStart = Math.max(obj.gridStart[1], obj.gridStop[1]), gridStop = Math.min(obj.gridStart[1], obj.gridStop[1]);
        
        switch(labelOptions.location) {
          case 'bottom':
            offset.top += gridStop;
            break;
          case 'middle':
            offset.top += gridStart + ((gridStop - gridStart) / 2) - (elem.height() / 2);
            break;
          case 'top':
          default:
            offset.top -= elem.height() / 2;
            break;
        }
        
        offset.top += ($.isNumeric(labelOptions.offset.top) ? labelOptions.offset.top : 0);
        offset.left += xaxis.series_u2p(opts.x) + ($.isNumeric(labelOptions.offset.left) ? labelOptions.offset.left : 0) - (elem.width() / 2);
        break;
    }
    
    elem.offset(offset);
    
    elem.show();
  }

	function isNearLine(point, lstart, lstop, width) {
		// r is point to test, p and q are end points.
		var rx = point[0];
		var ry = point[1];
		var px = Math.round(lstop[0]);
		var py = Math.round(lstop[1]);
		var qx = Math.round(lstart[0]);
		var qy = Math.round(lstart[1]);

		var l = Math.sqrt(Math.pow(px - qx, 2) + Math.pow(py - qy, 2));

		// scale error term by length of line.
		var eps = width * l;
		var res = Math.abs((qx - px) * (ry - py) - (qy - py) * (rx - px));
		var ret = (res < eps) ? true : false;
		return ret;
	}
	
	function isNearArrow(point, obj) {
      if (obj.options.isDraggable && obj.options.dragable.showArrow && obj.draggableArrows.length) {
        for (var j=0; j<obj.draggableArrows.length; j++) {
          var arrowPoints = obj.draggableArrows[j];
          if (checkNearArrow(point[0], point[1], arrowPoints[0], arrowPoints[1], arrowPoints[2], arrowPoints[3], arrowPoints[4], arrowPoints[5])) {
            return true; 
          }
        }
      }
      
      return false;
	}

	function isNearRectangle(point, lstart, lstop, width) {
		// r is point to test, p and q are end points.
		var rx = point[0];
		var ry = point[1];
		var px = Math.round(lstop[0]);
		var py = Math.round(lstop[1]);
		var qx = Math.round(lstart[0]);
		var qy = Math.round(lstart[1]);

		var temp;
		if (px > qx) {
			temp = px;
			px = qx;
			qx = temp;
		}
		if (py > qy) {
			temp = py;
			py = qy;
			qy = temp;
		}

		var ret = (rx >= px && rx <= qx && ry >= py && ry <= qy);

		return ret;
	}

	function checkNearLine(objs, point, plot) {
		var obj;
		var len = objs.length;
		var lstart, lstop, width;
		for (var i = 0; i < len; i++) {
			obj = objs[i];
			if (obj.type === 'rectangle') {
				continue;
			}
			lstart = obj.gridStart;
			lstop = obj.gridStop;
			width = obj.tooltipWidthFactor;

			// r is point to test, p and q are end points.
			var rx = point[0];
			var ry = point[1];
			if (lstop && lstart) {
				var px = Math.round(lstop[0]);
				var py = Math.round(lstop[1]);
				var qx = Math.round(lstart[0]);
				var qy = Math.round(lstart[1]);
			} else {
				return null;
			}

			var l = Math.sqrt(Math.pow(px - qx, 2) + Math.pow(py - qy, 2));

			// scale error term by length of line.
			var eps = width * l;
			var res = Math.abs((qx - px) * (ry - py) - (qy - py) * (rx - px));
			if (res < eps) {
				return {
          lineIndex : i
        };
			} else if (obj.options.isDraggable && obj.options.dragable.showArrow && obj.draggableArrows.length) {
			  for (var j=0; j<obj.draggableArrows.length; j++) {
			    var arrowPoints = obj.draggableArrows[j];
			    if (checkNearArrow(rx, ry, arrowPoints[0], arrowPoints[1], arrowPoints[2], arrowPoints[3], arrowPoints[4], arrowPoints[5])) {
			      return {
              lineIndex : i
            }; 
			    }
			  }
			}
		}

		return null;
	}
	
  function checkNearArrow (pointX, pointY, v1X, v1Y, v2X, v2Y, v3X, v3Y) {
    var A =  (-v2Y * v3X + v1Y * (-v2X + v3X) + v1X * (v2Y - v3Y) + v2X * v3Y) / 2;
    var sign = A < 0 ? -1 : 1;
    var s = (v1Y * v3X - v1X * v3Y + (v3Y - v1Y) * pointX + (v1X - v3X) * pointY) * sign;
    var t = (v1X * v2Y - v1Y * v2X + (v1Y - v2Y) * pointX + (v2X - v1X) * pointY) * sign;
    return s > 0 && t > 0 && s + t < 2 * A * sign;
  }

	function handleMove(ev, gridpos, datapos, neighbor, plot) {
		var co = plot.plugins.canvasOverlay;
		var objs = co.objects;
		var l = objs.length;
		var obj, haveHighlight = false;
		var elem;

		// customizing (2011-11-11, Roy Choi)
		if (co.isDragging && co._neighbor !== null) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
			return;
		}

		for (var i = 0; i < l; i++) {
			obj = objs[i];
			if (obj.options.showTooltip || obj.options.isDraggable) {
				var n;
				if (obj.type === 'rectangle') {
					n = isNearRectangle([gridpos.x, gridpos.y], obj.gridStart, obj.gridStop, obj.tooltipWidthFactor);
				} else {
					n = isNearLine([gridpos.x, gridpos.y], obj.gridStart, obj.gridStop, obj.tooltipWidthFactor) || isNearArrow([gridpos.x, gridpos.y], obj);
				}
			}
			
			if (n) {
                ev.preventDefault();
                ev.stopImmediatePropagation();
			}
			
			if(obj.options.isDraggable && !obj.options.isOver && n) {
				//obj.options._cursor.push(ev.target.style.cursor);
				switch (obj.type) {
					case 'line':
						break;
					case 'horizontalLine':
					case 'dashedHorizontalLine':
						ev.target.style.cursor = "row-resize";
						break;

					case 'verticalLine':
					case 'dashedVerticalLine':
						ev.target.style.cursor = "col-resize";
						break;
					default:
						break;
				} 
				obj.options.isOver = true;
			} else if (obj.options.isDraggable && obj.options.isOver && !n) {
				ev.target.style.cursor = /*obj.cursor.length > 0 ? obj.cursor.pop() :*/ 'auto';
				obj.options.isOver = false;
			}
			
			if (obj.options.showTooltip) {
				datapos = [plot.axes[obj.options.xaxis].series_p2u(gridpos.x), plot.axes[obj.options.yaxis].series_p2u(gridpos.y)];

				// cases:
				//    near line, no highlighting
				//    near line, highliting on this line
				//    near line, highlighting another line
				//    not near any line, highlighting
				//    not near any line, no highlighting

				// near line, not currently highlighting
				if (n && co.highlightObjectIndex == null) {
					switch (obj.type) {
						case 'line':
							showTooltip(plot, obj, [gridpos.x, gridpos.y], datapos);
							break;

						case 'horizontalLine':
						case 'dashedHorizontalLine':
							showTooltip(plot, obj, [gridpos.x, obj.gridStart[1]], [datapos[0], obj.options.y]);
							break;

						case 'verticalLine':
						case 'dashedVerticalLine':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						case 'rectangle':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						default:
							break;
					}
					co.highlightObjectIndex = i;
					haveHighlight = true;
					break;
				}

				// near line, highlighting another line.
				else if (n && co.highlightObjectIndex !== i) {
					// turn off tooltip.
					elem = co._tooltipElem;
					if (obj.fadeTooltip) {
						elem.fadeOut(obj.tooltipFadeSpeed).empty();
					} else {
						elem.hide().empty();
					}

					// turn on right tooltip.
					switch (obj.type) {
						case 'line':
							showTooltip(plot, obj, [gridpos.x, gridpos.y], datapos);
							break;

						case 'horizontalLine':
						case 'dashedHorizontalLine':
							showTooltip(plot, obj, [gridpos.x, obj.gridStart[1]], [datapos[0], obj.options.y]);
							break;

						case 'verticalLine':
						case 'dashedVerticalLine':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						case 'rectangle':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						default:
							break;
					}

					co.highlightObjectIndex = i;
					haveHighlight = true;
					break;
				}

				// near line, already highlighting this line, update
				else if (n) {
					switch (obj.type) {
						case 'line':
							showTooltip(plot, obj, [gridpos.x, gridpos.y], datapos);
							break;

						case 'horizontalLine':
						case 'dashedHorizontalLine':
							showTooltip(plot, obj, [gridpos.x, obj.gridStart[1]], [datapos[0], obj.options.y]);
							break;

						case 'verticalLine':
						case 'dashedVerticalLine':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						case 'rectangle':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						default:
							break;
					}

					haveHighlight = true;
					break;
				}
			}
		}

		// check if we are highlighting and not near a line, turn it off.
		if (!haveHighlight && co.highlightObjectIndex !== null) {
			elem = co._tooltipElem;
			obj = co.getObject(co.highlightObjectIndex);
			if (obj && obj.fadeTooltip) {
				elem.fadeOut(obj.tooltipFadeSpeed).empty();
			} else {
				elem.hide().empty();
			}
			co.highlightObjectIndex = null;
		}
	}

	// customizing (2011-11-11, Roy Choi)
	function handleDown(ev, gridpos, datapos, neighbor, plot) {
		var co = plot.plugins.canvasOverlay;
		var objs = co.objects;

		neighbor = checkNearLine(objs, [gridpos.x, gridpos.y], plot);
		if (neighbor != null) {
			var obj = objs[neighbor.lineIndex];
			obj.cursor.push(ev.target.style.cursor);
			var dragable = obj.options.isDraggable;
			if (dragable && !co.isDragging) {
				ev.preventDefault();
				ev.stopImmediatePropagation();

				co._neighbor = neighbor;
				co.isDragging = true;
				//co.preZoomStatus.push(plot.plugins.cursor.zoom);
				co._prevCursorShow = plot.plugins.cursor.show;
				plot.plugins.cursor.show = false;

				//if (document.onselectstart != undefined) {
				co._oldHandlers.onselectstart = document.onselectstart;
				document.onselectstart = function() {
					return false;
				};
				//}
				if (document.ondrag != undefined) {
					co._oldHandlers.ondrag = document.ondrag;
					document.ondrag = function() {
						return false;
					};
				}
				if (document.onmousedown != undefined) {
					co._oldHandlers.onmousedown = document.onmousedown;
					document.onmousedown = function() {
						return false;
					};
				}
				
        $(document).on('mousemove', {plot: plot}, handleDrag);
        $(document).on('mouseup', {plot: plot}, handleUp);

				//initDragPoint(obj);
				//ev.target.style.cursor = "move";
				//plot.target.trigger('jqplotDragStart', [neighbor.lineIndex, null, gridpos, null]);

				//$(document).one('mouseup.jqplot_canvasoverlay', {plot:plot}, handleMouseUp);
			}
		} else {
			co.isDragging = false;
		}
	}
  
  function handleDrag(ev) {
    var plot = ev.data.plot;
    var co = plot.plugins.canvasOverlay;
    
    if (co.isDragging && co._neighbor !== null) {
        
      ev.preventDefault();
      //ev.stopImmediatePropagation();
        
      var position = getEventPosition(ev);
      var gridPos = position.gridPos;
      var dataPos = position.dataPos;
      var an = ['xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
      var ax = plot.axes;
      var n, axis;
      for (n=11; n>0; n--) {
          axis = an[n-1];
          if (ax[axis].show) {
              dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);
          }
      }
  
      var n = co._neighbor;
      n.gridPos = gridPos;
      n.dataPos = dataPos;
      obj = co.get(n.lineIndex);
      //var drag = obj.options.dragable;
  
      switch (obj.type) {
        case 'line':
          return;
          break;
  
        case 'horizontalLine':
        case 'dashedHorizontalLine':
          if (dataPos[obj.options.yaxis] <= plot.axes[obj.options.yaxis].max && dataPos[obj.options.yaxis] >= plot.axes[obj.options.yaxis].min) {
            var y = dataPos[obj.options.yaxis];
            if (obj.options.dragable.min != null && obj.options.dragable.min > y) {
                y = obj.options.dragable.min;
            } else if (obj.options.dragable.max != null && obj.options.dragable.max < y) {
                y = obj.options.dragable.max;
            }
            
            if (obj.options.y === y) {
                return;
            }
            
            obj.options.y = y;
            co.draw(plot, obj, ev);
          }
          break;
  
        case 'verticalLine':
        case 'dashedVerticalLine':
          if (dataPos[obj.options.xaxis] <= plot.axes[obj.options.xaxis].max && dataPos[obj.options.xaxis] >= plot.axes[obj.options.xaxis].min) {
            var x = dataPos[obj.options.xaxis];
            if (obj.options.dragable.min != null && obj.options.dragable.min > x) {
                x = obj.options.dragable.min;
            } else if (obj.options.dragable.max != null && obj.options.dragable.max < x) {
                x = obj.options.dragable.max;
            }
            
            if (obj.options.x === x) {
                return;
            }
            
            obj.options.x = x;
            co.draw(plot, obj, ev);
          }
          break;
        default:
          break;
      }
    }
  }

	// customizing (2011-11-11, Roy Choi)
	function handleUp(ev) {
    ev.preventDefault();
    ev.stopImmediatePropagation();
    
    var plot = ev.data.plot;
    var co = plot.plugins.canvasOverlay;
		var objs = co.objects;

		if (co._neighbor !== null && co.isDragging) {

      var position = getEventPosition(ev);
      
      var obj = co.get(co._neighbor.lineIndex);
      
      var drag = obj.options.dragable;
      co.isDragging = false;
      co._neighbor = null;
      $('body').css('cursor', 'auto');
      $(plot.target).css('cursor', 'auto');
      plot.eventCanvas._elem.css('cursor', 'auto');
      plot.plugins.cursor.show = co._prevCursorShow;

			if (drag && typeof drag.afterRedraw == 'function') {
				switch(obj.constructor) {
					case HorizontalLine:
					case DashedHorizontalLine:
						drag.afterRedraw.call(obj, ev, true, obj.options.y, plot, this);
						break;
					case VerticalLine:
					case DashedVerticalLine:
						drag.afterRedraw.call(obj, ev, true, obj.options.x, plot, this);
						break;
				}
			}

			//if (document.onselectstart != undefined && c._oldHandlers.onselectstart != null){
			document.onselectstart = co._oldHandlers.onselectstart;
			co._oldHandlers.onselectstart = null;
			//}
			if (document.ondrag != undefined && co._oldHandlers.ondrag != null) {
				document.ondrag = co._oldHandlers.ondrag;
				co._oldHandlers.ondrag = null;
			}
			if (document.onmousedown != undefined && co._oldHandlers.onmousedown != null) {
				document.onmousedown = co._oldHandlers.onmousedown;
				co._oldHandlers.onmousedown = null;
			}

      $(document).off('mousemove', handleDrag);
      $(document).off('mouseup', handleUp);
		}
	}
	
  function getEventPosition(ev) {
      var plot = ev.data.plot;
      var go = plot.eventCanvas._elem.offset();
      var gridPos = {x:ev.pageX - go.left, y:ev.pageY - go.top};
      var dataPos = {xaxis:null, yaxis:null, x2axis:null, y2axis:null, y3axis:null, y4axis:null, y5axis:null, y6axis:null, y7axis:null, y8axis:null, y9axis:null, yMidAxis:null};
      var an = ['xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
      var ax = plot.axes;
      var n, axis;
      for (n=11; n>0; n--) {
          axis = an[n-1];
          if (ax[axis].show) {
              dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);
          }
      }

      return {offsets:go, gridPos:gridPos, dataPos:dataPos};
  }

	/// TODO : outside drag
	// customizing (2013-03-11, Roy Choi)
	/*function handleMouseUp(ev, neighbor) {
	var plot = ev.data.plot;
	var co = plot.plugins.canvasOverlay;
	var objs = co.objects;

	if (co._neighbor !== null && co.isDragging) {
	var obj = objs[co._neighbor.lineIndex];
	co.isDragging = false;
	var drag = obj.options.dragable;
	// compute the new grid position with any constraints.
	//var x = (drag.constrainTo == 'y') ? datapos[0] : datapos[s.xaxis];
	//var y = (drag.constrainTo == 'x') ? dp.data[1] : datapos[s.yaxis];
	// var x = datapos[s.xaxis];
	// var y = datapos[s.yaxis];
	resetArea(obj, neighbor.gridpos, neighbor.datapos, plot);
	co._neighbor = null;
	ev.target.style.cursor = obj.cursor.pop();
	plot.plugins.cursor.zoom = co.preZoomStatus.pop();

	if (drag && typeof drag.afterRedraw == 'function') {
	switch(obj.constructor) {
	case HorizontalLine:
	case DashedHorizontalLine:
	drag.afterRedraw.call(obj, obj.options.y, plot, this);
	break;
	case VerticalLine:
	case DashedVerticalLine:
	drag.afterRedraw.call(obj, obj.options.x, plot, this);
	break;
	}

	}

	//plot.target.trigger('jqplotDragStop', [gridpos, datapos]);
	}
	}*/

	// customizing (2011-11-11, Roy Choi)
	function resetArea(obj, gridpos, datapos, plot) {
		/// TODO : outside drag
	}
	
	function drawArrow(ctx, type, point, opts, obj) {
	  var width = opts.width;
	  var height = opts.height;
	  
	  var x1, y1, x2, y2, x3, y3;
	  
    ctx.lineWidth = opts.strokeWidth;
    ctx.strokeStyle = opts.color || this.color;
    ctx.fillStyle = opts.fillStyle || this.color;
    
    var gapWidth = opts.gapWidth != null ? Math.abs(opts.gapWidth) : 0;
	  
	  switch(type) {
	     case 'top':
	       x1 = point[0] - (width / 2);
	       y1 = point[1] - gapWidth;
	       x2 = point[0] + (width / 2);
	       y2 = point[1] - gapWidth;
	       x3 = point[0];
	       y3 = point[1] - gapWidth - height;
	       break;
	     case 'bottom':
	       x1 = point[0] - (width / 2);
         y1 = point[1] + gapWidth;
         x2 = point[0] + (width / 2);
         y2 = point[1] + gapWidth;
         x3 = point[0];
         y3 = point[1] + gapWidth + height;
	       break;
	     case 'left':
	       x1 = point[0] - gapWidth;
	       y1 = point[1] - (height / 2);
	       x2 = point[0] - gapWidth;
	       y2 = point[1] + (height / 2);
	       x3 = point[0] - gapWidth - width;
	       y3 = point[1];
	       break;
	     case 'right':
	       x1 = point[0] + gapWidth;
	       y1 = point[1] - (height / 2);
	       x2 = point[0] + gapWidth;
	       y2 = point[1] + (height / 2);
	       x3 = point[0] + gapWidth + width;
	       y3 = point[1];
	       break;
	     default:
	       return;
	  }
	  
     ctx.moveTo(x1, y1);
     ctx.lineTo(x2, y2);
     ctx.lineTo(x3, y3);
     ctx.closePath();
     
     if (opts.stroke) {
       ctx.stroke();
     }
     if (opts.fill) {
       ctx.fill();
     }
     
     obj.draggableArrows.push([x1, y1, x2, y2, x3, y3]);
	}
	
	$.jqplot.postInitHooks.push($.jqplot.CanvasOverlay.postPlotInit);
	$.jqplot.postDrawHooks.push($.jqplot.CanvasOverlay.postPlotDraw);
	$.jqplot.eventListenerHooks.push(['jqplotMouseMove', handleMove]);
	$.jqplot.eventListenerHooks.push(['jqplotMouseDown', handleDown]);
	//$.jqplot.eventListenerHooks.push(['jqplotMouseUp', handleUp]);

})(jQuery);

/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 *
 *
 */
(function($) {
	var objCounter = 0;
	// class: $.jqplot.CanvasWindow
	$.jqplot.CanvasWindow = function(opts) {
		var options = opts || {};
		this.options = {
			show : options.show == null ? $.jqplot.config.enablePlugins : options.show,
			deferDraw : false,
			
			canvasExtension: null,
			canvasExtendDirection: 'top',
			canvasExtensionEvents: {},
			snapToGrid: false,
			snapToGridInterval: null,
			defaultConfigIcon: ''
		};
		// prop: objects
		this.objects = [];
		this.objectNames = [];
		this.canvas = null;
		this.markerRenderer = new $.jqplot.MarkerRenderer({
			style : 'line'
		});
		this.markerRenderer.init();
		this.highlightObjectIndex = null;

		this.bcanvas = null;
		this._neighbor = null;
		this.isDragging = false;
		this.preZoomStatus = [];
		this._oldHandlers = {};
		
		this._prevCursorShow = false;

		if (options.objects) {
			var objs = options.objects, obj;
			for (var i = 0; i < objs.length; i++) {
				obj = objs[i];
				for (var n in obj) {
					switch (n) {
						case 'line':
							this.addLine(obj[n]);
							break;
						case 'horizontalLine':
							this.addHorizontalLine(obj[n]);
							break;
						case 'dashedHorizontalLine':
							this.addDashedHorizontalLine(obj[n]);
							break;
						case 'verticalLine':
							this.addVerticalLine(obj[n]);
							break;
						case 'dashedVerticalLine':
							this.addDashedVerticalLine(obj[n]);
							break;
						case 'rectangle':
							this.addRectangle(obj[n]);
							break;
						default:
							break;
					}
				}
			}
		}
		$.extend(true, this.options, options);
	};

	// called with scope of a plot object
	$.jqplot.CanvasWindow.postPlotInit = function(target, data, opts) {
	  if (opts.canvasWindow.show === false) return;
		var options = opts || {};
		// add a canvasWindow attribute to the plot
		this.plugins.canvasWindow = new $.jqplot.CanvasWindow(options.canvasWindow);
		
		this.target.unbind('mouseleave', handleLeave);
		this.target.bind('mouseleave', {plot: this}, handleLeave);
	};

	// customizing
	function ShapeBase() {
		this.uid = null;
		this.type = null;
		this.gridStart = null;
		this.gridStop = null;
		this.tooltipWidthFactor = 0;
		this.options = {
			// prop: name
			// Optional name for the overlay object.
			// Can be later used to retrieve the object by name.
			name : null,
			// prop: show
			// true to show (draw), false to not draw.
			show : true,
			// prop: lineWidth
			// Width of the line.
			lineWidth : 2,
			// prop: lineCap
			// Type of ending placed on the line ['round', 'butt', 'square']
			lineCap : 'round',
			// prop: color
			// color of the line
			color : '#666666',
			// prop: shadow
			// wether or not to draw a shadow on the line
			shadow : true,
			// prop: shadowAngle
			// Shadow angle in degrees
			shadowAngle : 45,
			// prop: shadowOffset
			// Shadow offset from line in pixels
			shadowOffset : 1,
			// prop: shadowDepth
			// Number of times shadow is stroked, each stroke offset shadowOffset from the last.
			shadowDepth : 3,
			// prop: shadowAlpha
			// Alpha channel transparency of shadow.  0 = transparent.
			shadowAlpha : '0.07',
			// prop: xaxis
			// X axis to use for positioning/scaling the line.
			xaxis : 'xaxis',
			// prop: yaxis
			// Y axis to use for positioning/scaling the line.
			yaxis : 'yaxis',
			// prop: showTooltip
			// Show a tooltip with data point values.
			showTooltip : false,
			// prop: showTooltipPrecision
			// Controls how close to line cursor must be to show tooltip.
			// Higher number = closer to line, lower number = farther from line.
			// 1.0 = cursor must be over line.
			showTooltipPrecision : 0.6,
			// prop: tooltipLocation
			// Where to position tooltip, 'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'
			tooltipLocation : 'nw',
			// prop: fadeTooltip
			// true = fade in/out tooltip, flase = show/hide tooltip
			fadeTooltip : true,
			// prop: tooltipFadeSpeed
			// 'slow', 'def', 'fast', or number of milliseconds.
			tooltipFadeSpeed : "fast",
			// prop: tooltipOffset
			// Pixel offset of tooltip from the highlight.
			tooltipOffset : 4,
			// prop: tooltipFormatString
			// Format string passed the x and y values of the cursor on the line.
			// e.g., 'Dogs: %.2f, Cats: %d'.
			tooltipFormatString : '%d, %d',
			
			// overlay or underlay
			isBackground : false,
			isFullLine : false,
			fillBehind : false,
			
			configIcon: {
			    show: false,
			    image: null,
			    width: 0,
			    height: 0,
			    style: {},   // css style
			    classes: [], // css classes
			    location: 'ne', // same with tooltip
			    events: {}
			}
		};
	}

	// customizing
	function LineBase() {
		ShapeBase.call(this);
		
		this.cursor = [];
		this.isOver = false;

		var opts = {
			// customizing (2011-11-03, Roy Choi)
			// dragable line
			isDraggable : false,
			dragable : {
				color : 'rgba(200,200,200,0.5)',
				constrainTo : 'y',
				afterRedraw : null,
				showTooltip: false,
				notifyOnDrag : false		// customizing (2013-03-07, Roy Choi)
			},
			fillArea : false,
			fillStyle : null,
			fillToValue : 0,
			fillToMax : false,
			fillToMin : false,
			fillToBind : null

		};

		$.extend(true, this.options, opts);
	}

	function Rectangle(options) {
		ShapeBase.call(this);
		this.type = 'rectangle';
		var opts = {
			// prop: xmin
			// x value for the start of the line, null to scale to axis min.
			xmin : null,
			// prop: xmax
			// x value for the end of the line, null to scale to axis max.
			xmax : null,
			// prop xOffset
			// offset ends of the line inside the grid. Number
			xOffset : '6px', // number or string. Number interpreted as units, string as pixels.
			xminOffset : null,
			xmaxOffset : null,

			ymin : null,
			ymax : null,
			yOffset : '6px', // number or string. Number interpreted as units, string as pixels.
			yminOffset : null,
			ymaxOffset : null,
			
			// customizing (2014-04-16, Roy Choi)
			xminBind: null,
			xmaxBind: null,
			yminBind: null,
			ymaxBind: null
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}

	/**
	 * Class: Line
	 * A straight line.
	 */
	function Line(options) {
		LineBase.call(this);
		this.type = 'line';
		var opts = {
			// prop: start
			// [x, y] coordinates for the start of the line.
			start : [],
			// prop: stop
			// [x, y] coordinates for the end of the line.
			stop : []
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	Line.prototype = new LineBase();
	Line.prototype.constructor = Line;

	/**
	 * Class: HorizontalLine
	 * A straight horizontal line.
	 */
	function HorizontalLine(options) {
		LineBase.call(this);
		this.type = 'horizontalLine';
		var opts = {
			// prop: y
			// y value to position the line
			y : null,
			// prop: xmin
			// x value for the start of the line, null to scale to axis min.
			xmin : null,
			// prop: xmax
			// x value for the end of the line, null to scale to axis max.
			xmax : null,
			// prop xOffset
			// offset ends of the line inside the grid.  Number
			xminBind : null,
			xmaxBind : null,
			xOffset : '6px', // number or string.  Number interpreted as units, string as pixels.
			xminOffset : null,
			xmaxOffset : null
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	HorizontalLine.prototype = new LineBase();
	HorizontalLine.prototype.constructor = HorizontalLine;

	/**
	 * Class: DashedHorizontalLine
	 * A straight dashed horizontal line.
	 */
	function DashedHorizontalLine(options) {
		LineBase.call(this);
		this.type = 'dashedHorizontalLine';
		var opts = {
			y : null,
			xmin : null,
			xmax : null,
			xminBind : null,
			xmaxBind : null,
			xOffset : '6px', // number or string.  Number interpreted as units, string as pixels.
			xminOffset : null,
			xmaxOffset : null,
			// prop: dashPattern
			// Array of line, space settings in pixels.
			// Default is 8 pixel of line, 8 pixel of space.
			// Note, limit to a 2 element array b/c of bug with higher order arrays.
			dashPattern : [8, 8]
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	DashedHorizontalLine.prototype = new LineBase();
	DashedHorizontalLine.prototype.constructor = DashedHorizontalLine;

	/**
	 * Class: VerticalLine
	 * A straight vertical line.
	 */
	function VerticalLine(options) {
		LineBase.call(this);
		this.type = 'verticalLine';
		var opts = {
			x : null,
			ymin : null,
			ymax : null,
			yOffset : '6px', // number or string.  Number interpreted as units, string as pixels.
			yminOffset : null,
			ymaxOffset : null
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	VerticalLine.prototype = new LineBase();
	VerticalLine.prototype.constructor = VerticalLine;

	/**
	 * Class: DashedVerticalLine
	 * A straight dashed vertical line.
	 */
	function DashedVerticalLine(options) {
		LineBase.call(this);
		this.type = 'dashedVerticalLine';
		this.start = null;
		this.stop = null;
		var opts = {
			x : null,
			ymin : null,
			ymax : null,
			yOffset : '6px', // number or string.  Number interpreted as units, string as pixels.
			yminOffset : null,
			ymaxOffset : null,
			// prop: dashPattern
			// Array of line, space settings in pixels.
			// Default is 8 pixel of line, 8 pixel of space.
			// Note, limit to a 2 element array b/c of bug with higher order arrays.
			dashPattern : [8, 8]
		};
		$.extend(true, this.options, opts, options);

		if (this.options.showTooltipPrecision < 0.01) {
			this.options.showTooltipPrecision = 0.01;
		}
	}


	DashedVerticalLine.prototype = new LineBase();
	DashedVerticalLine.prototype.constructor = DashedVerticalLine;

	$.jqplot.CanvasWindow.prototype.addLine = function(opts) {
		var line = new Line(opts);
		line.canvas = opts.isBackground ? this.bcanvas : this.canvas;
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasWindow.prototype.addHorizontalLine = function(opts) {
		var line = new HorizontalLine(opts);
		line.canvas = opts.isBackground ? this.bcanvas : this.canvas;
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasWindow.prototype.addDashedHorizontalLine = function(opts) {
		var line = new DashedHorizontalLine(opts);
		line.canvas = opts.isBackground ? this.bcanvas : this.canvas;
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasWindow.prototype.addVerticalLine = function(opts) {
		var line = new VerticalLine(opts);
		line.canvas = opts.isBackground ? this.bcanvas : this.canvas;
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasWindow.prototype.addDashedVerticalLine = function(opts) {
		var line = new DashedVerticalLine(opts);
		line.canvas = opts.isBackground ? this.bcanvas : this.canvas;
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	$.jqplot.CanvasWindow.prototype.addRectangle = function(opts) {
		var line = new Rectangle(opts);
		line.canvas = opts.isBackground ? this.bcanvas : this.canvas;
		line.uid = objCounter++;
		this.objects.push(line);
		this.objectNames.push(line.options.name);
	};

	// customizing (2013-01-24, Roy Choi)
	$.jqplot.CanvasWindow.prototype.modifyObject = function(plot, name, opts) {
		var obj = this.get(name);
		try {
			if (obj) {
				obj.options = $.extend(true, obj.options, opts);
				this.draw(plot, obj);
				return true;
			} else {
				return false;
			}
		} catch(e) {
			return false;
		} finally {
			obj = null;
		}
	};
	
	$.jqplot.CanvasWindow.prototype.setObjects = function(plot, objects) {
		if ($.isArray(objects)) {
			var cw = this;
			cw.removeObject();
			objects.forEach(function(object) {
				var type = Object.keys(object).shift();
				var obj = object[type];
				switch (type) {
					case 'line':
						cw.addLine(obj);
						break;
					case 'horizontalLine':
						cw.addHorizontalLine(obj);
						break;
					case 'dashedHorizontalLine':
						cw.addDashedHorizontalLine(obj);
						break;
					case 'verticalLine':
						cw.addVerticalLine(obj);
						break;
					case 'dashedVerticalLine':
						cw.addDashedVerticalLine(obj);
						break;
					case 'rectangle':
						cw.addRectangle(obj);
						break;
					default:
						break;
				}
			});
			cw.draw(plot);
		} 
	};
	
	$.jqplot.CanvasWindow.prototype.addObjects = function(plot, objects) {
		if ($.isArray(objects) && objects.length) {
			var cw = this;
			objects.forEach(function(object) {
				var type = Object.keys(object).shift();
				var obj = object[type];
				switch (type) {
					case 'line':
						cw.addLine(obj);
						break;
					case 'horizontalLine':
						cw.addHorizontalLine(obj);
						break;
					case 'dashedHorizontalLine':
						cw.addDashedHorizontalLine(obj);
						break;
					case 'verticalLine':
						cw.addVerticalLine(obj);
						break;
					case 'dashedVerticalLine':
						cw.addDashedVerticalLine(obj);
						break;
					case 'rectangle':
						cw.addRectangle(obj);
						break;
					default:
						break;
				}
			});
			cw.draw(plot);
		} 
	};

	$.jqplot.CanvasWindow.prototype.removeObject = function(idx) {
		// check if integer, remove by index
		if ($.type(idx) == 'number') {
			this.objects.splice(idx, 1);
			this.objectNames.splice(idx, 1);
		}
		// if string, remove by name
		else if ($.type(idx) === 'string') {
			var id = $.inArray(idx, this.objectNames);
			if (id != -1) {
				this.objects.splice(id, 1);
				this.objectNames.splice(id, 1);
			}
			// all objects
		} else {
			this.objectNames.splice(0);
			this.objects.splice(0);
		}
	};

	$.jqplot.CanvasWindow.prototype.getObject = function(idx) {
		// check if integer, remove by index
		if ($.type(idx) == 'number') {
			return this.objects[idx];
		}
		// if string, remove by name
		else {
			var id = $.inArray(idx, this.objectNames);
			if (id != -1) {
				return this.objects[id];
			}
		}
	};

	// Set get as alias for getObject.
	$.jqplot.CanvasWindow.prototype.get = $.jqplot.CanvasWindow.prototype.getObject;

	$.jqplot.CanvasWindow.prototype.clear = function(plot) {
		if (!this.canvas || !this.bcanvas) {
			return;
		}
		this.canvas._ctx.clearRect(0, 0, this.canvas.getWidth() + 1, this.canvas.getHeight() + 1);
		this.bcanvas._ctx.clearRect(0, 0, this.bcanvas.getWidth() + 1, this.bcanvas.getHeight() + 1);
		$('.jqplot-canvaswindow-configicon', plot.target).each(function() {
		  $(this).remove();
		});
	};

	$.jqplot.CanvasWindow.prototype.draw = function(plot, dragobj, ev) {
		var obj, objs = this.objects, mr = this.markerRenderer, start, stop;
		if (this.options.show) {
			this.clear(plot);
			/*this.canvas._ctx.clearRect(0,0,this.canvas.getWidth(), this.canvas.getHeight());
			 this.bcanvas._ctx.clearRect(0,0,this.bcanvas.getWidth(), this.bcanvas.getHeight());*/
			
			if (plot.data.length === 0) {
			    return;
			}

			for (var k = 0; k < objs.length; k++) {
				obj = objs[k];
				var opts = $.extend(true, {}, obj.options);
				if (opts.show) {
					if (obj.canvas === null || (obj.canvas._elem && !obj.canvas._elem.hasClass('jqplot-canvaswindow-canvas'))) {
                        if (obj.canvas !== null) {
                            obj.canvas.resetCanvas();
                        }
						obj.canvas = opts.isBackground ? this.bcanvas : this.canvas;
					}
				
					// style and shadow properties should be set before
					// every draw of marker renderer.
					mr.shadow = opts.shadow;
					obj.tooltipWidthFactor = opts.lineWidth / opts.showTooltipPrecision;
					
					// TODO: bug fix plot.axes[opts.xaxis].series_u2p
					// Temporary
					if (opts.xaxis === 'xaxis' && typeof plot.axes[opts.xaxis].series_u2p === 'undefined') {
						var xaxis_series_u2p = plot.axes['x2axis'].series_u2p;
					} else {
						var xaxis_series_u2p = plot.axes[opts.xaxis].series_u2p;
					}
					
					if (opts.yaxis === 'yaxis' && typeof plot.axes[opts.yaxis].series_u2p === 'undefined') {
						var yaxis_series_u2p = plot.axes['y2axis'].series_u2p;
					} else {
						var yaxis_series_u2p = plot.axes[opts.yaxis].series_u2p;
					}
					
					
					switch (obj.type) {
						case 'line':
							// style and shadow properties should be set before
							// every draw of marker renderer.
							mr.style = 'line';
							opts.closePath = false;
							start = [xaxis_series_u2p(opts.start[0]), yaxis_series_u2p(opts.start[1])];
							stop = [xaxis_series_u2p(opts.stop[0]), yaxis_series_u2p(opts.stop[1])];
							obj.gridStart = start;
							obj.gridStop = stop;
							mr.draw(start, stop, obj.canvas._ctx, opts);
							break;
						case 'horizontalLine':
							// style and shadow properties should be set before
							// every draw of marker renderer.
							if (opts.y != null) {
								mr.style = 'line';
								opts.closePath = false;
								var xaxis = plot.axes[opts.xaxis], yaxis = plot.axes[opts.yaxis], xstart = xaxis.series_u2p(xaxis.min), xstop = xaxis.series_u2p(xaxis.max), y = yaxis_series_u2p(opts.y), xminoff = opts.xminOffset || opts.xOffset, xmaxoff = opts.xmaxOffset || opts.xOffset, fillStart = xaxis.series_u2p(xaxis.min), fillStop = xaxis.series_u2p(xaxis.max);
								if (opts.xmin != null) {
									fillStart = xaxis.series_u2p(opts.xmin);
									if (!opts.isFullLine)
										xstart = fillStart;
								} else if (opts.xminBind != null) {
									fillStart = xaxis.series_u2p(this.get(opts.xminBind).options.x);
									if (!opts.isFullLine)
										xstart = fillStart;
								} else if (xminoff != null) {
									if ($.type(xminoff) == "number") {
										fillStart = xaxis.series_u2p(xaxis.min + xminoff);
										if (!opts.isFullLine)
											xstart = fillStart;
									} else if ($.type(xminoff) == "string") {
										fillStart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff);
										if (!opts.isFullLine)
											xstart = fillStart;
									}
								}
								if (opts.xmax != null) {
									fillStop = xaxis.series_u2p(opts.xmax);
									if (!opts.isFullLine)
										xstop = fillStop;
								} else if (opts.xmaxBind != null && this.get(opts.xmaxBind).options.show) {
									fillStop = xaxis.series_u2p(this.get(opts.xmaxBind).options.x);
									if (!opts.isFullLine)
										xstop = fillStop;
								} else if (xmaxoff != null) {
									if ($.type(xmaxoff) == "number") {
										fillStop = xaxis.series_u2p(xaxis.max - xmaxoff);
										if (!opts.isFullLine)
											xstop = fillStop;
									} else if ($.type(xmaxoff) == "string") {
										fillStop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff);
										if (!opts.isFullLine)
											xstop = fillStop;
									}
								}
								if (xstop != null && xstart != null) {
									obj.gridStart = [xstart, y];
									obj.gridStop = [xstop, y];

									mr.draw([xstart, y], [xstop, y], obj.canvas._ctx, opts);

									if (opts.fillArea) {
										var ctx = opts.fillBehind ? this.bcanvas._ctx : obj.canvas._ctx;
										
										if (fillStart < 0) {
											fillStart = 0;
											fillStop += parseFloat(xminoff);
										}

										// customizing for outsideTooltip (2013-03-04, Roy choi)
										if (this.options.outsideDraw) {
											if (this._paddingDirection == 'left') {
												fillStart += this._paddingWidth;
												fillStop += this._paddingWidth;
											}
										}

										ctx.fillStyle = opts.fillStyle;
										var fillToValue = null;
										if (opts.fillToBind && this.get(opts.fillToBind)) {
											fillToValue = this.get(opts.fillToBind).options.y;
										} else if (opts.fillToMin) {
											fillToValue = yaxis.min;
										} else if (opts.fillToMax) {
											fillToValue = yaxis.max;
										} else if (opts.fillToValue != null) {
											fillToValue = opts.fillToValue;
										}
										//var fillToValue = opts.fillToBind && this.get(opts.fillToBind) ? this.get(opts.fillToBind).options.y : opts.fillToValue;
										var ystart = yaxis.series_u2p(fillToValue);
										var ystop = yaxis.series_u2p(opts.y) - yaxis.series_u2p(fillToValue);
										ctx.fillRect(fillStart, ystart, fillStop - fillStart, ystop);
										
										if (opts.configIcon.show && (this.options.defaultConfigIcon.match(/\.(bmp|jpeg|jpg|gif|png)$/i) || opts.configIcon.image.match(/\.(bmp|jpeg|jpg|gif|png)$/i))) {
                        showConfigIcon(plot, obj, opts.configIcon, {
                          x: fillStart,
                          y: ystart,
                          width: fillStop - fillStart,
                          height: ystop
                        }, ctx.canvas);
                    }
										
										ctx.restore();
										
										ctx = null;
									}
								}
								
								if (opts.showTooltip && this.isDragging && opts.dragable && opts.dragable.showTooltip && dragobj && dragobj.options.name === opts.name) {
									var neighbor = this._neighbor;
									showTooltip(plot, obj, [neighbor.gridPos.x, neighbor.gridPos.y], neighbor.dataPos);
								}
								
								if (opts.dragable && opts.dragable.notifyOnDrag && $.isFunction(opts.dragable.afterRedraw) && this.isDragging && dragobj && dragobj.options.name === opts.name) {
									opts.dragable.afterRedraw.call(obj, ev, false, opts.y, plot, this);
								}
							}

							break;

						case 'dashedHorizontalLine':

							var dashPat = opts.dashPattern;
							var dashPatLen = 0;
							for (var i = 0; i < dashPat.length; i++) {
								dashPatLen += dashPat[i];
							}

							// style and shadow properties should be set before
							// every draw of marker renderer.
							if (opts.y != null) {
								mr.style = 'line';
								opts.closePath = false;
								var xaxis = plot.axes[opts.xaxis], xstart = xaxis.series_u2p(xaxis.min), xstop = xaxis.series_u2p(xaxis.max), y = yaxis_series_u2p(opts.y), xminoff = opts.xminOffset || opts.xOffset, xmaxoff = opts.xmaxOffset || opts.xOffset, fillStart = xaxis.series_u2p(xaxis.min), fillStop = xaxis.series_u2p(xaxis.max);
								if (opts.xmin != null) {
									fillStart = xaxis.series_u2p(opts.xmin);
									if (!opts.isFullLine)
										xstart = fillStart;
								} else if (opts.xminBind != null) {
									fillStart = xaxis.series_u2p(this.get(opts.xminBind).options.x);
									if (!opts.isFullLine)
										xstart = fillStart;
								} else if (xminoff != null) {
									if ($.type(xminoff) == "number") {
										fillStart = xaxis.series_u2p(xaxis.min + xminoff);
										if (!opts.isFullLine)
											xstart = fillStart;
									} else if ($.type(xminoff) == "string") {
										fillStart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff);
										if (!opts.isFullLine)
											xstart = fillStart;
									}
								}
								if (opts.xmax != null) {
									fillStop = xaxis.series_u2p(opts.xmax);
									if (!opts.isFullLine)
										xstop = fillStop;
								} else if (opts.xmaxBind != null) {
									fillStop = xaxis.series_u2p(this.get(opts.xmaxBind).options.x);
									if (!opts.isFullLine)
										xstop = fillStop;
								} else if (xmaxoff != null) {
									if ($.type(xmaxoff) == "number") {
										fillStop = xaxis.series_u2p(xaxis.max - xmaxoff);
										if (!opts.isFullLine)
											xstop = fillStop;
									} else if ($.type(xmaxoff) == "string") {
										fillStop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff);
										if (!opts.isFullLine)
											xstop = fillStop;
									}
								}
								if (xstop != null && xstart != null) {
									obj.gridStart = [xstart, y];
									obj.gridStop = [xstop, y];

									var numDash = Math.ceil((xstop - xstart) / dashPatLen);
									var b = xstart, e;
									for (var i = 0; i < numDash; i++) {
										for (var j = 0; j < dashPat.length; j += 2) {
											e = b + dashPat[j];
											mr.draw([b, y], [e, y], obj.canvas._ctx, opts);
											b += dashPat[j];
											if (j < dashPat.length - 1) {
												b += dashPat[j + 1];
											}
										}
									}
									if (opts.fillArea) {
										var ctx = opts.fillBehind ? this.bcanvas._ctx : obj.canvas._ctx;
										
										if (fillStart < 0) {
											fillStart = 0;
											fillStop += parseFloat(xminoff);
										}

										// customizing for outsideTooltip (2013-03-04, Roy choi)
										if (this.options.outsideDraw) {
											if (this._paddingDirection == 'left') {
												fillStart += this._paddingWidth;
												fillStop += this._paddingWidth;
											}
										}

										ctx.fillStyle = opts.fillStyle;
										var fillToValue = null;
										if (opts.fillToBind && this.get(opts.fillToBind)) {
											fillToValue = this.get(opts.fillToBind).options.y;
										} else if (opts.fillToMin) {
											fillToValue = yaxis.min;
										} else if (opts.fillToMax) {
											fillToValue = yaxis.max;
										} else if (opts.fillToValue != null) {
											fillToValue = opts.fillToValue;
										}
										//var fillToValue = opts.fillToBind && this.get(opts.fillToBind) ? this.get(opts.fillToBind).options.y : opts.fillToValue;
										var ystart = yaxis.series_u2p(fillToValue);
										var ystop = yaxis.series_u2p(opts.y) - yaxis.series_u2p(fillToValue);
										ctx.fillRect(fillStart, ystart, fillStop - fillStart, ystop);
										
										if (opts.configIcon.show && (this.options.defaultConfigIcon.match(/\.(bmp|jpeg|jpg|gif|png)$/i) || opts.configIcon.image.match(/\.(bmp|jpeg|jpg|gif|png)$/i))) {
                        showConfigIcon(plot, obj, opts.configIcon, {
                          x: fillStart,
                          y: ystart,
                          width: fillStop - fillStart,
                          height: ystop
                        }, ctx.canvas);
                    }
										
										ctx.restore();
											
										ctx = null;
									}
								}
								
								if (opts.showTooltip && this.isDragging && opts.dragable && opts.dragable.showTooltip && dragobj && dragobj.options.name === opts.name) {
									var neighbor = this._neighbor;
									showTooltip(plot, obj, [neighbor.gridPos.x, neighbor.gridPos.y], neighbor.dataPos);
								}

								if (opts.dragable && opts.dragable.notifyOnDrag && $.isFunction(opts.dragable.afterRedraw) && this.isDragging && dragobj && dragobj.options.name === opts.name) {
									opts.dragable.afterRedraw.call(obj, ev, false, opts.y, plot, this);
								}
							}
							break;

						case 'verticalLine':

							// style and shadow properties should be set before
							// every draw of marker renderer.
							if (opts.x != null) {
								mr.style = 'line';
								opts.closePath = false;
								var yaxis = plot.axes[opts.yaxis], xaxis = plot.axes[opts.xaxis], ystart, ystop, x = xaxis_series_u2p(opts.x), yminoff = opts.yminOffset || opts.yOffset, ymaxoff = opts.ymaxOffset || opts.yOffset;
								
								if (opts.isFullLine) {
									if (this.options.canvasExtension) {
										ystart = obj.canvas._ctx.canvas.height;
										ystop = 0;
									}
								} else {
									ystart = yaxis.min;
									ystop = yaxis.max;
									
									if (opts.ymin != null) {
										ystart = yaxis.series_u2p(opts.ymin);
									} else if (yminoff != null) {
										if ($.type(yminoff) == "number") {
											ystart = yaxis.series_u2p(yaxis.min - yminoff);
										} else if ($.type(yminoff) == "string") {
											ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff);
										}
									}
									if (opts.ymax != null) {
										ystop = yaxis.series_u2p(opts.ymax);
									} else if (ymaxoff != null) {
										if ($.type(ymaxoff) == "number") {
											ystop = yaxis.series_u2p(yaxis.max + ymaxoff);
										} else if ($.type(ymaxoff) == "string") {
											ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff);
										}
									}
								}

								if (ystop != null && ystart != null) {
									obj.gridStart = [x, ystart];
									obj.gridStop = [x, ystop];

									mr.draw([x, ystart], [x, ystop], obj.canvas._ctx, opts);

									if (opts.fillArea) {
										var ctx = opts.fillBehind ? this.bcanvas._ctx : obj.canvas._ctx;
										
										ctx.fillStyle = opts.fillStyle;

										var fillToValue = null;
										if (opts.fillToBind && this.get(opts.fillToBind)) {
											fillToValue = this.get(opts.fillToBind).options.x;
										} else if (opts.fillToMin) {
											fillToValue = xaxis.min;
										} else if (opts.fillToMax) {
											fillToValue = xaxis.max;
										} else if (opts.fillToValue != null) {
											fillToValue = opts.fillToValue;
										}
										//var fillToValue = opts.fillToBind && this.get(opts.fillToBind) ? this.get(opts.fillToBind).options.x : opts.fillToValue;
										var xstop = xaxis.series_u2p(opts.x) - xaxis.series_u2p(fillToValue);
										var xstart = xaxis.series_u2p(fillToValue);
										ctx.fillRect(xstart, ystart, xstop, ystop - ystart);
										
										if (opts.configIcon.show && (this.options.defaultConfigIcon.match(/\.(bmp|jpeg|jpg|gif|png)$/i) || opts.configIcon.image.match(/\.(bmp|jpeg|jpg|gif|png)$/i))) {
										    showConfigIcon(plot, obj, opts.configIcon, {
										      x: xstart,
										      y: ystart,
										      width: xstop,
										      height: ystop - ystart
										    }, ctx.canvas);
										}
										
										ctx.restore();
									}
								}
								
								if (opts.showTooltip && this.isDragging && opts.dragable && opts.dragable.showTooltip && dragobj && dragobj.options.name === opts.name) {
									var neighbor = this._neighbor;
									var ypos = this.options.canvasExtension && this.options.canvasExtendDirection === 'top' ? neighbor.gridPos.y - this.options.canvasExtension : neighbor.gridPos.y;
									showTooltip(plot, obj, [neighbor.gridPos.x, ypos], neighbor.dataPos);
								}

								if (opts.dragable && opts.dragable.notifyOnDrag && $.isFunction(opts.dragable.afterRedraw) && this.isDragging && dragobj && dragobj.options.name === opts.name) {
									opts.dragable.afterRedraw.call(obj, ev, false, opts.x, plot, this);
								}
							}
							break;

						case 'dashedVerticalLine':

							var dashPat = opts.dashPattern;
							var dashPatLen = 0;
							for (var i = 0; i < dashPat.length; i++) {
								dashPatLen += dashPat[i];
							}

							// style and shadow properties should be set before
							// every draw of marker renderer.
							if (opts.x != null) {
								mr.style = 'line';
								opts.closePath = false;
								var yaxis = plot.axes[opts.yaxis], xaxis = plot.axes[opts.xaxis], ystart, ystop, x = xaxis_series_u2p(opts.x), yminoff = opts.yminOffset || opts.yOffset, ymaxoff = opts.ymaxOffset || opts.yOffset;
								
								if (opts.isFullLine) {
									if (this.options.canvasExtension) {
										ystart = obj.canvas._ctx.canvas.height;
										ystop = 0;
									}
								} else {
									ystart = yaxis.min;
									ystop = yaxis.max;
									
									if (opts.ymin != null) {
										ystart = yaxis.series_u2p(opts.ymin);
									} else if (yminoff != null) {
										if ($.type(yminoff) == "number") {
											ystart = yaxis.series_u2p(yaxis.min - yminoff);
										} else if ($.type(yminoff) == "string") {
											ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff);
										}
									}
									if (opts.ymax != null) {
										ystop = yaxis.series_u2p(opts.ymax);
									} else if (ymaxoff != null) {
										if ($.type(ymaxoff) == "number") {
											ystop = yaxis.series_u2p(yaxis.max + ymaxoff);
										} else if ($.type(ymaxoff) == "string") {
											ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff);
										}
									}
								}

								if (ystop != null && ystart != null) {
									obj.gridStart = [x, ystart];
									obj.gridStop = [x, ystop];


									var numDash = Math.ceil((ystart - ystop) / dashPatLen);
									var firstDashAdjust = ((numDash * dashPatLen) - (ystart - ystop)) / 2.0;
									var b = ystart, e, bs, es;
									for (var i = 0; i < numDash; i++) {
										for (var j = 0; j < dashPat.length; j += 2) {
											e = b - dashPat[j];
											if (e < ystop) {
												e = ystop;
											}
											if (b < ystop) {
												b = ystop;
											}
											// es = e;
											// if (i == 0) {
											//  es += firstDashAdjust;
											// }
											mr.draw([x, b], [x, e], obj.canvas._ctx, opts);
											b -= dashPat[j];
											if (j < dashPat.length - 1) {
												b -= dashPat[j + 1];
											}
										}
									}
									if (opts.fillArea) {
										
										var ctx = opts.fillBehind ? this.bcanvas._ctx : obj.canvas._ctx;

										ctx.fillStyle = opts.fillStyle;

										var fillToValue = null;
										if (opts.fillToBind && this.get(opts.fillToBind)) {
											fillToValue = this.get(opts.fillToBind).options.x;
										} else if (opts.fillToMin) {
											fillToValue = xaxis.min;
										} else if (opts.fillToMax) {
											fillToValue = xaxis.max;
										} else if (opts.fillToValue != null) {
											fillToValue = opts.fillToValue;
										}
										//var fillToValue = opts.fillToBind && this.get(opts.fillToBind) ? this.get(opts.fillToBind).options.x : opts.fillToValue;
										var xstop = xaxis.series_u2p(opts.x) - xaxis.series_u2p(fillToValue);
                    var xstart = xaxis.series_u2p(fillToValue);
										ctx.fillRect(xstart, ystart, xstop, ystop - ystart);
										
										if (opts.configIcon.show && (this.options.defaultConfigIcon.match(/\.(bmp|jpeg|jpg|gif|png)$/i) || opts.configIcon.image.match(/\.(bmp|jpeg|jpg|gif|png)$/i))) {
                        showConfigIcon(plot, obj, opts.configIcon, {
                          x: xstart,
                          y: ystart,
                          width: xstop,
                          height: ystop - ystart
                        }, ctx.canvas);
                    }
										
										ctx.restore();
									}
								}
								
								if (opts.showTooltip && this.isDragging && opts.dragable && opts.dragable.showTooltip && dragobj && dragobj.options.name === opts.name) {
									var neighbor = this._neighbor;
									var ypos = this.options.canvasExtension && this.options.canvasExtendDirection === 'top' ? neighbor.gridPos.y + this.options.canvasExtension : neighbor.gridPos.y;
									showTooltip(plot, obj, [neighbor.gridPos.x, ypos], neighbor.dataPos);
								}

								if (opts.dragable && opts.dragable.notifyOnDrag && $.isFunction(opts.dragable.afterRedraw) && this.isDragging && dragobj && dragobj.options.name === opts.name) {
									opts.dragable.afterRedraw.call(obj, ev, false, opts.x, plot, this);
								}
							}
							break;

						case 'rectangle':
							// style and shadow properties should be set before
							// every draw of marker renderer.
							mr.style = 'line';
							opts.closePath = true;

							var xaxis = plot.axes[opts.xaxis], xstart, xstop, y = yaxis_series_u2p(opts.y), xminoff = opts.xminOffset || opts.xOffset, xmaxoff = opts.xmaxOffset || opts.xOffset;
							// customizing start (2014-04-16, Roy Choi)
							if (typeof opts.xminBind === 'string' && this.get(opts.xminBind)) {
								xstart = xaxis.series_u2p(this.get(opts.xminBind).options.x);
							// customizing end
							} else if (opts.xmin != null) {
								xstart = xaxis.series_u2p(opts.xmin);
							} else if (xminoff != null) {
								if ($.type(xminoff) == "number") {
									xstart = xaxis.series_u2p(xaxis.min + xminoff);
								} else if ($.type(xminoff) == "string") {
									xstart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff);
								}
							}
							// customizing start (2014-04-16, Roy Choi)
							if (typeof opts.xmaxBind === 'string' && this.get(opts.xmaxBind)) {
								xstop = xaxis.series_u2p(this.get(opts.xmaxBind).options.x);
							// customizing end
							} else if (opts.xmax != null) {
								xstop = xaxis.series_u2p(opts.xmax);
							} else if (xmaxoff != null) {
								if ($.type(xmaxoff) == "number") {
									xstop = xaxis.series_u2p(xaxis.max - xmaxoff);
								} else if ($.type(xmaxoff) == "string") {
									xstop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff);
								}
							}

							var yaxis = plot.axes[opts.yaxis], ystart, ystop, x = xaxis_series_u2p(opts.x), yminoff = opts.yminOffset || opts.yOffset, ymaxoff = opts.ymaxOffset || opts.yOffset;
							// customizing start (2014-04-16, Roy Choi)
							if (typeof opts.yminBind === 'string' && this.get(opts.yminBind)) {
								ystart = yaxis.series_u2p(this.get(opts.yminBind).options.y);
							// customizing end
							} else if (opts.ymin != null) {
								ystart = yaxis.series_u2p(opts.ymin);
							} else if (yminoff != null) {
								if ($.type(yminoff) == "number") {
									ystart = yaxis.series_u2p(yaxis.min - yminoff);
								} else if ($.type(yminoff) == "string") {
									ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff);
								}
							}
							// customizing start (2014-04-16, Roy Choi)
							if (typeof opts.ymaxBind === 'string' && this.get(opts.ymaxBind)) {
								ystop = yaxis.series_u2p(this.get(opts.ymaxBind).options.y);
							// customizing end
							} else if (opts.ymax != null) {
								ystop = yaxis.series_u2p(opts.ymax);
							} else if (ymaxoff != null) {
								if ($.type(ymaxoff) == "number") {
									ystop = yaxis.series_u2p(yaxis.max + ymaxoff);
								} else if ($.type(ymaxoff) == "string") {
									ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff);
								}
							}

							if (xstop != null && xstart != null && ystop != null && ystart != null) {
								obj.gridStart = [xstart, ystart];
								obj.gridStop = [xstop, ystop];
								
								var yend;
								if (ystop - ystart < -ystart) {	// temporary bug fix
									yend = -ystart;
								} else {
									yend = ystop - ystart;
								}
								
								var ctx = opts.isBackground ? this.bcanvas._ctx : this.canvas;
								
                ctx.fillStyle = opts.color;
                ctx.fillRect(xstart, ystart, xstop - xstart, yend);
								
								if (opts.configIcon.show && (this.options.defaultConfigIcon.match(/\.(bmp|jpeg|jpg|gif|png)$/i) || opts.configIcon.image.match(/\.(bmp|jpeg|jpg|gif|png)$/i))) {
                    showConfigIcon(plot, obj, opts.configIcon, {
                      x: xstart,
                      y: ystart,
                      width: xstop - xstart,
                      height: yend
                    }, ctx.canvas);
                }
                
                ctx.restore();
                ctx = null;
							}
							break;

						default:
							break;
					}
				}
			}
			
			var coelem = this.canvas._elem.detach();
			var cobelem = this.bcanvas._elem.detach();
      if (plot.plugins.specWindow && plot.plugins.specWindow.specCanvas._elem && plot.plugins.specWindow.specCanvas._elem.width() > 0) {
        plot.plugins.specWindow.specCanvas._elem.before(cobelem);
        plot.plugins.specWindow.specCanvas._elem.before(coelem);
      } else if (plot.series.length > 0) {
        plot.series[plot.seriesStack[0]].canvas._elem.before(cobelem);
        plot.eventCanvas._elem.before(coelem);
      }

			coelem = cobelem = null;
		}
	};

	// called within context of plot
	// create a canvas which we can draw on.
	// insert it before the eventCanvas, so eventCanvas will still capture events.
	$.jqplot.CanvasWindow.postPlotDraw = function() {
		var cw = this.plugins.canvasWindow;
		if (cw == null) return;
		// Memory Leaks patch
		if (cw && cw.highlightCanvas) {
			cw.highlightCanvas.resetCanvas();
			cw.highlightCanvas = null;
		}
		cw.canvas = new $.jqplot.GenericCanvas();
		cw.bcanvas = new $.jqplot.GenericCanvas();

		var canvasGridPadding = $.extend(true, {}, this._gridPadding);
		if (cw.options.canvasExtension) {
			canvasGridPadding[cw.options.canvasExtendDirection] -= cw.options.canvasExtension;
		}
		
		this.eventCanvas._elem.before(cw.canvas.createElement(canvasGridPadding, 'jqplot-canvaswindow-canvas', this._plotDimensions, this));
		this.eventCanvas._elem.before(cw.bcanvas.createElement(canvasGridPadding, 'jqplot-canvaswindow-canvas', this._plotDimensions, this));

		cw.canvas.setContext();
		cw.bcanvas.setContext();
		
		cw.canvas._elem.on('mousemove', {plot: this, canvas: cw.canvas}, function(ev) {
      var positions = getEventPosition(ev);
      var p = ev.data.plot;
      var evt = $.Event('jqplotMouseMove');
      evt.pageX = ev.pageX;
      evt.pageY = ev.pageY;
      evt.target = ev.data.canvas._elem;
      handleMove(evt, positions.gridPos, positions.dataPos, null, p);
		});
		cw.canvas._elem.on('mousedown', {plot: this, canvas: cw.canvas}, function(ev) {
      var positions = getEventPosition(ev);
      var plot = ev.data.plot;
      var evt = $.Event('jqplotMouseDown');
      evt.pageX = ev.pageX;
      evt.pageY = ev.pageY;
      handleDown(ev, positions.gridPos, positions.dataPos, null, plot);
		});
		cw.canvas._elem.on('mouseenter', {canvasWindow: cw}, function(ev) {
		  if (!ev.data.canvasWindow.isDragging) {
		    ev.data.canvasWindow.canvas._elem.css('cursor', 'default');
		  }
		});

		if ($.isPlainObject(cw.options.canvasExtensionEvents)) {
			var plot = this;
			$.each(cw.options.canvasExtensionEvents, function(eventKey, handler) {
				cw.canvas._elem.on(eventKey, {plot: plot, canvas: cw.canvas}, function(evt) {
					var plot = evt.data.plot;
					var cw = plot.plugins.canvasWindow;
					var position = getEventPosition(evt);
					var neighbor = checkNearLine(cw.objects, position.gridPos, position.dataPos);
					if (neighbor === null && !cw.isDragging) {
						var objName = checkFillArea(evt, plot);
						if (eventKey === 'click' && objName) {
							var obj = cw.get(objName);
							handler.call(this, evt, objName, obj, plot);
						} else {
							var ca = plot.plugins.customAxes;
							if (ca && $.isPlainObject(ca.axes) && Object.keys(ca.axes).length) {
								$.each(ca.axes, function(key, axis) {
							    var pEvent = $.Event(evt);
							    var target = axis._canvas._elem;
							    pEvent.target = target;
							    pEvent.type = evt.type,
							    pEvent.data = evt.data;
							    pEvent.currentTarget = target;
							    pEvent.pageX = evt.pageX;
							    pEvent.pageY = evt.pageY;
							    pEvent.result = evt.result;
							    pEvent.timeStamp = evt.timeStamp;
							    pEvent.which = evt.which;
							    pEvent.button = evt.button;
							    $(target).trigger(evt, pEvent);
									ca = null;
								});
							}
						}
					}
					cw = null;
				});
			});
			
			// add mouse over,move,out event binding for customAxes
		    cw.canvas._elem.on('mouseover mousemove mouseout', {plot: plot, canvas: cw.canvas}, function(evt) {
                var plot = evt.data.plot;
                var position = getEventPosition(evt);
                var ca = plot.plugins.customAxes;
                if (ca && $.isPlainObject(ca.axes) && Object.keys(ca.axes).length) {
                    $.each(ca.axes, function(key, axis) {
                        var pEvent = $.Event(evt);
                        var target = axis._canvas._elem;
                        pEvent.target = target;
                        pEvent.type = evt.type,
                        pEvent.data = evt.data;
                        pEvent.currentTarget = target;
                        pEvent.pageX = evt.pageX;
                        pEvent.pageY = evt.pageY;
                        pEvent.result = evt.result;
                        pEvent.timeStamp = evt.timeStamp;
                        pEvent.which = evt.which;
                        pEvent.button = evt.button;
                        $(target).trigger(evt, pEvent);
                        ca = null;
                    });
                }
            });
		}

		if (!cw.deferDraw) {
			cw.draw(this);
		}

		var elem = document.createElement('div');
		cw._tooltipElem = $(elem);
		elem = null;
		cw._tooltipElem.addClass('jqplot-canvasWindow-tooltip');
		cw._tooltipElem.css({
			position : 'absolute',
			display : 'none'
		});

		this.eventCanvas._elem.before(cw._tooltipElem);
		this.eventCanvas._elem.bind('mouseleave', {
			elem : cw._tooltipElem
		}, function(ev) {
			ev.data.elem.hide().empty();
		});

		var cw = null;
	};
	
	function showConfigIcon(plot, obj, configIcon, offset, canvas) {
	  var cw = plot.plugins.canvasWindow;
	  
	  var elem = $('<div></div>');
	  elem.addClass('jqplot-canvaswindow-configicon').css({
	    position: 'absolute',
	    width: configIcon.width,
	    height: configIcon.height,
	    backgroundRepeat: 'no-repeat',
	    backgroundPosition: 'center center'
	  });
	  if (configIcon.style) {
	    elem.css(configIcon.style);
	  }
	  if ($.isArray(configIcon.classes.length) && configIcon.classes.length > 0) {
      configIcon.classes.forEach(function(className) {
        elem.addClass(className);
      });
    }
    
    if (configIcon.image !== null) {
      elem.css({
        backgroundImage: 'url('+configIcon.image+')'
      });
    }

	  plot.eventCanvas._elem.after(elem);
	  
	  if (Math.abs(offset.width) < elem.outerWidth(true)) {
	    elem.css({
        width: Math.max(0, Math.abs(offset.width) - (elem.outerWidth(true) - elem.width()))
      });
	  }
	  
    if (Math.abs(offset.height) < elem.outerHeight(true)) {
      elem.css({
        width: Math.max(0, Math.abs(offset.height) - (elem.outerHeight(true) - elem.height()))
      });
    }
	  
	  var top = 0, left = 0;
	  var x1, y1, x2, y2;
	  
	  var canvasOffset = $(canvas).offset();
	  
	  var plotOffset = plot.target.offset();
	  var gridPadding = plot._gridPadding;
	  
	  if (offset.width > 0) {
	    x1 = canvasOffset.left + offset.x;
	    x2 = canvasOffset.left + offset.x + offset.width;
	  } else {
      x1 = canvasOffset.left + offset.x + offset.width;
      x2 = canvasOffset.left + offset.x;
	  }
	  
	  if (offset.height > 0) {
      y1 = canvasOffset.top + offset.y;
      y2 = canvasOffset.top + offset.y + offset.height;
    } else {
      y1 = canvasOffset.top + offset.y + offset.height;
      y2 = canvasOffset.top + offset.y;
    }
    
    switch (configIcon.location) {
      case 'n':
        top = y1;
        left = x1 + offset.width / 2 - elem.outerWidth(true) / 2;
        break;
      case 's':
        top = y2 - elem.outerHeight(true);
        left = x1 + offset.width / 2 - elem.outerWidth(true) / 2;
        break;
      case 'e':
        top = y1 + offset.height / 2 - elem.outerHeight(true) / 2;
        left = x2 - elem.outerWidth(true);
        break;
      case 'se':
        top = y2 - elem.outerHeight(true);
        left = x2 - elem.outerWidth(true);
        break;
      case 'nw':
        top = y1;
        left = x1;
        break;
      case 'w':
        top = y1 + offset.height / 2 - elem.outerHeight(true) / 2;
        left = x1;
        break;
      case 'sw':
        top = y2 - elem.outerHeight(true);
        left = x1;
        break;
      case 'ne':
      default:
        top = y1;
        left = x2 - elem.outerWidth(true);
        break;
    }
    
    elem.offset({
      top: top,
      left: left
    });
    
    if (configIcon.events) {
      $.each(configIcon.events, function(eventName, eventCallback) {
        elem.bind(eventName, {obj: obj.options, plot: plot}, function(ev) {
          eventCallback(ev, ev.data.obj.name, ev.data.obj, ev.data.plot);
        });
      });
    }
    
    elem.bind();
	}

	function showTooltip(plot, obj, gridpos, datapos) {
		var cw = plot.plugins.canvasWindow;
		var elem = cw._tooltipElem;

		var opts = obj.options, x, y;

		elem.html($.isFunction(opts.tooltipFormatString) ? opts.tooltipFormatString(plot, obj, gridpos, datapos) : $.jqplot.sprintf(opts.tooltipFormatString, datapos[0], datapos[1]));

		switch (opts.tooltipLocation) {
			case 'nw':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true);
				break;
			case 'n':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) / 2;
				y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true);
				break;
			case 'ne':
				x = gridpos[0] + plot._gridPadding.left + opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true);
				break;
			case 'e':
				x = gridpos[0] + plot._gridPadding.left + opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - elem.outerHeight(true) / 2;
				break;
			case 'se':
				x = gridpos[0] + plot._gridPadding.left + opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset;
				break;
			case 's':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) / 2;
				y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset;
				break;
			case 'sw':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset;
				break;
			case 'w':
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - elem.outerHeight(true) / 2;
				break;
			default:
				// same as 'nw'
				x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(true) - opts.tooltipOffset;
				y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(true);
				break;
		}

		elem.css('left', x);
		elem.css('top', y);
		if (opts.fadeTooltip) {
			// Fix for stacked up animations.  Thnanks Trevor!
			elem.stop(true, true).fadeIn(opts.tooltipFadeSpeed);
		} else {
			elem.show();
		}
		elem = null;
	}

	function isNearLine(point, lstart, lstop, width) {
		// r is point to test, p and q are end points.
		var rx = point[0];
		var ry = point[1];
		var px = Math.round(lstop[0]);
		var py = Math.round(lstop[1]);
		var qx = Math.round(lstart[0]);
		var qy = Math.round(lstart[1]);

		var l = Math.sqrt(Math.pow(px - qx, 2) + Math.pow(py - qy, 2));

		// scale error term by length of line.
		var eps = width * l;
		var res = Math.abs((qx - px) * (ry - py) - (qy - py) * (rx - px));
		var ret = (res < eps) ? true : false;
		return ret;
	}

	function isNearRectangle(point, lstart, lstop, width) {
		// r is point to test, p and q are end points.
		var rx = point[0];
		var ry = point[1];
		var px = Math.round(lstop[0]);
		var py = Math.round(lstop[1]);
		var qx = Math.round(lstart[0]);
		var qy = Math.round(lstart[1]);

		var temp;
		if (px > qx) {
			temp = px;
			px = qx;
			qx = temp;
		}
		if (py > qy) {
			temp = py;
			py = qy;
			qy = temp;
		}

		var ret = (rx >= px && rx <= qx && ry >= py && ry <= qy);

		return ret;
	}

	function checkNearLine(objs, gridPos, dataPos) {
		var obj;
		var len = objs.length;
		var lstart, lstop, width;
		for (var i = 0; i < len; i++) {
			obj = objs[i];
			if (obj.type === 'rectangle') {
				continue;
			}
			lstart = obj.gridStart;
			lstop = obj.gridStop;
			width = obj.tooltipWidthFactor;

			// r is point to test, p and q are end points.
			var rx = gridPos.x;
			var ry = gridPos.y;
			if (lstop && lstart) {
				var px = Math.round(lstop[0]);
				var py = Math.round(lstop[1]);
				var qx = Math.round(lstart[0]);
				var qy = Math.round(lstart[1]);
			} else {
				return null;
			}

			var l = Math.sqrt(Math.pow(px - qx, 2) + Math.pow(py - qy, 2));

			// scale error term by length of line.
			var eps = width * l;
			var res = Math.abs((qx - px) * (ry - py) - (qy - py) * (rx - px));
			if (res < eps) {
				ret = {
					lineIndex : i
				};
				return ret;
			}
		}

		return null;
	}
	
	function checkFillArea(ev, plot) {
		var obj, robj;
		var cw = plot.plugins.canvasWindow;
		var objs = cw.objects;
		var len = objs.length;
		var opts;
		var start, stop;
		var max, min;
		var axis, direction;
		var position = getEventPosition(ev);
		
		for (var i = 0; i < len; i++) {
			obj = objs[i];
			opts = obj.options;
			if (obj.type === 'rectangle' || !opts.fillArea) {
				continue;
			}
			
			switch(obj.constructor) {
				case HorizontalLine:
				case DashedHorizontalLine:
					direction = 'y';
					axis = opts['yaxis'];
					break;
				case VerticalLine:
				case DashedVerticalLine:
					direction = 'x';
					axis = opts['xaxis'];
					break;
			}
			
			start = opts[direction];

			if (opts.fillToBind) {
				robj = cw.get(opts.fillToBind);
				stop = robj.options[direction];
			} else if (opts.fillToValue) {
				stop = opts.fillToValue;
			} else if (opts.fillToMax) {
				stop = plot.axes[axis].max;
			} else if (opts.fillToMin) {
				stop = plot.axes[axis].min;
			}
			
			if ((start < stop && start <= position.dataPos[axis] && stop >= position.dataPos[axis])
				|| (start >= stop && start >= position.dataPos[axis] && stop <= position.dataPos[axis])){
				return obj.options.name;
			}
		}

		return null;
	}

	function handleMove(ev, gridpos, datapos, neighbor, plot) {
		var cw = plot.plugins.canvasWindow;
		if (cw == null) return;
		var objs = cw.objects;
		var l = objs.length;
		var obj, haveHighlight = false;
		var elem;

		// customizing (2011-11-11, Roy Choi)
		if (cw.isDragging && cw._neighbor !== null) {
			/*var n = cw._neighbor;
			obj = objs[n.lineIndex];
			//var drag = obj.options.dragable;

			switch (obj.type) {
				case 'line':
					return;
					break;

				case 'horizontalLine':
				case 'dashedHorizontalLine':
					obj.options.y = datapos.yaxis;
					cw.draw(plot, obj);
					break;

				case 'verticalLine':
				case 'dashedVerticalLine':
					obj.options.x = datapos.xaxis;
					cw.draw(plot, obj);
					break;
				default:
					break;
			}*/
			return;
			//haveHighlight = true;
		}

		for (var i = 0; i < l; i++) {
			obj = objs[i];
			if (obj.options.showTooltip || obj.options.isDraggable) {
				var n;
				if (obj.type === 'rectangle') {
					n = isNearRectangle([gridpos.x, gridpos.y], obj.gridStart, obj.gridStop, obj.tooltipWidthFactor);
				} else {
					n = isNearLine([gridpos.x, gridpos.y], obj.gridStart, obj.gridStop, obj.tooltipWidthFactor);
				}
			}

			if(obj.options.isDraggable && !obj.options.isOver && n) {
				//obj.options._cursor.push(ev.target.style.cursor);
				switch (obj.type) {
					case 'line':
						break;
					case 'horizontalLine':
					case 'dashedHorizontalLine':
						$(ev.target).css('cursor', 'row-resize');
						break;

					case 'verticalLine':
					case 'dashedVerticalLine':
						$(ev.target).css('cursor', 'col-resize');
						break;
					default:
						break;
				} 
				obj.options.isOver = true;
			} else if (obj.options.isDraggable && obj.options.isOver && !n) {
				$(ev.target).css('cursor', 'default');
				obj.options.isOver = false;
			}
			
			if (obj.options.showTooltip) {
				datapos = [plot.axes[obj.options.xaxis].series_p2u(gridpos.x), plot.axes[obj.options.yaxis].series_p2u(gridpos.y)];
				var addYpos = 0;
				if (cw.options.canvasExtension && cw.options.canvasExtendDirection === 'top' && ev.target === cw.canvas._elem) {
					addYpos = -cw.options.canvasExtension;
				}

				// cases:
				//    near line, no highlighting
				//    near line, highliting on this line
				//    near line, highlighting another line
				//    not near any line, highlighting
				//    not near any line, no highlighting

				// near line, not currently highlighting
				if (n && cw.highlightObjectIndex == null) {
					switch (obj.type) {
						case 'line':
							showTooltip(plot, obj, [gridpos.x, gridpos.y], datapos);
							break;

						case 'horizontalLine':
						case 'dashedHorizontalLine':
							showTooltip(plot, obj, [gridpos.x, obj.gridStart[1]], [datapos[0], obj.options.y]);
							break;

						case 'verticalLine':
						case 'dashedVerticalLine':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y + addYpos], [obj.options.x, datapos[1]]);
							break;

						case 'rectangle':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						default:
							break;
					}
					cw.highlightObjectIndex = i;
					haveHighlight = true;
					break;
				}

				// near line, highlighting another line.
				else if (n && cw.highlightObjectIndex !== i) {
					// turn off tooltip.
					elem = cw._tooltipElem;
					if (obj.fadeTooltip) {
						elem.fadeOut(obj.tooltipFadeSpeed).empty();
					} else {
						elem.hide().empty();
					}

					// turn on right tooltip.
					switch (obj.type) {
						case 'line':
							showTooltip(plot, obj, [gridpos.x, gridpos.y], datapos);
							break;

						case 'horizontalLine':
						case 'dashedHorizontalLine':
							showTooltip(plot, obj, [gridpos.x, obj.gridStart[1]], [datapos[0], obj.options.y]);
							break;

						case 'verticalLine':
						case 'dashedVerticalLine':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y + addYpos], [obj.options.x, datapos[1]]);
							break;

						case 'rectangle':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						default:
							break;
					}

					cw.highlightObjectIndex = i;
					haveHighlight = true;
					break;
				}

				// near line, already highlighting this line, update
				else if (n) {
					switch (obj.type) {
						case 'line':
							showTooltip(plot, obj, [gridpos.x, gridpos.y], datapos);
							break;

						case 'horizontalLine':
						case 'dashedHorizontalLine':
							showTooltip(plot, obj, [gridpos.x, obj.gridStart[1]], [datapos[0], obj.options.y]);
							break;

						case 'verticalLine':
						case 'dashedVerticalLine':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y + addYpos], [obj.options.x, datapos[1]]);
							break;

						case 'rectangle':
							showTooltip(plot, obj, [obj.gridStart[0], gridpos.y], [obj.options.x, datapos[1]]);
							break;

						default:
							break;
					}

					haveHighlight = true;
					break;
				}
			}
		}

		// check if we are highlighting and not near a line, turn it off.
		if (!haveHighlight && cw.highlightObjectIndex !== null) {
			elem = cw._tooltipElem;
			obj = cw.getObject(cw.highlightObjectIndex);
			if (obj && obj.fadeTooltip) {
				elem.fadeOut(obj.tooltipFadeSpeed).empty();
			} else {
				elem.hide().empty();
			}
			cw.highlightObjectIndex = null;
		}
	}

	// customizing (2011-11-11, Roy Choi)
	function handleDown(ev, gridpos, datapos, neighbor, plot) {
		var cw = plot.plugins.canvasWindow;
		if (cw == null) return;
		var objs = cw.objects;

		neighbor = checkNearLine(objs, gridpos, datapos);
		if (neighbor != null) {
			ev.preventDefault();
			ev.stopImmediatePropagation();
			var obj = objs[neighbor.lineIndex];
			//obj.cursor.push($(ev.target).css('cursor'));
			var dragable = obj.options.isDraggable;
			if (dragable && !cw.isDragging) {
				cw._neighbor = neighbor;
				cw.isDragging = true;
				//cw.preZoomStatus.push(plot.plugins.cursor.show);
				cw._prevCursorShow = plot.plugins.cursor.show;
				plot.plugins.cursor.show = false;

				//if (document.onselectstart != undefined) {
				cw._oldHandlers.onselectstart = document.onselectstart;
				document.onselectstart = function() {
					return false;
				};
				//}
				if (document.ondrag != undefined) {
					cw._oldHandlers.ondrag = document.ondrag;
					document.ondrag = function() {
						return false;
					};
				}
				if (document.onmousedown != undefined) {
					cw._oldHandlers.onmousedown = document.onmousedown;
					document.onmousedown = function() {
						return false;
					};
				}

				$(document).on('mousemove', {plot: plot, canvas:cw.canvas}, handleDrag);
				$(document).on('mouseup', {plot: plot, canvas:cw.canvas}, handleUp);

				//initDragPoint(obj);
				//ev.target.style.cursor = "move";
				//plot.target.trigger('jqplotDragStart', [neighbor.lineIndex, null, gridpos, null]);

				//$(document).one('mouseup.jqplot_canvasoverlay', {plot:plot}, handleMouseUp);
			}
		} else {
			cw.isDragging = false;
		}
	}

	// customizing (2011-11-11, Roy Choi)
	function handleUp(ev) {
		ev.preventDefault();
		ev.stopImmediatePropagation();
		
    var plot = ev.data.plot;
    var cw = plot.plugins.canvasWindow;

		if (cw._neighbor !== null && cw.isDragging) {
			
			var position = getEventPosition(ev);

	    var canvas = cw.canvas;

			var obj = cw.get(cw._neighbor.lineIndex);
			var drag = obj.options.dragable;
			cw.isDragging = false;
			cw._neighbor = null;
			$('body').css('cursor', 'auto');
			$(plot.target).css('cursor', 'auto');
			$(cw.canvas._elem).css('cursor', 'auto');
			plot.eventCanvas._elem.css('cursor', 'auto');
			plot.plugins.cursor.show = cw._prevCursorShow;
      
      if (cw.options.snapToGrid && $.isNumeric(cw.options.snapToGridInterval)) {
        switch(obj.constructor) {
          case HorizontalLine:
          case DashedHorizontalLine:
            obj.options.y = Math.round(obj.options.y / cw.options.snapToGridInterval) * cw.options.snapToGridInterval;
            cw.draw(plot);
            break;
          case VerticalLine:
          case DashedVerticalLine:
            obj.options.x = Math.round(obj.options.x / cw.options.snapToGridInterval) * cw.options.snapToGridInterval;
            cw.draw(plot);
            break;
        }
      }

			if ($.isFunction(drag.afterRedraw)) {
				switch(obj.constructor) {
					case HorizontalLine:
					case DashedHorizontalLine:
						drag.afterRedraw.call(obj, ev, true, obj.options.y, plot, cw);
						break;
					case VerticalLine:
					case DashedVerticalLine:
						drag.afterRedraw.call(obj, ev, true, obj.options.x, plot, cw);
						break;
				}

			}

			//if (document.onselectstart != undefined && c._oldHandlers.onselectstart != null){
			document.onselectstart = cw._oldHandlers.onselectstart;
			cw._oldHandlers.onselectstart = null;
			//}
			if (document.ondrag != undefined && cw._oldHandlers.ondrag != null) {
				document.ondrag = cw._oldHandlers.ondrag;
				cw._oldHandlers.ondrag = null;
			}
			if (document.onmousedown != undefined && cw._oldHandlers.onmousedown != null) {
				document.onmousedown = cw._oldHandlers.onmousedown;
				cw._oldHandlers.onmousedown = null;
			}
			
			$(document).off('mousemove', handleDrag);
			$(document).off('mouseup', handleUp);

			//plot.target.trigger('jqplotDragStop', [gridpos, datapos]);
		}
	}
	
	function handleDrag(ev) {
		var plot = ev.data.plot;
		var cw = plot.plugins.canvasWindow;
		
		if (cw.isDragging && cw._neighbor !== null) {
	    var canvas = cw.canvas;
	    var position = getEventPosition(ev);
	    var gridPos = position.gridPos;
	    var dataPos = position.dataPos;
	    var an = ['xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
	    var ax = plot.axes;
	    var n, axis;
	    for (n=11; n>0; n--) {
	        axis = an[n-1];
	        if (ax[axis].show) {
	            dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);
	        }
	    }
	
			var n = cw._neighbor;
			n.gridPos = gridPos;
			n.dataPos = dataPos;
			obj = cw.get(n.lineIndex);
			//var drag = obj.options.dragable;
	
			switch (obj.type) {
				case 'line':
					return;
					break;
	
				case 'horizontalLine':
				case 'dashedHorizontalLine':
					if (dataPos[obj.options.yaxis] <= plot.axes[obj.options.yaxis].max && dataPos[obj.options.yaxis] >= plot.axes[obj.options.yaxis].min) {
						obj.options.y = dataPos[obj.options.yaxis];
						cw.draw(plot, obj, ev);
					}
					break;
	
				case 'verticalLine':
				case 'dashedVerticalLine':
					if (dataPos[obj.options.xaxis] <= plot.axes[obj.options.xaxis].max && dataPos[obj.options.xaxis] >= plot.axes[obj.options.xaxis].min) {
						obj.options.x = dataPos[obj.options.xaxis];
						cw.draw(plot, obj, ev);
					}
					break;
				default:
					break;
			}
		}
	}

  function getEventPosition(ev) {
      var plot = ev.data.plot;
      var canvas = ev.data.canvas;
      var go = canvas._elem.offset();
      var gridPos = {x:ev.pageX - go.left, y:ev.pageY - go.top};
      var dataPos = {xaxis:null, yaxis:null, x2axis:null, y2axis:null, y3axis:null, y4axis:null, y5axis:null, y6axis:null, y7axis:null, y8axis:null, y9axis:null, yMidAxis:null};
      var an = ['xaxis', 'yaxis', 'x2axis', 'y2axis', 'y3axis', 'y4axis', 'y5axis', 'y6axis', 'y7axis', 'y8axis', 'y9axis', 'yMidAxis'];
      var ax = plot.axes;
      var n, axis;
      for (n=11; n>0; n--) {
          axis = an[n-1];
          if (ax[axis].show) {
              dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]);
          }
      }

      return {offsets:go, gridPos:gridPos, dataPos:dataPos};
  }
  
  function handleLeave(ev) {
      var plot = ev.data.plot;
      var cw = plot.plugins.canvasWindow;
      if (cw._tooltipElem) {
          cw._tooltipElem.hide().empty();
      }
  }



	$.jqplot.postInitHooks.push($.jqplot.CanvasWindow.postPlotInit);
	$.jqplot.postDrawHooks.push($.jqplot.CanvasWindow.postPlotDraw);
	$.jqplot.eventListenerHooks.push(['jqplotMouseMove', handleMove]);
	$.jqplot.eventListenerHooks.push(['jqplotMouseDown', handleDown]);
    //$.jqplot.eventListenerHooks.push(['jqplotMouseUp', handleUp]);

})(jQuery);

/**
 jqPlot Event Line Plugin
 2015-12-15, Roy Choi
 */
(function($) {
    /**
     * Class: $.jqplot.EventLine
     * Plugin which will show by event line.
     */
    $.jqplot.EventLine = function(options) {
        this.enable = $.jqplot.config.enablePlugins;
        this.options = {
            show: false,
            tooltip: {
                show: true,
                adjust: 5,
                formatter: null,
                style: '',
                classes: ''
            },
            events: [],
            panels: {
                left: {
                    show: false
                },
                right: {
                    show: false
                },
                top: {
                    show: false
                },
                bottom: {
                    show: false
                }
            }
        };
        
        $.extend(true, this.options, options);
        
        this._canvas = null;
        this._bcanvas = null;
        this._events = [];
        this._markerRenderer = new $.jqplot.MarkerRenderer({
            style : 'line'
        });
        this._markerRenderer.init();
        this._labelElem = null;
        this._panels = {
            left: null,
            right: null,
            top: null,
            bottom: null
        };
        this._isDragging = false;
        this._neighbor = null;
        this._oldHandlers = {};
        this._cursor = 'default';
    };
    
    $.jqplot.EventLine.Types = {
        LINE: 'line',
        AREA: 'area'
    };
    
    // called with scope of plot
    $.jqplot.EventLine.init = function(target, data, opts) {
        var options = opts || {};

        // add a highlighter attribute to the plot
        this.plugins.eventLine = new $.jqplot.EventLine(options.eventLine);
        
        if (this.plugins.eventLine.enable && this.plugins.eventLine.options.show) {
            this.plugins.eventLine._canvas = new $.jqplot.GenericCanvas();
            this.plugins.eventLine._bcanvas = new $.jqplot.GenericCanvas();
        }
    };
    
    $.jqplot.EventLine.postPlotDraw = function() {
        if (!this.plugins.eventLine.enable || !this.plugins.eventLine.options.show) {
            return;
        }
        var eventLine = this.plugins.eventLine;
        
        if (eventLine._canvas) {
            eventLine._canvas.resetCanvas();
            eventLine._canvas = null;
        }
        if (eventLine._bcanvas) {
            eventLine._bcanvas.resetCanvas();
            eventLine._bcanvas = null;
        }
        
        eventLine._canvas = new $.jqplot.GenericCanvas();
        eventLine._bcanvas = new $.jqplot.GenericCanvas();
        
        var canvasGridPadding = $.extend(true, {}, this._gridPadding),
            canvasElem = eventLine._canvas.createElement(canvasGridPadding, 'jqplot-eventline-canvas', this._plotDimensions, this),
            bcanvasElem = eventLine._bcanvas.createElement(canvasGridPadding, 'jqplot-eventline-canvas', this._plotDimensions, this);
        if (this.series.length > 0) {
            this.series[this.seriesStack[0]].canvas._elem.before(bcanvasElem);
        } else {
            this.eventCanvas._elem.before(bcanvasElem);
        }
        this.eventCanvas._elem.before(canvasElem);
        
        canvasElem = bcanvasElem = null;
        
        eventLine._canvas.setContext();
        eventLine._bcanvas.setContext();
        
        // add panels
        eventLine.addPanels(this);
        
        eventLine.draw(this);
    };
    
    // Draw all events
    $.jqplot.EventLine.prototype.draw = function (plot) {
        $('.jqplot-eventline-labels', plot.target).remove();
        this._labelElem = $('<div class="jqplot-eventline-labels" style="position:absolute;top:0;width:100%;height:100%;pointer-events:none;"></div>');
        plot.target.append(this._labelElem);
        
        var self = this;
        
        this._events = [];
        this.options.events.forEach(function(event) {
            self._events.push(new Event(event, plot));
        });

        if (!checkAxes(plot, this._events)) {
            plot.replot({resetAxes: true});
            return;
        }

        if (this.options.show) {
            this.drawLines(plot);
            this.drawLabels(plot);
        }
    };
    
    $.jqplot.EventLine.prototype.addPanels = function (plot) {
        var self = this;
        $.each(this.options.panels, function(key, panelOptions) {
            var panel = new Panel(key, panelOptions);
            panel.draw(plot);
            self._panels[key] = panel;
        });
    };
    
    $.jqplot.EventLine.prototype.setEvents = function (events) {
        this.options.events = events;
    };
    
    $.jqplot.EventLine.prototype.drawLines = function (plot) {
        if (this._canvas != null) {
            var ctx = this._canvas._ctx, bctx = this._bcanvas._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            bctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            ctx = bctx = null;
        }
        
        this._events.forEach(function(event) {
            event.draw(plot);
        });
        
        $.each(this._panels, function(location, panel) {
            if (panel.show && panel.showGridLine && panel._gridLine) {
                panel._gridLine.draw({type: 'line', axis: panel.axis, background: false}, plot);
            }
        });
    };
    
    $.jqplot.EventLine.prototype.drawLabels = function (plot) {
        $('.jqplot-eventline-labels', plot.target).empty();
        
        this._events.forEach(function(event) {
            event.drawLabel(plot);
        });
    };
    
    $.jqplot.EventLine.prototype.nearLine = function (gridpos) {
        var neighbor = null;
        var el = this;
        $.each(this._events, function(index, event) {
            if (event.type === $.jqplot.EventLine.Types.LINE) {
                if (event._instance.isNear([gridpos.x, gridpos.y])) {
                    neighbor = {
                        event: event,
                        line: event._instance,
                        lineOption: el.options.events[index].line
                    };
                    return false;
                }
            } else {
                if (event._instance._endLine && event._instance._endLine.isNear([gridpos.x, gridpos.y])) {
                    neighbor = {
                        event: event,
                        line: event._instance._endLine,
                        lineOption: el.options.events[index].end
                    };
                    return false;
                } else if (event._instance._startLine && event._instance._startLine.isNear([gridpos.x, gridpos.y])) {
                    neighbor = {
                        event: event,
                        line: event._instance._startLine,
                        lineOption: el.options.events[index].start
                    };
                    return false;
                }
            }
        });
        
        return neighbor;
    };

    $.jqplot.EventLine.prePlotDraw = function(options) {
        var el = this.plugins.eventLine;

        if (!el.options.show || this.data.length === 0) {
            return;
        }

        el.options.events.forEach(function(event) {
            if (!event.show) return;
            el.resetAxes(event, this)
        }, this);
    };

    function checkAxes(plot, events) {
        var ret = true;
        events.forEach(function(event) {
            var axis = plot.axes[event.axis];
            var oldMin = axis._dataBounds.min;
            var oldMax = axis._dataBounds.max;
            if (event.type == $.jqplot.EventLine.Types.AREA) {
                pack(axis, event.start.value);
                pack(axis, event.end.value);
            } else {
                pack(axis, event.line.value);
            }
            if (oldMin > axis._dataBounds.min || oldMax < axis._dataBounds.max) {
                ret = false;
            }
        });
        return ret;
    }

    function pack(axis, value) {
        if (axis._dataBounds.min !== null && axis._dataBounds.min > value) {
            axis._dataBounds.min = value;
        }
        if (axis._dataBounds.max !== null && axis._dataBounds.max < value) {
            axis._dataBounds.max = value;
        }
    }

    $.jqplot.EventLine.prototype.resetAxes = function(event, plot) {
        var axis = plot.axes[event.axis]
        if (event.type == $.jqplot.EventLine.Types.AREA) {
            pack(axis, event.start.value);
            pack(axis, event.end.value);
        } else {
            pack(axis, event.line.value);
        }
    };
    
    function Event(options, plot) {
        this.name = '';
        this.show = true;
        this.axis = 'xaxis';
        this.type = 'line';
        this.background = true;
        this.line = {
            show: false
        };
        this.label = {
            show: false
        };
        
        $.extend(true, this, options);
        
        this._instance = null;
        this._label = null;
        
        if (this.type == null) {
            this.type = $.jqplot.EventLine.Types.LINE;
        }
        switch(this.type.toLowerCase()) {
            case $.jqplot.EventLine.Types.AREA:
                this._instance = new Area(options, plot);
            break;
            case $.jqplot.EventLine.Types.LINE:
                this._instance = new Line(this.line, plot);
                this._instance._parent = this;
            break;
        }
        
        if (this.label.show) {
            this._label = new Label(this.label);
        }
    }
    
    function Line(options, plot) {
        var el = plot.plugins.eventLine;
        
        this.name = '';
        this.show = true;
        this.value = null;
        this.color = '#000';
        this.width = 1;
        this.adjust = 0;
        this.pattern = null;
        this.shadow = false;
        this.eventDistance = 3;
        this.tooltip = $.extend(true, {
            show: true,
            adjust: 5,
            formatter: null,
            style: '',
            classes: ''
        }, el.options.tooltip);
        this.offset = {
            top: 0,
            left: 0
        };
        this.label = {
            show: false
        };
        // draggable
        this.draggable = {
            show: false,
            min: null,
            max: null,
            showArrow: false,
            arrowOptions: {
                adjust: 3,
                width: 10,
                height: 10,
                showHighArrow: true,
                showLowArrow: true,
                stroke: false,
                strokeWidth: 1,
                fill: true,
                color: null,
                fillStyle: null
            },
            // events
            dragStart: function(ev, neighbor, plot) {},                 // if the callback returns false then the dragging process is stoped
            drag: function(ev, neighbor, plot, eventPosition) {},       // the callback is called after modifying
            dragStop: function(ev, neighbor, plot, eventPosition) {}    // the callbadck is called after all process done
        },
        
        $.extend(true, this, options);
        
        this._start =null;
        this._stop = null;
        this._label = null;
        this._arrows = [];
        if (this.label.show) {
            this._label = new Label(this.label);
        }
    }
    
    function Area(options, plot) {
        this.show = true;
        
        // line options
        this.start = {
            show: false
        };
        this.end = {
            show: false
        };
        this.fill = false;
        this.fillStyle = '';
        this.axis = 'xaxis';
        
        // label options
        this.label = {
            show: false
        };
        
        $.extend(true, this, options);
        
        this._startLine = new Line(this.start, plot);
        this._endLine = new Line(this.end, plot);
        
        this._startLine._parent = this;
        this._endLine._parent = this;
        
        if (this.label.show) {
            this._label = new Label(this.label);
        }
    }
    
    function Label(options) {
        this.show = true;
        this.classes = '';
        this.style = '';
        // same as option of tooltip location
        /*
         * nw     n     ne
         * 
         * w      c     e
         * 
         * sw     s     se
         */
        this.position = 'n';
        this.offset = {
            top: 0,
            left: 0
        };
        
        this.formatter = null;
        
        $.extend(true, this, options);
    }
    
    Event.prototype.draw = function(plot) {
        if (!this.show || this._instance == null || plot.series.length === 0) {
            return;
        }
        
        this._instance.draw(this, plot);
    };
    
    Event.prototype.drawLabel = function(plot) {
        if (!this.show || this._instance == null || plot.series.length === 0) {
            return;
        }
        
        this._instance.drawLabel(this, plot);
        
        if (this._label) {
            this._label.draw(this.name, this._instance, this, plot);
        }
    };
    
    Line.prototype.calculate = function(event, plot) {
        if (!this.show || this.value === null) {
            return;
        }
        
        var el = plot.plugins.eventLine,
            ctx = event.background ? el._bcanvas._ctx : el._canvas._ctx,
            width = ctx.canvas.width, height = ctx.canvas.height,
            start, stop,
            axis = plot.axes[event.axis],
            p = axis.series_u2p(this.value);
        
        if(event.axis.charAt(0) === 'y') {
            start = [0, p];
            stop = [width - this.adjust, p];
        } else {
            start = [p, 0];
            stop = [p, height - this.adjust];
        }
        
        start[0] += this.offset.left;
        stop[0] += this.offset.left;
        
        start[1] += this.offset.top;
        stop[1] += this.offset.top;
        
        this._start = start;
        this._stop = stop;
        
        ctx = null;
    };
    
    Line.prototype.draw = function(event, plot) {
        if (!this.show || this.value === null) {
            return;
        }
        
        this.calculate(event, plot);
        
        var el = plot.plugins.eventLine,
            ctx = event.background ? el._bcanvas._ctx : el._canvas._ctx,
            mr = el._markerRenderer,
            options = {
                show: true,
                stroke: true,
                color: this.color,
                lineWidth: this.width,
                linePattern: this.pattern,
                fill: false,
                closePath: false
            };
        
        mr.shadow = this.shadow;
        mr.draw(this._start, this._stop, ctx, options);
        
        if (this.draggable.showArrow) {
            var arrow;
            this._arrows = [];
            if (this.draggable.arrowOptions.showLowArrow) {
                arrow = new Arrow(this.draggable.arrowOptions, event.axis.charAt(0) === 'x' ? 'left' : 'bottom', true);
                arrow.draw(ctx, this);
                this._arrows.push(arrow);
            }
            if (this.draggable.arrowOptions.showHighArrow) {
                arrow = new Arrow(this.draggable.arrowOptions, event.axis.charAt(0) === 'x' ? 'right' : 'top', true);
                arrow.draw(ctx, this);
                this._arrows.push(arrow);
            }
        }
        
        ctx = null;
    };
    
    Line.prototype.drawLabel = function(event, plot) {
        if (!this.show || this.value === null || !this.label.show) {
            return;
        }
        
        if (this._label) {
            this._label.draw(this.name, this, event, plot);
        }
    };
    
    Line.prototype.isNear = function(point) {
        // r is point to test, p and q are end points.
        if (!this.show || !this._start || !this._stop) {
            return null;
        }
        
        var lstart = this._start, lstop = this._stop,
            rx = point[0],
            ry = point[1],
            px = Math.round(lstop[0]),
            py = Math.round(lstop[1]),
            qx = Math.round(lstart[0]),
            qy = Math.round(lstart[1]),
            l = Math.sqrt(Math.pow(px - qx, 2) + Math.pow(py - qy, 2));
        
        // scale error term by length of line.
        var eps = (this.width + this.eventDistance) * l,
            res = Math.abs((qx - px) * (ry - py) - (qy - py) * (rx - px));
            
        if (res < eps) {
            return true;
        } else {
            var arrow;
            for (var i = 0; i < this._arrows.length; i++) {
                arrow = this._arrows[i];
                if (arrow.show && arrow.isNear(point)) {
                    return true;
                }
            }
            
            return false;
        };
    };
    
    Area.prototype.calculate = function(event, plot) {
        if (!this.show) {
            return;
        }
        
        this._startLine.calculate(event, plot);
        this._endLine.calculate(event, plot);
    };
    
    Area.prototype.draw = function(event, plot) {
        if (!this.show) {
            return;
        }
        
        this.calculate(event, plot);
        
        this.fillRect(event, plot);
        this._startLine.draw(event, plot);
        this._endLine.draw(event, plot);
    };
    
    Area.prototype.drawLabel = function(event, plot) {
        if (!this.show) {
            return;
        }
        
        this._startLine.drawLabel(event, plot);
        this._endLine.drawLabel(event, plot);
    };
    
    Area.prototype.fillRect = function(event, plot) {
        if (!this.fill || !!!this.fillStyle || !this._startLine.show || !this._endLine.show) {
            return;
        }
        
        var startX = this._startLine._start[0],
            startY = this._startLine._start[1],
            stopX = this._endLine._stop[0],
            stopY = this._endLine._stop[1],
            el = plot.plugins.eventLine,
            ctx = event.background ? el._bcanvas._ctx : el._canvas._ctx;

        ctx.fillStyle = this.fillStyle;
        ctx.fillRect(startX, startY, stopX - startX, stopY - startY);
    };
    
    Label.prototype.draw = function(str, obj, event, plot) {
        if (!this.show) {
            return;
        }
        
        if (this._elem) {
            this._elem.remove();
            this._elem = null;
        }
        
        var el = plot.plugins.eventLine,
            canvasWidth = el._canvas._elem.width(),
            canvasHeight = el._canvas._elem.height(),
            canvasOffset = el._canvas._elem.offset(),
            type = obj.constructor === Area ? 'area' : 'line',
            axis = plot.axes[event.axis];

        
        var elem = $('<div class="jqplot-eventline-label" style="position:absolute;left:-2000px;'+(typeof this.style === 'string' ? this.style : '')+'"></div>');
        elem.addClass(this.classes);
        if ($.isPlainObject(this.style)) {
            elem.css(this.style);
        }
        el._labelElem.append(elem);
        
        elem.html($.isFunction(this.formatter) ? this.formatter(str, this, event, plot) : str);
        
        var plotOffset = plot.eventCanvas._elem.offset(),
            offset = {
                top: plotOffset.top,
                left: plotOffset.left
            },
            elemWidth = elem.width(),
            elemHeight = elem.height();

        if (type === 'line') {
            var line = obj;
            if (line.value < axis.min || line.value > axis.max) {
                elem.remove();
                return;
            }
            if (event.axis.charAt(0) === 'y') {
                offset.top += line._start[1];
                switch(this.position) {
                    case 'c':
                        offset.top -= elemHeight / 2;
                        offset.left += line._start[0] + (line._stop[0] - line._start[0]) / 2 - elemWidth / 2;
                    break;
                    case 'nw':
                        offset.top -= elemHeight;
                        offset.left -= elemWidth;
                    break;
                    case 'ne':
                        offset.top -= elemHeight;
                        offset.left +=  canvasWidth;
                    break;
                    case 'w':
                        offset.top -= elemHeight / 2;
                        offset.left -= elemWidth;
                    break;
                    case 'e':
                        offset.top -= elemHeight / 2;
                        offset.left += canvasWidth;
                    break;
                    case 'sw':
                        offset.left -= elemWidth;
                    break;
                    case 's':
                        offset.left += line._start[0] + (line._stop[0] - line._start[0]) / 2 - elemWidth / 2;
                    break;
                    case 'se':
                        offset.left += canvasWidth;
                    break;
                    case 'n':
                    default:
                        offset.top -= elemHeight;
                        offset.left += line._start[0] + (line._stop[0] - line._start[0]) / 2 - elemWidth / 2;
                    break;
                }
            } else {
                offset.left += line._start[0];
                switch(this.position) {
                    case 'c':
                        offset.left -= elemWidth / 2;
                        offset.top += line._start[1] + (line._stop[1] - line._start[1]) / 2 - elemHeight / 2;
                    break;
                    case 'nw':
                        offset.top -= elemHeight;
                        offset.left -= elemWidth;
                    break;
                    case 'ne':
                        offset.top -= elemHeight;
                    break;
                    case 'w':
                        offset.left -= elemWidth;
                        offset.top += line._start[1] + (line._stop[1] - line._start[1]) / 2 - elemHeight / 2;
                    break;
                    case 'e':
                        offset.top += line._start[1] + (line._stop[1] - line._start[1]) / 2 - elemHeight / 2;
                    break;
                    case 'sw':
                        offset.left -= elemWidth;
                        offset.top += canvasHeight;
                    break;
                    case 's':
                        offset.left -= elemWidth / 2;
                        offset.top += canvasHeight;
                    break;
                    case 'se':
                        offset.top += canvasHeight;
                    break;
                    case 'n':
                    default:
                        offset.left -= elemWidth / 2;
                        offset.top -= elemHeight;
                    break;
                }
            }
        } else {
            var area = obj;
            if (!area.start.show || !area.end.show) {
                return;
            }
            var x1, x2, y1, y2;
            if (event.axis.charAt(0) === 'y') {
                x1 = area._startLine._start[0];
                x2 = area._startLine._stop[0];
                if (area._startLine.value > area._endLine.value) {
                    y1 = area._startLine._start[1];
                    y2 = area._endLine._start[1];
                } else {
                    y1 = area._endLine._start[1];
                    y2 = area._startLine._start[1];
                }
            } else {
                if (area._startLine.value < area._endLine.value) {
                    x1 = area._startLine._start[0];
                    x2 = area._endLine._start[0];
                } else {
                    x1 = area._endLine._start[0];
                    x2 = area._startLine._start[0];
                }
                y1 = area._startLine._start[1];
                y2 = area._startLine._stop[1];
            }
            
            switch(this.position) {
                case 'nw':
                case 'sw':
                case 'w':
                    offset.left += x1 - elemWidth;
                    offset.top += y1 + (y2 - y1) / 2 - elemHeight / 2;
                break;
                case 'ne':
                case 'se':
                case 'e':
                    offset.left += x2;
                    offset.top += y1 + (y2 - y1) / 2 - elemHeight / 2;
                break;
                case 's':
                    offset.left += x1 + (x2 - x1) / 2 - elemWidth / 2;
                    offset.top += y2;
                break;
                case 'n':
                    offset.left += x1 + (x2 - x1) / 2 - elemWidth / 2;
                    offset.top += y1 - elemHeight;
                break;
                case 'c':
                default:
                    offset.left += x1 + (x2 - x1) / 2 - elemWidth / 2;
                    offset.top += y1 + (y2 - y1) / 2 - elemHeight / 2;
                break;
            }
            
            var checkLeft = offset.left - canvasOffset.left,
                checkTop = offset.top - canvasOffset.top;
            
            if (checkLeft + elemWidth < 0 || checkLeft > canvasWidth
                || checkTop + elemHeight < 0 || checkTop > canvasHeight) {
                elem.remove();
                return;
            }
        }
        
        offset.top += this.offset.top;
        offset.left += this.offset.left;
        
        elem.offset(offset);
        
        this._elem = elem;
        
        elem = null;
    };
    
    function Panel(location, options) {
        this.show = false;
        this.location = location;
        this.axis = '';
        this.classes = '';
        this.style = '';
        this.actions = {};
        this.showGridLine = false;
        this.gridLineOptions = {
            show: true,
            name: '',
            color: '#000',
            width: 1,
            adjust: 0,    //  pixel 
            pattern: null,
            shadow: false,
            label: {
                show: true,
                classes: '',
                style: '',
                position: 'n',
                offset: {
                    top: 0,
                    left: 0
                }
            }
        };
        
        $.extend(true, this, options);
        
        this._elem = null;
        this._gridLine = null;
    }
    
    Panel.prototype.draw = function(plot) {
        if (!this.show || plot.series.length === 0) {
            return;
        }
        
        // add panel element
        var elem = $($.jqplot.sprintf('<div class="jqplot-eventline-panel" style="position:absolute;top:0;%s"></div>', typeof this.style === 'string' ? this.style : ''));
        
        var canvasWidth = plot.eventCanvas._elem.width(),
            canvasHeight = plot.eventCanvas._elem.height(),
            offset = plot.eventCanvas._elem.offset(),
            legendShow = plot.legend.show,
            legendHeight = legendShow ? plot.legend._elem.height() : 0,
            legendWidth = legendShow ? plot.legend._elem.width() : 0,
            legendLocation = plot.legend.location,
            additionalSize = {
                w: 0,
                e: 0,
                n: 0,
                s: 0
            };
            additionalSize[legendLocation] = ['w', 'e'].indexOf(legendLocation) > -1 ? legendWidth : legendHeight;
        
        switch(this.location) {
            case 'left':
                elem.width(plot._gridPadding.left - additionalSize.w).height(canvasHeight);
                offset.left -= elem.width();
            break;
            case 'right':
                elem.width(plot._gridPadding.right - additionalSize.e).height(canvasHeight);
                offset.left += canvasWidth;
            break;
            case 'top':
                elem.width(canvasWidth).height(plot._gridPadding.top - additionalSize.n);
                offset.top -= elem.height();
            break;
            case 'bottom':
                elem.width(canvasWidth).height(plot._gridPadding.bottom - additionalSize.s);
                offset.top += canvasHeight;
            break;
        }
        
        elem.addClass(this.classes);
        if ($.isPlainObject(this.style)) {
            elem.css(this.style);
        }
        
        plot.eventCanvas._elem.after(elem);
        elem.offset(offset);
        
        var self = this;
        
        // bind action
        $.each(this.actions, function(eventName, callback) {
            if ($.isFunction(callback)) {
                elem.bind(eventName, function(ev) {
                    ev.data = $.extend(true, ev.data, {plot: plot});
                    callback.call(this, ev, self, plot);
                });
            }
        });
        
        if (this.showGridLine) {
            this._gridLine = new Line(this.gridLineOptions, plot);
            
            elem.bind('mouseenter', {panel: this, plot: plot}, drawGridLine);
            elem.bind('mousemove', {panel: this, plot: plot}, drawGridLine);
            elem.bind('mouseout', {panel: this, plot: plot}, removeGridLine);
        }
        
        this._elem = elem;
        elem = null;
    };
    
    function Arrow(options, type, show) {
        this.adjust = 3;
        this.width = 10;
        this.height = 10;
        this.stroke = false;
        this.strokeWidth = 1;
        this.fill = true;
        this.color = null;
        this.fillStyle = null;
        
        $.extend(true, this, options);
        this.type = type;
        this.show = show;
        
        this._coordinates = [];
    }
    
    Arrow.prototype.draw = function(ctx, line) {
        if (!this.show) {
            return;
        }
        
        var width = this.width,
            height = this.height,
            x1, y1, x2, y2, x3, y3,
            point = line._start[0] === line._stop[0] ? [line._start[0], (line._stop[1] - line._start[1]) / 2 + line._start[1]] : [(line._stop[0] - line._start[0]) / 2 + line._start[0], line._start[1]];
  
        ctx.lineWidth = this.strokeWidth;
        ctx.strokeStyle = this.color || line.color;
        ctx.fillStyle = this.fillStyle || ctx.strokeStyle;

        var adjust = this.adjust != null ? Math.abs(this.adjust) : 0;
  
        switch(this.type) {
        case 'top':
            x1 = point[0] - (width / 2);
            y1 = point[1] - adjust;
            x2 = point[0] + (width / 2);
            y2 = point[1] - adjust;
            x3 = point[0];
            y3 = point[1] - adjust - height;
        break;
        case 'bottom':
           x1 = point[0] - (width / 2);
            y1 = point[1] + adjust;
            x2 = point[0] + (width / 2);
            y2 = point[1] + adjust;
            x3 = point[0];
            y3 = point[1] + adjust + height;
        break;
        case 'left':
            x1 = point[0] - adjust;
            y1 = point[1] - (height / 2);
            x2 = point[0] - adjust;
            y2 = point[1] + (height / 2);
            x3 = point[0] - adjust - width;
            y3 = point[1];
        break;
        case 'right':
            x1 = point[0] + adjust;
            y1 = point[1] - (height / 2);
            x2 = point[0] + adjust;
            y2 = point[1] + (height / 2);
            x3 = point[0] + adjust + width;
            y3 = point[1];
        break;
        default:
            return;
        }
  
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();
        
        if (this.stroke) {
            ctx.stroke();
        }
        if (this.fill) {
            ctx.fill();
        }
        
        this._coordinates = [x1, y1, x2, y2, x3, y3];
    };
    
    Arrow.prototype.isNear = function(point) {
        if (this._coordinates.length > 0) {
            var v1X = this._coordinates[0], v1Y = this._coordinates[1], v2X = this._coordinates[2], v2Y = this._coordinates[3], v3X = this._coordinates[4], v3Y = this._coordinates[5],
                pointX = point[0], pointY = point[1],
                A =  (-v2Y * v3X + v1Y * (-v2X + v3X) + v1X * (v2Y - v3Y) + v2X * v3Y) / 2,
                sign = A < 0 ? -1 : 1,
                s = (v1Y * v3X - v1X * v3Y + (v3Y - v1Y) * pointX + (v1X - v3X) * pointY) * sign,
                t = (v1X * v2Y - v1Y * v2X + (v1Y - v2Y) * pointX + (v2X - v1X) * pointY) * sign;
            return s > 0 && t > 0 && s + t < 2 * A * sign;
        }
        return false;
    };
    
    // ----------------------------------------------------------------------------------------------- //
    // Event handlers
    function showTooltip(ev, line, plot) {
        removeTooltip(ev, plot);
        
        var el = plot.plugins.eventLine,
            elem = $($.jqplot.sprintf('<div class="jqplot-eventline-tooltip" style="position:absolute;%s"></div>', typeof line.tooltip.style === 'string' ? line.tooltip.style : ''));
        
        elem.addClass(line.tooltip.classes);
        if ($.isPlainObject(line.tooltip.style)) {
            elem.css(line.tooltip.style);
        }
        
        elem.html($.isFunction(line.tooltip.formatter) ? line.tooltip.formatter.call(line, line.value, plot) : line.value);
        el._labelElem.append(elem);
        
        var eventPosition = plot.getEventPosition(ev),
            axis = plot.axes[line._parent.axis],
            xMax, yMax,
            x = eventPosition.gridPos.x, y = eventPosition.gridPos.y,
            offset = {};
            
            if (line._parent.axis.charAt(0) === 'x') {
                x = line._start[0];
                yMax = el._canvas._elem.height();
                
                if (y < 0) {
                    y = 0;
                } else if (y > yMax) {
                    y = yMax;
                }
            } else {
                y = line._start[1];
                xMax = el._canvas._elem.width();
                
                if (x < 0) {
                    x = 0;
                } else if (x > xMax) {
                    x = xMax;
                }
            }
            
            offset.top = eventPosition.offsets.top + y - line.tooltip.adjust - elem.height();
            offset.left = eventPosition.offsets.left + x + line.tooltip.adjust;
            
        if (offset)
        elem.offset(offset);
    }
    
    function removeTooltip(ev, plot) {
        $('.jqplot-eventline-tooltip', plot.plugins.eventLine._labelElem).remove();
    }
    
    function drawGridLine(ev) {
        var panel = ev.data.panel,
            plot = ev.data.plot,
            eventPosition = plot.getEventPosition(ev),
            value;
        
        if (!panel.showGridLine) {
            return;
        }
        
        value = eventPosition.dataPos[panel.axis];
        
        if (panel._gridLine === null) {
           panel._gridLine = new Line(panel.gridLineOptions, plot);
        }
        
        panel._gridLine.name = value;
        panel._gridLine.value = value;
        
        plot.plugins.eventLine.drawLines(plot);
        
        if (panel._gridLine._label) {
            panel._gridLine.drawLabel({type: 'line', axis: panel.axis, background: false}, plot);
        }
    }
    
    function removeGridLine(ev) {
        var panel = ev.data.panel,
            plot = ev.data.plot;
        if (panel._gridLine._label._elem) {
            panel._gridLine._label._elem.remove();
        }
        
        panel._gridLine = null;
        
        plot.plugins.eventLine.drawLines(plot);
    }
    
    function handleMove(ev, gridpos, datapos, neighbor, plot) {
        var el = plot.plugins.eventLine,
            neighbor = null,
            events = el._events,
            l = events.length,
            line = null,
            elem;
        
        if (el._isDragging && el._neighbor !== null) {
            // ev.preventDefault();
            // ev.stopImmediatePropagation();
            return;
        }
        
        neighbor = el.nearLine(gridpos);
        
        if (neighbor !== null) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
            
            line = neighbor.line;
            if (line.draggable.show) {
                if (neighbor.event.axis.charAt(0) === 'x') {
                    ev.target.style.cursor = 'col-resize';
                    el._cursor = 'col-resize';
                } else {
                    ev.target.style.cursor = 'row-resize';
                    el._cursor = 'row-resize';
                }
            }
            
            if (line.tooltip.show) {
                showTooltip(ev, line, plot);
            }
        } else {
            // to avoid interrupt with other plugin
            if (el._cursor !== 'default') {
                $(ev.target).css('cursor', 'default');
                el._cursor = 'default';
            }
            removeTooltip(ev, plot);
        }
    }
    
    
    function handleDown(ev, gridpos, datapos, neighbor, plot) {
        var el = plot.plugins.eventLine,
            events = el._events,
            neighbor = null,
            parent = null,
            line = null;
        
        neighbor = el.nearLine(gridpos);
        
        if (neighbor !== null) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
            
            line = neighbor.line;
            
            var draggable = line.draggable;
            if (draggable.show && !el._isDragging) {
                if ($.isFunction(line.draggable.dragStart)) {
                    var ret = line.draggable.dragStart(ev, neighbor, plot);
                    if (ret === false) {
                        return;
                    }
                }
                
                ev.preventDefault();
                ev.stopImmediatePropagation();

                el._neighbor = neighbor;
                el._isDragging = true;
                
                el._prevCursorShow = plot.plugins.cursor.show;
                plot.plugins.cursor.show = false;
                
                if (document.ondrag != undefined) {
                    el._oldHandlers.onselectstart = document.onselectstart;
                    document.onselectstart = function() {
                        return false;
                    };
                }
                
                if (document.ondrag != undefined) {
                    el._oldHandlers.ondrag = document.ondrag;
                    document.ondrag = function() {
                        return false;
                    };
                }
                if (document.onmousedown != undefined) {
                    el._oldHandlers.onmousedown = document.onmousedown;
                    document.onmousedown = function() {
                        return false;
                    };
                }
                
                $(document).on('mousemove', {plot: plot}, handleDrag);
                $(document).on('mouseup', {plot: plot}, handleUp);
            }
        } else {
            el._isDragging = false;
        }
    }
    
    function drawOnDragging(ev, neighbor, plot, stop) {
        var el = plot.plugins.eventLine,
            line = neighbor.line,
            event = neighbor.event;
            axis = plot.axes[event.axis],
            min = axis.min, max = axis.max,
            p2u = plot.axes[event.axis].series_p2u,
            gridPos = plot.getEventPosition(ev).gridPos,
            newValue = p2u(gridPos[event.axis.charAt(0)]);
            
        if (event.type === $.jqplot.EventLine.Types.LINE) {
            if (line.draggable.min !== null && newValue < line.draggable.min) {
                newValue = line.draggable.min;
            } else if (line.draggable.max !== null && newValue > line.draggable.max) {
                newValue = line.draggable.max;
            }
        } else {
            if (line === event._instance._startLine && event._instance._endLine.value < newValue) {
                newValue = event._instance._endLine.value;
            } else if (line === event._instance._endLine && event._instance._startLine.value > newValue) {
                newValue = event._instance._startLine.value;
            }
            
            if (line.draggable.min !== null && newValue < line.draggable.min) {
                newValue = line.draggable.min;
            } else if (line.draggable.max !== null && newValue > line.draggable.max) {
                newValue = line.draggable.max;
            }
        }
        
        if (newValue < min) {
            newValue = min;
        } else if (newValue > max) {
            newValue = max;
        }
        
        if (!stop && $.isFunction(line.draggable.drag) && line.draggable.drag(ev, newValue, neighbor, plot) === false) {
            handleUp(ev, true);
            return;
        } else if (stop && $.isFunction(line.draggable.dragStop) && line.draggable.dragStop(ev, newValue, neighbor, plot) === false) {
            return;
        }
        
        neighbor.lineOption.value = line.value = newValue;
        
        el.drawLines(plot);
        
        neighbor.event.drawLabel(plot);
    }

    function handleDrag(ev) {
        var plot = ev.data.plot,
            el = plot.plugins.eventLine,
            neighbor = el._neighbor,
            line = neighbor.line;
        
        if (el._isDragging && line) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
            
            drawOnDragging(ev, neighbor, plot, false);
        
            showTooltip(ev, line, plot);
        }
    }
    
    function handleUp(ev, doNotDraw) {
        var plot = ev.data.plot,
            el = plot.plugins.eventLine;
        
        
        if (el._isDragging && el._neighbor) {
            var neighbor = el._neighbor;
            
            ev.preventDefault();
            ev.stopImmediatePropagation();
            
            plot.plugins.cursor.show = el._prevCursorShow;
        
            el._isDragging = false;
            el._neighbor = null;
            
            if (document.onselectstart != undefined && el._oldHandlers.onselectstart != null){
                document.onselectstart = co._oldHandlers.onselectstart;
                el._oldHandlers.onselectstart = null;
            }
            if (document.ondrag != undefined && el._oldHandlers.ondrag != null) {
                document.ondrag = el._oldHandlers.ondrag;
                el._oldHandlers.ondrag = null;
            }
            if (document.onmousedown != undefined && el._oldHandlers.onmousedown != null) {
                document.onmousedown = el._oldHandlers.onmousedown;
                el._oldHandlers.onmousedown = null;
            }
            
            $(document).off('mousemove', handleDrag);
            $(document).off('mouseup', handleUp);
            
            if (doNotDraw !== true) {
                drawOnDragging(ev, neighbor, plot, true);
            }
            
            removeTooltip(ev, plot);
        }
    }
    
    function handleLeave(ev, gridPos, dataPos, data, plot) {
        removeTooltip(ev, plot);
    }
    
    // TODO Selectable
    
    // TODO Editable (Label)
    
    // Add Event
    $.jqplot.preInitHooks.push($.jqplot.EventLine.init);
    $.jqplot.preDrawHooks.push($.jqplot.EventLine.prePlotDraw);
    $.jqplot.postDrawHooks.push($.jqplot.EventLine.postPlotDraw);
    $.jqplot.eventListenerHooks.push(['jqplotMouseMove', handleMove]);
    $.jqplot.eventListenerHooks.push(['jqplotMouseDown', handleDown]);
    $.jqplot.eventListenerHooks.push(['jqplotMouseLeave', handleLeave]);
})(jQuery); 

/**
 jqPlot Spec Window Plugin
 2014-10-27, Roy Choi
 */
(function($) {
    /**
     * Class: $.jqplot.SpecWindow
     * Plugin which will show by spec window.
     */
    $.jqplot.SpecWindow = function(options) {
        // Group: Properties
        //
        //prop: enable
        // true to enable the Show By Group.
        this.enable = $.jqplot.config.enablePlugins;
        // prop: showByGroup
        // true to show by group plot
        this.show = false;
        this.shadow = false;
        this.showMarker = false;
        this.showLine = true;
        this.highlight = false;
        this.showLabel = false;
        
        this.fitStep = false;
        this.stepInfo = null;
        this.stepColumn = null;
        this.stepSequenceColumn = null;
        
        this.useSeriesData = false;
        this.baseSeries = 0;
        this.dataSeries = null;

        this.xaxis = 'xaxis';
        this.yaxis = 'yaxis';
        this.xaxisColumn = 0;
        this.data = [];

        this.specType = 'band';

        /*
        type: band, line, circle
        */
        this.specLimit = {
            show: true,
            lowerLimit: null,
            upperLimit: null,
            circleLimit: null,
            color: '#ffff00', 
            fillColor: 'rgba(255, 255, 0, .9)',
            showLine: true,
            fill: true
        };
        
        this.controlLimit = {
            show: true,
            lowerLimit: null,
            upperLimit: null,
            circleLimit: null,      
            color: '#00ff00', 
            fillColor: 'rgba(0, 255, 0, .9)',
            showLine: true,
            fill: true
        };
        
        $.extend(true, this, options);
        
        this.defaultSeriesOptions = {
            show: this.show,
            lowerLimit: [],
            upperLimit: [],
            circleLimit: [],
            shadow: this.shadow,
            showMarker: this.showMarker,
            showLine: this.showLine,
            highlight: this.highlight,
            showLabel: this.showLabel,
            hasNullPoint: false
        };
        
        this._data = [];
        
        this.specs = [];
        
        this.stepIndex = {};
        
        this.dataBounds = {
            xaxis: {
                min: null,
                max: null
            },
            yaxis: {
                min: null,
                max: null
            }
        };
    };
    
    function SpecSeries(options, data) {
        this.show = false;
        this.shadow = false;
        this.highlight = false;
        this.color = null;
        
        $.extend(true, this, options);
        
        this.data = data;
        
        this.gridData = [];
    }
    
    function SpecWindow(options, specType) {
        this.show = false;
        this.shadow = false;
        this.showMarker = false;
        this.showLine = true;
        this.highlight = false;
        this.color = null;
        this.fill = true;
        this.fillColor = null;
        this.hasNullPoint = false;
        
        $.extend(true, this, options);
        
        var sopts = {
            show: this.show,
            shadow: this.shadow,
            showMarker: this.showMarker,
            showLine: this.showLine,
            highlight: this.highlight,
            color: this.color
        };
        
        if (specType == 'circle') {
            this.circleLimit = new SpecSeries(sopts, options.circleLimit);
        } else {
            this.lowerLimit = new SpecSeries(sopts, options.lowerLimit);
            this.upperLimit = new SpecSeries(sopts, options.upperLimit);        
        }
    }


    // axis.renderer.tickrenderer.formatter

    // called with scope of plot
    $.jqplot.SpecWindow.init = function(target, data, opts) {
        var options = opts || {};

        // add a highlighter attribute to the plot
        this.plugins.specWindow = new $.jqplot.SpecWindow(options.specWindow);
        
        if (this.plugins.specWindow.fitStep) {
            this.plugins.specWindow.createStepIndex();
        }

        this.plugins.specWindow.specCanvas = new $.jqplot.GenericCanvas();
    };

    $.jqplot.SpecWindow.prePlotDraw = function(options) {
        var sw = this.plugins.specWindow;
        
        sw.specs = [];
        
        if (!sw.show || this.data.length === 0) {
            return;
        }
        
        var data;
        var x, lowerLimit, upperLimit, circleLimit;
        var ymin, ymax;
        var step, dataSequnece;
        var stepSequence;
        
        if (sw.useSeriesData) {
            if (sw.dataSeries != null && $.isArray(this.data[sw.dataSeries])) {
                if (this.series[sw.dataSeries].breakOnDiff != null) {
                    data = [];
                    var diff = null;
                    var newSpec = [];
                    var self = this;
                    this.data[sw.dataSeries].forEach(function(pointData) {
                        if (pointData[self.series[sw.dataSeries].breakOnDiff] !== diff) {
                            diff = pointData[self.series[sw.dataSeries].breakOnDiff];
                            
                            if (newSpec.length) {
                               data.push(newSpec);
                            }
                            newSpec = [];
                        }
                        newSpec.push(pointData);
                    });
                    if (newSpec.length) {
                        data.push(newSpec);
                    }
                } else {
                    data = [this.data[sw.dataSeries]];
                }
            } else {
                data = this.data;
            }
        } else {
            data = sw._data;
        }
        
        sw.dataBounds = {
            xaxis: {
                min: null,
                max: null
            },
            yaxis: {
                min: null,
                max: null
            }
        };
        
        if (sw.fitStep) {
            if ($.isArray(sw.stepInfo) && sw.stepInfo.length > 0 && $.isNumeric(sw.stepSequenceColumn) && $.isNumeric(sw.stepColumn)) {
                for (var i=0; i<data.length; i++) {
                    var spec = {
                        specLimit: null,
                        controlLimit: null
                    };
                    
                    var seriesOptions = $.extend(true, {}, sw.defaultSeriesOptions);
                    
                    if (sw.specLimit.show) {
                        var specLimitSeriesOptions = $.extend(true, {}, seriesOptions, {
                            show: true,
                            specType: sw.specLimit.specType,
                            color: sw.specLimit.color,
                            fillColor: sw.specLimit.fillColor,
                            showLine: sw.specLimit.showLine,
                            fill: sw.specLimit.fill
                        });
                    }
                    
                    if (sw.controlLimit.show) {
                        var controlLimitSeriesOptions = $.extend(true, {}, seriesOptions, {
                            show: true,
                            specType: sw.controlLimit.specType,
                            color: sw.controlLimit.color,
                            fillColor: sw.controlLimit.fillColor,
                            showLine: sw.controlLimit.showLine,
                            fill: sw.controlLimit.fill
                        });
                    }
                    
                    data[i].forEach(function(pointData, index) {
                        step = pointData[sw.stepColumn];
                        stepSequence = pointData[sw.stepSequenceColumn];
                        
                        x = sw.getDataSequence(step, stepSequence);
                        
                        if (x === null || isNaN(x)) return;
                        
                        if (sw.specLimit.show) {
                            upperLimit = pointData[sw.specLimit.upperLimit];
                            lowerLimit = (sw.specLimit.lowerLimit === null) ? 'min' : pointData[sw.specLimit.lowerLimit];
                            
                            sw.pack(specLimitSeriesOptions, lowerLimit, upperLimit, x);
                        }
                        if (sw.controlLimit.show) {
                            upperLimit = pointData[sw.controlLimit.upperLimit];
                            lowerLimit = (sw.controlLimit.lowerLimit === null) ? 'min' : pointData[sw.controlLimit.lowerLimit];
                            
                            sw.pack(controlLimitSeriesOptions, lowerLimit, upperLimit, x);
                        }
                    });
                    
                    currentStep = null;
                    
                    spec.specLimit = new SpecWindow(specLimitSeriesOptions);
                    spec.controlLimit = new SpecWindow(controlLimitSeriesOptions);
                    sw.specs.push(spec);
                }
            } else {
                console.warn('fitStep is true but some settings are not set');
            }
        } else {
            for (var i=0; i<data.length; i++) {
                var spec = {
                    specType: sw.specType,
                    specLimit: null,
                    controlLimit: null
                };
                
                var seriesOptions = $.extend(true, {}, sw.defaultSeriesOptions);
                
                if (sw.specLimit.show) {
                    var specLimitSeriesOptions = $.extend(true, {}, seriesOptions, {
                        show: true,
                        color: sw.specLimit.color,
                        fillColor: sw.specLimit.fillColor,
                        showLine: sw.specLimit.showLine,
                        fill: sw.specLimit.fill
                    });
                }
                
                if (sw.controlLimit.show) {
                    var controlLimitSeriesOptions = $.extend(true, {}, seriesOptions, {
                        show: true,
                        color: sw.controlLimit.color,
                        fillColor: sw.controlLimit.fillColor,
                        showLine: sw.controlLimit.showLine,
                        fill: sw.controlLimit.fill
                    });
                }
                
                data[i].forEach(function(pointData, index) {
                    if (spec.specType == 'circle') {
                        if (sw.specLimit.show) {
                            circleLimit = pointData[sw.specLimit.circleLimit];
                            sw.circlePack(specLimitSeriesOptions, circleLimit);
                        }
                        if (sw.controlLimit.show) {
                            circleLimit = pointData[sw.controlLimit.circleLimit];
                            sw.circlePack(controlLimitSeriesOptions, circleLimit);
                        }
                    } else {
                        x = pointData[sw.xaxisColumn];
                        if (x === null || (x !== 'min' && x !== 'max' && isNaN(x))) return;

                        if (sw.specLimit.show) {
                            upperLimit = pointData[sw.specLimit.upperLimit];
                            lowerLimit = (sw.specLimit.lowerLimit === null) ? 'min' : pointData[sw.specLimit.lowerLimit];

                            sw.pack(specLimitSeriesOptions, lowerLimit, upperLimit, x);
                        }
                        if (sw.controlLimit.show) {
                            upperLimit = pointData[sw.controlLimit.upperLimit];
                            lowerLimit = (sw.controlLimit.lowerLimit === null) ? 'min' : pointData[sw.controlLimit.lowerLimit];

                            sw.pack(controlLimitSeriesOptions, lowerLimit, upperLimit, x);
                        }
                    }
                });
                
                spec.specLimit = new SpecWindow(specLimitSeriesOptions, spec.specType);
                spec.controlLimit = new SpecWindow(controlLimitSeriesOptions, spec.specType);
                sw.specs.push(spec);
            }
        }
        

        
        sw.resetAxes(this);
    };
    
    $.jqplot.SpecWindow.postPlotDraw = function() {
        var sw = this.plugins.specWindow;
        
        if (!sw.show || this.series.length === 0) {
            return;
        }
        
        if (sw && sw.specCanvas) {
            sw.specCanvas.resetCanvas();
            sw.specCanvas = null;
        }
        
        sw.specCanvas = new $.jqplot.GenericCanvas();
        
        var canvasGridPadding = $.extend(true, {}, this._gridPadding);
        this.series[this.seriesStack[0]].canvas._elem.before(sw.specCanvas.createElement(canvasGridPadding, 'jqplot-spec-canvas', this._plotDimensions, this));
        sw.specCanvas.setContext();
        
        sw.draw(this);
    };
    
    $.jqplot.SpecWindow.preParseOptions = function(options) {
      var sw = this.plugins.specWindow;
      if (sw.show && options.specWindow && $.isArray(options.specWindow.data)) {
        sw._data = options.specWindow.data;
      }
    };
    
  $.jqplot.SpecWindow.preReinitOptions = function(target, data, options) {
    if (this.options.specWindow && options && options.specWindow && $.isArray(options.specWindow.data)) {
      this.options.specWindow.data = [];
    }
  };

    $.jqplot.preInitHooks.push($.jqplot.SpecWindow.init);
    $.jqplot.preParseOptionsHooks.push($.jqplot.SpecWindow.preParseOptions);
    $.jqplot.preDrawHooks.push($.jqplot.SpecWindow.prePlotDraw);
    $.jqplot.postDrawHooks.push($.jqplot.SpecWindow.postPlotDraw);
    $.jqplot.preReinitHooks.push($.jqplot.SpecWindow.preReinitOptions);
    
    function getGridData(data, xU2p, yU2p) {
        var plot = this;
        var sw = this.plugins.specWindow;
        var gd = [];
        data.forEach(function(pointData) {
            var isSetPoint  = pointData[0] === 'min' || pointData[0] === 'max';
            var isYSetPoint = pointData[1] === 'min' || pointData[1] === 'max';
            if (!isYSetPoint && (pointData[1] === null || isNaN(pointData[1]))) {
                gd.push([isSetPoint  ? xU2p(plot.axes[sw.xaxis][pointData[0]]) + plot.grid.borderWidth : xU2p(pointData[0]), null]);
            } else {
                gd.push([isSetPoint ? xU2p(plot.axes[sw.xaxis][pointData[0]]) - plot.grid.borderWidth : xU2p(pointData[0]), isYSetPoint ? yU2p(plot.axes[sw.yaxis][pointData[1]]) - plot.grid.borderWidth : yU2p(pointData[1])]);
            }
        });
        
        return gd;
    }

    function getCircleGridData(data, xU2p, yU2p) {
        var plot = this;
        var sw = this.plugins.specWindow;
        var gd = [];
        //yu, xu, yl, xl;
        var yu = data[0], xu = data[1], yl = data[2], xl = data[3];
        var xc = ((xu-xl)/2)+xl;
        var yc = ((yu-yl)/2)+yl;

        gd.push([xU2p(xc), yU2p(yu)]);
        gd.push([xU2p(xu), yU2p(yc)]);
        gd.push([xU2p(xc), yU2p(yl)]);
        gd.push([xU2p(xl), yU2p(yc)]);
        
        return gd;
    }
    
    $.jqplot.SpecWindow.prototype.createStepIndex = function() {
        this.stepInfo.forEach(function(stepObj) {
            this.stepIndex[stepObj.step] = stepObj;
        }, this);
    };
    
    $.jqplot.SpecWindow.prototype.getDataSequence = function(stepName, stepSequence) {
        var step = this.stepIndex[stepName];
        var sequnce = null;
        
        if (step && $.isNumeric(stepSequence) && stepSequence < step.maxCount) {
            sequnce = step.startCountSlot + stepSequence;
        }
        
        return sequnce;
    };
    
    $.jqplot.SpecWindow.prototype.pack = function(seriesOptions, lowerLimit, upperLimit, x) {
        var ymin, ymax;
        seriesOptions.upperLimit.push([x, upperLimit]);
        seriesOptions.lowerLimit.push([x, lowerLimit]);
     
        if (upperLimit !== null && !(upperLimit !== 'max' && isNaN(upperLimit)) && lowerLimit !== null && !(lowerLimit !== 'min' && isNaN(lowerLimit))) {
            ymin = Math.min(lowerLimit === 'min' ? 0 : lowerLimit, upperLimit);
            if (this.dataBounds.yaxis.min === null || this.dataBounds.yaxis.min > ymin) {
                this.dataBounds.yaxis.min = ymin;
            }
            ymax = Math.max(lowerLimit === 'min' ? 0 : lowerLimit, upperLimit);
            if (this.dataBounds.yaxis.max === null || this.dataBounds.yaxis.max < ymax) {
                this.dataBounds.yaxis.max = ymax;
            }
        } else {
            seriesOptions.hasNullPoint = true;
        }
    };

    $.jqplot.SpecWindow.prototype.circlePack = function(seriesOptions, circleLimit) {
        var ymin, ymax;
        seriesOptions.circleLimit = circleLimit;
        //yu, xu, yl, xl;
        if (circleLimit[0] !== null && !isNaN(circleLimit[0]) && circleLimit[1] !== null && !isNaN(circleLimit[1]) && circleLimit[2] !== null && !isNaN(circleLimit[2]) && circleLimit[3] !== null && !isNaN(circleLimit[3])) {
            ymin = Math.min(circleLimit[0], circleLimit[2]);
            if (this.dataBounds.yaxis.min === null || this.dataBounds.yaxis.min > ymin) {
                this.dataBounds.yaxis.min = ymin;
            }
            ymax = Math.max(circleLimit[0], circleLimit[2]);
            if (this.dataBounds.yaxis.max === null || this.dataBounds.yaxis.max < ymax) {
                this.dataBounds.yaxis.max = ymax;
            }
            xmin = Math.min(circleLimit[1], circleLimit[3]);
            if (this.dataBounds.xaxis.min === null || this.dataBounds.xaxis.min > xmin) {
                this.dataBounds.xaxis.min = xmin;
            }
            xmax = Math.max(circleLimit[1], circleLimit[3]);
            if (this.dataBounds.xaxis.max === null || this.dataBounds.xaxis.max < xmax) {
                this.dataBounds.xaxis.max = xmax;
            }
        } else {
            seriesOptions.hasNullPoint = true;
        }
    };
    
    $.jqplot.SpecWindow.prototype.resetAxes = function(plot) {
        if (!this.show) {
            return;
        }
        
        var xaxis, yaxis;
        
        var axes = plot.axes;
        
        xaxis = axes[this.xaxis];
        yaxis = axes[this.yaxis];
        
        /*if (xaxis._dataBounds.min > this.dataBounds.xaxis.min) {
            xaxis._dataBounds.min = this.dataBounds.xaxis.min;
        }
        if (xaxis._dataBounds.max < this.dataBounds.xaxis.max) {
            xaxis._dataBounds.max = this.dataBounds.xaxis.max;
        }*/
        if (yaxis._dataBounds.min !== null && this.dataBounds.yaxis.min !== null && yaxis._dataBounds.min > this.dataBounds.yaxis.min) {
            yaxis._dataBounds.min = this.dataBounds.yaxis.min;
        }
        if (yaxis._dataBounds.max !== null && this.dataBounds.yaxis.max !== null && yaxis._dataBounds.max < this.dataBounds.yaxis.max) {
            yaxis._dataBounds.max = this.dataBounds.yaxis.max;
        }
        if (xaxis._dataBounds.min !== null && this.dataBounds.xaxis.min !== null && xaxis._dataBounds.min > this.dataBounds.xaxis.min) {
            xaxis._dataBounds.min = this.dataBounds.xaxis.min;
        }
        if (xaxis._dataBounds.max !== null && this.dataBounds.xaxis.max !== null && xaxis._dataBounds.max < this.dataBounds.xaxis.max) {
            xaxis._dataBounds.max = this.dataBounds.xaxis.max;
        }
    };
    
    $.jqplot.SpecWindow.prototype.draw = function(plot) {
        var specs = this.specs;
        var sw = plot.plugins.specWindow;
        
        if (!this.show || plot.series.length === 0) {
            return;
        }
        
        var axes = plot.axes;
        
        xaxis = axes[this.xaxis];
        yaxis = axes[this.yaxis];
        
        var ctx = this.specCanvas._ctx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        var xU2p = xaxis.series_u2p, yU2p = yaxis.series_u2p;
        specs.forEach(function(spec) {
            if (spec.specType == 'circle') {
                if (spec.specLimit.show) {
                    spec.specLimit.circleLimit.gridData = getCircleGridData.call(plot, spec.specLimit.circleLimit.data, xU2p, yU2p);
                    this.drawEllipse.call(plot, spec.specLimit);
                }
                
                if (spec.controlLimit.show) {
                    spec.controlLimit.circleLimit.gridData = getCircleGridData.call(plot, spec.controlLimit.circleLimit.data, xU2p, yU2p);
                    this.drawEllipse.call(plot, spec.controlLimit);
                }
            } else {
                if (spec.specLimit.show) {
                    spec.specLimit.lowerLimit.gridData = getGridData.call(plot, spec.specLimit.lowerLimit.data, xU2p, yU2p);
                    spec.specLimit.upperLimit.gridData = getGridData.call(plot, spec.specLimit.upperLimit.data, xU2p, yU2p);

                    if (spec.specLimit.showLine) {
                        spec.specLimit.lowerLine = sw.specLimit.lowerLimit == null ? false : true;
                        spec.specLimit.upperLine = sw.specLimit.upperLimit == null ? false : true;
                    }
                    this.doFillBetweenLines.call(plot, spec.specLimit, this.baseSeries);
                }
                
                if (spec.controlLimit.show) {
                    spec.controlLimit.lowerLimit.gridData = getGridData.call(plot, spec.controlLimit.lowerLimit.data, xU2p, yU2p);
                    spec.controlLimit.upperLimit.gridData = getGridData.call(plot, spec.controlLimit.upperLimit.data, xU2p, yU2p);
                    
                    if (spec.controlLimit.showLine) {
                        spec.controlLimit.lowerLine = sw.controlLimit.lowerLimit == null ? false : true;
                        spec.controlLimit.upperLine = sw.controlLimit.upperLimit == null ? false : true;
                    }
                    this.doFillBetweenLines.call(plot, spec.controlLimit, this.baseSeries);
                }
            };
        }, this);
    };

    $.jqplot.SpecWindow.prototype.doFillBetweenLines = function (specLimits, baseSeries) {
        var sw = this.plugins.specWindow;
        var series1 = specLimits.lowerLimit;
        var series2 = specLimits.upperLimit;
        var gd = [], tempgd = [];
        var sr = new $.jqplot.ShapeRenderer();
        var opts = {color: specLimits.color, fill: false, closePath: false, breakOnNull: true, hasNullPoint: specLimits.hasNullPoint};
        var fillOpts = {fillStyle: specLimits.fillColor, fill: true, closePath: true};
        
        if (specLimits.showLine) {
            if (specLimits.lowerLine) {
                sr.draw(sw.specCanvas._ctx, series1.gridData, opts);
            };
            if (specLimits.upperLine) {
                sr.draw(sw.specCanvas._ctx, series2.gridData, opts);
            };
        }
        
        if (specLimits.fill) {
            if (specLimits.hasNullPoint) {
                series1.gridData.forEach(function(s1, index) {
                    var s2 = series2.gridData[index];
                    
                    if (s1[0] === null || isNaN(s1[0]) || s1[1] === null || isNaN(s1[1]) || s2[1] === null || isNaN(s2[1])) {
                        if (gd.length) {
                            sr.draw(sw.specCanvas._ctx, gd.concat(tempgd.reverse()), fillOpts);
                            gd = [];
                            tempgd = [];
                        }
                    } else {
                        gd.push(s1);
                        tempgd.push(s2);
                    }
                });
                
                if (gd.length) {
                    sr.draw(sw.specCanvas._ctx, gd.concat(tempgd.reverse()), fillOpts);
                }
            } else {
                tempgd = series2.gridData.slice(0).reverse();
                gd = series1.gridData.concat(tempgd);
                
                sr.draw(sw.specCanvas._ctx, gd, fillOpts);
            }
        }
        
        sr = null;
    };

    $.jqplot.SpecWindow.prototype.drawEllipse = function (specLimits) {
        var sw = this.plugins.specWindow;
        var xstart, xstop, ystart, ystop;        

        //yu, xu, yl, xl;
        xstart  = specLimits.circleLimit.gridData[3][0];
        xstop   = specLimits.circleLimit.gridData[1][0];
        ystart  = specLimits.circleLimit.gridData[2][1];
        ystop   = specLimits.circleLimit.gridData[0][1];

        var height = ystart - ystop;
        
        // TODO: bug if do zoom of many counts
        var x = xstart;
        var y = ystop;
        var w = xstop - xstart;
        var h = (height<0) ? height*-1 : height; 

        var kappa = .5522848;

        ox = (w / 2) * kappa, // control point offset horizontal
        oy = (h / 2) * kappa, // control point offset vertical

        xe = x + w,           // x-end
        ye = y + h,           // y-end
        xm = x + w / 2,       // x-middle
        ym = y + h / 2;       // y-middle

        sw.specCanvas._ctx.beginPath();

        sw.specCanvas._ctx.moveTo(x, ym);

        sw.specCanvas._ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
        sw.specCanvas._ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
        sw.specCanvas._ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        sw.specCanvas._ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);

        sw.specCanvas._ctx.closePath();

        if (specLimits.showLine) {
            sw.specCanvas._ctx.strokeStyle = specLimits.color;
            sw.specCanvas._ctx.stroke();
        }
        if (specLimits.fill) {
            sw.specCanvas._ctx.fillStyle = specLimits.fillColor;
            sw.specCanvas._ctx.fill();
        } 
    };

})(jQuery); 

/**
 * jqPlot
 * Pure JavaScript plotting plugin using jQuery
 *
 * Version: 1.0.8
 * Revision: 1250
 *
 * Copyright (c) 2009-2013 Chris Leonello
 * jqPlot is currently available for use in all personal or commercial projects 
 * under both the MIT (http://www.opensource.org/licenses/mit-license.php) and GPL 
 * version 2.0 (http://www.gnu.org/licenses/gpl-2.0.html) licenses. This means that you can 
 * choose the license that best suits your project and use it accordingly. 
 *
 * Although not required, the author would appreciate an email letting him 
 * know of any substantial use of jqPlot.  You can reach the author at: 
 * chris at jqplot dot com or see http://www.jqplot.com/info.php .
 *
 * If you are feeling kind and generous, consider supporting the project by
 * making a donation at: http://www.jqplot.com/donate.php .
 *
 * sprintf functions contained in jqplot.sprintf.js by Ash Searle:
 *
 *     version 2007.04.27
 *     author Ash Searle
 *     http://hexmen.com/blog/2007/03/printf-sprintf/
 *     http://hexmen.com/js/sprintf.js
 *     The author (Ash Searle) has placed this code in the public domain:
 *     "This code is unrestricted: you are free to use it however you like."
 * 
 */
(function($) {
    
    /**
     * Class: $.jqplot.PointLabels
     * Plugin for putting labels at the data points.
     * 
     * To use this plugin, include the js
     * file in your source:
     * 
     * > <script type="text/javascript" src="plugins/jqplot.pointLabels.js"></script>
     * 
     * By default, the last value in the data ponit array in the data series is used
     * for the label.  For most series renderers, extra data can be added to the 
     * data point arrays and the last value will be used as the label.
     * 
     * For instance, 
     * this series:
     * 
     * > [[1,4], [3,5], [7,2]]
     * 
     * Would, by default, use the y values in the labels.
     * Extra data can be added to the series like so:
     * 
     * > [[1,4,'mid'], [3 5,'hi'], [7,2,'low']]
     * 
     * And now the point labels would be 'mid', 'low', and 'hi'.
     * 
     * Options to the point labels and a custom labels array can be passed into the
     * "pointLabels" option on the series option like so:
     * 
     * > series:[{pointLabels:{
     * >    labels:['mid', 'hi', 'low'],
     * >    location:'se',
     * >    ypadding: 12
     * >    }
     * > }]
     * 
     * A custom labels array in the options takes precendence over any labels
     * in the series data.  If you have a custom labels array in the options,
     * but still want to use values from the series array as labels, set the
     * "labelsFromSeries" option to true.
     * 
     * By default, html entities (<, >, etc.) are escaped in point labels.  
     * If you want to include actual html markup in the labels, 
     * set the "escapeHTML" option to false.
     * 
     */
    $.jqplot.PointLabels = function(options) {
        // Group: Properties
        //
        // prop: show
        // show the labels or not.
        this.show = $.jqplot.config.enablePlugins;
        // prop: location
        // compass location where to position the label around the point.
        // 'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'
        this.location = 'n';
        // prop: labelsFromSeries
        // true to use labels within data point arrays.
        this.labelsFromSeries = false;
        // prop: seriesLabelIndex
        // array index for location of labels within data point arrays.
        // if null, will use the last element of the data point array.
        this.seriesLabelIndex = null;
        // prop: labels
        // array of arrays of labels, one array for each series.
        this.labels = [];
        // actual labels that will get displayed.
        // needed to preserve user specified labels in labels array.
        this._labels = [];
        // prop: stackedValue
        // true to display value as stacked in a stacked plot.
        // no effect if labels is specified.
        this.stackedValue = false;
        // prop: ypadding
        // vertical padding in pixels between point and label
        this.ypadding = 6;
        // prop: xpadding
        // horizontal padding in pixels between point and label
        this.xpadding = 6;
        // prop: escapeHTML
        // true to escape html entities in the labels.
        // If you want to include markup in the labels, set to false.
        this.escapeHTML = true;
        // prop: edgeTolerance
        // Number of pixels that the label must be away from an axis
        // boundary in order to be drawn.  Negative values will allow overlap
        // with the grid boundaries.
        this.edgeTolerance = -5;
        // prop: formatter
        // A class of a formatter for the tick text.  sprintf by default.
        this.formatter = $.jqplot.DefaultTickFormatter;
        // prop: formatString
        // string passed to the formatter.
        this.formatString = '';
        // prop: hideZeros
        // true to not show a label for a value which is 0.
        this.hideZeros = false;
        this._elems = [];
        
        $.extend(true, this, options);
    };
    
    var locations = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
    var locationIndicies = {'nw':0, 'n':1, 'ne':2, 'e':3, 'se':4, 's':5, 'sw':6, 'w':7};
    var oppositeLocations = ['se', 's', 'sw', 'w', 'nw', 'n', 'ne', 'e'];
    
    // called with scope of a series
    $.jqplot.PointLabels.init = function (target, data, seriesDefaults, opts, plot){
        var options = $.extend(true, {}, seriesDefaults, opts);
        if (options.pointLabels === undefined || !options.pointLabels.show) {
            return;
        }
        options.pointLabels = options.pointLabels || {};
        if (this.renderer.constructor === $.jqplot.BarRenderer && this.barDirection === 'horizontal' && !options.pointLabels.location) {
            options.pointLabels.location = 'e';
        }
        // add a pointLabels attribute to the series plugins
        this.plugins.pointLabels = new $.jqplot.PointLabels(options.pointLabels);
        this.plugins.pointLabels.setLabels.call(this);
    };
    
    // called with scope of series
    $.jqplot.PointLabels.prototype.setLabels = function() {   
        var p = this.plugins.pointLabels; 
        var labelIdx;
        if (p.seriesLabelIndex != null) {
            labelIdx = p.seriesLabelIndex;
        }
        else if (this.renderer.constructor === $.jqplot.BarRenderer && this.barDirection === 'horizontal') {
           labelIdx = (this._plotData[0].length < 3) ? 0 : this._plotData[0].length -1;
        }
        else {
            labelIdx = (this._plotData.length === 0) ? 0 : this._plotData[0].length -1;
        }
        p._labels = [];
        if (p.labels.length === 0 || p.labelsFromSeries) {    
            if (p.stackedValue) {
                if (this._plotData.length && this._plotData[0].length){
                    // var idx = p.seriesLabelIndex || this._plotData[0].length -1;
                    for (var i=0; i<this._plotData.length; i++) {
                        p._labels.push(this._plotData[i][labelIdx]);
                    }
                }
            }
            else {
                // var d = this._plotData;
                var d = this.data;
                if (this.renderer.constructor === $.jqplot.BarRenderer && this.waterfall) {
                    d = this._data;
                }
                if (d.length && d[0].length) {
                    // var idx = p.seriesLabelIndex || d[0].length -1;
                    for (var i=0; i<d.length; i++) {
                        p._labels.push(d[i][labelIdx]);
                    }
                }
                d = null;
            }
        }
        else if (p.labels.length){
            p._labels = p.labels;
        }
    };
    
    $.jqplot.PointLabels.prototype.xOffset = function(elem, location, padding) {
        location = location || this.location;
        padding = padding || this.xpadding;
        var offset;
        
        switch (location) {
            case 'nw':
                offset = -elem.outerWidth(true) - this.xpadding;
                break;
            case 'n':
                offset = -elem.outerWidth(true)/2;
                break;
            case 'ne':
                offset =  this.xpadding;
                break;
            case 'e':
                offset = this.xpadding;
                break;
            case 'se':
                offset = this.xpadding;
                break;
            case 's':
                offset = -elem.outerWidth(true)/2;
                break;
            case 'sw':
                offset = -elem.outerWidth(true) - this.xpadding;
                break;
            case 'w':
                offset = -elem.outerWidth(true) - this.xpadding;
                break;
            default: // same as 'nw'
                offset = -elem.outerWidth(true) - this.xpadding;
                break;
        }
        return offset; 
    };
    
    $.jqplot.PointLabels.prototype.yOffset = function(elem, location, padding) {
        location = location || this.location;
        padding = padding || this.xpadding;
        var offset;
        
        switch (location) {
            case 'nw':
                offset = -elem.outerHeight(true) - this.ypadding;
                break;
            case 'n':
                offset = -elem.outerHeight(true) - this.ypadding;
                break;
            case 'ne':
                offset = -elem.outerHeight(true) - this.ypadding;
                break;
            case 'e':
                offset = -elem.outerHeight(true)/2;
                break;
            case 'se':
                offset = this.ypadding;
                break;
            case 's':
                offset = this.ypadding;
                break;
            case 'sw':
                offset = this.ypadding;
                break;
            case 'w':
                offset = -elem.outerHeight(true)/2;
                break;
            default: // same as 'nw'
                offset = -elem.outerHeight(true) - this.ypadding;
                break;
        }
        return offset; 
    };
    
    // called with scope of series
    $.jqplot.PointLabels.draw = function (sctx, options, plot) {
        if ((options.pointLabels && !options.pointLabels.show) || (plot.options.seriesDefaults.pointLabels === undefined || !plot.options.seriesDefaults.pointLabels.show)) {
            return;
        }
        var p = this.plugins.pointLabels;
        // set labels again in case they have changed.
        p.setLabels.call(this);
        // remove any previous labels
        for (var i=0; i<p._elems.length; i++) {
            // Memory Leaks patch
            // p._elems[i].remove();
            p._elems[i].emptyForce();
        }
        p._elems.splice(0, p._elems.length);

        if (p.show) {
            var ax = '_'+this._stackAxis+'axis';
        
            if (!p.formatString) {
                p.formatString = this[ax]._ticks[0].formatString;
                p.formatter = this[ax]._ticks[0].formatter;
            }
        
            var pd = this._plotData;
            var ppd = this._prevPlotData;
            var xax = this._xaxis;
            var yax = this._yaxis;
            var elem, helem;

            for (var i=0, l=p._labels.length; i < l; i++) {
                var label = p._labels[i];
                
                if (label == null || (p.hideZeros && parseInt(label, 10) == 0)) {
                    continue;
                }
                
                label = p.formatter(p.formatString, label);

                helem = document.createElement('div');
                p._elems[i] = $(helem);

                elem = p._elems[i];


                elem.addClass('jqplot-point-label jqplot-series-'+this.index+' jqplot-point-'+i);
                elem.css('position', 'absolute');
                elem.insertAfter(sctx.canvas);

                if (p.escapeHTML) {
                    elem.text(label);
                }
                else {
                    elem.html(label);
                }
                var location = p.location;
                if ((this.fillToZero && pd[i][1] < 0) || (this.fillToZero && this._type === 'bar' && this.barDirection === 'horizontal' && pd[i][0] < 0) || (this.waterfall && parseInt(label, 10)) < 0) {
                    location = oppositeLocations[locationIndicies[location]];
                }


                var ell = xax.u2p(pd[i][0]) + p.xOffset(elem, location);
                var elt = yax.u2p(pd[i][1]) + p.yOffset(elem, location);

                // we have stacked chart but are not showing stacked values,
                // place labels in center.
                if (this._stack && !p.stackedValue) {
                    if (this.barDirection === "vertical") {
                        elt = (this._barPoints[i][0][1] + this._barPoints[i][1][1]) / 2 + plot._gridPadding.top - 0.5 * elem.outerHeight(true);
                    }
                    else {
                        ell = (this._barPoints[i][2][0] + this._barPoints[i][0][0]) / 2 + plot._gridPadding.left - 0.5 * elem.outerWidth(true);
                    }
                }

                if (this.renderer.constructor == $.jqplot.BarRenderer) {
                    if (this.barDirection == "vertical") {
                        ell += this._barNudge;
                    }
                    else {
                        elt -= this._barNudge;
                    }
                }
                elem.css('left', ell);
                elem.css('top', elt);
                var elr = ell + elem.width();
                var elb = elt + elem.height();
                var et = p.edgeTolerance;
                var scl = $(sctx.canvas).position().left;
                var sct = $(sctx.canvas).position().top;
                var scr = sctx.canvas.width + scl;
                var scb = sctx.canvas.height + sct;
                // if label is outside of allowed area, remove it
                if (ell - et < scl || elt - et < sct || elr + et > scr || elb + et > scb) {
                    elem.remove();
                }

                elem = null;
                helem = null;
            }

            // finally, animate them if the series is animated
            // if (this.renderer.animation && this.renderer.animation._supported && this.renderer.animation.show && plot._drawCount < 2) {
            //     var sel = '.jqplot-point-label.jqplot-series-'+this.index;
            //     $(sel).hide();
            //     $(sel).fadeIn(1000);
            // }

        }
    };
    
    $.jqplot.postSeriesInitHooks.push($.jqplot.PointLabels.init);
    $.jqplot.postDrawSeriesHooks.push($.jqplot.PointLabels.draw);
})(jQuery);
/**
 jqPlot Multiple Select Plugin
 2016-09-20, Roy Choi
 */
(function($) {
    /**
     * Class: $.jqplot.MultiSelect
     * Plugin which will show by spec window.
     */
    $.jqplot.MultiSelect = function(options) {
        // Group: Properties
        //
        //prop: enable
        // true to enable the Show By Group.
        this.enable = $.jqplot.config.enablePlugins;
        // prop: show
        // true to show
        this.show = true;
        this.selected = [];
        this.selectAreaStyle = {
            fillStyle: 'rgba(42,127,213,0.2)',
            strokeStyle: 'rgb(42,127,213)',
            lineWidth: 1
        };
        this.sizeAdjust = 2.5;
        this.strokeStyle = '#000';
        this.strokeWidth = 2;

        // event : select changed
        this.onSelected = null;

        $.extend(true, this, options);
        this._canvas = null;

        this._start = null;
        this._selecting = false;
        this._dragging = false;
        this._clicking = false;
        this._keyboard = {
            ctrl: false,
            shift: false
        };
        this._strokeOption = {
            stroke: true,
            strokeStyle: this.strokeStyle,
            lineWidth: this.strokeWidth,
            sizeAdjust: this.sizeAdjust
        };
        this._markerRenderer = new $.jqplot.MarkerRenderer({
            shadow : false
        });
    };
    // axis.renderer.tickrenderer.formatter

    // called with scope of plot
    $.jqplot.MultiSelect.init = function(target, data, opts) {
        var options = opts || {};

        // add a highlighter attribute to the plot
        this.plugins.multiSelect = new $.jqplot.MultiSelect(options.multiSelect);
    };

    $.jqplot.MultiSelect.postPlotDraw = function() {
        var ms = this.plugins.multiSelect;
        
        if (!ms.show || this.series.length === 0) {
            return;
        }
        
        if (ms && ms._canvas) {
            ms._canvas.resetCanvas();
            ms._canvas = null;
        }
        
        ms._canvas = new $.jqplot.GenericCanvas();
        
        var canvasGridPadding = $.extend(true, {}, this._gridPadding);
        this.eventCanvas._elem.before(ms._canvas.createElement(canvasGridPadding, 'jqplot-multi-select-canvas', this._plotDimensions, this));
        ms._canvas.setContext();

        if ($.isArray(this._selected) && this._selected.length) {
            ms.selected = this._selected;
            reSelect(ms, this);
        } else if (ms.selected.length) {
            ms.select(ms.selected, this, false);
        }
        this.target.unbind('jqPlot.PreviousSeriesOrder', clearSelect);
        this.target.unbind('jqPlot.OriginalSeriesOrder', clearSelect);
        this.target.unbind('jqPlot.legendClick', clearSelectFromLegend);
        this.target.unbind('jqPlot.SeriesToBack', unselectSeries);
        
        this.target.bind('jqPlot.PreviousSeriesOrder', clearSelect);
        this.target.bind('jqPlot.OriginalSeriesOrder', clearSelect);
        this.target.bind('jqPlot.legendClick', clearSelectFromLegend);
        this.target.bind('jqPlot.SeriesToBack', unselectSeries);
    };

    $.jqplot.preInitHooks.push($.jqplot.MultiSelect.init);
    $.jqplot.postDrawHooks.push($.jqplot.MultiSelect.postPlotDraw);

    $.jqplot.eventListenerHooks.unshift(['jqplotMouseDown', handleMouseDown]);
    $.jqplot.eventListenerHooks.push(['jqplot.selectSinglePoint', selectPoint]);
    $.jqplot.eventListenerHooks.push(['jqplot.preSelectSinglePoint', preSelectPoint]);
    /**
     * Select by param
     * @param selected - [{
     *  seriesIndex: 1,
     *  pointIndexes: [3, 7, ...]
     * }, ...]
     * @param plot
     */
    $.jqplot.MultiSelect.prototype.select = function(selected, plot, continuous) {
        if ($.isArray(selected) && selected.length) {
            // draw selected
            selected = continuous ? continuousSelectedAreaProc.call(this, {}, formatNewSelected(selected), plot) : formatNewSelected(selected);
            drawBorders.call(this, selected, plot);
            setSelected(null, selected, this, plot);

            moveSeriesToFront(plot, selected);
        } else {
            clear.call(this, plot);
            setSelected(null, [], this, plot);
            plot.restorePreviousSeriesOrder();
        }
    };
    /**
     * Clear all selected data
     * @param plot
     */
    $.jqplot.MultiSelect.prototype.clear = function(plot) {
        clearSelect(null, plot);
        plot.restorePreviousSeriesOrder();
    }

    function setSelected(ev, selected, ms, plot) {
        plot._selected = plot.options.multiSelect.selected = ms.selected = selected;
        if (ev != null) {
            if ($.isFunction(ms.onSelected)) {
                ms.onSelected(ev, selected, plot);
            }
            plot.target.trigger('jqPlot.multiSelected', [selected, plot]);
        }
    }

    //clear selections
    function clearSelect(ev, plot) {
        var ms = plot.plugins.multiSelect;
        if (ms && ms.show && !ms.clicking) {
            if (ms.selected.length === 0) {
                return;
            }
            setSelected(ev, [], ms, plot);
            clear.call(ms, plot);
        }
    }

    function clearSelectFromLegend(ev, seriesIndex, series, plot) {
        clearSelect(ev, plot, true);
    }

    //clear canvas
    function clear(plot) {
        var ctx = this._canvas._ctx;
        clearRect(ctx);
        ctx = null;
    }

    function clearRect(ctx) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }

    function formatNewSelected(selected) {
        return selected.map(function(selectedSeries) {
            selectedSeries.oldPointIndexes = [];
            selectedSeries.newPointIndexes = selectedSeries.pointIndexes.slice();
            return selectedSeries;
        });
    }

    function reSelect(ms, plot) {
        drawBorders.call(ms, ms.selected, plot);
    }

    // unselect series
    function unselectSeries(ev, seriesIndex, plot) {
        var ms = plot.plugins.multiSelect;
        var index = _.findIndex(ms.selected, {seriesIndex: seriesIndex});

        if (index > -1) {
            ms.selected.splice(index, 1);
            setSelected(ev, ms.selected, ms, plot);
        }

        drawBorders.call(ms, ms.selected, plot);
    }

    // ready for selecting a point
    function preSelectPoint(ev, plot, neighbor, continuous) {
        var ms = plot.plugins.multiSelect;
        if (!ms || !ms.show) {
            return;
        }
        ms.clicking = true; 
    }

    // select a point 
    function selectPoint(ev, plot, neighbor, continuous) {
        var ms = plot.plugins.multiSelect;

        if (!ms || !ms.show) {
            return;
        }

        ms.clicking = false;

        if (!continuous && neighbor === null) {
            clearSelect(ev, plot);
            return;
        } else if (continuous && neighbor === null) {
            return;
        }

        var newSelected, selected = {
            seriesIndex: neighbor.seriesIndex,
            pointIndexes: [neighbor.pointIndex],
            oldPointIndexes: [],
            newPointIndexes: [neighbor.pointIndex]
        };
        if (ms.show) {
            if (continuous) {
                newSelected = continuousSelectedPointProc.call(ms, ev, selected, plot, neighbor);
                drawBorders.call(ms, newSelected, plot);
            } else {
                newSelected = [selected];
                drawBorders.call(ms, [selected], plot);
            }
            setSelected(ev, newSelected, ms, plot);
        }
    }

    function mergeSelected(oldSelected, newSelected) {
        return oldSelected.map(function(series) {
            var addPointSeries = _.find(newSelected, {seriesIndex: series.seriesIndex});
            return {
                seriesIndex: series.seriesIndex,
                pointIndexes: series.pointIndexes.slice(),
                oldPointIndexes: series.pointIndexes.slice(),
                newPointIndexes: addPointSeries ? addPointSeries.pointIndexes.slice() : []
            };
        });
    }

    function sortMergedArray(selected, seriesStack) {
        if (selected.length < 2) {
            return selected;
        }

        var temp = selected.splice(0);
        seriesStack.forEach(function(seriesIndex) {
            var idx = _.findIndex(temp, {seriesIndex: seriesIndex});
            if (idx > -1) {
                selected.push(temp[idx]);
            }
        });

        temp = null;

        return selected;
    }

    // check a point is selected already
    // merge points in same series and remove series if it is empty
    function continuousSelectedPointProc(ev, selectedInfo, plot, neighbor) {
        var mergedSelected = mergeSelected(this.selected, [selectedInfo]);
        var selectedIndex = _.findIndex(mergedSelected, {seriesIndex: selectedInfo.seriesIndex});
        
        if (selectedIndex > -1) {
            var series = mergedSelected[selectedIndex];
            selectedInfo.pointIndexes.forEach(function(pointIndex) {
                var index = series.pointIndexes.indexOf(pointIndex);
                if (index > -1) {
                    series.pointIndexes.splice(index, 1);
                    if (series.pointIndexes.length === 0) {
                        mergedSelected.splice(selectedIndex, 1);
                        plot.moveSeriesToBack(selectedInfo.seriesIndex);
                        if (ev.type === 'jqplot' && ev.namespace === 'selectPoint') plot.eventCanvas._elem.trigger('jqplot.clearTooltip', [plot]);
                    }
                } else {
                    series.pointIndexes = series.pointIndexes.concat(selectedInfo.pointIndexes);
                    if (ev.type === 'jqplot' && ev.namespace === 'selectPoint') plot.eventCanvas._elem.trigger('jqplot.showTooltip', [plot, plot.series[selectedInfo.seriesIndex], neighbor, false]);
                }
            }, this);
            
        } else {
            mergedSelected.push(selectedInfo);
        }

        return sortMergedArray(mergedSelected, plot.seriesStack);
    }

    // check all points are selected already
    // merge points in same series and remove series if it is empty
    function continuousSelectedAreaProc(ev, newSelected, plot) {
        var mergedSelected = mergeSelected(this.selected, newSelected);

        newSelected.forEach(function(selectedInfo) {
            var selectedIndex = _.findIndex(mergedSelected, {seriesIndex: selectedInfo.seriesIndex});
        
            if (selectedIndex > -1) {
                var series = mergedSelected[selectedIndex];
                selectedInfo.pointIndexes.forEach(function(pointIndex) {
                    var index = series.pointIndexes.indexOf(pointIndex);
                    if (index < 0) {
                        series.pointIndexes.push(pointIndex);
                        //if (ev.type === 'jqplot' && ev.namespace === 'selectPoint') plot.eventCanvas._elem.trigger('jqplot.showTooltip', [plot, plot.series[selectedInfo.seriesIndex], neighbor, false]);
                    }
                }, this);
                
            } else {
                mergedSelected.push(selectedInfo);
            }
        }, this);
        
        return sortMergedArray(mergedSelected, plot.seriesStack);
    }

    function getSelectedInformations(start, end, plot) {
        var seriesStack = plot.seriesStack,
            selected = [];
        
        seriesStack.forEach(function(seriesIndex) {
            var s = plot.series[seriesIndex];
            if (s.hide || !s.show) {
                return;
            }
            var pointIndexes = plot.getIntersectionDataByRectangle(s, start, end);
            if (pointIndexes.length) {
                selected.push({
                    seriesIndex: s.index,
                    pointIndexes: pointIndexes,
                    oldPointIndexes: [],
                    newPointIndexes: pointIndexes.slice()
                });
            }
        });

        return selected;
    }

    //TODO: draw selected borders
    function drawBorders(selected, plot) {
        drawMarkers.call(this, selected, plot, true);
    }

    // draw selected markers
    function drawMarkers(selected, plot, isLast, options) {
        options = options || {}
        var opts = isLast ? $.extend(false, {}, this._strokeOption, options) : options;
        var ctx = this._canvas._ctx;
        var mr = this._markerRenderer;

        clearRect(ctx);

        selected.forEach(function(selectedSeries) {
            var series = plot.series[selectedSeries.seriesIndex];
            var renderer = series.renderer;
            var x_u2p = series._xaxis.series_u2p;
            var y_u2p = series._yaxis.series_u2p;

            switch(renderer.constructor) {
                case $.jqplot.LineRenderer:
                case $.jqplot.BigDataScatterRenderer:
                    var smr = series.markerRenderer;
                    var isOldSelected = false, isNewSelected = false;
                    mr.style = smr.style;
                    mr.color = smr.color;
                    mr.stroke = opts.stroke || smr.show;
                    mr.lineWidth = opts.lineWidth || smr.lineWidth;
                    mr.strokeStyle = opts.strokeStyle || this.strokeStyle;
                    mr.shapeRenderer.color = mr.color;
                    mr.init();

                    selectedSeries.pointIndexes.forEach(function(pointIndex) {
                        var x, y, point;
                        isOldSelected = selectedSeries.oldPointIndexes.indexOf(pointIndex) > -1;
                        isNewSelected = selectedSeries.newPointIndexes.indexOf(pointIndex) > -1;
                        if (isLast) {
                            mr.size = smr.size + opts.sizeAdjust;
                        } else {
                            if (isOldSelected && isNewSelected) {
                                opts.stroke = true;
                                opts.lineWidth = this.strokeWidth;
                                opts.strokeStyle = this.strokeStyle;
                                mr.size = smr.size + this.sizeAdjust*2;
                            } else if (isOldSelected && !isNewSelected) {
                                opts.stroke = true;
                                opts.lineWidth = this.strokeWidth;
                                opts.strokeStyle = this.strokeStyle;
                                mr.size = smr.size + this.sizeAdjust;
                            } else {
                                opts.stroke = false;
                                mr.size = smr.size + this.sizeAdjust;
                            }
                        }
                        
                        // customizing (2017-01-18, Carrie Bae) : apply fillStyleFilter
                        if ($.isFunction(smr.fillStyleFilter)) { 
                            opts.fillStyle = smr.fillStyleFilter.call(smr, series.data[pointIndex], pointIndex);
                        };     

                        if (renderer.constructor === $.jqplot.BigDataScatterRenderer) {
                            point = series.data[pointIndex];
                            x = x_u2p(point[0]);
                            y = y_u2p(point[1]);
                        } else {
                            point = series.gridData[pointIndex];
                            x = point[0];
                            y = point[1];
                        }
                        mr.draw(x, y, ctx, opts);
                    }, this);
                    break;
                case $.jqplot.BarRenderer:
                case $.jqplot.PyramidRenderer:
                    var smr = series.markerRenderer,
                        color = series.color,
                        opt = {stroke: true, fill: false, fillStyle: 'transparent', strokeStyle: opts.strokeStyle || this.strokeStyle};
                    
                    selectedSeries.pointIndexes.forEach(function(pointIndex) {
                        var isOldSelected = false, isNewSelected = false;
                        isOldSelected = selectedSeries.oldPointIndexes.indexOf(pointIndex) > -1;
                        isNewSelected = selectedSeries.newPointIndexes.indexOf(pointIndex) > -1;

                        if (isLast) {
                            opt.lineWidth = opts.lineWidth
                        } else {
                            if (isOldSelected) {
                                opt.lineWidth = this.strokeWidth;
                            } else {
                                opt.lineWidth = .5;
                            }
                        }
                        series.renderer.shapeRenderer.draw(ctx, series._barPoints[pointIndex], opt);
                    }, this);
                    break;
                default:
                    break;
            }
        }, this);

        ctx = null;
    }

    //handle on mouse down
    function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {
        var cursor = plot.plugins.cursor;
        var ms = plot.plugins.multiSelect;

        if (!ms || !ms.show || (ev.originalEvent.ctrlKey && plot.checkMacOS())) {
            return;
        }

        ms._keyboard.ctrl = plot.checkCtrlKey(ev.originalEvent);
        ms._keyboard.shift = ev.originalEvent.shiftKey;

        plot.eventCanvas._elem.unbind('click', plot.onClick);
        plot.eventCanvas._elem.bind('click', {
            plot : plot
        }, plot.onClick);

        ms._start = gridpos;
        ms._selecting = true;
        ms._dragging = false;

        //ctrl & shift key logic

        if (!cursor.zoom) {
            $(document).unbind('mousemove', handleSelectDrag);
            $(document).unbind('mouseup', handleSelectStop);

            $(document).bind('mousemove', {plot: plot}, handleSelectDrag);
            $(document).bind('mouseup', {plot: plot}, handleSelectStop);
        }
    }

    function handleSelectDrag(ev) {
        ev.preventDefault();
        ev.stopImmediatePropagation();
        
        var plot = ev.data.plot;
        var ms = plot.plugins.multiSelect;
        var ctx = ms._canvas._ctx;

        //clearRect(ctx);

        if (plot.checkMacOS() && ev.ctrlKey) {
            return;
        }

        if (!ms.show || !ms._selecting) {
            return;
        }
        
        var position = plot.getEventPosition(ev);
        var gridpos = position.gridPos;
        
        if (gridpos.x < 0) {
            gridpos.x = 0;
        } else if (gridpos.x >= ms._canvas._ctx.canvas.width) {
            gridpos.x = ms._canvas._ctx.canvas.width - 1;
        }
        if (gridpos.y < 0) {
            gridpos.y = 0;
        } else if (gridpos.y >= ms._canvas._ctx.canvas.height) {
            gridpos.y = ms._canvas._ctx.canvas.height - 1;
        }

        if (Math.abs(gridpos.x - ms._start.x) * Math.abs(gridpos.y - ms._start.y) < 5) {
            return;
        }

        plot.eventCanvas._elem.unbind('click', plot.onClick);
        
        ms._dragging = true;
        
        ms._stop = position.gridPos;
        var newSelected = getSelectedInformations(ms._start, gridpos, plot);
        newSelected = continuousSelectedAreaProc.call(ms, ev, newSelected, plot);
        drawMarkers.call(ms, newSelected, plot, false);

        drawSelectingArea.call(ms, ev, ctx, ms._start, gridpos, plot);
        ctx = null;
    }

    function handleSelectStop(ev) {
        var plot = ev.data.plot;
        var ms = plot.plugins.multiSelect;    
        var ctx = ms._canvas._ctx;
        var position = plot.getEventPosition(ev);
        var neighbor = plot.checkIntersection(ev, position.gridPos, plot);
        var newSelected = [];

        var continuous = ms._keyboard.ctrl;

        ms._keyboard.ctrl = false;
        ms._keyboard.shift = false;


        $(document).unbind('mousemove', handleSelectDrag);
        $(document).unbind('mouseup', handleSelectStop);

        if (ms.show && ms._dragging && ms._start && ms._selecting) {
            clearRect(ctx);
            
            ms._stop = position.gridPos;
            newSelected = getSelectedInformations(ms._start, ms._stop, plot);

            if (newSelected.length === 0) {
                clearSelect(ev, plot);
                plot.restorePreviousSeriesOrder();
            } else {
                if (plot.checkCtrlKey(ev)) {
                    newSelected = continuousSelectedAreaProc.call(ms, ev, newSelected, plot);
                }

                drawBorders.call(ms, newSelected, plot);
                
                setSelected(ev, newSelected, ms, plot);
                
                moveSeriesToFront(plot, ms.selected);
            }
        }

        ms._dragging = false;
        ms._selecting = false;
    }

    function moveSeriesToFront(plot, selected) {
        selected.forEach(function(series, index) {
            plot.moveSeriesToFront(series.seriesIndex, index > 0);
        });
    }

    //draw selecting area
    function drawSelectingArea(ev, ctx, start, stop, plot) {
        ctx.save();
        
        var l, t, h, w;
        if (stop.x > start.x) {
            l = start.x;
            w = stop.x - start.x;
        } else {
            l = stop.x;
            w = start.x - stop.x;
        }
        if (stop.y > start.y) {
            t = start.y;
            h = stop.y - start.y;
        } else {
            t = stop.y;
            h = start.y - stop.y;
        }
        ctx.fillStyle = this.selectAreaStyle.fillStyle;
        ctx.strokeStyle = this.selectAreaStyle.strokeStyle;
        ctx.lineWidth = this.selectAreaStyle.lineWidth;
        
        //ctx.fillRect(l,t,w,h);
        ctx.strokeRect(l,t,w,h);
        ctx.fillRect(l,t,w,h);
        
        ctx.restore();
        ctx = null;
    }

})(jQuery); 
